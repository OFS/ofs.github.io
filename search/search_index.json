{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open FPGA Stack Overview","text":"<p> <p>Open FPGA Stack (OFS): OFS is an open-source hardware and software framework that reduces the development time for creating your custom platform.   Provided within this framework are reference designs targeting different Intel\u00ae FPGA devices with upstreamed drivers and management software tools.  </p> <p> <p>The reference shells, called FPGA Interface Manager (FIMs), provide an integrated, timing closed design with the most common interfaces for applications. You can add or subtract interfaces depending on your application requirements. You can leverage the build scripts, RTL, unit tests, Universal Verification Methodology (UVM) environment, software and drivers targeting this reference shell as a starting point for your own FPGA platform solution.</p> <p>OFS targets Intel Stratix\u00ae 10 and Intel Agilex\u2122 FPGA Device Families. To find out more about Intel FPGAs, visit the Intel Stratix 10 and Intel Agilex pages at Intel.com</p> <p></p>"},{"location":"#how-can-i-start-using-ofs","title":"How Can I Start Using OFS?","text":"<p>If you are board developer you can get started in four basic steps.  <p>Start by selecting the reference FIM that closest matches your requirements and leveraging our evaluation scripts to give OFS a test drive. The reference FIMs can be used as-is or as a starting point for modification, greatly reducing development time. </p> <p>If you are a workload developer, you can choose between an RTL or OneAPI based design flow.  </p> <p>For all of our designs, we have up-streamed software drivers and user space tools that you can use to get your application up and running quickly.  Please refer to our Software Documentation for more details.</p> <p>Below details the three current reference designs (aka FIMs) you can choose from:</p> <p>OFS FIM Targeting Intel\u00ae Agilex\u00ae PCIe Attach  Features</p> <p> Key Feature Description PCIe P-tile PCIe* Gen4x16 Virtualization 5 physical functions/4 virtual functions with ability to expand Memory 5 DDR Channels:* One HPS DDR4 bank, x40 (x32 Data and x8 ECC), 1200 MHz, 1GB each* Four Fabric DDR4 banks, x32 (no ECC), 1200 MHz, 4GB Ethernet 2x4x25GbE Hard Processor System 64-bit quad core Arm\u00ae Cortex\u00ae-A53 MPCore with integrated peripherals. Configuration and Board Manageability * FPGA Management Engine that provides general control of common FPGA tasks (ex. error reporting, partial reconfiguration)* Platform Controller Management Interface (PMCI) Module for Board Management Controller Partial Reconfiguration Supported OneAPI OneAPI Acceleration Support Package (ASP) provided with compiled FIM to support OneAPI Runtime Software Support * Linux DFL drivers targeting OFS FIMs* OPAE Software Development Kit* OPAE Tools <p>Click here for the OFS Collateral for Intel\u00ae Agilex\u00ae PCIe Attach Reference FIM documentation.</p> <p></p> <p>OFS FIM Features Targeting Intel\u00ae Agilex\u00ae SoC Attach</p> <p> Key Feature Description PCIe P-tile PCIe* Gen4x16 to the HostP-tile PCIe* Gen4x16 to the SoC (IceLake-D) Virtualization Host: 2 physical functions SoC:   1 physical function and 3 Virtual functions Memory Four Fabric DDR4 banks, x40 (optional ECC, be configured as x32 and ECC x8 ), 1200 MHz, 4GB Ethernet 2x4x25GbE Configuration and Board Manageability * FPGA Management Engine that provides general control of common FPGA tasks (ex. error reporting, partial reconfiguration) * Platform Controller Management Interface (PMCI) Module for Board Management Controller Partial Reconfiguration Supported Software Support * Linux DFL drivers targeting OFS FIMs * OPAE Software Development Kit * OPAE Tools <p>Note: Source code for BMC RTL/Firmware that works with this reference FIM can be obtained by contacting your Intel Sales Representative.</p> <p>Click here for the OFS Collateral for Intel\u00ae Agilex\u00ae SoC Attach Reference FIM documentation.</p> <p></p> <p>OFS FIM Targeting Intel\u00ae Stratix\u00ae 10 FPGA PCIe Attach</p> <p> Key Feature Intel Stratix 10 Reference FIM FPGA Intel Stratix 10 SX FPGA Ethernet Configuration 1x10GbE example with 2x100GbE capability PCIe Gen3x16 EMIF Up to four DDR channels PF/VF 1 PF/3 VFs Management FPGA Management Engine (FME) with FIM management registers Interface Arm\u00ae AMBA\u00ae4 AXI Interface HLD support oneAPI Software Kernel code upstreamed to Linux.org <p>Click here for the OFS Collateral for Intel\u00ae Stratix\u00ae 10 FPGA PCIe Attach Reference FIM documentation.</p> <p>To find information on the latest releases, go to the Discussions Tab in the OFS GitHub repository.</p> <p></p>"},{"location":"#open-fpga-stack-repositories","title":"Open FPGA Stack Repositories","text":"<p>Accessing OFS ingredients to use within the development framework is easy.  The github.com/OFS site provides all the hardware and software repositories in one location.</p> Development Focus Repository Folder Description Hardware ofs-n6001 Provides RTL, unit tests, and build scripts to create Intel\u00ae Agilex\u00ae FIM and is leveraged as a starting point for a custom PCIe Attach design.  The reference FIM targets an Intel\u00ae FPGA SmartNIC N6001-PL Platform. Hardware ofs-f2000x-pl Provides RTL, unit tests, and build scripts to create Intel\u00aeAgilex\u00ae FIM and is leveraged as a starting point for a custom SoC Attach design.  The reference FIM targets an Intel\u00ae FPGA IPU F2000X-PL Platform. Hardware ofs-d5005 Provides RTL, unit tests, and build scripts to create Intel\u00ae Stratix 10\u00ae FIM and is leveraged as a starting point for a custom PCIe Attach design.  The reference FIM targets an Intel\u00ae FPGA PAC D5005 development board. Hardware oneapi-asp Contains the files to generate the support package that works with the reference shells and allows you to use OneAPI. This is an optional repository for developers interested in OneAPI Hardware ofs-fim-common Provides RTL components that are shared among all new platforms that are introduced in OFS.  This folder is a subumodule in each platform repository folder. Hardware examples-afu Provides simple Accelerator Functional Unit (AFU) examples you can use as a template for starting your own workload design. Hardware ofs-platform-afu-bbb Contains the hardware code to build a standard interface between the FIM and your workload. Software linux-dfl This repository is a mirror of the linux.org Git site and contains the most up-to-date drivers that are being developed and upstreamed for OFS platforms. Software meta-ofs) This repository provides the Linux\u00ae DFL kernel and the OPAE SDK for the Yocto\u00ae Project. Software opae-sdk Contains the ingredients to build the OFS Open Programmable Acceleration Engine (OPAE) Software Development Kit which provides APIs and userspace tools for OFS FPGA management. Software opae-sim This repository is used to build the AFU Hardware/Software Co-Simulation Environment workload developers can use to ensure their AFU can work with the OFS software stack. Software linux-dfl-backport A place for finding and leveraging out-of-tree backported drivers for older OS versions . Software opae-legacy Supports OFS platforms built on the legacy version of OPAE software.  Not used in current OFS designs Documentation ofs.github.io Contains the hardware and software collateral that surfaces on the OFS website: https://ofs.github.io <p></p>"},{"location":"#rtl-repository","title":"RTL Repository","text":"<p>Every FPGA RTL development repository is named after the platform it targets.  This platform target is a starting point for development and can be considered a best known configuration for debugging.</p> <p>The structure of the RTL repository remains the same regardless of which device platform you decide to use.  The advantage of this is you will quickly become familiar with the hierarchy as you consider new FPGA application development.</p> <p> <p></p> Directory Description eval_scripts Provides resources to setup, compile, simulate and test the reference FIM that can be built in the repository. ipss Contains the code and supporting files that configure and build the default configuration of the key subsystems license Contains license required to build the IP in Quartus\u00ae.  Note you still utilize an evaluation license or purchase a license to use Quartus Prime Pro Software. ofs-common@commit# Contains scripts and source code that are common to all of the platform RTL repositories and to your own FPGA design.  This directory is referenced through a specific commit and you have the option to update to the latest ofs-common as your design evolves. sim Provides test benches and supporting code for unit tests. src Contains all structural and behavioral code for FIM including top-level RTL for synthesis and AFU infrastructure code. syn Provides scripts, settings and setup files for running FIM synthesis."},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/","title":"Software Reference Manual: Open FPGA Stack","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#10-introduction","title":"1.0 Introduction","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#11-audience","title":"1.1 Audience","text":"<p>The information presented in this document is intended to be used by software developers looking to increase their knowledge of the OPAE SDK user-space software stack and the kernel-space linux-dfl drivers. This information is intended as a starting point, with links to where users can deep dive on specific topics.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#12-opae-software-development-kit-sdk","title":"1.2 OPAE Software Development Kit (SDK)","text":"<p>The OPAE C library is a lightweight user-space library that provides abstraction for FPGA resources in a compute environment. Built on top of the OPAE Intel\u00ae FPGA driver stack that supports Intel\u00ae FPGA platforms, the library abstracts away hardware specific and OS specific details and exposes the underlying FPGA resources as a set of features accessible from within software programs running on the host. The OPAE source code is available on the OPAE SDK repository, under the opae-sdk tag.</p> <p>These features include the acceleration logic configured on the device, as well as functions to manage and reconfigure the device. The library enables user applications to transparently and seamlessly leverage FPGA-based acceleration.</p> <p>Most of the information related to OPAE can be found on the official OFS Site page. The following is a summary of the information present on this web page:</p> <ul> <li>Configuration options present in the OPAE SDK build and installation flow</li> <li>The steps required to build a sample OPAE application</li> <li>An explanation of the basic application flow</li> <li>A reference for the C, C++, and Python APIs</li> <li>An explanation of the OPAE Linux Device Driver Architecture</li> <li>Definitions for the various user-facing OPAE SDK tools</li> </ul> <p>The remaining sections on OPAE in this document are unique and build on basic principles explained in opae.github.io.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#table-additional-websites-and-links","title":"Table : Additional Websites and Links","text":"Document Link OPAE SDK on github OPAE SDK repository OPAE Documents OFS Site pybind11 https://pybind11.readthedocs.io/en/stable/ CLI11 https://github.com/CLIUtils/CLI11 spdlog https://github.com/gabime/spdlog"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#20-opae-c-api","title":"2.0 OPAE C API","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21-libopae-c","title":"2.1 libopae-c","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#211-device-abstraction","title":"2.1.1 Device Abstraction","text":"<p>The OPAE C API relies on two base abstractions concerning how the FIM and accelerator are presented to and manipulated by the user. The FIM is concerned with management functionality. Access to the FIM and its interfaces is typically restricted to privileged (root) users. The accelerator contains the user-defined logic in its reconfigurable region. Most OPAE end-user applications are concerned with querying and opening the accelerator device, then interacting with the AFU via MMIO and shared memory.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2111-device-types","title":"2.1.1.1 Device types","text":"<p>The C enum fpga_objtype defines two variants. The FPGA_DEVICE variant corresponds to the FIM portion of the device, and the FPGA_ACCELERATOR refers to the accelerator, also known as the AFU.</p> <p>An FPGA_DEVICE refers loosely to the sysfs tree rooted at the dfl-fme.X directory, for example /sys/class/fpga_region/region0/dfl-fme.0, and its associated device file /dev/dfl-fme.0.</p> <p>An FPGA_ACCELERATOR refers loosely to the sysfs tree rooted at the dfl-port.X directory, for example /sys/class/fpga_region/region0/dfl-port.0, and its associated device file /dev/dfl-port.0.</p> <p>The number X in dfl-fme.X and dfl-port.X refers to a numeric ID that is assigned by the DFL device driver to uniquely identify an instance of the FIM/Accelerator. Systems with multiple FPGA acceleration devices will have multiple dfl-fme.X\u2019s and matching dfl-port.X\u2019s.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2112-tokens-and-handles","title":"2.1.1.2 Tokens and Handles","text":"<p>An fpga_token is an opaque data structure that uniquely represents an FPGA_DEVICE or an FPGA_ACCELERATOR. Tokens convey existence, but not ownership. Tokens are retrieved via the OPAE enumeration process described below using the fpgaEnumerate() call.</p> <p>An fpga_handle is an opaque data structure that corresponds to an opened device instance, whether FPGA_DEVICE or FPGA_ACCELERATOR. A Handle is obtained from a token via the fpgaOpen() call. A handle conveys that the /dev/dfl-fme.X or /dev/dfl-port.X device file has been opened and is ready for interaction via its IOCTL interface.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#212-enumeration","title":"2.1.2 Enumeration","text":"<p>Enumeration is the process by which an OPAE application becomes aware of the existence of FPGA_DEVICE\u2019s and FPGA_ACCELERATOR\u2019s. Refer to the signature of the fpgaEnumerate() call:</p> <pre><code>fpga_result fpgaEnumerate(const fpga_properties *filters,\nuint32_t num_filters,\nfpaa_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n</code></pre> <p>Figure 1 fpgaEnumerate()</p> <p>The typical enumeration flow involves an initial call to fpgaEnumerate() to discover the number of available tokens.</p> <pre><code>uint32_t num_matches = 0;\nfpgaEnumerate(NULL, 0, NULL, 0, &amp;num_matches);\n</code></pre> <p>Figure 2 Discovering Number of Tokens</p> <p>Once the number of available tokens is known, the application can allocate the correct amount of space to hold the tokens:</p> <pre><code>fpga_token *tokens;\nuint32_t num_tokens = num_matches;\ntokens = (fpga_token *)calloc(num_tokens, sizeof(fpga_token));\nfpgaEnumerate(NULL, 0, tokens, num_tokens, &amp;num_matches);\n</code></pre> <p>Figure 3 Enumerating All Tokens</p> <p>Note that parameters filters and num_filters were not used in the preceding example, as they were NULL and 0. When no filtering criteria are provided, fpgaEnumerate() returns all tokens that can be enumerated.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2121-fpga_properties-and-filtering","title":"2.1.2.1 fpga_properties and Filtering","text":"<p>An fpga_properties is an opaque data structure used to retrieve all of the properties concerning an FPGA_DEVICE or FPGA_ACCELERATOR. These properties can be included in the filters parameter to fpgaEnumerate() to select tokens by specific criteria.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21211-common-properties","title":"2.1.2.1.1 Common Properties","text":"<p>Table 3 lists the set of properties that are common to FPGA_DEVICE and FPGA_ACCELERATOR:</p>  Property  Description fpga_guid guid; FPGA_DEVICE: PR Interface ID FPGA_ACCELERATOR: AFU ID fpga_token parent; FPGA_DEVICE: always NULL FPGA_ACCELERATOR: the token of the corresponding FPGA_DEVICE, if any. Otherwise, NULL. fpga_objtype objtype; FPGA_DEVICE or FPGA_ACCELERATOR uint16_t segment; The segment portion of the PCIe address: ssss:bb:dd.f uint8_t bus; <p>The bus portion of the PCIe address:</p> <p>ssss:bb:dd.f</p> uint8_t device; <p>The device portion of the PCIe address:</p> <p>ssss:bb:dd.f</p> uint8_t function; The function portion of the PCIe address: ssss:bb:dd.f uint64_t object_id; A unique 64-bit value that identifies this token on the system. uint16_t vendor_id; The PCIe Vendor ID uint16_t device_id; The PCIe Device ID uint32_t num_errors; The number of error sysfs nodes available for this token. fpga_interface interface; An identifier for the underlying plugin-based access method. <p>Table 3 Common Properties</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21212-fpga_device-properties","title":"2.1.2.1.2 FPGA_DEVICE Properties","text":"<p>Table 4 lists the set of properties that are specific to FPGA_DEVICE token types.</p> Property Description uint64_t bbs_id; FIM-specific Blue Bitstream ID fpga_version bbs_version; BBS version <p>Table 4 FPGA_DEVICE Properties</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21213-fpga_accelerator-properties","title":"2.1.2.1.3 FPGA_ACCELERATOR Properties","text":"<p>Table 5 lists the set of properties that are specific to FPGA_ACCELERATOR token types.</p> Property Description fpga_accelerator_state state; Whether the Accelerator is currently open uint32_t num_mmio; The number of MMIO regions available uint32_t num_interrupts; The number of interrupts available <p>Table 5 FPGA_ACCELERATOR Properties</p> <p>Following is an example of using fpga_properties to enumerate a specific AFU:</p> <p><pre><code>#define NLB0_AFU \"D8424DC4-A4A3-C413-F89E-433683F9040B\"\nfpga_properties filter = NULL;\nfpga_guid afu_id;\nfpgaGetProperties(NULL, &amp;filter); // NULL: a new empty properties\nfpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\nuuid_parse(NLB0_AFU, afu_id);\nfpgaPropertiesSetGuid(filter, afu_id);\nfpgaEnumerate(&amp;filter, 1, tokens, num_tokens, &amp;num_matches);\n</code></pre> Relevant Links:  - fpga_guid - fpgaGetProperties - fpgaPropertiesSetObjectType - fpgaPropertiesSetGUID</p> <p>Figure 4 Filtering During Enumeration</p> <p>Note that fpga_properties and fpga_token\u2019s are allocated resources that must be freed by their respective API calls, ie fpgaDestroyProperties() and fpgaDestroyToken().</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#213-access","title":"2.1.3 Access","text":"<p>Once a token is discovered and returned to the caller by fpgaEnumerate(), the token can be converted into a handle by fpgaOpen(). Upon a successful call to fpgaOpen(), the associated /dev/dfl-fme.X (FPGA_DEVICE) or /dev/dfl-port.X (FPGA_ACCELERATOR) is opened and ready for use. Having acquired an fpga_handle, the application can then use the handle with any of the OPAE APIs that require an fpga_handle as an input parameter.</p> <p>Like tokens and properties, handles are allocated resources. When a handle is no longer needed, it should be closed and released by calling fpgaClose().</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#214-events","title":"2.1.4 Events","text":"<p>Event registration in OPAE is a two-step process. First, the type of event must be identified. The following fpga_event_type variants are defined:</p> Event Description FPGA_EVENT_INTERRUPT AFU interrupt FPGA_EVENT_ERROR Infrastructure error event (FME/Port Error) <p>Table 6 FPGA Event Types</p> <p>Once the desired event type is known, an fpga_event_handle is created via fpgaCreateEventHandle(). Once the event handle is available, the event notification is registered using fpgaRegisterEvent(). In the example below, note the use of the flags field for passing the desired IRQ vector when the event type is FPGA_EVENT_INTERRUPT. With the event registered, the application can then use fpgaGetOSObjectFromEventHandle() to obtain a file descriptor for use with the poll() system call. When the interrupt occurs, the file descriptor will be set to the signaled state by the DFL driver.</p> <pre><code>fpga_event_handle event_handle = NULL;\nint fd = -1;\nfpgaCreateEventHandle(&amp;event_handle);\nfpgaRegisterEvent(fpga_handle, FPGA_EVENT_INTERRUPT,\nevent_handle, irq_vector);\nfpgaGetOSObjectFromEventHandle(event_handle, &amp;fd);\n</code></pre> <p>Figure 5 Creating and Registering Events</p> <p>When an event notification is no longer needed, it should be released by calling fpgaUnregisterEvent(). Like device handles, event handles are allocated resources that must be freed when no longer used. To free an event handle, use the fpgaDestroyEventHandle() call.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#215-mmio-and-shared-memory","title":"2.1.5 MMIO and Shared Memory","text":"<p>Communication with the AFU is achieved via reading and writing CSRs and by reading and writing to AFU/host shared memory buffers. An AFU\u2019s CSRs are memory-mapped into the application process address space by way of the fpgaMapMMIO() call.</p> <pre><code>uint32_t mmio_num = 0;\nfpgaMapMMIO(fpga_handle, mmio_num, NULL);\nfpgaWriteMMIO64(fpga_handle, mmio_num, MY_CSR, 0xa);\n</code></pre> <p>Figure 6 Mapping and Accessing CSRs</p> <p>The second parameter, mmio_num, is the zero-based index identifying the desired MMIO region. The maximum number of MMIO regions for a particular handle is found by accessing the num_mmio property. Refer to the fpgaPropertiesGetNumMMIO() call.</p> <p>Once the AFU CSRs are mapped into the process address space, the application can use the fpgaReadMMIO**XX**() and fpgaWriteMMIO**XX**() family of functions, eg fpgaReadMMIO64() and fpgaWriteMMIO64(). When an MMIO region is no longer needed, it should be unmapped from the process address space using the fpgaUnmapMMIO() call.</p> <p>Shared memory buffers are allocated by way of the fpgaPrepareBuffer() call.</p> <pre><code>fpga_result fpgaPrepareBuffer(fpga_handle handle,\nuint64_t len,\nvoid **buf_addr,\nuint64_t *wsid,\nint flags);\n</code></pre> <p>Figure 7 fpgaPrepareBuffer()</p> <p>Three buffer lengths are supported by this allocation method:</p> Length Description 4096 (4KiB) No memory configuration needed. 2097152 (2MiB) Requires 2MiB huge pages to be allocated. 1073741824 (1GiB) Requires 1GiB huge pages to be allocated. <p>Table 7 fpgaPrepareBuffer() Lengths</p> <pre><code>echo 8 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages\necho 2 &gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages\n</code></pre> <p>Figure 8 Configuring Huge Pages</p> <p>The buf_addr parameter to fpgaPrepareBuffer() is a pointer to a void * that accepts the user virtual base address of the newly-created buffer. The wsid parameter is a pointer to a uint64_t that receives a unique workspace ID for the buffer allocation. This workspace ID is used in subsequent calls to fpgaReleaseBuffer(), which should be called when the buffer is no longer needed and in calls to fpgaGetIOAddress() which is used to query the IO base address of the buffer. The IO base address can be programmed into the AFU by means of the AFU CSR space. For example, here is a code snippet from the hello_fpga sample that demonstrates programming a shared buffer\u2019s IO base address into an AFU CSR in MMIO region 0:</p> <pre><code>#define LOG2_CL 6\n#define CACHELINE_ALIGNED_ADDR(p) ((p) &gt;&gt; LOG2_CL)\nfpgaGetIOAddress(accelerator_handle, input_wsid, &amp;iova);\nfpgaWriteMMIO64(accelerator_handle, 0, nlb_base_addr + CSR_SRC_ADDR,\nCACHELINE_ALIGNED_ADDR(iova));\n</code></pre> <p>Figure 9 Programming Shared Memory</p> <p>If applications need to map a shared buffer that has been allocated by some other means than fpgaPrepareBuffer(), then the flags parameter can be set to FPGA_BUF_PREALLOCATED. This causes fpgaPrepareBuffer() to skip the allocation portion of the call and to only memory map the given buf_addr into the application process address space.</p> <p>Buffers can also be allocated and mapped as read-only by specifying FPGA_BUF_READ_ONLY.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#216-management","title":"2.1.6 Management","text":"<p>The management feature in OPAE concerns re-programming the programmable region of the Port. To program the Port bitstream, pass a handle to the FPGA_DEVICE associated with the desired Port. The slot parameter identifies which Port to program in the case of multi-port implementations. Most designs will only pass zero as the slot parameter. The bitstream parameter is a buffer that contains the entire bitstream contents, including the JSON bitstream header information. The bitstream_len field gives the length of bitstream in bytes.</p> <p>fpgaReconfigureSlot() first checks whether the FPGA_ACCELERATOR corresponding to the FPGA_DEVICE in fme_handle is open. If it is open, then the programming request is aborted with an error code. The application may pass FPGA_RECONF_FORCE in the flags parameter in order to avoid this open check and forcefully program the bitstream.</p> <pre><code>fpga_result fpgaReconfigureSlot(fpga_handle fme_handle,\nuint32_t slot,\nconst uint8_t *bitstream,\nsize_t bitstream_len,\nint flags);\n</code></pre> <p>Figure 10 fpgaReconfigureSlot()</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#217-errors","title":"2.1.7 Errors","text":"<p>The OPAE errors API provides a means to query and clear both FPGA_DEVICE and FPGA_ACCELERATOR errors. Each FPGA device exports a collection of error registers via the DFL drivers\u2019 sysfs tree, for both the FME and the Port. Each register is typically an unsigned 64-bit mask of the current errors, where each bit or some collection of bits specifies an error type. An error is signaled if its bit or collection of bits is non-zero. Note that the 32-bit error index may vary from one process execution to the next. Applications should use fpgaGetErrorInfo() and examine the error name returned in the struct fpga_error_info to identify the desired 64-bit error mask.</p> <pre><code>struct fpga_error_info {\nchar name[FPGA_ERROR_NAME_MAX];\nbool can_clear;\n};\n</code></pre> <p>Figure 11 struct fpga_error_info</p> <p>Each 64-bit mask of errors is assigned a unique 32-bit integer index and a unique name. Given an fpga_token and an error index, fpgaGetErrorInfo() retrieves the struct fpga_error_info corresponding to the error.</p> <pre><code>fpga_result fpgaGetErrorInfo(fpga_token token,\nuint32_t error_num,\nstruct fpga_error_info *error_info);\n</code></pre> <p>Figure 12 fpgaGetErrorInfo()</p> <p>fpgaReadError() provides access to the raw 64-bit error mask, given the unique error index. fpgaClearError() clears the errors for a particular index. fpgaClearAllErrors() clears all the errors for the given fpga_token.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#218-metrics","title":"2.1.8 Metrics","text":"<p>The OPAE metrics API refers to a group of functions and data structures that allow querying the various device metrics from the Board Management Controller component of the FPGA device. A metric is described by an instance of struct fpga_metric_info.</p> <p><pre><code>typedef struct fpga_metric_info {\nuint64_t metric_num;\nfpga_guid metric_guid;\nchar qualifier_name[FPGA_METRIC_STR_SIZE];\nchar group_name[FPGA_METRIC_STR_SIZE];\nchar metric_name[FPGA_METRIC_STR_SIZE];\nchar metric_units[FPGA_METRIC_STR_SIZE];\nenum fpga_metric_datatype metric_datatype;\nenum fpga_metric_type metric_type;\n} fpga_metric_info;\n</code></pre> Relevant Links:  - fpga_metric_datatype - fpga_metric_type</p> <p>Figure 13 fpga_metric_info</p> <p>The group_name field holds a string describing the broad categorization of the metric. Some sample values for group_name are \u201cthermal_mgmt\u201d and \u201cpower_mgmt\u201d. The metric_name field contains the metric\u2019s name. The number and names of metrics may vary from one FPGA platform to the next. The qualifier_name field is a concatenation of group_name and metric_name, with a colon character in between. The metric_units field contains the string name of the unit of measurement for the specific metric. Some examples for metric_units are \u201cVolts\u201d, \u201cAmps\u201d, and \u201cCelsius\u201d.</p> <p>The metric_datatype field uniquely identifies the underlying C data type for the metric\u2019s value:</p> <pre><code>enum fpga_metric_datatype {\nFPGA_METRIC_DATATYPE_INT,\nFPGA_METRIC_DATATYPE_FLOAT,\nFPGA_METRIC_DATATYPE_DOUBLE,\nFPGA_METRIC_DATATYPE_BOOL,\nFPGA_METRIC_DATATYPE_UNKNOWN\n};\n</code></pre> <p>Figure 14 enum fpga_metric_datatype</p> <p>The metric_type field classifies the metric into a broad category. This information is redundant with the group_name field.</p> <pre><code>enum fpga_metric_type {\nFPGA_METRIC_TYPE_POWER,\nFPGA_METRIC_TYPE_THERMAL,\nFPGA_METRIC_TYPE_PERFORMANCE_CTR,\nFPGA_METRIC_TYPE_AFU,\nFPGA_METRIC_TYPE_UNKNOWN\n};\n</code></pre> <p>Figure 15 enum fpga_metric_type</p> <p>In order to enumerate the information for each of the metrics available from the FPGA device, determine the number of metrics using fpgaGetNumMetrics().</p> <pre><code>uint64_t num_metrics = 0;\nfpgaGetNumMetrics(handle, &amp;num_metrics);\n</code></pre> <p>Figure 16 Determining Number of Metrics</p> <p>This call retrieves the number of available metrics for the FPGA_DEVICE that is opened behind the handle parameter to the call. Refer to 2.1.3 Access for information about the fpgaOpen() call. When the number of available metrics is known, allocate a buffer large enough to hold that many fpga_metric_info data structures, and call fpgaGetMetricsInfo() to populate the entries:</p> <pre><code>fpga_metric_info *metric_info;\nuint64_t metric_infos = num_metrics;\nmetric_info = calloc(num_metrics, sizeof(fpga_metric_info));\nfpgaGetMetricsInfo(handle, metric_info, &amp;metric_infos);\n</code></pre> <p>Figure 17 Querying Metrics Info</p> <p>The fpga_metric structure is the representation of a metric\u2019s value:</p> <p><pre><code>typedef struct fpga_metric {\nuint64_t metric_num;\nmetric_value value;\nbool isvalid;\n} fpga_metric;\n</code></pre> Relevant Links: - metric_value</p> <p>Figure 18 struct fpga_metric</p> <p>The metric_num field matches the metric_num field of the fpga_metric_info structure. value contains the metric value, which is encoded in the C data type identified by the metric_datatype field of fpga_metric_info. Finally, the isvalid field denotes whether the metric value is valid.</p> <p>There are two methods of obtaining a metric\u2019s value, given the information in the fpga_metric_info structure:</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2181-querying-metric-values-by-index","title":"2.1.8.1 Querying Metric Values by Index","text":"<p>fpgaGetMetricsByIndex() retrieves a metric value using the metric_num field of the metric info:</p> <pre><code>uint64_t metric_num = metric_info[0]-&gt;metric_num;\nfpga_metric metric0;\nfpgaGetMetricsByIndex(handle, &amp;metric_num, 1, &amp;metric0);\n</code></pre> <p>Figure 19 Retrieve Metric by Index</p> <p>This call allows retrieving one or more metric values, each identified by their unique metric_num. The second and fourth parameters allow passing arrays so that multiple values can be fetched in a single call.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2182-querying-metric-values-by-name","title":"2.1.8.2 Querying Metric Values by Name","text":"<p>fpgaGetMetricsByName() retrieves a metric value using the metric_name field of the metric info:</p> <pre><code>char *metric_name = metric_info[1]-&gt;metric_name;\nfpga_metric metric1;\nfpgaGetMetricsByName(handle, &amp;metric_name, 1, &amp;metric1);\n</code></pre> <p>This call also allows retrieving one or more metric values, each identified by their unique metric_name. The second and fourth parameters allow passing arrays so that multiple values can be fetched in a single call.</p> <p>The fpgaGetMetricsThresholdInfo() call is provided for legacy implementations only. It should be considered deprecated for current and future FPGA designs.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#219-sysobject","title":"2.1.9 SysObject","text":"<p>When the hardware access method in use is the DFL drivers (see 2.3.2 libxfpga Plugin), the sysfs tree rooted at the struct _fpga_token\u2019s sysfspath member is accessible via the OPAE SDK SysObject API. The SysObject API provides an abstraction to search, traverse, read, and write sysfs entities. These sysfs entities may take the form of directories, which are referred to as containers, or files, which are referred to as attributes. Figure 20 enum fpga_sysobject_type shows the API\u2019s means of distinguishing between the two types.</p> <pre><code>enum fpga_sysobject_type {\nFPGA_OBJECT_CONTAINER = (1u &lt;&lt; 0),\nFPGA_OBJECT_ATTRIBUTE = (1u &lt;&lt; 1)\n};\n</code></pre> <p>Figure 20 enum fpga_sysobject_type</p> <p>The SysObject API introduces another opaque structure type, fpga_object. An fpga_object can be queried from an fpga_token or an fpga_handle by way of the fpgaTokenGetObject() and fpgaHandleGetObject() API\u2019s.</p> <pre><code>fpga_result fpgaTokenGetObject(fpga_token token, const char *name,\nfpga_object *object, int flags);\nfpga_result fpgaHandleGetObject(fpga_handle handle, const char *name,\nfpga_object *object, int flags);\n</code></pre> <p>Figure 21 fpgaTokenGetObject() / fpgaHandleGetObject()</p> <p>The remainder of the SysObject API is broken into two categories of calls, depending on the fpga_object\u2019s type. The type of an fpga_object is learned via fpgaObjectGetType().</p> <pre><code>fpga_result fpgaObjectGetType(fpga_object obj,\nenum fpga_sysobject_type *type);\n</code></pre> <p>Figure 22 fpgaObjectGetType()</p> <p>When an fpga_object is no longer needed, it should be freed via fpgaDestroyObject().</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2191-fpga_object_container-apis","title":"2.1.9.1 FPGA_OBJECT_CONTAINER API\u2019s","text":"<p>For directory sysfs entities, passing a value of FPGA_OBJECT_RECURSE_ONE or FPGA_OBJECT_RECURSE_ALL in the flags parameter to fpgaTokenGetObject() or fpgaHandleGetObject() causes these two API\u2019s to treat the target object as either a single-layer or multi-layer directory structure, making its child entities available for query via fpgaObjectGetObject() and fpgaObjectGetObjectAt().</p> <pre><code>fpga_result fpgaObjectGetObject(fpga_object parent, const char *name,\nfpga_object *object, int flags);\nfpga_result fpgaObjectGetObjectAt(fpga_object parent, size_t idx,\nfpga_object *object);\n</code></pre> <p>Figure 23 fpgaObjectGetObject() / fpgaObjectGetObjectAt()</p> <p>Any child object resulting from fpgaObjectGetObject() or fpgaObjectGetObjectAt() must be freed via fpgaDestroyObject() when it is no longer needed.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2192-fpga_object_attribute-apis","title":"2.1.9.2 FPGA_OBJECT_ATTRIBUTE API\u2019s","text":"<p>Attribute sysfs entities may be queried for their size and read from or written to. In order to determine the size of an attribute\u2019s data, use fpgaObjectGetSize().</p> <pre><code>fpga_result fpgaObjectGetSize(fpga_object obj,\nuint32_t *value, int flags);\n</code></pre> <p>Figure 24 fpgaObjectGetSize()</p> <p>Attributes containing arbitrary string data can be read with fpgaObjectRead().</p> <pre><code>fpga_result fpgaObjectRead(fpga_object obj, uint8_t *buffer,\nsize_t offset, size_t len, int flags);\n</code></pre> <p>Figure 25 fpgaObjectRead()</p> <p>If an attribute contains an unsigned integer value, its value can be read with fpgaObjectRead64() and written with fpgaObjectWrite64().</p> <pre><code>fpga_result fpgaObjectRead64(fpga_object obj,\nuint64_t *value, int flags);\nfpga_result fpgaObjectWrite64(fpga_object obj,\nuint64_t value, int flags);\n</code></pre> <p>Figure 26 fpgaObjectRead64() / fpgaObjectWrite64()</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2110-utilities","title":"2.1.10 Utilities","text":"<p>The fpga_result enumeration defines a set of error codes used throughout OPAE. In order to convert an fpga_result error code into a printable string, the application can use the fpgaErrStr() call.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#22-dfl-driver-ioctl-interfaces","title":"2.2 DFL Driver IOCTL Interfaces","text":"<p>The DFL drivers export an IOCTL interface which the libxfpga.so plugin consumes in order to query and configure aspects of the FME and Port. These interfaces are used only internally by the SDK; they are not customer-facing. The description here is provided for completeness only.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#221-port-reset","title":"2.2.1 Port Reset","text":"<p>The DFL_FPGA_PORT_RESET ioctl is used by the fpgaReset() call in order to perform a Port reset. The fpga_handle passed to fpgaReset() must be a valid open handle to an FPGA_ACCELERATOR. The ioctl requires no input/output parameters.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#222-port-information","title":"2.2.2 Port Information","text":"<p>The DFL_FPGA_PORT_GET_INFO ioctl is used to query properties of the Port, notably the number of associated MMIO regions. The ioctl requires a pointer to a struct dfl_fpga_port_info.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#223-mmio-region-information","title":"2.2.3 MMIO Region Information","text":"<p>The DFL_FPGA_PORT_GET_REGION_INFO ioctl is used to query the details of an MMIO region. The ioctl requires a pointer to a struct dfl_fpga_port_region_info. The index field of the struct is populated by the caller, and the padding, size, and offset values are populated by the DFL driver.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#224-shared-memory-mapping-and-unmapping","title":"2.2.4 Shared Memory Mapping and Unmapping","text":"<p>The DFL_FPGA_PORT_DMA_MAP ioctl is used to map a memory buffer into the application\u2019s process address space. The ioctl requires a pointer to a struct dfl_fpga_port_dma_map.</p> <p>The DFL_FPGA_PORT_DMA_UNMAP ioctl is used to unmap a memory buffer from the application\u2019s process address space. The ioctl requires a pointer to a struct dfl_fpga_port_dma_unmap.</p> <p>These ioctls provide the underpinnings of the fpgaPrepareBuffer() and fpgaReleaseBuffer() calls.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#225-number-of-port-error-irqs","title":"2.2.5 Number of Port Error IRQs","text":"<p>The DFL_FPGA_PORT_ERR_GET_IRQ_NUM ioctl is used to query the number of Port error interrupt vectors available. The ioctl requires a pointer to a uint32_t that receives the Port error interrupt count.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#226-port-error-interrupt-configuration","title":"2.2.6 Port Error Interrupt Configuration","text":"<p>The DFL_FPGA_PORT_ERR_SET_IRQ ioctl is used to configure one or more file descriptors for the Port Error interrupt. The ioctl requires a pointer to a struct dfl_fpga_irq_set. The values stored in the evtfds field of this struct should be populated with the event file descriptors for the interrupt, as returned by the eventfd() C standard library API.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#227-number-of-afu-interrupts","title":"2.2.7 Number of AFU Interrupts","text":"<p>The DFL_FPGA_PORT_UINT_GET_IRQ_NUM ioctl is used to query the number of AFU interrupt vectors available. The ioctl requires a pointer to a uint32_t that receives the AFU interrupt count.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#228-user-afu-interrupt-configuration","title":"2.2.8 User AFU Interrupt Configuration","text":"<p>The DFL_FPGA_PORT_UINT_SET_IRQ ioctl is used to configure one or more file descriptors for the AFU interrupt. The ioctl requires a pointer to a struct dfl_fpga_irq_set. The values stored in the evtfds field of this struct should be populated with the event file descriptors for the interrupt, as returned by the eventfd() C standard library API.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#229-partial-reconfiguration","title":"2.2.9 Partial Reconfiguration","text":"<p>The DFL_FPGA_FME_PORT_PR ioctl is used to update the logic stored in the Port\u2019s programmable region. This ioctl must be issued on the device file descriptor corresponding to the FPGA_DEVICE (/dev/dfl-fme.X). The ioctl requires a pointer to a struct dfl_fpga_fme_port_pr with each of the fields populated.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2210-number-of-fme-error-irqs","title":"2.2.10 Number of FME Error IRQs","text":"<p>The DFL_FPGA_FME_ERR_GET_IRQ_NUM ioctl is used to query the number of FME error interrupt vectors available. The ioctl requires a pointer to a uint32_t that receives the FME error interrupt count.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2211-fme-error-interrupt-configuration","title":"2.2.11 FME Error Interrupt Configuration","text":"<p>The DFL_FPGA_FME_ERR_SET_IRQ ioctl is used to configure one or more file descriptors for the FME Error interrupt. The ioctl requires a pointer to a struct dfl_fpga_irq_set. The values stored in the evtfds field of this struct should be populated with the event file descriptors for the interrupt, as returned by the eventfd() C standard library API. as returned by the eventfd() C standard library API.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#23-plugin-manager","title":"2.3 Plugin Manager","text":"<p>The OPAE Plugin Manager refers to initialization code in libopae-c that examines an FPGA device\u2019s PCIe Vendor and Device ID and makes an association between a particular FPGA device and its access method. OPAE currently supports three device access methods:</p> <p>Access Method</p> <p>Plugin Module</p> Device Feature List drivers libxfpga.so Virtual Function I/O libopae-v.so AFU Simulation Environment libase.so <p>Table 9 Plugin Device Access Methods</p> <p>The Plugin Manager allows code that is written to a specific API signature to access FPGA hardware via different mechanisms. In other words, the end user codes to the OPAE API; and the OPAE API, based on configuration data, routes the hardware access to the device via different means.</p> <p>As an example, consider an API configuration that accesses FPGA device_A via the Device Feature List drivers and that accesses FPGA device_B via VFIO. The application is coded against the OPAE API.</p> <p>As part of its initialization process, the application enumerates and discovers an fpga_token corresponding to device_A. That fpga_token is opened and its MMIO region 0 is mapped via a call to fpgaMapMMIO().</p> <p>The API configuration for device_A is such that the fpga_handle corresponding to device_A routes its hardware access calls through libxfpga.so. The call to fpgaMapMMIO() is redirected to libxfpga.so\u2019s implementation of the MMIO mapping function, xfpga_fpgaMapMMIO(). As a result, the call to xfpga_fpgaMapMMIO() uses its AFU file descriptor to communicate with the DFL driver to map the MMIO region.</p> <p>Subsequently, the application enumerates and discovers an fpga_token corresponding to device_B. That fpga_token is opened and its MMIO region 0 is mapped via a call to fpgaMapMMIO().</p> <p>The API configuration for device_B is such that the fpga_handle corresponding to device_B routes its hardware access calls through libopae-v.so. The call to fpgaMapMMIO() is redirected to libopae-v.so\u2019s implementation of the MMIO mapping function, vfio_fpgaMapMMIO(). As a result, the call to vfio_fpgaMapMMIO() uses the MMIO mapping performed by libopaevfio.so during initialization of the VFIO session.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#231-plugin-model","title":"2.3.1 Plugin Model","text":"<p>The OPAE SDK plugin model is facilitated by its use of opaque C structures for fpga_token and fpga_handle. These types are both declared as void *; and this allows the parameters to the OPAE SDK functions to take different forms, depending on the layer of the SDK being used.</p> <p>At the topmost layer, for example when calling fpgaEnumerate(), the output fpga_token parameter array is actually an array of pointers to opae_wrapped_token struct\u2019s.</p> <pre><code>typedef struct _opae_wrapped_token {\nuint32_t magic;\nfpga_token opae_token;\nuint32_t ref_count;\nstruct _opae_wrapped_token *prev;\nstruct _opae_wrapped_token *next;\nopae_api_adapter_table *adapter_table;\n} opae_wrapped_token;\n</code></pre> <p>Figure 27 opae_wrapped_token</p> <p>An opae_wrapped_token, as the name suggests, is a thin wrapper around the lower-layer token which is stored in struct member opae_token. The adapter_table struct member is a pointer to a plugin-specific adapter table. The adapter table provides a mapping between the top-layer opae_wrapped_token and its underlying plugin-specific API entry points, which are called using the opae_token struct member (the lower-level token).</p> <pre><code>typedef struct _opae_api_adapter_table {\nstruct _opae_api_adapter_table *next;\nopae_plugin plugin;\n...\nfpga_result (*fpgaEnumerate)(const fpga_properties *filters,\nuint32_t num_filters,\nfpga_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n...\nint (*initialize)(void);\nint (*finalize)(void);\n} opae_api_adapter_table;\n</code></pre> <p>Figure 28 opae_api_adapter_table</p> <p>When libopae-c loads, the plugin manager uses the plugin configuration data to open and configure a session to each of the required plugin libraries. During this configuration process, each plugin is passed an empty adapter table struct. The purpose of the plugin configuration is to populate this adapter table struct with each of the plugin-specific API entry points.</p> <p>When the top-level fpgaEnumerate() is called, each adapter table\u2019s plugin-specific fpgaEnumerate() struct member is called; and the output fpga_token\u2019s are collected. At this point, these fpga_token\u2019s are the lower-level token structure types. Before the top-level fpgaEnumerate() returns, these plugin-specific tokens are wrapped inside opae_wrapped_token structures, along with a pointer to the respective adapter table.</p> <p>After enumeration is complete, the application goes on to call other top-level OPAE SDK functions with the wrapped tokens. Each top-level entry point which accepts an fpga_token knows that it is actually being passed an opae_wrapped_token. With this knowledge, the entry point peeks inside the wrapped token and calls through to the plugin-specific API entry point using the adapter table, passing the lower-level opae_token struct member.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#232-libxfpga-plugin","title":"2.3.2 libxfpga Plugin","text":"<p>2.3.1 Plugin Model introduced the concept of an opae_wrapped_token and a corresponding plugin-specific token structure. libxfpga.so is the plugin library that implements the DFL driver hardware access method. Its plugin-specific token data structure is struct _fpga_token.</p> <p><pre><code>struct _fpga_token {\nfpga_token_header hdr;\nuint32_t device_instance;\nuint32_t subdev_instance;\nchar sysfspath[SYSFS_PATH_MAX];\nchar devpath[DEV_PATH_MAX];\nstruct error_list *errors;\n};\n</code></pre> Relevant Links: - fpga_token_header - error_list</p> <p>Figure 29 struct _fpga_token</p> <p>A struct _fpga_token corresponding to the Port will have sysfspath and devpath members that contain strings like the following example paths:</p> <pre><code>sysfspath: \u201c/sys/class/fpga_region/region0/dfl-port.0\u201d\ndevpath: \u201c/dev/dfl-port.0\u201d\n</code></pre> <p>Figure 30 libxfpga Port Token</p> <p>Likewise, a struct _fpga_token corresponding to the FME will have sysfspath and devpath members that contain strings like the following example paths:</p> <pre><code>sysfspath: \u201c/sys/class/fpga_region/region0/dfl-fme.0\u201d\ndevpath: \u201c/dev/dfl-fme.0\u201d\n</code></pre> <p>Figure 31 libxfpga FME Token</p> <p>When a call to the top-level fpgaOpen() is made, the lower-level token is unwrapped and passed to xfpga_fpgaOpen(). In return, xfpga_fpgaOpen() opens the character device file identified by the devpath member of the struct _fpga_token. It then allocates and initializes an instance of libxfpga.so\u2019s plugin-specific handle data structure, struct _fpga_handle.</p> <p><pre><code>struct _fpga_handle {\npthread_mutex_t lock;\nuint64_t magic;\nfpga_token token;\nint fddev;\nint fdfpgad;\nuint32_t num_irqs;\nuint32_t irq_set;\nstruct wsid_tracker *wsid_root;\nstruct wsid_tracker *mmio_root;\nvoid *umsg_virt;\nuint64_t umsg_size;\nuint64_t *umsg_iova;\nbool metric_enum_status;\nfpga_metric_vector fpga_enum_metric_vector;\nvoid *bmc_handle;\nstruct _fpga_bmc_metric *_bmc_metric_cache_value;\nuint64_t num_bmc_metric;\nuint32_t flags;\n};\n</code></pre> Relevant Links: - wsid_tracker - fpga_metric_vector - _fpga_bmc_metric</p> <p>Figure 32 struct _fpga_handle</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#233-libopae-v-plugin","title":"2.3.3 libopae-v Plugin","text":"<p>libopae-v.so is the plugin library that implements the VFIO hardware access method. Its plugin-specific token data structure is vfio_token.</p> <p><pre><code>#define USER_MMIO_MAX 8\ntypedef struct _vfio_token {\nfpga_token_header hdr;\nfpga_guid compat_id;\npci_device_t *device;\nuint32_t region;\nuint32_t offset;\nuint32_t mmio_size;\nuint32_t pr_control;\nuint32_t user_mmio_count;\nuint32_t user_mmio[USER_MMIO_MAX];\nuint64_t bitstream_id;\nuint64_t bitstream_mdata;\nuint8_t num_ports;\nstruct _vfio_token *parent;\nstruct _vfio_token *next;\nvfio_ops ops;\n} vfio_token;\n</code></pre> Relevant Links: - fpga_token_header - pci_device_t - vfio_ops</p> <p>Figure 33 vfio_token</p> <p>When a call to the top-level fpgaOpen() is made, the lower-level token is unwrapped and passed to vfio_fpgaOpen(). In return, vfio_fpgaOpen() opens the VFIO device matching the device address found in the input vfio_token. It then allocates and initializes an instance of libopae-v.so\u2019s plugin-specific handle data structure, vfio_handle.</p> <p><pre><code>typedef struct _vfio_handle {\nuint32_t magic;\nstruct _vfio_token *token;\nvfio_pair_t *vfio_pair;\nvolatile uint8_t *mmio_base;\nsize_t mmio_size;\npthread_mutex_t lock;\n#define OPAE_FLAG_HAS_AVX512 (1u &lt;&lt; 0)\nuint32_t flags;\n} vfio_handle;\n</code></pre> Relevant Links: - vfio_token - vfio_pair_t</p> <p>Figure 34 vfio_handle</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2331-supporting-libraries","title":"2.3.3.1 Supporting Libraries","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#23311-libopaevfio","title":"2.3.3.1.1 libopaevfio","text":"<p>libopaevfio.so is OPAE\u2019s implementation of the Linux kernel\u2019s Virtual Function I/O interface. This VFIO interface presents a generic means of configuring and accessing PCIe endpoints from a user-space process via a supporting Linux kernel device driver, vfio-pci.</p> <p>libopaevfio.so provides APIs for opening/closing a VFIO device instance, for mapping/unmapping MMIO spaces, for allocating/freeing DMA buffers, and for configuring interrupts for the device.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#23312-libopaemem","title":"2.3.3.1.2 libopaemem","text":"<p>Each DMA buffer allocation made by libopaevfio.so\u2019s opae_vfio_buffer_allocate() and opae_vfio_buffer_allocate_ex() APIs requires a backing I/O Virtual Address range. These address ranges are discovered at VFIO device open time by way of the VFIO_IOMMU_GET_INFO ioctl.</p> <p>Each range specifies a large contiguous block of I/O Virtual Address space. The typical DMA buffer allocation size is significantly less than one of these IOVA blocks, so the division of each block into allocatable segments must be managed so that multiple DMA buffer allocations can be made from a single block. In other words, the IOVA blocks must be memory-managed in order to make efficient use of them.</p> <p>libopaemem.so provides a generic means of managing a large memory space, consisting of individual large memory blocks of contiguous address space. When a DMA buffer allocation is requested, libopaevfio.so uses this generic memory manager to carve out a small chunk of contiguous IOVA address space in order for the DMA mapping to be made. The IOVA space corresponding to the allocation is marked as allocated, and the rest of the large block remains as allocatable space within the memory manager. Subsequent de-allocation returns a chunk of IOVA space to the free state, coalescing contiguous chunks as they are freed. The allocations and de-allocations of the IOVA space can occur in any order with respect to each other. libopaemem.so tracks both the allocated and free block space, carving out small chunks from the large IOVA blocks on allocations, and coalescing small chunks back into larger ones on frees.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2332-configuring-pcie-virtual-functions","title":"2.3.3.2 Configuring PCIe Virtual Functions","text":"<p>Before an AFU can be accessed with VFIO, the FPGA Physical Function must be configured to enable its Virtual Functions. Then, each VF must be bound to the vfio-pci Linux kernel driver.</p> <p>As of the Arrow Creek program, the FPGA hardware allows multiple AFU\u2019s to co-exist by placing each AFU in its own PCIe Virtual Function. Upon system startup, no PCIe VF\u2019s exist. The pci_device command can be used to enable the VF\u2019s and their AFU\u2019s. First, use the lspci command to examine the current device topology:</p> <pre><code># lspci | grep cel\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\nb1:00.2 Processing accelerators: Intel Corporation Device bcce\nb1:00.3 Processing accelerators: Intel Corporation Device bcce\nb1:00.4 Processing accelerators: Intel Corporation Device bcce\n</code></pre> <p>Figure 35 lspci Device Topology</p> <p>In this example, VF\u2019s are controlled by PF 0, as highlighted in Figure 35 lspci Device Topology. In the figure, each PF is shown as having the Arrow Creek PF PCIe device ID of bcce.</p> <p>Now, use the pci_device command to enable three VF\u2019s for PF0:</p> <pre><code># pci_device 0000:b1:00.0 vf 3\n# lspci | grep cel\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\nb1:00.2 Processing accelerators: Intel Corporation Device bcce\nb1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device\nb1:00.4 Processing accelerators: Intel Corporation Device bcce\nb1:00.5 Processing accelerators: Intel Corporation Device bccf\nb1:00.6 Processing accelerators: Intel Corporation Device bccf\nb1:00.7 Processing accelerators: Intel Corporation Device bccf\n</code></pre> <p>Figure 36 Enable Virtual Functions</p> <p>Figure 20 Enable Virtual Functions shows that three VF\u2019s were created. Each VF is shown as having the Arrow Creek VF PCIe device ID of bccf.</p> <p>Now, each Virtual Function must be bound to the vfio-pci Linux kernel driver so that it can be accessed via VFIO:</p> <pre><code># opaevfio -i -u myuser -g mygroup 0000:b1:00.5\nBinding (0x8086,0xbccf) at 0000:b1:00.5 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:b1:00.5 is 318\n</code></pre> <p>Figure 37 Bind VF's to vfio-pci</p> <p>Here, myuser and mygroup identify the unprivileged user/group that requires access to the device. The opaevfio command will change the ownership of the device per the values given.</p> <p>Once the VF\u2019s are bound to vfio-pci, the OPAE SDK will find and enumerate them with libopae-v.so:</p> <pre><code># fpgainfo port\n//****** PORT ******//\nObject Id : 0xEF00000\nPCIe s:b:d.f : 0000:B1:00.0\nDevice Id : 0xBCCE\nSocket Id : 0x00\n//****** PORT ******//\nObject Id : 0xE0B1000000000000\nPCIe s:b:d.f : 0000:B1:00.7\nDevice Id : 0xBCCF\nSocket Id : 0x01\nAccelerator GUID : 4dadea34-2c78-48cb-a3dc-5b831f5cecbb\n//****** PORT ******//\nObject Id : 0xC0B1000000000000\nPCIe s:b:d.f : 0000:B1:00.6\nDevice Id : 0xBCCF\nSocket Id : 0x01\nAccelerator GUID : 823c334c-98bf-11ea-bb37-0242ac130002\n//****** PORT ******//\nObject Id : 0xA0B1000000000000\nPCIe s:b:d.f : 0000:B1:00.5\nDevice Id : 0xBCCF\nSocket Id : 0x01\nAccelerator GUID : 8568ab4e-6ba5-4616-bb65-2a578330a8eb\n</code></pre> <p>Figure 38 List VF's with fpgainfo</p> <p>When the VF\u2019s are no longer needed, they can be unbound from the vfio-pci driver:</p> <pre><code># opaevfio -r 0000:b1:00.5\nReleasing (0x8086,0xbccf) at 0000:b1:00.5 from vfio-pci\n# opaevfio -r 0000:b1:00.6\nReleasing (0x8086,0xbccf) at 0000:b1:00.6 from vfio-pci\n# opaevfio -r 0000:b1:00.7\nReleasing (0x8086,0xbccf) at 0000:b1:00.7 from vfio-pci\n</code></pre> <p>Figure 39 Unbind VF's from vfio-pci</p> <p>Finally, the VF\u2019s can be disabled:</p> <pre><code># pci_device 0000:b1:00.0 vf 0\n# lspci | grep cel\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\nb1:00.2 Processing accelerators: Intel Corporation Device bcce\nb1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device\nb1:00.4 Processing accelerators: Intel Corporation Device bcce\n</code></pre> <p>Figure 40 Disable Virtual Functions</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#24-application-flow","title":"2.4 Application Flow","text":"<p>A typical OPAE application that interacts with an AFU via MMIO and shared memory will have a flow similar to the one described in this section.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#241-create-filter-criteria","title":"2.4.1 Create Filter Criteria","text":"<p>Refer to 2.1.2 Enumeration. When enumerating AFU\u2019s, if no filtering criteria is specified, then fpgaEnumerate() returns fpga_token\u2019s for each AFU that is present in the system. In order to limit the enumeration search to a specific AFU, create an fpga_properties object and set its guid to that of the desired AFU:</p> <pre><code>#define MY_AFU_GUID \u201c57fa0b03-ab4f-4b02-b4eb-d3fe1ec18518\u201d\nfpga_properties filter = NULL;\nfpga_guid guid;\nfpgaGetProperties(NULL, &amp;filter);\nuuid_parse(MY_AFU_GUID, guid);\nfpgaPropertiesSetGUID(filter, guid);\n</code></pre> <p>Figure 41 Flow: Create Filter Criteria</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#242-enumerate-the-afu","title":"2.4.2 Enumerate the AFU","text":"<p>With the filtering criteria in place, enumerate to obtain an fpga_token for the AFU:</p> <pre><code>fpga_token afu_token = NULL;\nuint32_t num_matches = 0;\nfpgaEnumerate(&amp;filter, 1, &amp;afu_token, 1, &amp;num_matches);\n</code></pre> <p>Figure 42 Flow: Enumerate the AFU</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#243-open-the-afu","title":"2.4.3 Open the AFU","text":"<p>After finding an fpga_token for the AFU using fpgaEnumerate(), the token must be opened with fpgaOpen() to establish a session with the AFU. The process of opening an fpga_token creates an fpga_handle:</p> <pre><code>fpga_handle afu_handle = NULL;\nfpgaOpen(afu_token, &amp;afu_handle, 0);\n</code></pre> <p>Figure 43 Flow: Open the AFU</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#244-map-mmio-region","title":"2.4.4 Map MMIO Region","text":"<p>In order to access the MMIO region of the AFU to program its CSR\u2019s, the region must first be mapped into the application\u2019s process address space. This is accomplished using fpgaMapMMIO():</p> <pre><code>uint32_t region = 0;\nfpgaMapMMIO(afu_handle, region, NULL);\n</code></pre> <p>Figure 44 Flow: Map MMIO Region</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#245-allocate-dma-buffers","title":"2.4.5 Allocate DMA Buffers","text":"<p>If the AFU is DMA-capable, shared memory buffers can be allocated and mapped into the process address space and the IOMMU with fpgaPrepareBuffer(). Refer to Figure 8 Configuring Huge Pages for instructions on configuring 2MiB and 1GiB huge pages.</p> <pre><code>#define BUF_SIZE (2 * 1024 * 1024)\nvolatile uint64_t *src_ptr = NULL;\nuint64_t src_wsid = 0;\nvolatile uint64_t *dest_ptr = NULL;\nuint64_t dest_wsid = 0;\nfpgaPrepareBuffer(afu_handle, BUF_SIZE, (void **)&amp;src_ptr,\n&amp;src_wsid, 0);\nfpgaPrepareBuffer(afu_handle, BUF_SIZE, (void **)&amp;dest_ptr,\n&amp;dest_wsid, 0);\nmemset(src_ptr, 0xaf, BUF_SIZE);\nmemset(dest_ptr, 0xbe, BUF_SIZE);\n</code></pre> <p>Figure 45 Flow: Allocate DMA Buffers</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#246-make-afu-aware-of-dma-buffers","title":"2.4.6 Make AFU Aware of DMA Buffers","text":"<p>The process by which locations of shared memory buffers and their sizes are made known to the AFU is entirely AFU-specific. This example shows the method used by the Native Loopback AFU. Each buffer I/O virtual address is cacheline-aligned and programmed into a unique AFU CSR; then the buffer size in lines is programmed into a length CSR:</p> <pre><code>#define CSR_SRC_ADDR 0x000A // AFU-specific\n#define CSR_DEST_ADDR 0x000B // AFU-specific\n#define CSR_NUM_LINES 0x000C // AFU-specific\nuint64_t src_iova = 0;\nuint64_t dest_iova = 0;\nfpgaGetIOAddress(afu_handle, src_wsid, &amp;src_iova);\nfpgaGetIOAddress(afu_handle, dest_wsid, &amp;dest_iova);\nfpgaWriteMMIO64(afu_handle, 0, CSR_SRC_ADDR, src_iova &gt;&gt; 6);\nfpgaWriteMMIO64(afu_handle, 0, CSR_DEST_ADDR, dest_iova &gt;&gt; 6);\nfpgaWriteMMIO32(afu_handle, 0, CSR_NUM_LINES, BUF_SIZE / 64);\n</code></pre> <p>Figure 46 Flow: Make AFU Aware of DMA Buffers</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#247-initiate-an-acceleration-task","title":"2.4.7 Initiate an Acceleration Task","text":"<p>With the shared buffer configuration complete, the AFU can be told to initiate the acceleration task. This process is AFU-specific. The Native Loopback AFU starts the acceleration task by writing a value to its control CSR:</p> <pre><code>#define CSR_CTRL 0x000D // AFU-specific\nfpgaWriteMMIO32(afu_handle, 0, CSR_CTRL, 3);\n</code></pre> <p>Figure 47 Initiate an Acceleration Task</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#248-wait-for-task-completion","title":"2.4.8 Wait for Task Completion","text":"<p>Once the acceleration task is initiated, the application may poll the AFU for a completion status. This process is AFU-specific. The AFU may provide a status CSR for the application to poll; or the AFU may communicate status to the application by means of a result code written to a shared buffer.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#249-free-dma-buffers","title":"2.4.9 Free DMA Buffers","text":"<p>When the acceleration task completes and the AFU is quiesced such that there are no outstanding memory transactions targeted for the shared memory, the DMA buffers can be unmapped and freed using fpgaReleaseBuffer():</p> <pre><code>fpgaReleaseBuffer(afu_handle, src_wsid);\nfpgaReleaseBuffer(afu_handle, dest_wsid);\n</code></pre> <p>Figure 48 Flow: Free DMA Buffers</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2410-unmap-mmio-region","title":"2.4.10 Unmap MMIO Region","text":"<p>The MMIO regions should also be unmapped using fpgaUnmapMMIO():</p> <p><pre><code>fpgaUnmapMMIO(afu_handle, region);\n</code></pre> </p> <p>Figure 49 Flow: Unmap MMIO Region</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2411-close-the-afu","title":"2.4.11 Close the AFU","text":"<p>The AFU handle should be closed via fpgaClose() to release its resources:</p> <p></p> <pre><code>fpgaClose(afu_handle);\n</code></pre> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2412-release-the-tokens-and-properties","title":"2.4.12 Release the Tokens and Properties","text":"<p>The fpga_token\u2019s returned by fpgaEnumerate() should be destroyed using the fpgaDestroyToken() API. The fpga_properties objects should be destroyed using the fpgaDestroyProperties() API:</p> <pre><code>fpgaDestroyToken(&amp;afu_token);\nfpgaDestroyProperties(&amp;filter);\n</code></pre> <p>Figure 51 Flow: Release the Tokens and Properties</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#30-opae-c-api","title":"3.0 OPAE C++ API","text":"<p>The OPAE C++ API refers to a C++ layer that sits on top of the OPAE C API, providing object-oriented implementations of the main OPAE C API abstractions: properties, tokens, handles, dma buffers, etc. Like the OPAE C API, the C++ API headers contain Doxygen markup for each of the provided classes.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#31-libopae-cxx-core","title":"3.1 libopae-cxx-core","text":"<p>The implementation files for the C++ API are compiled into libopae-cxx-core.so. A convenience header, core.h, provides a quick means of including each of the C++ API headers. Each of the types comprising the C++ API is located within the opae::fpga::types C++ namespace.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#311-properties","title":"3.1.1 Properties","text":"<p>Class properties provides the C++ implementation of the fpga_properties type and its associated APIs.</p> <pre><code>properties::ptr_t filter = properties::get();\n</code></pre> <p>Figure 52 C++ Create New Empty Properties</p> <p>Class properties provides member variables for each fpga_properties item that can be manipulated with fpgaPropertiesGet\u2026() and fpgaPropertiesSet\u2026(). For example, to set the AFU ID in a properties instance and to set that instance\u2019s type to FPGA_ACCELERATOR:</p> <pre><code>#define MY_AFU_ID \u201c8ad74241-d13b-48eb-b428-7986dcbcab14\u201d\nfilter-&gt;guid.parse(MY_AFU_ID);\nfilter-&gt;type = FPGA_ACCELERATOR;\n</code></pre> <p>Figure 53 C++ Properties Set GUID and Type</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#312-tokens","title":"3.1.2 Tokens","text":"<p>Class token provides the C++ implementation of the fpga_token type and its associated APIs. Class token also provides the enumerate() static member function:</p> <pre><code>std::vector&lt;token::ptr_t&gt; tokens = token::enumerate({filter});\nif (tokens.size() &lt; 1) {\n// flag error and return\n}\ntoken::ptr_t tok = tokens[0];\n</code></pre> <p>Figure 54 C++ Enumeration</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#313-handles","title":"3.1.3 Handles","text":"<p>Class handle provides the C++ implementation of the fpga_handle type and its associated APIs. The handle class provides member functions for opening and closing a token, for reading and writing to MMIO space, and for reconfiguring the FPGA\u2019s Programmable Region.</p> <pre><code>handle::ptr_t accel = handle::open(tok, 0);\n</code></pre> <p>Figure 55 C++ Opening a Handle</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#314-shared-memory","title":"3.1.4 Shared Memory","text":"<p>The shared_buffer class provides member functions for allocating and releasing DMA buffers, for querying buffer attributes, and for reading and writing buffers.</p> <pre><code>#define BUF_SIZE (2 * 1024 * 1024)\nshared_buffer::ptr_t input = shared_buffer::allocate(accel, BUF_SIZE);\nshared_buffer::ptr_t output = shared_buffer::allocate(accel, BUF_SIZE);\nstd::fill_n(input-&gt;c_type(), BUF_SIZE, 0xaf);\nstd::fill_n(output-&gt;c_type(), BUF_SIZE, 0xbe);\n</code></pre> <p>Figure 56 C++ Allocate and Init Buffers</p> <p>Once DMA buffers have been allocated, their IO addresses are programmed into AFU-specific CSRs to enable the DMA. Here, the IO address of each buffer is aligned to the nearest cache line before programming it into the AFU CSR space. The number of cache lines is then programmed into the appropriate AFU CSR.</p> <pre><code>#define CSR_SRC_ADDR 0x000A // AFU-specific\n#define CSR_DEST_ADDR 0x000B // AFU-specific\n#define CSR_NUM_LINES 0x000C // AFU-specific\n#define LOG2_CL 6\naccel-&gt;write_csr64(CSR_SRC_ADDR, input-&gt;io_address() &gt;&gt; LOG2_CL);\naccel-&gt;write_csr64(CSR_DEST_ADDR, output-&gt;io_address() &gt;&gt; LOG2_CL);\naccel-&gt;write_csr32(CSR_NUM_LINES, BUF_SIZE / 64);\n</code></pre> <p>Figure 57 C++ Make the AFU Aware of DMA Buffers</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#315-events","title":"3.1.5 Events","text":"<p>The event class provides member functions for event registration. In order to register an event, provide the handle::ptr_t for the desired device, along with the event type and optional flags.</p> <pre><code>int vect = 2;\nevent::ptr_t evt = event::register_event(accel,\nFPGA_EVENT_INTERRUPT,\nvect);\nint evt_fd = evt.os_object();\n</code></pre> <p>Figure 58 C++ Event Registration</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#316-errors","title":"3.1.6 Errors","text":"<p>Class error provides a means of querying the device errors given a token::ptr_t. The token and integer ID provided to the error::get() static member function uniquely identify one of the 64-bit error masks associated with the token.</p> <pre><code>error::ptr_t err = error::get(tok, 0); </code></pre> <p>Figure 59 C++ Query Device Errors</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#317-sysobject","title":"3.1.7 SysObject","text":"<p>Class sysobject is the C++ implementation of the OPAE SysObject API. sysobject provides a means of creating class instances via its two sysobject::get() static member functions. A third non-static sysobject::get() enables creating a sysobject instance given a parent sysobject instance. The read64() and write64() member functions allow reading and writing the sysobject\u2019s value as a 64-bit unsigned integer. The bytes() member functions allow reading a sysobject\u2019s value as a raw byte stream.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#40-opae-python-api","title":"4.0 OPAE Python API","text":"<p>The OPAE Python API refers to a Python layer that sits on top of the OPAE C++ API, providing Python implementations of the OPAE C++ API abstractions: properties, tokens, handles, dma buffers, etc.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#41-_opae","title":"4.1 _opae","text":"<p>The Python API is coded as a pybind11 project, which allows C++ code to directly interface with Python internals. Each C++ API concept is encoded into a Python equivalent. The functionality exists as a Python extension module, compiled into _opae.so.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#411-enumeration","title":"4.1.1 Enumeration","text":"<p>Enumeration is somewhat simplified as compared to the OPAE C/C++ APIs. The fpga.enumerate() function accepts keyword arguments for each of the property names that are defined in the C++ API. As an example, to enumerate for an FPGA_ACCELERATOR by its GUID:</p> <pre><code>from opae import fpga\nMY_ACCEL = \u201cd573b29e-176f-4cb7-b810-efbf7be34cc9\u201d\ntokens = fpga.enumerate(type=fpga.ACCELERATOR, guid=MY_ACCEL)\nassert tokens, \u201cNo accelerator matches {}\u201d.format(MY_ACCEL)\n</code></pre> <p>Figure 60 Python Enumeration</p> <p>The return value from the fpga.enumerate() function is a list of all the token objects matching the search criteria.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#412-properties","title":"4.1.2 Properties","text":"<p>Querying properties for a token or handle is also a bit different in the Python API. In order to query properties for one of these objects, pass the object to the fpga.properties() constructor. The return value is a properties object with each of the property names defined as instance attributes.</p> <pre><code>prop = fpga.properties(tokens[0])\nprint(f'0x{prop.vendor_id:04x} 0x{prop.device_id:04x}')\n</code></pre> <p>Figure 61 Python Get Token Properties</p> <p>Properties objects may also be created by invoking the fpga.properties() constructor, passing the same keyword arguments as those to fpga.enumerate(). Properties objects created in this way are also useful for enumeration purposes:</p> <pre><code>props = fpga.properties(type=fpga.ACCELERATOR)\ntokens = fpga.enumerate([props])\n</code></pre> <p>Figure 62 Python Properties Constructor</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#413-tokens","title":"4.1.3 Tokens","text":"<p>Tokens overload both the __getitem__ and __getattr__ methods to enable the SysObject API. Both of the following are valid forms of accessing the \u2018errors/first_error\u2019 sysfs attribute, given a token object:</p> <pre><code>tok = tokens[0]\nferr = tok['errors/first_error']\nprint(f'first error: 0x{ferr.read64():0x}')\nprint('0x{:0x}'.format(tok.errors.first_error.read64()))\n</code></pre> <p>Figure 63 Python Tokens and SysObject API</p> <p>Tokens also implement a find() method, which accepts a glob expression in order to search sysfs. The following example finds the \u201cid\u201d sysfs entry in the given token\u2019s sysfs tree.</p> <pre><code>my_id = tok.find(\u2018i?\u2019)\nprint(f'{my_id.read64()}')\n</code></pre> <p>Figure 64 Python Token Find</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#414-handles","title":"4.1.4 Handles","text":"<p>Tokens are converted to handles by way of the fpga.open() function. The flags (second) parameter to fpga.open() may be zero or fpga.OPEN_SHARED.</p> <pre><code>with fpga.open(tok, fpga.OPEN_SHARED) as handle:\nuse_the_handle(handle)\n</code></pre> <p>Figure 65 Python Open Handle</p> <p>Like token objects, handle objects overload __getitem__ and __getattr__ methods to enable the SysObject API. handle also provides a find() method similar to token\u2019s find().</p> <pre><code>err = handle['errors/errors']\nprint(f'errors: 0x{err.read64():0x}')\nprint('first error: 0x{:0x}'.format(\nhandle.errors.first_error.read64()))\nmy_id = handle.find('i?')\nprint(f'{my_id.read64()}')\n</code></pre> <p>Figure 66 Python Handles and SysObject API</p> <p>Partial reconfiguration is provided by class handle\u2019s reconfigure() method. The first parameter, slot, will be zero in most designs. The second parameter is an opened file descriptor to the file containing the GBS image. The third parameter, flags, defaults to zero.</p> <pre><code>with open(\u2018my.gbs\u2019, \u2018rb\u2019) as fd:\nhandle.reconfigure(0, fd)\n</code></pre> <p>Figure 67 Python Partial Reconfiguration</p> <p>Device reset is accomplished by means of handle\u2019s reset() method, which takes no parameters.</p> <p>Finally for handles, CSR space reads are accomplished via read_csr32() and read_csr64(). Both methods accept the register offset as the first parameter and an optional csr_space index, which defaults to zero, as the second parameter. CSR space writes are accomplished via write_csr32() and write_csr64(). Both methods accept the register offset as the first parameter, the value to write as the second, and an optional csr_space index, which defaults to zero, as the third.</p> <pre><code>print(\u20190x{:0x}\u2019.format(handle.read_csr32(0x000a)))\nprint(\u20180x{:0x}\u2019.format(handle.read_csr64(0x000c)))\nhandle.write_csr32(0x000b, 0xdecafbad, 2)\nhandle.write_csr64(0x000e, 0xc0cac01adecafbad, 2)\n</code></pre> <p>Figure 68 Python Read/Write CSR</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#415-shared-memory","title":"4.1.5 Shared Memory","text":"<p>The fpga.allocate_shared_buffer() function provides access to the OPAE memory allocator. The allocation sizes and required huge page configurations are the same as those noted in 2.1.5 MMIO and Shared Memory.</p> <p>The fpga.allocate_shared_buffer() function returns an object instance of type shared_buffer. The shared_buffer class implements methods size(), wsid(), and io_address(), which return the buffer size in bytes, the unique workspace ID, and the IO address respectively:</p> <pre><code>buf = fpga.allocate_shared_buffer(handle, 4096)\nprint(f\u2019size: {buf.size()}\u2019)\nprint(f\u2019wsid: 0x{buf.wsid():0x}\u2019)\nprint(f\u2019io_address: 0x{buf.io_address():0x}\u2019)\n</code></pre> <p>Figure 69 Python Allocate Shared Memory</p> <p>The shared_buffer class implements a fill() method which takes an integer parameter which is applied to each byte of the buffer (similar to C standard library\u2019s memset()). The compare() method compares the contents of the first size bytes of one buffer to another. The value returned from compare() is the same as the C standard library\u2019s memcmp(). The copy() method copies the first size bytes of the calling buffer into the argument buffer.</p> <pre><code>b0 = fpga.allocate_shared_buffer(handle, 4096)\nb1 = fpga.allocate_shared_buffer(handle, 4096)\nb0.fill(0xa5)\nb1.fill(0xa5)\nprint(f'compare: {b0.compare(b1, 4096)}')\nb1.fill(0xa0)\nb0.copy(b1, 4096)\nprint(f'compare: {b0.compare(b1, 4096)}')\n</code></pre> <p>Figure 70 Python Buffer Fill, Copy, Compare</p> <p>shared_buffer\u2019s read32() and read64() methods read a 32- or 64-bit value from the given offset. The write32() and write64() methods write a 32- or 64-bit value to the given offset.</p> <pre><code>print(f'value at 0: 0x{b0.read32(0):0x}')\nprint(f'value at 4: 0x{b0.read64(4):0x}')\nb0.write32(0xabadbeef, 0)\nb0.write64(0xdecafbadabadbeef, 4)\nprint(f'value at 0: 0x{b0.read32(0):0x}')\nprint(f'value at 4: 0x{b0.read64(4):0x}')\n</code></pre> <p>Figure 71 Python Buffer Read and Write</p> <p>The shared_buffer class provides three polling methods: poll(), poll32(), and poll64(). Each method takes an offset as its first parameter. The second parameter is a value and the third is a mask. The value and mask parameters are 8 bits wide for poll(), 32 bits wide for poll32(), and 64 bits wide for poll64(). The fourth and last parameter is a timeout value which defaults to 1000 microseconds.</p> <p>Each polling method reads the n-bit wide item at offset and applies (logical AND) the mask to that value. The masked value created in the previous step is then compared to the second parameter, value. If the two values are equal, then the method returns true immediately. Otherwise, the method continues to loop, attempting the same comparison over and over without sleeping. Finally, if the elapsed time from the beginning of the call to the current time is greater than or equal to the timeout value, then the method times out and returns false.</p> <pre><code>if b0.poll32(0, 0xbebebebe, 0xffffffff, 250):\nprint(\u2018Got it!\u2019)\n</code></pre> <p>Figure 72 Python Buffer Poll</p> <p>The shared_buffer split() method allows creating two or more buffer objects from one larger buffer object. The return value is a list of shared_buffer instances whose sizes match the arguments given to split().</p> <pre><code>b1, b2 = b1.split(2048, 2048)\nprint(f'b1 io_address: 0x{b1.io_address():0x}')\nprint(f'b2 io_address: 0x{b2.io_address():0x}')\n</code></pre> <p>Figure 73 Python Splitting Buffer</p> <p>Finally, the shared_buffer class implements the Python buffer protocol to support memoryview objects. The Python buffer protocol allows access to an object\u2019s underlying memory without copying that memory. As a brief example:</p> <pre><code>mv = memoryview(b1)\nassert mv\nassert mv[0] == 0xbe\nb1[15] = int(65536)\nassert struct.unpack('&lt;L', bytearray(b1[15:19]))[0] == 65536\n</code></pre> <p>Figure 74 Python memoryview</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#416-events","title":"4.1.6 Events","text":"<p>Given a handle and an event type, the fpga.register_event() function returns an object of type event. The event class implements one method, os_object(), which returns the underlying file descriptor that can be used to poll for the event:</p> <pre><code>import select\nevt = fpga.register_event(handle, fpga.EVENT_ERROR)\nos_object = evt.os_object()\nreceived_event = False\nepoll = select.epoll()\nepoll.register(os_object, select.EPOLLIN)\nfor fileno, ev in epoll.poll(1):\nif fileno == os_object:\nreceived_event = True\nprint(f'received: {received_event}')\n</code></pre> <p>Figure 75 Python Events</p> <p>In addition to fpga.EVENT_ERROR, fpga.EVENT_INTERRUPT, and fpga.EVENT_POWER_THERMAL are also supported.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#417-errors","title":"4.1.7 Errors","text":"<p>Given a token, the fpga.errors() function returns a list of objects of type error. Each error instance represents a 64-bit mask of error values. The error bit masks are platform-dependent. Each error instance has two attributes: name and can_clear and one method: read_value() which returns the 64-bit error mask.</p> <pre><code>for e in fpga.errors(tok):\nprint(f\u2019name: \"{e.name}\"\u2019)\nprint(f\u2019can_clear: {e.can_clear}\u2019)\nprint(f\u2019value: {e.read_value()}\u2019)\n</code></pre> <p>Figure 76 Python Get Errors</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#418-sysobject","title":"4.1.8 SysObject","text":"<p>The Python API\u2019s SysObject implementation is introduced in 4.1.3 Tokens and 4.1.4 Handles. When the index operator (__getitem__) or attribute reference (__getattr__) is used and the referenced string or attribute name corresponds to a sysfs entry in the sysfs path of either a token or a handle, then an object of type sysobject is returned.</p> <p>The size() method returns the length of the sysfs entry in bytes. Note that a typical sysfs entry is terminated with a \u2018\\n\u2019 followed by the \u2018\\0\u2019 NULL terminator. The bytes() method returns the sysfs entry\u2019s value as a string.</p> <pre><code>afu_id = tok['afu_id']\nassert afu_id\nprint(f'size: {afu_id.size()} bytes: {afu_id.bytes().rstrip()}')\n</code></pre> <p>Figure 77 Python sysobject as Bytes</p> <p>The sysobject read64() and write64() methods provide a means to read and write a sysfs entry\u2019s value as an unsigned 64-bit integer. The sysobject class itself also implements the __getitem__ and __getattr__ methods so that a sysobject of type FPGA_OBJECT_CONTAINER can retrieve sysobject instances for child sysfs entries.</p> <pre><code>errs = tok['errors']\nfirst = errs['first_error']\nassert first\nprint(f'first 0x{first.read64():0x}')\n</code></pre> <p>Figure 78 Python sysobject Container</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#50-management-interfaces-opaeadmin","title":"5.0 Management Interfaces - opae.admin","text":"<p>While the OPAE SDK C, C++, and Python APIs focus on presenting the AFU and all its related functionality to the end user, there is also a need for a maintenance functionality to aid in configuring the platform and performing secure firmware updates for the FPGA device and its components.  opae.admin is a Python framework which provides abstractions for performing these types of maintenance tasks on FPGA devices.  opae.admin provides Python classes which model the FPGA and the sysfs interfaces provided by the DFL drivers.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#51-sysfs","title":"5.1 sysfs","text":"<p>opae.admin\u2019s sysfs module provides abstractions for interacting with sysfs nodes, which comprise the base entity abstraction of opae.admin.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#511-sysfs_node","title":"5.1.1 sysfs_node","text":"<p>A sysfs_node is an object that tracks a unique path within a sysfs directory tree.  sysfs_node provides methods for finding and constructing other sysfs_node objects, based on the root path of the parent sysfs_node object.  sysfs_node also provides a mechanism to read and write sysfs file contents.  sysfs_node serves as the base class for many of the sysfs module\u2019s other classes.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#512-pci_node","title":"5.1.2 pci_node","text":"<p>A pci_node is a sysfs_node that is rooted at /sys/bus/pci/devices.  Each pci_node has a unique PCIe address corresponding to the PCIe device it represents.  Methods for finding the pci_node\u2019s children, for determining the PCIe device tree rooted at the node, for manipulating the node\u2019s PCIe address, for determining the vendor and device ID\u2019s, and for removing, unbinding, and rescanning the device are provided.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#513-sysfs_driver","title":"5.1.3 sysfs_driver","text":"<p>A sysfs_driver is a sysfs_node that provides a method for unbinding a sysfs_device object.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#514-sysfs_device","title":"5.1.4 sysfs_device","text":"<p>A sysfs_device is a sysfs_node that is located under /sys/class or /sys/bus.  sysfs_device provides the basis for opae.admin\u2019s FPGA enumeration capability.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#515-pcie_device","title":"5.1.5 pcie_device","text":"<p>A pcie_device is a sysfs_device that is rooted at /sys/bus/pci/devices.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#52-fpga","title":"5.2 fpga","text":"<p>opae.admin\u2019s fpga module provides classes which abstract an FPGA and its components.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#521-region","title":"5.2.1 region","text":"<p>A region is a sysfs_node that has an associated Linux character device, rooted at /dev.  Methods for opening the region\u2019s character device file and for interacting with the character device via its IOCTL interface are provided.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#522-fme","title":"5.2.2 fme","text":"<p>An fme is a region that represents an FPGA device\u2019s FME component.  An fme provides accessors for the PR interface ID, the various bus paths that may exist under an FME, and the BMC firmware revision information.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#523-port","title":"5.2.3 port","text":"<p>A port is a region that represents an FPGA device\u2019s Port component.  A port provides an accessor for the Port AFU ID.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#524-fpga_base","title":"5.2.4 fpga_base","text":"<p>An fpga_base is a sysfs_device that provides accessors for the FPGA device\u2019s FME, for the FPGA device\u2019s Port, and for the secure update sysfs controls.  fpga_base provides routines for enabling and disabling AER and for performing device RSU.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#525-fpga","title":"5.2.5 fpga","text":"<p>An fpga (derived from fpga_base) is the basis for representing the FPGA device in opae.admin.  Utilities such as fpgasupdate rely on fpga\u2019s enum classmethod to enumerate all of the FPGA devices in the system.  In order for a device to enumerate via this mechanism, it must be bound to the dfl-pci driver at the time of enumeration.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#53-opaeadmin-utilities","title":"5.3 opae.admin Utilities","text":"<p>Several utilities are written on top of opae.admin\u2019s class abstractions.  The following sections highlight some of the most commonly-used utilities.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#531-fpgasupdate","title":"5.3.1 fpgasupdate","text":"<p>fpgasupdate, or FPGA Secure Update, is used to apply firmware updates to the components of the FPGA.  As the name implies, these updates target a secure FPGA device, one that has the ability to implement a secure root of trust. The command-line interface to fpgasupdate was designed to be as simple as possible for the end user.  The command simply takes a path to the firmware update file to be applied and the PCIe address of the targeted FPGA device.</p> <pre><code># fpgasupdate update-file.bin 0000:b2:00.0\n</code></pre> <p>Figure 79 fpgasupdate Interface</p> <p>fpgasupdate can apply a variety of firmware image updates. | Image| Description| | -----| -----| |Programmable Region Image| .gbs or Green BitStream| |SR Root Key Hash|  Static Region RKH| |PR Root Key Hash|  Programmable Region RKH| |FPGA Firmware Image|   Static Region Device Firmware| |PR Authentication Certificate| Programmable Region Auth Cert| |BMC Firmware Image|    Board Management Controller Firmware| |SR Thermal Image|  Static Region Thermal Sensor Thresholds| |PR Thermal Image|  Programmable Region Thermal Sensor Thresholds| |CSK Cancelation|   Code Signing Key Cancelation Request| |SDM Image| Secure Device Manager Firmware|</p> <p>Table 10 fpgasupdate Image Types</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#532-pci_device","title":"5.3.2 pci_device","text":"<p>pci_device is a utility that provides a convenient interface to some of the Linux Kernel\u2019s standard PCIe device capabilities.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5321-pci_device-aer-subcommand","title":"5.3.2.1 pci_device aer subcommand","text":"<p>The aer dump subcommand displays the Correctable, Fatal, and NonFatal device errors.</p> <pre><code># pci_device 0000:b2:00.0 aer dump\n</code></pre> <p>Figure 80 pci_device aer dump</p> <p>The aer mask subcommand displays, masks, or unmasks errors using the syntax of the setpci command.</p> <pre><code># pci_device 0000:b2:00.0 aer mask show\n0x00010000 0x000031c1\n# pci_device 0000:b2:00.0 aer mask all\n# pci_device 0000:b2:00.0 aer mask off\n# pci_device 0000:b2:00.0 aer mask 0x01010101 0x10101010\n</code></pre> <p>Figure 81 pci_device aer mask</p> <p>The aer clear subcommand clears the current errors.</p> <pre><code># pci_device 0000:b2:00.0 aer clear\naer clear errors: 00000000\n</code></pre> <p>Figure 82 pci_device aer clear</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5322-pci_device-unbind-subcommand","title":"5.3.2.2 pci_device unbind subcommand","text":"<p>The unbind subcommand unbinds the target device from the currently-bound device driver.</p> <pre><code># pci_device 0000:b2:00.0 unbind\n</code></pre> <p>Figure 83 pci_device unbind</p> <p>In order to re-bind the device to a driver, eg dfl-pci, use the following commands:</p> <pre><code># cd /sys/bus/pci/drivers/dfl-pci\n# echo 0000:b2:00.0 &gt; bind\n</code></pre> <p>Figure 84 Re-binding a Driver</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5323-pci_device-rescan-subcommand","title":"5.3.2.3 pci_device rescan subcommand","text":"<p>The rescan subcommand triggers a PCIe bus rescan of all PCIe devices.</p> <pre><code># pci_device 0000:b2:00.0 rescan\n</code></pre> <p>Figure 85 pci_device rescan</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5324-pci_device-remove-subcommand","title":"5.3.2.4 pci_device remove subcommand","text":"<p>The remove subcommand removes the target device from Linux kernel management.</p> <pre><code># pci_device 0000:b2:00.0 remove\n</code></pre> <p>Figure 86 pci_device remove</p> <p>Note: a reboot may be required in order to re-establish the Linux kernel management for the device.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5325-pci_device-topology-subcommand","title":"5.3.2.5 pci_device topology subcommand","text":"<p>The topology subcommand shows a tab-delimited depiction of the target device as it exists in the PCIe device tree in the Linux kernel.</p> <pre><code># pci_device 0000:b2:00.0 topology\n[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)\n[pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:b2:00.0), pci_id(0x8086, 0x0b30)] (dfl-pci)\n[pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)\n[pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n[pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n[pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n[pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n</code></pre> <p>Figure 87 pci_device topology</p> <p>The green output indicates the target device.  The other endpoint devices are shown in blue.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5326-pci_device-vf-subcommand","title":"5.3.2.6 pci_device vf subcommand","text":"<p>The vf subcommand allows setting the value of the sriov_numvfs sysfs node of the target device.  This is useful in scenarios where device functionality is presented in the form of one or more PCIe Virtual Functions.</p> <pre><code># pci_device 0000:b2:00.0 vf 3\n# pci_device 0000:b2:00.0 vf 0\n</code></pre> <p>Figure 88 pci_device vf</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#533-rsu","title":"5.3.3 rsu","text":"<p>rsu is a utility that performs Remote System Update.  rsu is used subsequent to programming a firmware update or other supported file type with fpgasupdate, in order to reset the targeted FPGA entity so that a newly-loaded firmware image becomes active.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5331-rsu-bmc-subcommand","title":"5.3.3.1 rsu bmc subcommand","text":"<p>The bmc subcommand causes a Board Management Controller reset.  This command is used to apply a previous fpgasupdate of a BMC firmware image.  The --page argument selects the desired boot image.  Valid values for --page are \u2018user\u2019 and \u2018factory\u2019.</p> <pre><code># rsu bmc --page user 0000:b2:00.0\n# rsu bmc --page factory 0000:b2:00.0\n</code></pre> <p>Figure 89 rsu bmc</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5332-rsu-retimer-subcommand","title":"5.3.3.2 rsu retimer subcommand","text":"<p>The retimer subcommand causes a Parkvale reset (specific to Vista Creek).  This command is used to apply a previous fpgasupdate of a BMC firmware image (the Parkvale firmware is contained within the BMC firmware image).  The retimer subcommand causes only the Parkvale to reset.</p> <pre><code># rsu retimer 0000:b2:00.0\n</code></pre> <p>Figure 90 rsu retimer</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5333-rsu-fpga-subcommand","title":"5.3.3.3 rsu fpga subcommand","text":"<p>The fpga subcommand causes a reconfiguration of the FPGA Static Region.  This command is used to apply a previous fpgasupdate of the Static Region image.  The --page argument selects the desired boot image.  Valid values for --page are \u2018user1\u2019, \u2018user2\u2019, and \u2018factory\u2019.</p> <pre><code># rsu fpga --page user1 0000:b2:00.0\n# rsu fpga --page user2 0000:b2:00.0\n# rsu fpga --page factory 0000:b2:00.0\n</code></pre> <p>Figure 91 rsu fpga</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5334-rsu-sdm-subcommand","title":"5.3.3.4 rsu sdm subcommand","text":"<p>The sdm subcommand causes a reset of the Secure Device Manager.  This command is used to apply a previous fpgasupdate of the SDM image.</p> <pre><code># rsu sdm 0000:b2:00.0\n</code></pre> <p>Figure 92 rsu sdm</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5335-rsu-fpgadefault-subcommand","title":"5.3.3.5 rsu fpgadefault subcommand","text":"<p>The fpgadefault subcommand can be used to display the default FPGA boot sequence; and it can be used to select the image to boot on the next reset of the FPGA. When given without additional parameters, the fpgadefault subcommand displays the default FPGA boot sequence:</p> <pre><code># rsu fpgadefault 0000:b2:00.0\n</code></pre> <p>Figure 93 rsu Displaying FPGA Boot Sequence</p> <p>The parameters to the fpgadefault subcommand are --page and --fallback.  The --page parameter accepts \u2018user1\u2019, \u2018user2\u2019, or \u2018factory\u2019, specifying the desired page to boot the FPGA from on the next reset.  Note that this subcommand does not actually cause the reset to occur.  Please refer to rsu fpga subcommand for an example of resetting the FPGA using the rsu command.</p> <pre><code># rsu fpgadefault --page user1 0000:b2:00.0\n# rsu fpgadefault --page user2 0000:b2:00.0\n# rsu fpgadefault --page factory 0000:b2:00.0\n</code></pre> <p>Figure 94 rsu Select FPGA Boot Image</p> <p>The --fallback parameter accepts a comma-separated list of the keywords \u2018user1\u2019, \u2018user2\u2019, and \u2018factory\u2019.  These keywords, in conjunction with the --page value are used to determine a fallback boot sequence for the FPGA. The fallback boot sequence is used to determine which FPGA image to load in the case of a boot failure.  For example, given the following command, the FPGA would attempt to boot in the order \u2018factory\u2019, \u2018user1\u2019, \u2018user2\u2019.  That is to say, if the \u2018factory\u2019 image failed to boot, then the \u2018user1\u2019 image would be tried.  Failing to boot \u2018user1\u2019, the \u2018user2\u2019 image would be tried.</p> <pre><code># rsu fpgadefault --page factory --fallback user1,user2 0000:b2:00.0\n</code></pre> <p>Figure 95 rsu Select FPGA Boot Image and Fallback</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#60-sample-applications","title":"6.0 Sample Applications","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#61-afu-test-framework","title":"6.1 afu-test Framework","text":"<p>afu-test refers to a test-writing framework that exists as a set of C++ classes written on top of the OPAE C++ bindings. The first class, afu, serves as the base class for the test application abstraction. Class afu provides integration with CLI11, a C++ \u201911 command-line parsing framework, and with spdlog, a C++ logging library. The second class, command represents a unique test sequence that is called by the afu object. Instances of the command class implement the test-specific workload.</p> <pre><code>class afu {\npublic:\nafu(const char *name,\nconst char *afu_id = nullptr,\nconst char *log_level = nullptr);\nint open_handle(const char *afu_id);\nint main(int argc, char *argv[]);\nvirtual int run(CLI::App *app, command::ptr_t test);\ntemplate&lt;class T&gt;\nCLI::App *register_command();\n};\n</code></pre> <p>Figure 96 C++ class afu</p> <p>The afu class constructor initializes the CLI11 command parser with some general, application-wide parameters.</p> Subcommand Description -g,--guid Accelerator AFU ID. -p,--pci-address Address of the accelerator device. -l,--log-level Requested spdlog output level. -s,--shared Open the AFU in shared mode? -t,--timeout Application timeout in milliseconds. <p>Figure 97 class afu Application Parameters</p> <p>The register_command() member function adds a test command instance to the afu object. Each test command that an afu object is capable of executing is registered during the test\u2019s startup code. For instance, here is the hssi application\u2019s use of register_command():</p> <pre><code>hssi_afu app;\nint main(int argc, char *argv[])\n{\napp.register_command&lt;hssi_10g_cmd&gt;();\napp.register_command&lt;hssi_100g_cmd&gt;();\napp.register_command&lt;hssi_pkt_filt_10g_cmd&gt;();\napp.register_command&lt;hssi_pkt_filt_100g_cmd&gt;();\n\u2026\napp.main(argc, argv);\n}\n</code></pre> <p>Figure 98 hssi's app.register_command()</p> <p>Next, the afu instance\u2019s main() member function is called. main() initializes the spdlog instance, searches its database of registered commands to find the command matching the test requested from the command prompt, uses the open_handle() member function to enumerate for the requested AFU ID, and calls its run() member function, passing the CLI::App and the test command variables. The run() member function initializes a test timeout mechanism, then calls the command parameter\u2019s run() to invoke the test-specific logic.</p> <p>With all the boiler-plate of application startup, configuration, and running handled by the afu class, the test-specific command class is left to implement only a minimum number of member functions:</p> <pre><code>class command {\npublic:\nvirtual const char *name() const = 0;\nvirtual const char *description() const = 0;\nvirtual int run(afu *afu, CLI::App *app) = 0;\nvirtual void add_options(CLI::App *app) { }\nvirtual const char *afu_id() const { return nullptr; }\n};\n</code></pre> <p>Figure 99 class command</p> <p>The name() member function gives the unique command name. Some examples of names from the hssi app are hssi_10g, hssi_100g, pkt_filt_10g, and pkt_filt_100g. The description() member function gives a brief description that is included in the command-specific help output. add_options() adds command-specific command-line options. afu_id() gives the AFU ID for the command, in string form. Finally, run() implements the command-specific test functionality.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#62-afu-test-based-samples","title":"6.2 afu-test Based Samples","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#621-dummy_afu","title":"6.2.1 dummy_afu","text":"<p>The dummy_afu application is a afu-test based application that implements three commands: mmio, ddr, and lpbk.</p> Target Description # dummy_afu mmio Targets special scratchpad area implemented by the AFU. # dummy_afu ddr Execute dummy_afu-specific DDR test. # dummy_afu lpbk Execute a simple loopback test."},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#622-host_exerciser","title":"6.2.2 host_exerciser","text":"<p>host_exerciser markdown document.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#623-hssi","title":"6.2.3 hssi","text":"<p>hssi markdown document.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#70-other-utilities","title":"7.0 Other Utilities","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#71-opaeio","title":"7.1 opae.io","text":"<p>opae.io markdown document.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#72-bitstreaminfo","title":"7.2 bitstreaminfo","text":"<p>The bitstreaminfo command prints diagnostic information about firmware image files that have been passed through the PACSign utility. PACSign prepends secure block 0 and secure block 1 data headers to the images that it processes. These headers contain signature hashes and other metadata that are consumed by the BMC firmware during a secure update.</p> <p>To run bitstreaminfo, pass the path to the desired firmware image file:</p> <pre><code># bitstreaminfo my_file.bin \n</code></pre> <p>Figure 100 Running bitstreaminfo</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#73-fpgareg","title":"7.3 fpgareg","text":"<p>The fpgareg command prints the register spaces for the following fpga device components:</p> Command Description # fpgareg 0000:b1:00.0 pcie Walks and prints the DFL for the device. # fpgareg 0000:b1:00.0 bmc Prints the BMC registers for the device. # fpgareg 0000:b1:00.0 hssi Prints the HSSI registers for the device. # fpgareg 0000:b1:00.0 acc Prints the AFU register spaces. <p>Figure 101 fpgareg Commands</p> <p>Note that fpgareg is only available as of Arrow Creek ADP and forward. It will not work with prior platforms, eg N3000.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#74-opaevfio","title":"7.4 opaevfio","text":"<p>opaevfio markdown document.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#80-building-opae","title":"8.0 Building OPAE","text":"<p>The OPAE SDK uses the cmake build and configuration system, version &gt;= 3.10. The basic steps required to build the SDK from source are:</p> <p>Install prerequisite packages.</p> <pre><code>$ git clone &lt;https://github.com/OFS/opae-sdk.git&gt;\n$ cd opae-sdk\n$ mkdir build\n$ cd build\n$ cmake .. &lt;cmake options&gt;\n$ make\n</code></pre>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#81-installing-prerequisite-packages","title":"8.1 Installing Prerequisite Packages","text":"<p>The OPAE SDK is intended to build and run on modern Linux distributions. The SDK contains a set of system configuration scripts to aid the system configuration process.</p> Script Target Operating System centos.sh CentOS 8.x fedora.sh Fedora 33/34 ubuntu.sh Ubuntu 20.04 LTS <p>Table 11 System Configuration Scripts</p> <p>For more information on the environment setup instructions for your exact platform, please visit https://ofs.github.io/ and refer to your platform's User Guide.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#82-cloning-the-sdk-repository","title":"8.2 Cloning the SDK repository","text":"<pre><code>$ git clone https://github.com/OFS/opae-sdk.git\n</code></pre>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#83-cmake-options","title":"8.3 CMake Options","text":"Option Description Values Default -DCMAKE_BUILD_TYPE Configure debugging info <p>Debug</p> <p>Release</p> <p>Coverage</p> <p>RelWithDebInfo</p> RelWithDebInfo -DCMAKE_INSTALL_PREFIX Root install path /usr/local -DOPAE_BUILD_SPHINX_DOC Enable/Disable docs ON/OFF OFF -DOPAE_BUILD_TESTS Enable/Disable unit tests ON/OFF OFF -DOPAE_ENABLE_MOCK Enable/Disable mock driver for unit tests ON/OFF OFF -DOPAE_INSTALL_RPATH Enable/Disable rpath for install ON/OFF OFF -DOPAE_VERSION_LOCAL Local version string -DOPAE_PRESERVE_REPOS Preserve local changes to external repos? ON/OFF OFF -D OPAE_BUILD_LIBOPAE_CXX Enable C++ bindings ON/OFF ON -DOPAE_WITH_PYBIND11 Enable pybind11 ON/OFF ON -D OPAE_BUILD_PYTHON_DIST Enable Python bindings ON/OFF OFF -DOPAE_BUILD_LIBOPAEVFIO Build libopaevfio.so ON/OFF ON -D OPAE_BUILD_PLUGIN_VFIO Build libopae-v.so ON/OFF ON -DOPAE_BUILD_LIBOPAEUIO Build libopaeuio.so ON/OFF ON -DOPAE_BUILD_LIBOFS Build OFS Copy Engine ON/OFF ON -DOPAE_BUILD_SAMPLES Build Samples ON/OFF ON -DOPAE_BUILD_LEGACY Build legacy repo ON/OFF OFF -DOPAE_LEGACY_TAG Specify legacy build tag master -DOPAE_WITH_CLI11 Enable apps which use CLI11 ON/OFF ON -DOPAE_WITH_SPDLOG Enable apps which use spdlog ON/OFF ON -DOPAE_WITH_LIBEDIT Enable apps which use libedit ON/OFF ON -DOPAE_WITH_HWLOC Enable apps which use hwloc ON/OFF ON -DOPAE_WITH_TBB Enable apps which use Thread Building Blocks ON/OFF ON -DOPAE_MINIMAL_BUILD Enable/Disable minimal build. When set to ON, disable CLI11, spdlog, libedit, hwloc, tbb ON/OFF OFF <p>Table 12 CMake Options</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#84-building-opae-for-debug","title":"8.4 Building OPAE for Debug","text":"<pre><code>$ cmake .. -DCMAKE_BUILD_TYPE=Debug\n</code></pre>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#85-creating-rpms","title":"8.5 Creating RPMs","text":"<p>To ease the RPM creation process, the OPAE SDK provides a simple RPM creation script. The parameters to the RPM create script are fedora or rhel, depending on which distribution is targeted. For rhel, the build flag -DOPAE_MINIMAL_BUILD is set to ON, omitting the binaries which have dependencies on external components that RHEL does not include in its base repositories.</p> <p>In order to create RPMs for Fedora, run the create script on a system loaded with all the Fedora build prerequisites. If prerequisites are missing, the create script will complain until they are resolved.</p> <p>In order to create RPMs for RHEL, run the create script on a system loaded with all the RHEL build prerequisites. If prerequisites are missing, the create script will complain until they are resolved.</p> <pre><code>$ cd opae-sdk\n$ ./packaging/opae/rpm/create fedora\n-OR-\n$ ./packaging/opae/rpm/create rhel\n</code></pre> <p> Figure 102 RPM Creation</p> <p>After running the create script, the RPM files will be located in the packaging/opae/rpm directory.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#851-updating-the-rpm-version-information","title":"8.5.1 Updating the RPM Version Information","text":"<p>The RPMs will be versioned according to the information found in the file packaging/opae/version. Edit this file to update the version information, then re-run the create script to create the RPMs.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#90-debugging-opae","title":"9.0 Debugging OPAE","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#91-enabling-debug-logging","title":"9.1  Enabling Debug Logging","text":"<p>The OPAE SDK has a built-in debug logging facility.  To enable it, set the cmake flag <code>-DCMAKE_BUILD_TYPE=Debug</code> and then use the following environment variables: | Variable| Description| | ----- | ----- | |LIBOPAE_LOG=1| Enable debug logging output.  When not set, only critical error messages are displayed.| |LIBOPAE_LOGFILE=file.log|  Capture debug log output to file.log.  When not set, the logging appears on stdout and stderr.  The file must appear in a relative path or it can be rooted at /tmp.|</p> <p> Table 13 Logging Environment Variables</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#92-gdb","title":"9.2 GDB","text":"<p>To enable gdb-based debugging, the cmake configuration step must specify a value for -DCMAKE_BUILD_TYPE of either Debug or RelWithDebInfo so that debug symbols are included in the output binaries. The OPAE SDK makes use of dynamically-loaded library modules.  When debugging with gdb, the best practice is to remove all OPAE SDK libraries from the system installation paths to ensure that library modules are only loaded from the local build tree:</p> <pre><code>$ cd opae-sdk/build\n$ LD_LIBRARY_PATH=$PWD/lib gdb --args &lt;some_opae_executable&gt; &lt;args&gt;\n</code></pre> <p>Figure 103 Debugging with GDB</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#100-adding-new-device-support","title":"10.0 Adding New Device Support","text":"<p>As of OPAE 2.2.0 the SDK has transitioned to a single configuration file model.  The libraries, plugins, and applications obtain their runtime configuration during startup by examining a single JSON configuration file.  In doing so, the original configuration file formats for libopae-c and fpgad have been deprecated in favor of the respective sections in the new configuration file. </p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#101-configuration-file-search-order","title":"10.1 Configuration File Search Order","text":"<p>By default the OPAE SDK will install its configuration file to /etc/opae/opae.cfg. </p> <pre><code>/etc/opae/opae.cfg </code></pre> <p>Figure 104 Default Configuration File</p> <p>The SDK searches for the configuration file during startup by employing the following search algorithm: </p> <p>First, the environment variable LIBOPAE_CFGFILE is examined.  If it is set to a path that represents a valid path to a configuration file, then that configuration file path is used, and the search is complete. </p> <p>Next, the HOME environment variable is examined.  If its value is valid, then it is prepended to the following set of relative paths.  If HOME is not set, then the search continues with the value of the current user\u2019s home path as determined by getpwuid().  The home path, if any, determined by getpwuid() is prepended to the following set of relative paths.  Searching completes successfully if any of these home-relative search paths is valid. </p> <pre><code>/.local/opae.cfg /.local/opae/opae.cfg /.config/opae/opae.cfg </code></pre> <p>Figure 105 HOME Relative Search Paths</p> <p>Finally, the configuration file search continues with the following system-wide paths.  If any of these paths is found to contain a configuration file, then searching completes successfully. </p> <pre><code>usr/local/etc/opae/opae.cfg /etc/opae/opae.cfg </code></pre> <p>Figure 106 System Search Paths</p> <p>If the search exhausts all of the possible configuration file locations without finding a configuration file, then an internal default configuration is used.  This internal default configuration matches that of the opae.cfg file shipped with the OPAE SDK. </p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#102-configuration-file-format","title":"**10.2 Configuration File Format **","text":"<p>The OPAE SDK configuration file is stored in JSON formatted text.  The file has two main sections: \u201cconfigs\u201d and \u201cconfigurations\u201d.  The \u201cconfigs\u201d section is an array of strings.  Each value in the \u201cconfigs\u201d array is a key into the data stored in the \u201cconfigurations\u201d section.  If a key is present in \u201cconfigs\u201d, then that key is searched for and processed in \u201cconfigurations\u201d.  If the key is not found in \u201cconfigs\u201d, then that section of \u201cconfigurations\u201d will not be processed, irrespective of whether it exists in \u201cconfigurations\u201d. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... } }, \u201cconfigs\u201d: [ \u201cc6100\u201d ] } </code></pre> <p>Figure 107 Keyed Configurations</p> <p>Each keyed section in \u201cconfigurations\u201d has four top-level entries: \u201cenabled\u201d, \u201cplatform\u201d, \u201cdevices\u201d, \u201copae\u201d. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { \u201cenabled\u201d: true, \u201cplatform\u201d: \u201cIntel Acceleration Development Platform C6100\u201d, \u201cdevices\u201d: [ { \u201cname\u201d: \u201cc6100_pf\u201d, \u201cid\u201d: [ ... ] }, { \u201cname\u201d: \u201cc6100_vf\u201d, \u201cid\u201d: [ ... ] } ], \u201copae\u201d: { ... } } }, } </code></pre> <p>Figure 108 Configurations Format</p> <p>The \u201cenabled\u201d key holds a Boolean value.  If the value is false or if the \u201cenabled\u201d key is omitted, then that configuration is skipped when parsing the file.  The \u201cplatform\u201d key holds a string that identifies the current configuration item as a product family.  The \u201cdevices\u201d key contains the device descriptions. </p> <p>\u201cdevices\u201d is an array of objects that contain a \u201cname\u201d and an \u201cid\u201d key.  The \u201cname\u201d is a shorthand descriptor for a device PF or VF.  The value of \u201cname\u201d appears elsewhere in the current \u201cconfigurations\u201d section in order to uniquely identify the device.  \u201cid\u201d is an array of four strings, corresponding to the PCIe Vendor ID, Device ID, Subsystem Vendor ID, and Subsystem Device ID of the device.  The entries corresponding to Vendor ID and Device ID must contain valid 16-bit hex integers.  The entries corresponding to Subsystem Vendor ID and Subsystem Device ID may be 16-bit hex integers or the special wildcard string \u201c*\u201d, which indicates a don\u2019t care condition. </p> <p>The remaining sections in this chapter outline the format of the \u201copae\u201d configurations key. </p> <p>\u201cplugin\u201d: libopae-c and libopae-v </p> <p>The \u201cplugin\u201d key in the \u201copae\u201d section of a configuration is an array of OPAE SDK plugin configuration data.  Each item in the array matches one or more PF or VF devices to a plugin library module. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201cplugin\u201d: [ { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibxfpga.so\u201d, \u201cdevices\u201d: [ \u201cc6100_pf\u201d ], \u201cconfiguration\u201d: {} }, { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibopae-v.so\u201d, \u201cdevices\u201d: [ \u201cc6100_pf\u201d, \u201cc6100_vf\u201d ], \u201cconfiguration\u201d: {} } ], } } }, } </code></pre> <p>Figure 109 \"opae\" / \"plugin\" key/</p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cplugin\u201d array entry is skipped, and parsing continues.  The \u201cmodule\u201d key is a string that identifies the desired plugin module library for the entry.  The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.  The \u201cconfiguration\u201d key of the \u201cplugin\u201d section specifies a unique plugin-specific configuration.  Currently, libopae-c and libopae-v use no plugin-specific config, so these keys are left empty. </p> <p>\u201cfpgainfo\u201d: fpgainfo application </p> <p>The \u201cfpgainfo\u201d key in the \u201copae\u201d section of a configuration is an array of fpgainfo plugin configuration data.  Each item in the array matches one or more PF or VF devices to an fpgainfo plugin library module. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201cfpgainfo\u201d: [ { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibboard_c6100.so\u201d, \u201cdevices\u201d: [ { \u201cdevice\u201d: \u201cc6100_pf\u201d, \u201cfeature_id\u201d: \u201c0x12\u201d }, { \u201cdevice\u201d: \u201cc6100_vf\u201d, \u201cfeature_id\u201d: \u201c0x12\u201d } ] } ], } } }, } </code></pre> <p>Figure 110 \"opae\" / \"fpgainfo\" key</p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cfpgainfo\u201d array entry is skipped, and parsing continues.  The \u201cmodule\u201d key is a string that identifies the desired fpgainfo module library for the entry.  Each \u201cdevices\u201d array entry gives a PF/VF identifier in its \u201cdevice\u201d key and a DFL feature ID in its \u201cfeature_id\u201d key. </p> <p>\u201cfpgad\u201d: fpgad daemon process </p> <p>The \u201cfpgad\u201d key in the \u201copae\u201d section of a configuration is an array of fpgad plugin configuration data.  Each item in the array matches one or more PF or VF devices to an fpgad plugin library module. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201cfpgad\u201d: [ { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibfpgad-vc.so\u201d, \u201cdevices\u201d: [ \u201cc6100_pf\u201d ], \u201cconfiguration\u201d: { ... } } ], } } }, } </code></pre> <p>Figure 111 \"opae\" / \"fpgad\" key </p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cfpgad\u201d array entry is skipped, and parsing continues.  The \u201cmodule\u201d key is a string that identifies the desired fpgad plugin module library for the entry.  The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.  The \u201cconfiguration\u201d key of the \u201cfpgad\u201d section specifies a unique plugin-specific configuration. </p> <p>\u201crsu\u201d: rsu script </p> <p>The \u201crsu\u201d key in the \u201copae\u201d section of a configuration is an array of rsu script configuration data.  Each item in the array matches one or more PF devices to an rsu configuration. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201crsu\u201d: [ { \u201cenabled\u201d: true, \u201cdevices\u201d: [ \u201cc6100_pf\u201d ], \u201cfpga_default_sequences\u201d: \u201ccommon_rsu_sequences\u201d } ], } } }, \u201ccommon_rsu_sequences\u201d: [ ... ] } </code></pre> <p>Figure 112 \"opae\" / \"rsu\" key  </p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201crsu\u201d array entry is skipped, and parsing continues.  When disabled, the device(s) mentioned in that array entry will not be available for the rsu command. The \u201cdevices\u201d array lists one or more PF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.  The \u201cfpga_default_sequences\u201d key of the \u201crsu\u201d section specifies a JSON key.  The configuration searches for that JSON key at the global level of the configuration file, and when found applies its value as the valid set of fpga boot sequences that can be used with the rsu fpgadefault subcommand. </p> <p><code>C \u201cfpgareg\u201d: fpgareg script</code></p> <p>The \u201cfpgareg\u201d key in the \u201copae\u201d section of a configuration is an array of fpgareg script configuration data.  Each item in the array matches one or more PF/VF devices to an fpgareg configuration. </p> <p>```C { </p> <p>\u201cconfigurations\u201d: { </p> <pre><code>\u201cc6100\u201d: {\n\n  ...\n\n  \u201copae\u201d: {\n\n    \u201cfpgareg\u201d: [\n\n      {\n\n        \u201cenabled\u201d: true,\n\n        \u201cdevices\u201d: [ \u201cc6100_pf\u201d, \u201cc6100_vf\u201d ]\n\n      }\n\n    ],\n\n  }\n\n}\n</code></pre> <p>}, </p> <p>}   ```</p> <p>Figure 113 \"opae\" / \"fpgareg\" key   </p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cfpgareg\u201d array entry is skipped, and parsing continues.  When disabled, the device(s) mentioned in that array entry will not be available for the fpgareg command. The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.   </p> <pre><code>\u201copae.io\u201d: opae.io application </code></pre> <p>The \u201copae.io\u201d key in the \u201copae\u201d section of a configuration is an array of opae.io configuration data.  Each item in the array matches one or more PF/VF devices to an opae.io platform string. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201copae.io\u201d: [ { \u201cenabled\u201d: true, \u201cdevices\u201d: [ \u201cc6100_pf\u201d, \u201cc6100_vf\u201d ] } ], } } }, } </code></pre> <p>Figure 114 \"opae\" / \"opae.io\" key    </p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201copae.io\u201d array entry is skipped, and parsing continues.  When disabled, the device(s) mentioned in that array entry will continue to be available for the opae.io command.  The device(s) platform string will not be shown in the <code>opae.io ls</code> command.  The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.   </p> <p>Libxfpga \u2013 Updating the Metrics API </p> <p>Edit libraries/plugins/xfpga/sysfs.c.  Find the definition of the opae_id_to_hw_type() function.  Update the function to add the new vendor/device ID to hw_type mapping. </p> <p>This mapping is used by the SDK\u2019s metrics API to determine the method of accessing the board sensor information and is very specific to the underlying BMC implementation.  It may be necessary to add a new hw_type value and to update the logic in libraries/plugins/xfpga/metrics. </p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#110-dfl-linux-kernel-drivers","title":"11.0 DFL Linux Kernel Drivers","text":"<p>OFS DFL driver software provides the bottom-most API to FPGA platforms. Libraries such as OPAE and frameworks such as DPDK are consumers of the APIs provided by OFS. Applications may be built on top of these frameworks and libraries. The OFS software does not cover any out-of-band management interfaces. OFS driver software is designed to be extendable, flexible, and provide for bare-metal and virtualized functionality.</p> <p>The OFS driver software can be found in the OFS repository - linux-dfl, under the linux-dfl specific category. This repository has an associated OFS repository - linux-dfl that includes the following information:</p> <ul> <li>An description of the three available branch archetypes</li> <li>Configuration tweaks required while building the kernel</li> <li>A functional description of the available DFL framework</li> <li>Descriptions for all currently available driver modules that support FPGA DFL board solutions</li> <li>Steps to create a new DFL driver</li> <li>Steps to port a DFL driver patch</li> </ul>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#appendix-a-integrating-an-n6001-based-custom-platform-with-dfl-and-opae","title":"Appendix A - Integrating an N6001 Based Custom Platform with DFL and OPAE","text":"<p>The process of adding a custom device to the DFL framework and OPAE SDK requires changes to files  in several locations. In this section we will walk through the additions necessary to instruct the kernel's probe and match function to associate your new device with OPAE, choose the correct OPAE plugin to associate with your board, and change basic descriptors to properly display the name of your new custom platform when using OPAE's management interfaces. </p> <p>This section does not require useage of an entirely new platform - we will use the Intel N6001's FIM design as our base, and alter only those settings in the PCIe IP necessary to change the following PCIe IDs for both the PF and VF:</p> <ul> <li>Vendor ID</li> <li>Device ID</li> <li>Subsystem Vendor ID</li> <li>Subsystem Device ID</li> </ul> <p>This document will not cover the process by which a FIM can be modified to support these new IDs. Refer to section 5.7 How to  change the PCIe device ID and Vendor ID in  F2000x FIM Developer guide or section 10.0 How to  change the PCIe device ID and Vendor ID in the N6001 FIM Developer guide for an overview of this process. The following sections assume you have a FIM that has been configured with new IDs. This FIM can be loaded onto your N6001 board using either the SOF via a USB-BlasterII cable and the Quartus Programmer, or by using the OPAE command <code>fpgasupdate</code> consuming a compatible binary programming file. The following values will be used as our new device IDs.</p> ID Type PF0 PF0-VF Vendor ID 0xff00 0xff00 Device ID 0x1234 0x5555 Subsystem Vendor ID 0xff00 0xff00 Subsystem Device ID 0x0x5678 0x5678 <p>The only value that differs between PF0 and PF0-VF in this example is the Device ID, and all other values do not currently exist in either the OPAE SDK or linux-dfl drivers. You will need to download the OPAE SDK and linux-dfl sources from GitHub and modify their contents. We will be using a validated Agilex OFS release to pair our OPAE SDK and linux-dfl versions together. Refer to the below table for a list of the exact version we will use for each software component and where you can  learn how to build and install. Your versions may not match those in the document.</p> Software Version Build Instructions OPAE SDK 2.3.0-1 4.0 OPAE Software Development Kit linux-dfl ofs-2022.3-2 3.0 Intel OFS DFL Kernel Drivers <p>The following steps will enable your device to use the OPAE SDK. We will call our new device the \"Intel FPGA Programmable Acceleration Card N6002\". This device is identical to the Intel FPGA Programmable Acceleration Card N6001, and will use the pre-existing plugins and feature ID associated with that device. We will also use the enum value <code>FPGA_HW_DCP_N6002</code> to describe our new board in the code. These plugins can be customized as you become more familiar with the OPAE SDK software. </p> <ol> <li>Download the OPAE SDK from GitHub. File paths assume the user is in the directory <code>opae-sdk</code>.</li> <li>Open the file <code>binaries/opae.io/opae/io/config.py</code>. Add a new configuration entry under <code>DEFAULT_OPAE_IO_CONFIG</code>. Save and exit.</li> </ol> <p>Example:</p> <pre><code>(0xff00, 0x1234, 0xff00, 0x5678) : {\n'platform': 'Intel FPGA Programmable Acceleration Card N6002'\n},\n</code></pre> <ol> <li>Open the file <code>libraries/libopae-c/cfg-file.c</code>. Add two new entries (one for PF0 and PF0-VF) under <code>STATIC libopae_config_data default_libopae_config_table[]</code>. Add  two new entries under <code>STATIC fpgainfo_config_data default_fpgainfo_config_table[]</code>. Save and exit.</li> </ol> <p>Example:</p> <pre><code>STATIC fpgainfo_config_data default_fpgainfo_config_table[] = {\n...\n{ 0xff00, 0x1234, 0xff00, 0x5678, 0x12, \"libboard_n6000.so\", NULL,\n\"Intel FPGA Programmable Acceleration Card N6002\" },                  // N6002 PF0\n{ 0xff00, 0x5555, 0xff00, 0x5678, 0x12, \"libboard_n6000.so\", NULL,\n\"Intel FPGA Programmable Acceleration Card N6002\" },                  // N6002 PF0-VF\n</code></pre> <p>Example:</p> <p><pre><code>STATIC libopae_config_data default_libopae_config_table[] = {\n...\n{ 0xff00, 0x1234, 0xff00,          0x5678,          \"libxfpga.so\",  \"{}\", 0 }    , // N6002 PF0\n{ 0xff00, 0x5555, 0xff00,          0x5678,          \"libxfpga.so\",  \"{}\", 0 }    , // N6002 PF0-VF\n</code></pre> 4. Open the file <code>libraries/plugins/xfpga/metrics/metric_utils.c</code>. Add one entry to the switch case under <code>enum_fpga_metrics(fpga_handle handle)</code>. The enum value used should match the enum set in step 6.  Add a new condition to the if statement beginning <code>if (((_fpga_enum_metric-&gt;hw_type == FPGA_HW_DCP_N3000)</code>. Save and exit.</p> <p>Example:</p> <pre><code>                 // DCP VC DC\ncase FPGA_HW_DCP_N3000:\ncase FPGA_HW_DCP_D5005:\ncase FPGA_HW_DCP_N6002:\ncase FPGA_HW_DCP_N5010: {\n...\n</code></pre> <p>Example:</p> <p><pre><code>                            if (((_fpga_enum_metric-&gt;hw_type == FPGA_HW_DCP_N3000) ||\n(_fpga_enum_metric-&gt;hw_type == FPGA_HW_DCP_D5005) ||\n(_fpga_enum_metric-&gt;hw_type == FPGA_HW_DCP_N6002) ||\n(_fpga_enum_metric-&gt;hw_type == FPGA_HW_DCP_N5010)) &amp;&amp;\n</code></pre> 5. Open the file <code>libraries/plugins/xfpga/sysfs.c</code>. Add a new set of switch cases under <code>enum fpga_hw_type opae_id_to_hw_type(uint16_t vendor_id, uint16_t device_id)</code>. The enum value used should match the enum value set in step 6. Save and exit.</p> <p>Example:</p> <p><pre><code>            if (vendor_id == 0xff00) {        switch (device_id) {\ncase 0x1234:\ncase 0x5555:\nhw_type = FPGA_HW_DCP_N6002;\nbreak;\ndefault:\nOPAE_ERR(\"unknown device id: 0x%04x\", device_id);\n</code></pre> 6. Open the file <code>libraries/plugins/xfpga/types_int.h</code>. Add your new enum value under <code>enum fpga_hw_type</code>. Save and exit.</p> <p>Example:</p> <p><pre><code>enum fpga_hw_type {\nFPGA_HW_MCP,\nFPGA_HW_DCP_RC,\nFPGA_HW_DCP_D5005,\nFPGA_HW_DCP_N3000,\nFPGA_HW_DCP_N5010,\nFPGA_HW_DCP_N6002,\nFPGA_HW_UNKNOWN\n};\n</code></pre> 7. Open the file <code>opae.cfg</code>. Create a new entry for device \"n6002\" by copying the entry for \"n6001,\"\" substituting our new values. Add one new entry under \"configs\" for the name \"n6002.\" Save and exit.</p> <p>Example:</p> <pre><code>    \"n6002\": {\n\"enabled\": true,\n\"platform\": \"Intel Acceleration Development Platform N6002\",\n\"devices\": [\n{ \"name\": \"n6002_pf\", \"id\": [ \"0xff00\", \"0x1234\", \"0xff00\", \"0x5678\" ] },\n{ \"name\": \"n6002_vf\", \"id\": [ \"0xff00\", \"0x5555\", \"0xff00\", \"0x5678\" ] }\n],\n\"opae\": {\n\"plugin\": [\n{\n\"enabled\": true,\n\"module\": \"libxfpga.so\",\n\"devices\": [ \"n6002_pf\" ],\n\"configuration\": {}\n},\n{\n\"enabled\": true,\n\"module\": \"libopae-v.so\",\n\"devices\": [ \"n6002_pf\", \"n6002_vf\" ],\n\"configuration\": {}\n}\n],\n\"fpgainfo\": [\n{\n\"enabled\": true,\n\"module\": \"libboard_n6000.so\",\n\"devices\": [\n{ \"device\": \"n6002_pf\", \"feature_id\": \"0x12\" },\n{ \"device\": \"n6002_vf\", \"feature_id\": \"0x12\" }\n]\n}\n],\n\"fpgad\": [\n{\n\"enabled\": true,\n\"module\": \"libfpgad-vc.so\",\n\"devices\": [ \"n6002_pf\" ],\n\"configuration\": {\n\"cool-down\": 30,\n\"get-aer\":     [ \"setpci -s %s ECAP_AER+0x08.L\",\n\"setpci -s %s ECAP_AER+0x14.L\" ],\n\"disable-aer\": [ \"setpci -s %s ECAP_AER+0x08.L=0xffffffff\",\n\"setpci -s %s ECAP_AER+0x14.L=0xffffffff\" ],\n\"set-aer\":     [ \"setpci -s %s ECAP_AER+0x08.L=0x%08x\",\n\"setpci -s %s ECAP_AER+0x14.L=0x%08x\" ],\n\"sensor-overrides\": [],\n\"monitor-seu\": false\n}\n}\n],\n\"rsu\": [\n{\n\"enabled\": true,\n\"devices\": [ \"n6002_pf\" ],\n\"fpga_default_sequences\": \"common_rsu_sequences\"\n}\n],\n\"fpgareg\": [\n{\n\"enabled\": true,\n\"devices\": [ \"n6002_pf\", \"n6002_vf\" ]\n}\n],\n\"opae.io\": [\n{\n\"enabled\": true,\n\"devices\": [ \"n6002_pf\", \"n6002_vf\" ]\n}\n]\n}\n},\n</code></pre> <p>Example:</p> <p><pre><code>\"configs\": [\n\"mcp\",\n\"a10gx\",\n\"d5005\",\n\"n3000\",\n\"n5010\",\n\"n5013\",\n\"n5014\",\n\"n6000\",\n\"n6001\",\n\"n6002\",\n...\n</code></pre> These conclude our integration of our new platform with the OPAE SDK. The next step is to download the source for linux-dfl (as shown above)  and configure our new kernel's match and probe function to associate the DFL drivers with our new custom platform. The following file path assumes the user is in the directory <code>linux-dfl</code> 1. Open the file <code>drivers/fpga/dfl-pci.c</code>. Define a list of necessary ID values at the top of the file. Use these values to add two new entries under <code>pci_device_id cci_pcie_id_tbl[]</code>, one for PF0 and the other for PF0-VF. Save and exit.</p> <p>Example:</p> <pre><code>/* N6002 IDS */\n#define PCIE_DEVICE_ID_PF_N6002                 0x1234\n#define PCIE_VENDOR_ID_PF_N6002                 0xff00\n#define PCIE_SUBDEVICE_ID_PF_N6002              0x5678\n#define PCIE_DEVICE_ID_VF_N6002                 0x5555\n</code></pre> <p>Example:</p> <pre><code>static struct pci_device_id cci_pcie_id_tbl[] = {\n...\n{PCI_DEVICE_SUB(PCIE_VENDOR_ID_PF_N6002, PCIE_DEVICE_ID_PF_N6002,\nPCIE_VENDOR_ID_PF_N6002, PCIE_SUBDEVICE_ID_PF_N6002),}, //N6002 PF0\n{PCI_DEVICE_SUB(PCIE_VENDOR_ID_PF_N6002, PCIE_DEVICE_ID_VF_N6002,\nPCIE_VENDOR_ID_PF_N6002, PCIE_SUBDEVICE_ID_PF_N6002),}, //N6002 PF0-VF\n...\n</code></pre> <p>This concludes our integration our new platform with the linux-dfl driver set. Build and install the linux-dfl enabled kernel and the OPAE SDK userspace libraries as discussed in their relevant sections in the user guide linked above. If the above conditions have been met, and your N6001 board has been configured with this new \"N6002\" FIM, you should see the following output when running the command \"fpgainfo fme\" (your Bitstream ID, PR Interface ID, and Image Info entries may differ). Check that the board's display name at the top and values for Vendor/Device/SubVendor/Subdevice IDs are correct.</p> <p>```bash session Intel Acceleration Development Platform N6002 Board Management Controller NIOS FW version: 3.11.0 Board Management Controller Build version: 3.11.0 //****** FME ******// Object Id                        : 0xED00001 PCIe s:b:d.f                     : 0000:B1:00.0 Vendor Id                        : 0xFF00 Device Id                        : 0x1234 SubVendor Id                     : 0xFF00 SubDevice Id                     : 0x5678 Socket Id                        : 0x00 Ports Num                        : 01 Bitstream Id                     : 0x5010202C8AD72D7 Bitstream Version                : 5.0.1 Pr Interface Id                  : 8df219e3-cf25-5e77-8689-f57102d54435 Boot Page                        : user1 Factory Image Info               : a2b5fd0e7afca4ee6d7048f926e75ac2 User1 Image Info                 : 9804075d2e8a71a192ec89602f2f5544 User2 Image Info                 : 9804075d2e8a71a192ec89602f2f5544</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/","title":"oneAPI Accelerator Support Package(ASP) Reference Manual: Open FPGA Stack","text":""},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#10-overview","title":"1.0 Overview","text":""},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a reference manual for platform designers wanting to enable oneAPI support on their Open FPGA Stack(OFS) platforms. The document describes essential hardware and software components required for enabling this design flow using OFS. Implementation details for <code>oneapi-asp</code> for Open FPGA Stack(OFS) reference platforms is covered towards the end of the document.</p> <p>Note: Table 1-1 in oneAPI Accelerator Support Package (ASP): Getting Started User Guide</p> <p>For more information about developing application kernels for FPGA using Intel\u00ae oneAPI Base Toolkit (Base Kit) refer to Intel\u00ae FPGA Add-on for oneAPI Base Toolkit webpage.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#12-terminology","title":"1.2 Terminology","text":"<p>This table defines some of the common terms used when discussing OFS.</p> <p>Table 1-1: Terminology</p> Term Abbreviation Description Open FPGA Stack OFS A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. Accelerator Functional Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside.  This AFU may or may not be a partial reconfiguration region. FPGA Interface Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs.  The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. High Level Design HLD For the purpose of this guide, this term refers to designing with Intel High Level Design tools like Intel\u00ae oneAPI Base Toolkit (Base Kit). oneAPI Accelerator Support Package oneAPI ASP A collection of hardware and software components that enable oneAPI kernel to communicate with oneAPI runtime and other OFS hardware, software components. oneAPI ASP hardware components and oneAPI kernel form the AFU region of a oneAPI system in OFS. Intel\u00ae FPGA Basic Building Blocks BBB Basic Building Blocks (BBB) for Intel\u00ae FPGAs is a suite of application building blocks and shims like Memory Properties Factory (MPF). BBB Memory Properties Factory BBB MPF Intel\u00ae FPGA BBB MPF block provides features like virtual to physical address (VTP), ordering read responses, read/write hazard detection, and masked (partial) writes. <code>oneapi-asp</code> uses MPF VTP feature. Open Programmable Acceleration Engine Software Development Kit OPAE SDK A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. Platform Interface Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Device Feature List DFL A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. Best Known Configuration BKC The exact hardware configuration Intel has optimized and validated the solution against. SYCL - SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL\u2122) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Installable Client Driver ICD Intel\u00ae FPGA Runtime for OpenCL\u2122 Software Technology supports the OpenCL ICD extension from the Khronos Group\u2122. The OpenCL ICD extension allows you to have multiple OpenCL implementations on your system. With the OpenCL ICD Loader Library, you may choose from a list of installed platforms and execute OpenCL API calls that are specific to your OpenCL implementation of choice. FPGA Client Driver FCD Intel\u00ae FPGA Runtime for OpenCL\u2122 Software Technology supports FPGA Client Driver(FCD) extension. FCD allows the runtime to automatically find and load the oneAPI ASP libraries at host run time <p>Note: <code>oneapi-asp</code> was referred to as <code>ofs-hld-shim</code> in OFS (Agilex &amp; Stratix 10 OFS) and OpenCL AFU Shim (<code>ofs-opencl-afu-shim</code>) in OFS early access(EA) release (for Intel\u00ae Stratix 10\u00ae FPGA with Intel\u00ae FPGA PAC D5005 as reference platform).</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#13-prerequisites","title":"1.3 Prerequisites","text":"<p>The content in this manual requires readers to be familiar with:</p> <ul> <li>Hardware and software components of Open FPGA Stack, especially the following:     * FPGA Interface Manager(FIM)         * Intel\u00ae Stratix 10\u00ae FPGA:             * FPGA Interface Manager Technical Reference Manual: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA             * Intel\u00ae FPGA Interface Manager Developer Guide: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA         * Intel\u00ae Agilex\u00ae FPGA:             * Open FPGA Stack Technical Reference Manual for Intel Agilex FPGA PCIe Attach             * Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs     * Accelerator Functional Unit(AFU)         * Intel\u00ae Stratix 10\u00ae FPGA: Accelerator Functional Unit Developer Guide: Open FPGA Stack for Intel\u00ae Stratix 10 FPGA         * Intel\u00ae Agilex\u00ae FPGA: AFU Development Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs     * OPAE SDK     * Linux-DFL     * ofs-platform-afu-bbb</li> </ul> <p>In addition to above, developers must be familiar with the following tools &amp; concepts: </p> <ul> <li>Intel\u00ae Quartus\u00ae Prime Design Software (Intel\u00ae Quartus\u00ae software revisions, Platform Designer, compilation Flows, timing analysis, compilation reports, understanding FPGA resource utilization, programming Intel\u00ae FPGAs) </li> <li>Partial Reconfiguration (PR)</li> <li>FPGA Peripheral IPs (PCIe, External Memory IP, Ethernet IP) </li> <li>Avalon\u00ae Interface</li> <li>Scripting (TCL, Python, Shell scripts) </li> <li>Verilog, SystemVerilog </li> <li>C++ </li> <li>Familiarity with SYCL </li> <li>Familiarity with oneAPI compilation process for FPGAs &amp; oneAPI code samples </li> <li>Familiarity with oneAPI Accelerator Support Package (ASP): Getting Started User Guide</li> </ul>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#14-introduction-to-oneapi-on-open-fpga-stackofs","title":"1.4 Introduction to oneAPI on Open FPGA Stack(OFS)","text":"<p>The Intel\u00ae oneAPI Base Toolkit (Base Kit) is a core set of tools and libraries for developing high-performance, data-centric applications across diverse architectures (CPUs, GPUs and FPGAs). It features an industry-leading C++ compiler that implements SYCL, an evolution of C++ for heterogeneous computing.</p> <p>Figure 1-1 shows the high-level representation of oneAPI application developers using FPGAs for acceleration of their applications. The runtime flow consists of a host code running on a processor and an application kernel code running on an FPGA. Open FPGA Stack enables vendors to enable support for this flow on their platforms.</p> <p>Figure 1-1: oneAPI Application on OFS Platforms</p> <p></p> <p>Intel\u00ae oneAPI Base Toolkit (Base Kit) consists of a compiler and runtime environment. The compiler converts a SYCL kernel (FPGA application code) into a hardware circuit. This hardware circuit requires additional logic to communicate with the runtime and FPGA board peripherals. This additional logic is provided by oneAPI Accelerator Support Package(oneAPI ASP). oneAPI ASP consists of hardware components that enable this generated hardware circuit to communicate with the host processor as well as software components that enable the runtime to identify and communicate with the kernel.</p> <p>Figure 1-2 shows the workload design steps and steps in which the Intel\u00ae oneAPI Base Toolkit (Base Kit) requires oneAPI ASP as input. For more information about workload development and how workload developers target a specific platform during compilation, refer to Intel oneAPI Programming Guide. The next section introduces oneAPI ASP.</p> <p>Figure 1-2: High Level Design Flow for FPGAs with Intel\u00ae oneAPI Base Toolkit (Base Kit)</p> <p></p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#15-introduction-to-oneapi-accelerator-support-packageasp","title":"1.5 Introduction to oneAPI Accelerator Support Package(ASP)","text":"<p>As mentioned in previous section, oneAPI ASP is a collection of hardware and software components that interface with the hardware circuit generated by the oneAPI compiler. The hardware circuit generated by the oneAPI compiler from a oneAPI kernel is referred to as the <code>kernel system</code>. While the <code>kernel system</code> consists of logic controlled by the workload developer's specifications, the <code>kernel system</code> interfaces are generated by the oneAPI compiler based on specifications provided by the OFS platform designer. These specifications are input to the compiler using XML files (discussed in section 2.0).</p> <p>Note: All the interfaces generated by the oneAPI compiler are Avalon\u00ae Interfaces.</p> <p>Figure 1-3: Kernel System Interfaces</p> <p></p> <p>Figure 1-3 shows a high-level representation of an OFS hardware design and interfaces to/from <code>kernel_system</code>. The numbered arrows depict the following:</p> <ul> <li>Path 1 represents host-to-External Memory Interface (EMIF)</li> <li>Path 2 represents the host to kernel interface</li> <li>Path 3 represents kernel to EMIF</li> <li>Path 4 represents kernel to host memory Interface</li> </ul> <p>oneAPI ASP hardware components can be divided into 3 categories:</p> <ol> <li>RTL components: constituting various interface logic, for example, host to External Memory Interface (EMIF), kernel to EMIF interface, host to kernel interface, kernel to host memory interface as well as additional components to handle kernel control signals and perform Direct Memory Access (DMA)</li> <li>XML files: for describing hardware interfaces and compilation environment to Intel\u00ae oneAPI Base Toolkit (Base Kit)</li> <li>Scripts: to control compile flow</li> </ol> <p>In addition to the hardware components, a software layer is required for handling I/O operations between oneAPI runtime and the board. The oneAPI ASP software layer can be divided into 2 categories:</p> <ol> <li>Memory Mapped Device (MMD) Layer: required by the host &amp; runtime to communicate with the oneAPI kernel &amp; other oneAPI ASP hardware registers</li> <li>oneAPI ASP utilities: required to setup and diagnose the board</li> </ol> <p>The MMD uses API provided by OPAE SDK to communicate with the device. The FPGA driver is provided by the linux-DFL kernel driver.</p> <p>Figure 1-4 shows how the above oneAPI ASP components tie into Open FPGA Stack.</p> <p>Figure 1-4: Open FPGA Stack (OFS) components</p> <p></p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#20-xml-files-in-oneapi-asp","title":"2.0 XML Files in oneAPI ASP","text":"<p>The <code>kernel system</code> interfaces generated by the oneAPI compiler are based on specifications provided by oneAPI ASP developer. An XML file, called <code>board_spec.xml</code> is used to pass the specifications to the oneAPI compiler. oneAPI ASP developers must create this XML file for their boards.</p> <p>In addition to <code>board_spec.xml</code>, the Intel\u00ae oneAPI Base Toolkit (Base Kit) relies on another XML file called <code>board_env.xml</code> to get information about the board environment. The <code>board_env.xml</code> file helps the runtime setup board installation.</p> <p>The next section explains the contents of board_spec.xml. Section 2.2 covers contents of <code>board_env.xml</code> file.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#21-board_specxml-file","title":"2.1 <code>board_spec.xml</code> File","text":"<p>A typical board_spec.xml structure is shown in Fig 2-1. In addition to kernel system interfaces, the <code>board_spec.xml</code> file is also used to specify other compilation details like Intel\u00ae Quartus\u00ae Prime Pro Edition Software version used in platform design, compilation scripts to help control Intel\u00ae Quartus\u00ae software compile flows, FPGA resource utilization details.</p> <p>Elements of board_spec.xml file are summarized in table 2-1. Each element has additional attributes and parameters. Details are covered in respective sections for each element.</p> <p>Figure 2-1: <code>board_spec.xml</code> File Structure</p> <p></p> <p>Table 2-1: Elements of board_spec.xml</p> Element Use of Element Attributes board Used to specify a name for the board and the version of Intel\u00ae Quartus\u00ae Prime Pro Edition Software used to develop the platform design. This board name is used to identify the board design to be compiled and must match the name of the directory in which board_spec.xml resides. version, name compile Used to describe different compile flows project, revision, qsys_file, generic_kernel, generate_cmd, synthesize_cmd, auto_migrate device Used to specify the FPGA device model file for the FPGA part on the board. device_model, used_resources global_mem Different attributes in this element are used to provide details about the external memory used as the global memory for the FPGA oneAPI kernel/application. name, max_bandwidth, interleaved_bytes, config_addr, default, interface host Used to specify the offset at which the kernel resides. kernel_config interfaces Used to specify control signals to oneAPI kernels interface, kernel_clk_reset <p>The compiler expects a separate <code>board_spec.xml</code> file for every board variant a platform supports. Board variants are different hardware design implementations for the same platform, a oneAPI ASP can have multiple board variants. A oneAPI kernel developer can select the variant suitable for their application at compile time. A <code>board_spec.xml</code> file must be located at the top most level of the board variants hardware directory (the hardware directory is specified by <code>board_env.xml</code>, please refer to section 2.2 for details on <code>hardware</code> element). For example, a separate <code>board_spec.xml</code> file for each board variant for OFS reference platforms is located in <code>oneapi-asp/Platform-Name/hardware/Board-Variant/</code> directory, where <code>Platform-Name</code> is <code>n6001</code> for Agilex OFS and <code>d5005</code> for Stratix 10 OFS.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#211-board-element","title":"2.1.1 board Element","text":"<p>The board element of the board_spec.xml file provides the Intel\u00ae Quartus\u00ae Prime Pro Edition Software version and the name of the board.</p> <p>Table 2-2: Attributes for the <code>board</code> Element</p> Attribute Description version The version of the board. The board version should match the version of the Intel\u00ae Quartus\u00ae Prime Pro Edition Software you use to develop the platform design. The oneAPI compiler uses this value to perform environment checks for supported version during application compile name The name of the accelerator board, which must match the name of the directory in which the board_spec.xml file resides. The name must contain a combination of only letters, numbers, underscores (_), hyphens (-), or periods (.) (for example, ofs_n6000). <p>Example below shows the <code>board</code> element populated for a board designed with Intel\u00ae Quartus\u00ae Prime Pro Edition Software version 22.3 and board variant named \"Agilex_brd1\".</p> <p>Note: A board variant name is different from a platform directory name. Please see Note in section 2.2 for more information on board variants.</p> <p>Figure 2-2: <code>board</code> Element</p> <p></p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#212-compile-element","title":"2.1.2 compile Element","text":"<p>Depending on the application requirements, the design may have different compilation flows and different design settings for each flow (for example, there can be a flat flow without partial reconfiguration support or a flow with partitions in the design to enable partial reconfiguration). Designers can control the flow and its settings using scripts. To allow selection of compile flow during application compile &amp; to describe control of Intel\u00ae Quartus\u00ae software compilation as well as registration, automigration, the <code>compile</code> element of the board_spec.xml file and its associated attributes and parameters are used.</p> <p>Table 2-3: Attributes for <code>compile</code> Element</p> Attribute Description name Name of the compilation flow. This name can be used to differentiate between flows at oneAPI kernel compilation time. oneAPI compiler allows selecting a compile flow using <code>-Xsbsp-flow</code> option. project Name of the Intel\u00ae Quartus\u00ae software project file (.qpf) that the Intel\u00ae Quartus\u00ae Prime Pro Edition Software intends to compile. revision Name of the revision within the Intel\u00ae Quartus\u00ae software project that the Intel\u00ae Quartus\u00ae Prime Pro Edition Software compiles to generate the final bitstream. qsys_file Name of the Platform Designer file into which the oneAPI kernel is embedded. You have the option to assign a value of \"none\" to qsys_file if you do not require the Intel\u00ae Quartus\u00ae Prime Pro Edition Software to create a top-level .qsys file for your design. In this scenario, oneAPI compiler adds a .qip file into the Intel\u00ae Quartus\u00ae software project. In this case, the custom oneAPI ASP must manually instantiate the generated HDL entity (generated entity is in the kernel_system.v file). generic_kernel Set this value to 1 if you want the offline compiler to generate a common Verilog interface for all compilations. This setting is necessary in situations where you must set up design partitions around the kernel, such as in the Configuration via Protocol (CvP) flow. generate_cmd Command required to prepare for full compilation, such as to generate the Verilog files for the Platform Designer system into which the oneAPI kernel is embedded. synthesize_cmd Command required to generate the fpga.bin file from the Custom Platform. Usually, this command instructs the Intel\u00ae Quartus\u00ae Prime Pro Edition Software to perform a full compilation. auto_migrate *platform_type\u2014Choose this value based on the value referenced in the Intel\u00ae FPGA Reference Platform from which you derive your Custom Platform. Valid values are a10_ref, s10_ref, and none.  *include fixes\u2014Comma-separated list of named fixes that you want to apply to the Custom Platform.  *exclude fixes\u2014Comma-separated list of named fixes that you do not want to apply to the Custom Platform. <p>Example below shows a populated <code>compile</code> element for a sample Intel\u00ae Quartus\u00ae software Project called ofs.qpf, the Intel\u00ae Quartus\u00ae software revision to be compiled is called asp (asp.qsf). In this example, the compiler generates the kernel system (entity is called kernel_system) and this entity is instantiated manually in the Intel\u00ae Quartus\u00ae software project (e.g. in a file called kernel_wrapper.v), hence <code>qsys_file</code> is set to \"none\". The <code>synthesize_cmd</code> points to a script \"compile.tcl\" located in the same directory as the board_spec.xml, compile script performs all necessary system generation and compile steps for generation of final bitstream. The project directory snippet below is for demonstration only. The compile flow is named \"demo_flow\".</p> <p>There can be multiple <code>compile</code> elements for the different compilation flows that a platform designer wishes to enable in their platform (e.g. different revisions with different Intel\u00ae Quartus\u00ae software settings or a PR revision).</p> <p>Figure 2-3: <code>compile</code> Element</p> <p></p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#213-device-element","title":"2.1.3 device Element","text":"<p>A device model(DM) file is an XML file that has the total resources on the device (i.e. ALMs, FFs, DSPs, RAMs). This is required for any FPGA part used in a oneAPI design. Most device model files are provided as part of the Intel\u00ae oneAPI Base Toolkit (Base Kit) installation (<code>$INTELFPGAOCLSDKROOT/share/models/dm</code>, where INTELFPGAOCLSDKROOT is set by the <code>setvars.sh</code> environment setup script provided by oneAPI toolkit). A new device model file can also be created using existing files as reference.</p> <p>The device model file name must be specified in the <code>device_model</code> attribute of <code>device</code> element. The <code>used_resources</code> attribute is used to specify the resources being utilized by the oneAPI ASP and peripheral IPs. The utilization by non-kernel logic is calculated during platform design. The compiler utilizes the total resources from device model file and utilized resources in <code>used_resources</code> section to estimate the available resources for application kernel.</p> <p>Table 2-4: Attributes for <code>device</code> Element</p> Attribute Description device_model The file name of the device model file that describes the available FPGA resources on the accelerator board. used_resources Reports the number of adaptive logic modules (ALMs), flip-flops, digital signal processor (DSP) blocks and RAM blocks that the board design consumes in the absence of any kernel. If you create a defined partition around all the board logic, you can obtain the used resources data from the Partition Statistics section of the Fitter report. Extract the information from the following parameters: * alms num \u2014 The number of logic ALMs used, excluding the number of ALMs with only their registers used. The value should correspond to [a]+[b]+[d] from part [A] of the Fitter Partition Statistics. * ffs num \u2014 The number of flip flops. * dsps num \u2014 The number of DSP blocks. * rams num \u2014 The number of RAM blocks. <p>Example below shows the <code>device</code> element added for a Intel\u00ae Agilex\u00ae FPGA based platform with device model file named \"agfb014r24a2e2vr0_dm.xml\". The number of used_resources are for demonstration purposes and are not to be used by platform developers.</p> <p>Figure 2-4: <code>device</code> Element</p> <p></p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#214-interface-attribute","title":"2.1.4 interface Attribute","text":"<p>Note: This is different from the <code>interfaces</code> element discussed in upcoming sections. In the board_spec.xml file, each global memory, channel or kernel connection is comprised of individual interfaces. For the <code>global_mem</code>, <code>channels</code>, and <code>interfaces</code> XML elements, an <code>interface</code> attribute must be included to specify the corresponding parameters for each connection.</p> <p>Table 2-5: Parameters for <code>interface</code> attribute</p> Parameter Description Applicable Interface name * For global_mem: instance name of the Platform Designer component.* For channels: instance name of the Platform Designer component that has the channel interface.* For interfaces: name of the entity in which the kernel interface resides (for example, board). All port * For global_mem: name of the Avalon\u00ae-MM interface in the Platform Designer component that corresponds to the interface attribute.* For channels: name of the streaming interface in the Platform Designer component.* For interfaces: name of the interface to the <code>OpenCL\u2122 Kernel Interface</code> Platform Designer component. For example, kernel_cra is the Avalon\u00ae-MM interface, and kernel_irq is an interrupt. All type * For global_mem: set to agent. * For channels: - Set to streamsource for a stream source that provides data to the kernel.- Set to streamsink for a stream sink interface that consumes data from the kernel.* For interfaces: set to either host, irq, or streamsource. All width * For global_mem: width of the memory interface in bits.For channels: number of bits in the channel interface.For interfaces: width of the kernel interface in bits. All waitrequest_allowance * For global_mem: [Optional] Amount of Avalon\u00ae-MM waitrequest allowance supported on the agent interface (that is, kernel-facing interface) of the clock-crossing bridge that spans between the memory and the kernel clock domains.* For kernel_cra: [Optional] Amount of Avalon\u00ae-MM waitrequest allowance that the kernel_cra agent interface must support.This parameter defaults to 0 if you do not specify it in the board_spec.xml file. A value of 0 indicates that this waitrequest allowance feature is disabled. All maxburst Maximum burst size for the agent interface.Attention: The value of width \u00f7 8 x maxburst must be less than the value of interleaved_bytes. global_mem address Starting address of the memory interface that corresponds to the host interface-side address.For example, address 0 should correspond to the bank1 memory host from the <code>OpenCL Memory Bank Divider</code>. In addition, any non-zero starting address must abut the end address of the previous memory. global_mem size Size of the memory interface in bytes. The sizes of all memory interfaces should be equal. global_mem latency_type If the memory interface has variable latency, set this parameter to average to signify that the specified latency is considered the average case. If the complete kernel-to-memory path has a guaranteed fixed latency, set this parameter to fixed. global_mem chan_id A string used to identify the channel interface. The string may have up to 128 characters. channels clock For the streamsource kernel interface type, the parameter specifies the name of the clock that the snoop stream uses. Usually, this clock is the kernel clock. interfaces <p>Example for how the <code>interface</code> attribute is used in <code>global_mem</code> and <code>interfaces</code> elements is covered in section for these elements respectively.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#215-global_mem-element","title":"2.1.5 global_mem Element","text":"<p>The <code>global_mem</code> element of the board_spec.xml file is used to provide information on the memory interfaces that connect to the kernel.</p> <p>Note: For each global memory that the kernel accesses, you must include one interface element that describes its characteristics. The different attributes for global_mem element are discussed in table 2-6.</p> <p>Table 2-6: Attributes for <code>global_mem</code> Element</p> Attribute Description name The name FPGA application/kernel developer should use to identify the memory type. Each name must be unique and must comprise of less than 32 characters. max_bandwidth The maximum bandwidth, in megabytes per second (MB/s), of all global memory interfaces combined in their current configuration. The oneAPI compiler uses max_bandwidth to choose an architecture suitable for the application and the board.  Compute this bandwidth value from datasheets of memories on your board.  Example max_bandwidth calculation for a 64-bit DDR4 interface running at 1200 MHz:  max_bandwidth = 1200 MHz x 2 x 64 bits \u00f7 8-bits = 19200 MB/s  The max_bandwidth value will change based on global memory configuration, for example, if the memory configuration comprises of 4 banks of DDR4 configured as a single homogenous memory, the max_bandwidth will be 19200 x 4 (i.e. number of memory interfaces from kernel). Please see section 2.1.5.1 for more information on global memory configurations.  Designers have the option to use block RAM instead of or in conjunction with external memory as global memory. The formula for calculating max_bandwidth for block RAM is max_bandwidth = block RAM speed x (block RAM interface size \u00f7 8 bits).  Example max_bandwidth calculation for a 512-bit block RAM running at 100 MHz:  max_bandwidth = 100 MHz x 512 bits \u00f7 8 bits = 6400 MB/s interleaved_bytes Include the interleaved_bytes attribute in the board_spec.xml file when you instantiate multiple interfaces(i.e. memory banks) for a given global memory system. This attribute controls the size of data that the offline compiler distributes across the interfaces.  The offline compiler currently can interleave data across banks no finer than the size of one full burst. This attribute specifies this size in bytes and following are the recommended values:  For two or fewer global memory banks: maxburst x width_bytes  For four or more global memory banks: maxburst x width_bytes x 4  The interleaved_bytes value must be the same for the host interface and the kernels. Therefore, the configuration of the <code>OpenCL Memory Bank Divider</code> must match the exported kernel agent interfaces in this respect (refer to section 3.1.1 for information about OpenCL Memory Bank Divider)  For block RAM, interleaved_bytes equals the width of the interface in bytes. config_addr The address of the ACL Mem Organization Control Platform Designer component (mem_org_mode) that the host software uses to configure memory. You may omit this attribute if your board has homogeneous memory; the software uses the default address (0x18) for this component. If your board has heterogeneous memory, there is a mem_org_mode component in the board system for each memory type.  Enter the config_addr attribute and set it to the value of the base address of the mem_org_mode component(s). default Include this optional attribute and assign a value of 1 to set the global memory as the default memory interface. The default memory must start at address 0x0.  If you do not implement this attribute, the first memory type defined in the board_spec.xml file becomes the default memory interface. interface See the <code>interface</code> section above for the parameters you must specify for each interface. allocation_type A list that specifies which USM allocator is used to allocate from the global_mem element. Values allowed in this list are <code>host</code>, <code>shared</code>, and <code>device</code>. The following conditions apply:  If there are multiple global_mem elements with the same allocation_type attribute, the first allocation_type attribute in the board_spec.xml is assumed to be the one used by the specified allocator.  If there is a single global_mem element with multiple allocation_type attributes, this indicates that allocations of the specified types use this global_mem interface.  [Legacy support] If you have not specified the allocation_type attribute, it is assumed that all global memory interfaces have the <code>device</code> allocation_type. <p>Example below shows a <code>global_mem</code> element configuration for a kernel system connected to four 4GB DDR4 memory banks. The DDR4 interface is 64 bit operating at 1200MHz. Note that the name of the platform designer system name is <code>board.qsys</code>. As mentioned in description for <code>interleaved_bytes</code> in table above, the <code>OpenCL Memory Bank Divider</code> configuration ensures that the host interface matches the interleaved_bytes setting (i.e. 512 bits x 64 burst size = 4096 bytes). For information on <code>waitrequest_allowance</code>, refer to section 2.1.4 on <code>interface</code> attribute.</p> <p>Note: More details on the <code>OpenCL Memory Bank Divider</code> and the Clock Crossing Bridges is covered in section 3.0</p> <p>Figure 2-5: Memory Connection Example Block Diagram and Corresponding <code>global_mem</code> Element in <code>board_spec.xml</code></p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#2151-global-memory-configurations","title":"2.1.5.1 Global Memory Configurations","text":"<p>A board can have a single memory bank, multiple memory banks of the same type (e.g. 4 banks of DDR4) or different banks of different types.</p> <p>The partitioning of memory for oneAPI kernel developers is explained in the FPGA optimization Guide for oneAPI. The global memory configuration required by an application kernel must match the configuration in board_spec.xml as the compiler uses this information to generate a suitable architecture for the application. The different memory configurations are</p> <ul> <li>A single global memory region (possible with same type of memory banks)</li> <li>Different global memories (heterogeneous memory)</li> </ul>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#21511-contiguous-global-memory","title":"2.1.5.1.1 Contiguous Global Memory","text":"<p>For boards with multiple memory banks of the same type, designers can configure these as a single contiguous global memory region. This is done by specifying each memory interface within a single global_mem element. Figure 2-5 showed 4 DDR4 memory banks configured as a single global memory region.</p> <p>With this configuration, FPGA application developers have the option to use contiguous memory region in an interleaved or a non-interleaved fashion. Even with contiguous memory regions, kernel developers can partition data buffers across the banks/memory channels. Please refer to Global Memory Access Optimization section in FPGA Optimization Guide for oneAPI for more details on these partitioning techniques.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#21512-heterogeneous-memory","title":"2.1.5.1.2 Heterogeneous Memory","text":"<p>For boards with different memory technologies, designers must specify each type of memory that the kernel needs to access as a separate global memory.</p> <p>Figure 2-6 shows heterogeneous configurations and the <code>global_mem</code> element structure for two different types of memories (QDR, DDR4). The <code>global_mem</code> element in example below also demonstrates use of the <code>default</code> attribute. It is set to \"1\" for the DDR4 memory banks, indicating to the oneAPI compiler that the default global memory for the kernel is DDR4.</p> <p>Figure 2-6: Heterogeneous Memory Example Block Diagram and Corresponding <code>global_mem</code> Element in <code>board_spec.xml</code></p> <p></p> <p></p> <p>Unified Shared Memory</p> <p>For applications that require USM support, the board_spec.xml must specify host and device memories in a heterogeneous manner. The <code>allocation_type</code> must be <code>host</code> for global memory region on the host processor. The <code>allocation_type</code> must be set to <code>device</code> for global memory on the FPGA board. Example below extends the board_spec.xml snippet in figure 2-5 to add a <code>global_mem</code> element for the kernel system to host processor memory interface.</p> <p>Figure 2-7: <code>global_mem</code> Element Example for Unified Shared Memory(USM)</p> <p></p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#216-host-element","title":"2.1.6 host Element","text":"<p>The host element of the board_spec.xml file provides information on the interface from the host to the kernel. Figure 2-8 shows an example of host element.</p> <p>Figure 2-8: <code>host</code> Element Example</p> <p></p> <p>Table 2-7: Attributes for the <code>host</code> Element</p> Attribute Description kernel_config This attribute informs the oneAPI compiler at what offset the kernel resides, from the perspective of the <code>kernel_cra</code> host on the kernel_interface module.* start: the starting address of the kernel. Normally, this attribute has a value of 0 because the kernel_cra host should not host anything except kernels.* size: keep this parameter at the default value of 0x0100000."},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#217-interfaces-element","title":"2.1.7 interfaces Element","text":"<p>The <code>interfaces</code> element of the board_spec.xml file describes the kernel interfaces that connect to application kernels and control kernel behavior. For this element, include one of each interface of types host, irq and streamsource. Refer to the <code>interface</code> section for the parameters you must specify for each interface. In addition to the host, irq, and streamsource interfaces, if your design includes a separate Platform Designer subsystem containing the board logic, the kernel clock and reset interfaces exported from it are also part of the interfaces element. Specify these interfaces with the <code>kernel_clk_reset</code> attribute and its corresponding parameters.</p> <p>Figure 2-9 shows example of <code>interfaces</code> element.</p> <p>Figure 2-9: <code>interfaces</code> Element Example</p> <p></p> <p>Table 2-8:  Parameters for the <code>kernel_clk_reset</code> Attribute</p> Attribute Description clk The Platform Designer name for the kernel clock interface clk2x The Platform Designer name for the 2xkernel clock interface reset The Platform Designer connection for the kernel reset <p>Note: Name the kernel clock and reset interfaces in the Platform Designer connection format (that is, .). For example: board.kernel_clk"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#22-board_envxml-file","title":"2.2 <code>board_env.xml</code> File","text":"<p>The <code>board_env.xml</code> file is used by the oneAPI toolkit to set up the board installation that enables the compiler to target a specific accelerator platform. The board_env.xml file must be located in the top most level of the oneAPI ASP for each platform. For example, the <code>board_env.xml</code> for oneAPI ASP for OFS reference platforms is located in the <code>oneapi-asp/Platform-Name</code> folder, where <code>Platform-Name</code> is <code>n6001</code> for Agilex OFS and <code>d5005</code> for Stratix 10 OFS.</p> <p>A sample board_env.xml file is shown below. Table 2-9 explains the elements of this file.</p> <p>Figure 2-10: <code>board_env.xml</code> File Structure</p> <p></p> <p>Table 2-9:  Specifications of XML Elements and Attributes in the <code>board_env.xml</code> File</p> Element Attribute Description board_env * version: The oneAPI compiler version used to create oneAPI ASP* name: The runtime uses this as the name of the FPGA Client Driver(FCD) file name hardware * dir: Name of the subdirectory, within the oneAPI ASP directory, that contains the board variant directories for a platform * default: The default board variant that the compiler targets when a platform has multiple board variants and user does not specify an explicit argument using -Xstarget option platform name: Name of the operating system. A separate <code>platform</code> element must be specified for each supported OS for the oneAPI ASP platform mmdlib A string that specifies the path to the MMD library of your oneAPI ASP. To load multiple libraries, specify them in an ordered, comma-separated list. The host application will load the libraries in the order that they appear in the list&gt; Note: You can use <code>%b</code> to reference your oneAPI ASP directory linkflags A string that specifies the linker flags necessary for linking with the MMD layer available with the board&gt; Note: %b to reference your oneAPI ASP directory linklibs A string that specifies the libraries the oneAPI runtime must link against to use the MMD layer available with the board utilbindir Directory in which the runtime expects to locate board utility executables (i.e. install, uninstall, program, diagnose, flash) &gt; Note: You can use %b to reference your board installation directory"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#30-oneapi-asp-hardware","title":"3.0 oneAPI ASP Hardware","text":"<p>The oneAPI compiler generates the <code>kernel system</code> interfaces based on specifications provided by the platform/board developer in the <code>board_spec.xml</code> file. The <code>kernel system</code> interfaces with the rest of the oneAPI ASP RTL as shown in figure 1-3.</p> <p>Figure 1-3 shows 4 different paths, summarized below:</p> <ul> <li>Host to EMIF: Consisting of RTL to handle data transfer between host and on-board memory (e.g. DDR4)</li> <li>Host to Kernel: Consisting of RTL to handle control signals &amp; interrupts between host and kernel</li> <li>Kernel to EMIF: Consisting of RTL to handle data transfer between kernel and on-board memory</li> <li>Kernel to Host memory: Required to support Unified Shared Memory. This requires some additional RTL to handle data transfer between kernel and host memory.</li> </ul> <p>Please note that the <code>kernel system</code> generated by oneAPI compiler has Avalon\u00ae interfaces. OFS FIM has AXI interfaces. Additional logic blocks from Platform Interface Manager are used to handle protocol conversions. Please refer to section 5.2.1 for more details on PIM. The next few sections cover some of the important IP components provided by Intel\u00ae oneAPI Base Toolkit (Base Kit) installation that are required to enable kernel communications with host and board peripherals. More design implementation details are covered in section 5.0.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#31-host-to-external-memory-interfaceemif","title":"3.1 Host to External Memory Interface(EMIF)","text":"<p>The host to EMIF datapath consists of a PCIe Subsytem(SS), EMIF Subsystem located in the FIM and a Direct Memory Access(DMA) engine in the oneAPI ASP.</p> <p>PCIe Subsystem(SS) has the PCIe IP and additional logic to handle PCIe packet format and routing. FIM handles routing signals received from host to the user design located in a region referred to as Accelerator Functional Unit(AFU) (the <code>Kernel system</code> resides in the AFU).</p> <p>Note: For more information about the PCIe SS, please refer to Intel FPGA IP Subsystem for PCI Express IP User Guide</p> <p>The External Memory Interface Subsystem (EMIF SS) consists of EMIF IP and additional logic for handling transfers between AFU and on-board memories.</p> <p>Note: For more information about the EMIF SS, please refer to Memory Subsystem Intel FPGA IP User Guide</p> <p>Large buffers of data are usually transferred between host and on-board memory in oneAPI applications. This necessitates a Direct Memory Access(DMA) Engine between host and on-board memory. In oneAPI ASP designs for OFS reference platform, this DMA engine is placed in the AFU region. </p> <p>As described in section 2.1.5.1, there are different configurations for memories on board. In addition to above, figure 1-3 also shows an additional IP in the host to memory datapath, called OpenCL Memory Bank Divider. This IP is a part of Intel\u00ae oneAPI Base Toolkit (Base Kit) installation and is used for handling one of the most commonly used configurations, i.e. configuring multiple memory banks of same type as a contiguous memory region. In this case, the kernel has a contiguous view of the memory and data can be interleaved across the different memory channels. The host must also have the same view of the memory in order to ensure read and write transactions from correct addresses.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#311-opencl-memory-bank-divider","title":"3.1.1 OpenCL Memory Bank Divider","text":"<p>The OpenCL\u2122 Memory Bank Divider is a Platform Designer component that takes an incoming request from the host interface on the Avalon\u00ae-MM agent port and routes it to the appropriate bank host port. This component must reside on the path between the host and the global memory interfaces. In addition, it must reside outside of the path between the kernel and the global memory interfaces.</p> <p>Figure 3-1: OpenCL Memory Bank Divider IP</p> <p></p> <p></p> <p>Table 3-1: Parameter Settings for the OpenCL Memory Bank Divider Component</p> Parameter Description Number of banks Number of memory banks for each of the global memory types included in your board system. Separate read/write ports Enable this parameter so that each bank has one port for read operation and one for write operation. Add pipeline stage to output Enable this parameter to allow for potential timing improvements. Data Width Width of the data bus to the memory in bits. Address Width (total addressable) Total number of address bits necessary to address all global memory. Burst size (maximum) Set to a value equal to interleaved_bytes/(width/8), where interleaved_bytes and width are defined in the interface attribute of the global_mem element in the board_spec.xml file. Maximum Pending Reads Maximum number of pending read transfers the component can process without asserting a waitrequest signal. Intel\u00ae recommended value is 64 if BSP has two global memory banks or fewer and 128 if BSP has four or more global memory banks.  CAUTION: A high Maximum Pending Reads value causes Platform Designer to insert a deep response FIFO buffer, between the component's host and agent, that consumes a lot of device resources. It also increases the achievable bandwidth between host and memory interfaces. Split read/write bursts on burst word boundary Enable splitting of read and write bursts on burst word boundary.  Enable this parameter if the Number of banks parameter value is greater than 1, and the burst reads and writes that the host controller sends to the agent port crosses burst word boundary. <p>Table 3-2: Signals and Ports for the OpenCL Memory Bank Divider Component</p> Signal or Port Description clk The bank divider logic uses this clock input. If the IP of your host and memory interfaces have different clocks, ensure that clk clock rate is not slower than the slowest of the two IP clocks. reset The reset input that connects to the board power-on reset. s The agent port that connects to the host interface controller. kernel_clk The kernel_clk drives this clock input kernel_reset The kernel_reset output from the <code>OpenCL Kernel Interface</code> drives this reset input. acl_bsp_snoop Export this Avalon\u00ae Streaming (Avalon\u00ae-ST) source. In the board_spec.xml file, under interfaces, describe only the snoop interface for the default memory (acl_internal_snoop). If you have a heterogeneous memory design, perform these tasks only for the <code>OpenCL Memory Bank Divider</code> component associated with the  default memory. Important: The memory system you build in Platform Designer alters the width of acl_bsp_snoop. You must update the width of the streamsource interface within the channels element in the board_spec.xml file to match the width of acl_bsp_snoop. In the board_spec.xml file, update the width of the snoop interface (acl_internal_snoop) specified with the streamsource kernel interface within the interfaces element. Updating the width ensures that the global_mem interface entries in <code>board_spec.xml</code> match the characteristics of the bank<code>N</code> Avalon\u00ae-MM hosts from corresponding <code>OpenCL Memory Bank Divider</code> component for the default memory. acl_bsp_memorg_host This conduit connects to the acl_bsp_memorg_host interface of the <code>OpenCL</code> Kernel Interface`.&gt; Note: Signal present if Number of banks &gt; 1. bank1, bank2, ..., bank8 The number of memory hosts available in the <code>OpenCL Memory Bank Divider</code> depends on the number of memory banks that were included when the unit was instantiated. Connect each bank with each memory interface in the same order as the starting address for the corresponding kernel memory interface specified in the board_spec.xml file.  For example, global_mem interface that begins at address 0 must correspond to the memory host in bank1 from the <code>OpenCL Memory Bank Divider</code>."},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#32-host-to-kernel-interface","title":"3.2 Host to Kernel Interface","text":"<p>The host exchanges control signals with kernel with the help of an additional IP provided as part of Intel\u00ae oneAPI Base Toolkit (Base Kit) installation. The control signals coming from the host are on a different clock domain (PCIe clock) while the kernel runs on different clock frequency . The OpenCL Kernel Interface IP handles the clock domain crossing for these control signals as well as handles communication with kernel CSR, interrupts, generates the reset for kernel. All oneAPI ASP designs must instantiate OpenCL Kernel Interface IPs to ensure the kernel functions correctly.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#321-opencl-kernel-interface","title":"3.2.1 OpenCL Kernel Interface","text":"<p>The OpenCL Kernel Interface is a Platform Designer component that allows the host interface to access and control the oneAPI kernel.</p> <p>Figure 3-2: OpenCL Kernel Interface IP</p> <p></p> <p></p> <p>*Note: OpenCL Kernel Interface IPs are device specific. There are different IPs for Intel\u00ae Stratix 10\u00ae FPGA and Intel\u00ae Agilex\u00ae FPGA device families. Please refer to hardware designs for oneAPI ASP for OFS reference platforms to view device specific instantiations for OpenCL Kernel Interface IPs.* Stratix 10 OFS <code>oneapi-asp</code>* Agilex OFS <code>oneapi-asp</code></p> <p>Table 3-3: Parameter Settings for the OpenCL Kernel Interface Component</p> Parameter Description Number of global memory systems Number of global memory types in your board design. <p>Table 3-4: Signals and Ports for the OpenCL Kernel Interface Component</p> Signal or Port Description clk The clock input used for the host control interface. The clock rate of clk can be slow. reset This reset input resets the control interface. It also triggers the kernel_reset signal, which resets all kernel logic. ctrl Use this agent port to connect to the host interface. This interface is a low-speed interface with which you set kernel arguments and start the kernel's execution. kernel_clk kernel clock drives this clock input. kernel_cra This Avalon\u00ae-MM host interface communicates directly with the kernels generated by the oneAPI compiler. Export the Avalon\u00ae-MM interface to the OpenCL Kernel Interface and name it in the board_spec.xml file. sw_reset_in When necessary, the host interface resets the kernel via the ctrl interface. If the board design requires a kernel reset, it can do so via this reset input. Otherwise, connect the interface to a global power-on reset. kernel_reset Use this reset output to reset the kernel and any other hardware that communicates with the kernel.  Warning: This reset occurs between the MMD open and close calls. Therefore, it must not reset anything necessary for the operation of your MMD. sw_reset_export This reset output is the same as kernel_reset, but it is synchronized to the clk interface. Use this output to reset logic that is not in the kernel_clk clock domain but should be reset whenever the kernel resets. acl_bsp_memorg_host The memory interfaces use these signals.  Based on the number of global memory systems you specify in the <code>OpenCL Kernel Interface</code> component parameter editor, the Intel\u00ae Quartus\u00ae Prime Pro Edition Software creates the corresponding number of copies of this signal, each with a different hexadecimal suffix. Connect each signal to the <code>OpenCL Memory Bank Divider</code> component associated with each global memory system (for example, DDR). Then, list the hexadecimal suffix in the config_addr attribute of the global_mem element in the board_spec.xml file. kernel_irq_from_kernel An interrupt input from the kernel. This signal is exported and named in the board_spec.xml file. kernel_irq_to_host An interrupt output from the kernel. This signal connects to the host interface."},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#33-kernel-to-external-memory-interface","title":"3.3 Kernel to External Memory Interface","text":"<p>The kernel system masters the interface from kernel to external memory. oneAPI compiler generates kernel system memory interface logic (e.g. Load-Store Unit) according to the global memory configuration and <code>interface</code> specifications in <code>board_spec.xml</code> file. The kernel system operates at kernel clock(see next section for more information), hence, oneAPI ASP developers must handle clock domain crossing from kernel to EMIF clock domain.</p> <p>For implementation details for all datapaths discussed above, please refer to section 5.2.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#40-oneapi-asp-software","title":"4.0 oneAPI ASP Software","text":"<p>The software components of oneAPI ASP consist of the Memory Mapped Device(MMD) layer and the board utility routine required by runtime.</p> <p>Section 4.1 introduces MMD layer and section 4.2 explains board utilities.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#41-memory-mapped-devicemmd-layer","title":"4.1 Memory Mapped Device(MMD) Layer","text":"<p>The oneAPI ASP Memory Mapped Device (MMD) layer sits in between the oneAPI runtime and OPAE SDK and provides a set of API for device communication and control. The runtime calls into the MMD API for various operations like opening a handle to the device, allocating memory etc.</p> <p>Note: For more information about the FPGA runtime, please refer to FPGA Runtime documentation here.</p> <p>A header file, called <code>aocl_mmd.h</code>, has the list of MMD API calls that must be implemented by oneAPI ASPs. From the perspective of the caller, below is typical MMD API lifecycle: 1. Open device to provide handle for further operations 2. Set interrupt and status handlers 3. Program device with kernel bitstream 4. Allocate memory if required 5. Perform Read, Write operations (DMA or MMIO) 6. Free memory if allocation done in step 4 7. Close device. No further operations permitted until subsequent open device call</p> <p>Section 5.3 discusses more about the implementation of the MMD layer APIs in oneAPI ASPs for OFS reference platforms.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#42-board-utilities","title":"4.2 Board Utilities","text":"<p>oneAPI runtime provides a set of options for the <code>aocl</code> utility.</p> <p>Note: <code>aocl</code> is an utility available in the oneAPI runtime environment, please use <code>aocl help</code> command for more information on this.</p> <p>Table 4-1 shows the subcommands that <code>aocl</code> utility provides for FPGA platforms.</p> <p>Table 4-1: <code>aocl</code> board utilities</p> Subcommand Description Executable Call install Install board into the host system. This installs the FPGA Client Driver (FCD) for your FPGA platform. FCD allows runtime to find and load the FPGA platform libraries at runtime aocl install <code>path-to-FPGA-platform-oneapi-asp</code> uninstall Uninstall board from the host system. Removes FCD. aocl uninstall <code>path-to-FPGA-platform-oneapi-asp</code> initialize Configure a default FPGA image onto the board aocl initialize <code>device-name</code> program Configure a new FPGA image onto the board aocl program <code>device-name</code> diagnose Runs ICD and FCD diagnostics followed by querying devices in installed platforms. If a <code>device-name</code> is specified in the call, it run board vendor's test program for the FPGA platform * aocl diagnose : This queries the devices in FPGA platform and supplies a list of valid strings assigned to the list of devices  * aocl diagnose <code>device-name</code> : This runs full diagnostic test on the FPGA platform <p>The runtime expects the routine for each of this utilities to be defined in the oneAPI ASP. It looks for the routine executables in the location specified by the <code>utilbinder</code> element in the <code>board_env.xml</code> file.</p> <p>install</p> <p>oneAPI runtime uses the information in <code>board_env.xml</code> file to create a FCD file. The FCD file name matches <code>name</code> attribute of <code>board_env</code> element and the FCD contents are the platform libraries specified in <code>mmdlib</code> element. Refer to section 2.2 for more information about <code>board_env.xml</code> file. The runtime adds the installed platform to the list of installed packages(file used by runtime to track installed platforms) and then invokes the install routine from oneAPI ASP.</p> <p>uninstall</p> <p>oneAPI runtime removes the FCD file and removes the platform from list of installed packages. It then invokes the uninstall routine for oneAPI ASP.</p> <p>initialize</p> <p>oneAPI runtime invokes initialize routine provided by oneAPI ASPs for installed platforms.</p> <p>program</p> <p>oneAPI runtime loads the programming file on the FPGA by invoking program routine provided by the oneAPI ASPs for the installed platform.</p> <p>diagnose</p> <p>oneAPI runtime runs ICD and FCD diagnostics to check the ICD and FCD files installed on the system. It then queries for available boards in the installed platform and lists boards matching every installed platform. If a <code>device-name</code> is specified in the call, runtime invokes the diagnostic routine provided in oneAPI ASP.</p> <p>For more information about the implementation of these routines in oneAPI ASPs for OFS reference platforms, please refer to section 5.4.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#50-oneapi-asp-implementation-details","title":"5.0 <code>oneapi-asp</code> Implementation Details","text":"<p><code>oneapi-asp</code> in the OFS has two reference platform releases, one is based on Intel\u00ae Stratix 10\u00ae FPGA and the other is based on an Intel\u00ae Agilex\u00ae FPGA. This chapter aims to explain the architecture and current implementation details of <code>oneapi-asp</code> for these platforms. The <code>oneapi-asp</code> repository is located here.</p> <p>The next section explains the <code>oneapi-asp</code> directory structure, followed by sections on hardware and MMD layers.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#51-oneapi-asp-directory-structure","title":"5.1 <code>oneapi-asp</code> Directory Structure","text":"<p>As described in section 2.0, oneAPI compiler &amp; runtime use the <code>board_env.xml</code> and <code>board_spec.xml</code> files to get information about the FPGA platform. The compiler expects the <code>board_env.xml</code> file to be at the topmost level in the platform directory. The board_env.xml file describes the location of the hardware files &amp; platform libraries.</p> <p>Figure 5-1: Sample board_env.xml File</p> <p></p> <p>Figure 5-1 shows a sample board_env.xml file, the corresponding oneAPI ASP directory structure must match the following format. Table 5-1 provides details on each folder.</p> <pre>\n    oneapi-asp_Platform-Name/\n    |--hardware/\n    |--|--Board-Variant-1/\n    |--|--Board-Variant-2/\n    |--source\n    |--linux64/\n    |--board_env.xml\n</pre> <p>Note:1. The <code>source</code> folder is located in <code>common</code> directory in case of oneAPI ASP for OFS reference platforms. This is because a common source code is utilized for both <code>d5005</code> and <code>n6001</code> reference platform ASPs.2. In addition to above folders, oneAPI ASPs for OFS reference platforms have additional directories called <code>scripts</code> and <code>bringup</code> which contain helper scripts for platform generation &amp; a sample for board bring up respectively. Please refer to the README for each reference platform in the oneASP-asp repository for more information on these additional folders.  * README for <code>oneapi-asp</code> targeting Intel\u00ae FPGA PAC D5005 reference platform: README  * README for <code>oneapi-asp</code> targeting Intel\u00ae FPGA SmartNIC N6001-PL Platform: README</p> <p>The <code>Platform-Name</code> is used for identifying the platform and can be alphanumeric value decided by the platform developer. For example, Intel uses the <code>Platform-Name</code> <code>d5005</code> for <code>oneapi-asp</code> for Intel\u00ae Stratix 10\u00ae FPGA as the reference platform is Intel\u00ae FPGA PAC D5005.</p> <p>Table 5-1: Directory Contents</p> Files/Folder Descriptions <code>hardware</code> Contains hardware files (RTL, platform designer files, SDCs, compilation scripts, floorplan settings) and the <code>board_spec.xml</code> files for all board variants. See table 5-2 for more details <code>source</code> Source code for MMD layer as well as <code>oneapi-asp</code> board utilities <code>linux64</code> Location for FPGA platform libraries and executables for <code>oneapi-asp</code> board utilities <code>board_env.xml</code> Contains platform installation information. Please refer to section 2.2 for more details on board_env.xml elements <p>Tables 5-2 to 5-4 give more details on each of these folders for oneAPI ASPs for OFS reference platforms.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#511-hardware-folder","title":"5.1.1 hardware Folder","text":"<pre>\nhardware/\n|--board-variant-1/\n|--|--build\n|--|--part-number_dm.xml (Please see note for this file in table 5-2)\n|--|--board_spec.xml\n|--|--quartus.ini\n</pre> <p>Table 5-2: <code>hardware</code> Folder Contents</p> Files/Folder Description <code>build</code> Contains all hardware design files including Intel\u00ae Quartus\u00ae software project file (*.qpf), Intel\u00ae Quartus\u00ae software Settings Files (*.qsf), IP files,  *.sv, *.qsys, *.sdc as well as scripts to control compile flow <code>board_spec.xml</code> Defines compile flow, global memory, kernel interfaces. Please see section 2.1 for more information about <code>board_spec.xml</code> file <code>part-number_dm.xml</code> Device Model file for Intel\u00ae FPGA part on the target platform. The name must be of the format <code>part-number</code>_dm.xml. This file has the total resources available on the device. &gt; Note: The device model files provided as part of the Intel\u00ae oneAPI Base Toolkit (Base Kit) installation are located in <code>$INTELFPGAOCLSDKROOT/share/models/dm</code>, where INTELFPGAOCLSDKROOT is set by the <code>setvars.sh</code> environment setup script provided by oneAPI toolkit. If the device model file for your part number is not included in <code>$INTELFPGAOCLSDKROOT/share/models/dm</code>, it must be created and placed in the same folder as <code>board_spec.xml</code>. <code>quartus.ini</code> Intel\u00ae Quartus\u00ae software ini settings file"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#512-source-folder","title":"5.1.2 source Folder","text":"<pre>\nsource/\n|--cmake/\n|--|--modules\n|--extra/\n|--|--intel-fpga-bbb\n|--host\n|--include\n|--util\n|--CMakeLists.txt\n</pre> <p>Table 5-3: <code>source</code> Folder Contents</p> Files/Folder Description <code>cmake/modules</code> Contains <code>Find***.cmake</code> files to find packages required for building MMD library <code>extra/intel-fpga-bbb</code> oneAPI ASP for OFS reference platforms uses a library provided as part of Intel\u00ae FPGA Basic Building Blocks (BBB) repository. The <code>oneapi-asp</code> build scripts clone this repository in <code>extra</code> directory by default <code>host</code> Source code for MMD API <code>include</code> Contains MMD header files <code>util</code> Contains source code for <code>oneapi-asp</code> reference platform routines for diagnose and program utilities <code>CMakeLists.txt</code> Top-level CMakeLists.txt file for building MMD and other libraries required by <code>oneapi-asp</code> as well as the executables for diagnose and program utilities"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#513-linux64-folder","title":"5.1.3 linux64 Folder","text":"<pre>\nlinux64/\n|--include (see note below)\n|--lib\n|--libexec\n</pre> <p>Note: The <code>include</code> and <code>lib</code> folders do not exist in the <code>oneapi-asp</code> repository. These are added after the <code>oneapi-asp</code> build flow is complete.</p> <p>Table 5-4: <code>linux64</code> Folder Contents</p> Files/Folder Description <code>include</code> Contains header files from Intel\u00ae FPGA BBB required by MMD (see section 5.3 for more information on use of MPF from Intel\u00ae FPGA BBB in MMD) <code>lib</code> Contains MMD and Intel\u00ae FPGA BBB libraries <code>libexec</code> Contains executables/scripts for <code>oneapi-asp</code> board utilities"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#52-oneapi-asp-hardware-implementation","title":"5.2 <code>oneapi-asp</code> Hardware Implementation","text":"<p>This section goes deeper into the current hardware architecture of the <code>oneapi-asp</code>.</p> <p>Figure 1-3 shows a high level overview of the hardware design. Figure 5-2 shows a detailed diagram of the <code>oneapi-asp</code> components.</p> <p>Figure 5-2: <code>oneapi-asp</code> Reference Platform Hardware Design</p> <p></p> <p>All <code>oneapi-asp</code> components reside in the AFU region in the PR slot. The <code>ofs_plat_afu.sv</code> is the top level entity for the <code>oneapi-asp</code>.</p> <p>Note: The architecture of the FIM with PR slot is explained in the FIM technical reference manuals, please refer to section 1.3 for link to the manuals.</p> <p>The <code>oneapi-asp</code> repository contains source files for components that reside in the <code>ofs-plat-afu.sv</code> for each reference platform. The FIM database is copied to the <code>oneapi-asp</code> during ASP build flow (<code>oneapi-asp/Platform-Name/scripts/build-bsp.sh</code>). Hence, <code>oneapi-asp</code> expects a compiled FIM netlist and a corresponding PR tree. ASP compile scripts import the FIM database during oneAPI compilation.</p> <p>Notes:  1. FIM developer guide outlines steps to compile a FIM and generate PR tree, please refer to section 1.3 for links to FIM developer guides 2. The steps to build <code>oneapi-asp</code> using PR tree and <code>build-bsp.sh</code> script are covered in the oneAPI Accelerator Support Package (ASP): Getting Started User Guide</p> <p>The following figure shows the <code>oneapi-asp</code> build process.</p> <p>Figure 5-3: <code>oneapi-asp</code> Build Flow</p> <p></p> <p>Table 5-5 Environment Variables used in Build Flow</p> Variable Number Environment Variable Description 1 OFS_PLATFORM_AFU_BBB Should point to location where ofs-platform-afu-bbb repository is cloned, if this variable is not set, <code>build-bsp.sh</code> script clones the repository 2 OPAE_PLATFORM_ROOT Must point to the PR tree generated during FIM build, this is a required variable and build flow fails without this 3 LIBOPAE_C_ROOT Should point to the installation location for OPAE libraries (please see oneAPI Accelerator Support Package (ASP): Getting Started User Guide for more information on this variable setting), <code>build-opae.sh</code> script is used to clone &amp; build OPAE library if this variable is not set 4 OPAE_SDK_REPO_BRANCH If <code>LIBOPAE_C_ROOT</code> is not set, it is recommended to set this variable to indicate the OPAE SDK branch to be used for building OPAE libraries (please see oneAPI Accelerator Support Package (ASP): Getting Started User Guide) <p>All scripts required for <code>oneapi-asp</code> build are located in <code>oneapi-asp/Platform-Name/scripts</code> folder, where <code>Platform-Name</code> is:</p> <ul> <li><code>n6001</code> for Agilex OFS</li> <li><code>d5005</code> for Stratix 10 OFS</li> </ul> <p>The build flow generates the complete hardware directories for all board variants in <code>oneapi-asp</code>.</p> <p>Each OFS reference platform currently has two <code>Board-Variants</code>. Figure 5-2 shows the first variant that has a DMA engine on the Host to EMIF path. The second variant has support for USM (Unified Shared Memory) added. This requires few additional modules in the <code>oneapi-asp</code> to handle the kernel to host memory datapath. Figure 5-4 shows the detailed diagram for board variant with USM support.</p> <p>Note: Please see <code>oneapi-asp/Platform-Name/hardware</code> folder for the board variants for each OFS reference platform. Board variants with USM support have a <code>_usm</code> in the name.</p> <p>Figure 5-4: <code>oneapi-asp</code> Reference Platform with USM Hardware Design</p> <p></p> <p>All hardware design files for the components inside <code>ofs_plat_afu</code> module are inside the <code>oneapi-asp/Platform-Name/hardware/Board-Variant/build</code> directory.</p> <p>Table 5-6 gives a brief description of the important design files in all board variants. Please refer to figure 5-2 and figure 5-4 for visual representation of the design.</p> <p>Table 5-6: Hardware Design Files</p> Files/Folder Description ip Contains all the *.ip files for IP components used in the hardware design rtl Contains the system verilog and verilog design files shown in figure 5-2 &amp; 5-4 above scripts Contains scripts to control oneAPI kernel and asp Intel\u00ae Quartus\u00ae software compile flow (see section 5.2.3 for more information on compile flow) platform Contains Platform Interface Modules (PIM) modules used in the design. See PIM subtopic below afu_flat.qsf Intel\u00ae Quartus\u00ae software Settings File for revision that is compiled by default. The name (<code>afu_flat.qsf</code>) matches <code>revision</code> attibute in <code>compile</code> element in <code>board_spec.xml</code> file afu_ip.qsf Adds platform specific settings &amp; design files, this file is sourced in afu_flat.qsf mpf_vtp.qsf Adds IP components from Intel\u00ae FPGA BBB (see section 5.2.2 below for information about use of MPF blocks from Intel\u00ae FPGA BBB) repository used in the design bsp_design_files.tcl Adds design files to the project, this file is source in afu_ip.qsf board.qsys Please refer to figure 5-2 for components in board.qsys system ddr_board.qsys Instantiated in the board.qsys system, contains IP components in the host to EMIF and kernel to EMIF datapath. <code>OpenCL Memory Bank Divider</code> is instantiated in this platform designer system. Please refer to section 3.1.1 for more details on <code>OpenCL Memory Bank Divider</code> ddr_channel.qsys Instantiated in ddr_board.qsys, contains bridges required for clock domain crossings between PCIe and EMIF clocks as well as kernel and EMIF clock"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#521-platform-interface-modulespim","title":"5.2.1 Platform Interface Modules(PIM)","text":"<p>In addition to above files/folders, an important part of the design are the <code>ofs_plat_*</code> modules provided by Platform Interface Manager (PIM). oneAPI kernel system and <code>oneapi-asp</code> have Avalon\u00ae interfaces. FIM components have AXI interfaces. PIM modules are used for protocol translation. </p> <p>Note: For more information about PIM, please refer to PIM README here.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#522-direct-memory-accessdma-module","title":"5.2.2 Direct Memory Access(DMA) Module","text":"<p>The Direct Memory Access module is located in the host to EMIF datapath in the <code>oneapi-asp</code> and provides a controller to execute transfers from host to DDR on the board and vice versa. The source files for the DMA module used in <code>oneapi-asp</code> for OFS reference platforms are located in <code>oneapi-asp/Platform-Name/hardware/Board-Variant/build/rtl/dma</code> directory. Figure 5-5 shows the DMA module interface.</p> <p>Figure 5-5: DMA Controller Block Diagram</p> <p></p> <p>Figure 5-2 shows the instantiation of this dma_top module as <code>dma_controller_inst</code>. Table 5-7 shows the signal names and descriptions.</p> <p>Table 5-7: DMA Module Signal Descriptions</p> Signal or Port Description mmio64_if Control signal from host, connects to DMA Control Status Registers(CSR) host_mem_rd_avmm_if Avalon\u00ae memory-mapped interface to read from host memory host_mem_wr_avmm_if Avalon\u00ae memory-mapped interface to write to host memory local_mem_rd_avmm_if Avalon\u00ae memory-mapped interface to read from on-board DDR4 memory local_mem_wr_avmm_if Avalon\u00ae memory-mapped interface to write to on-board DDR4 memory dma_irq_host2fpga Interrupt to indicate completion of host to FPGA DMA transaction (read from host, write to DDR4) dma_irq_fpga2host Interrupt to indicate completion of FPGA DDR4 to host DMA transaction (read from DDR4, write to host)&gt; Note: The <code>oneapi-asp</code> for OFS reference platforms uses a host memory write to indicate completion of FPGA to host transaction <p>The data transfer module manages data movement from source to destination addresses.</p> <p>To start a data transfer, the data transfer module requires following information, this is set by the <code>dma_dispatcher</code>:</p> <ul> <li>Source address</li> <li>Destination address</li> <li>Number of bytes to transfer</li> </ul> <p><code>oneapi-asp</code> for OFS reference platforms uses virtual addresses in the DMA controller for data transfer. The Memory Properties Factory(MPF) Virtual to Physical(VTP) blocks (i.e.<code>mpf_vtp_*</code> modules) shown in figure 5-2 translate virtual addresses to appropriate host addresses. </p> <p>.</p> <p>Note: Memory Properties Factory(MPF) is a part of Intel\u00ae FPGA Basic Building Blocks. Please refer to Intel\u00ae FPGA BBB repository for more information.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#523-hardware-compile-flow","title":"5.2.3 Hardware Compile Flow","text":"<p>Figure 5-6 shows the compile flow overview; the oneAPI compiler generated hardware circuit is compiled by Intel\u00ae Quartus\u00ae software along with design files for <code>oneapi-asp</code>.</p> <p>Figure 5-6: oneAPI Compile Flow Overview</p> <p></p> <p>The oneAPI compiler uses the <code>board_spec.xml</code> to get more information about the <code>oneapi-asp</code> configuration. <code>board_spec.xml</code> file has a <code>compile</code> element to allow control of the Intel\u00ae Quartus\u00ae software compilation flow. The attributes of this element are discussed in section 2.1.2. The <code>oneapi-asp</code> uses tcl scripts to control the Intel\u00ae Quartus\u00ae software compilation flow. Figure 5-7 shows the flow and scripts used. All compilation scripts are located in <code>oneapi-asp/Platform-Name/hardware/Board-Variant/build/scripts</code> folder.</p> <p>Figure 5-7: Compilation Scripts in <code>oneapi-asp</code></p> <p></p> <p>Table 5-8 summarizes notes for reference numbers 1-5 marked in figure above.</p> <p>Table 5-8 Notes for Reference Numbers in Figure 5-7</p> Reference Number Note 1 revision_name is <code>afu_flat</code> for <code>oneapi-asps</code> for OFS reference platforms 2 <code>import_opencl_kernel.tcl</code> script imports compiler generated files into <code>build</code> folder for Intel\u00ae Quartus\u00ae software compilation step 3 <code>add_bbb_to_pr_project.tcl</code> script adds the Intel\u00ae FPGA BBB MPF files to the Intel\u00ae Quartus\u00ae software project 4 <code>compile_script.tcl</code> runs synthesis(quartus_syn), fitter(quartus_fit), assembler(quartus_asm) and static timing analysis(quartus_sta) for the design 5 <code>adjust_plls.tcl</code> script calculates the highest achievable kernel clock frequency (to ensure timing closure) and writes the data to a pll_metadata.txt file, which is used while generating the gbs (bitstream for AFU region)"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#53-oneapi-asp-memory-mapped-devicemmd-layer-implementation","title":"5.3 <code>oneapi-asp</code> Memory Mapped Device(MMD) Layer Implementation","text":"<p>As discussed in section 4.1, the MMD provides a set of API that allow the runtime to control the device and communicate with it.</p> <p>The source code for MMD layer is located in <code>oneapi-asp/common/source/host</code> folder. <code>aocl_mmd.h</code> is the header file for the implemented API and is located in <code>oneapi-asp/common/source/include</code> folder. Table 5-9 summarizes the APIs that have been implemented in <code>oneapi-asp</code> for OFS reference platforms.</p> <p>Note: For more details about the API, its arguments and enums please refer to the <code>aocl_mmd.h</code> file</p> <p>Table 5-9: MMD API Implemented in <code>oneapi-asp</code></p> API Purpose aocl_mmd_get_offline_info Obtain offline information about the board. This function is offline because it is device-independent and does not require a handle from the <code>aocl_mmd_open()</code> call aocl_mmd_get_info Obtain information about the board specified in the <code>requested_info_id</code> argument aocl_mmd_open Open and initialize the specified device aocl_mmd_close Close an opened device via its handle aocl_mmd_set_interrupt_handler Set the interrupt handler for the opened device aocl_mmd_set_status_handler Set the operation status handler for the opened device aocl_mmd_yield The aocl_mmd_yield function is called when the host interface is idle. The host interface might be idle because it is waiting for the device to process certain events aocl_mmd_read Read operation on a single interface aocl_mmd_write Write operation on a single interface aocl_mmd_copy Copy operation on a single interface aocl_mmd_program Reprogram operation for the specified device aocl_mmd_host_alloc Provide memory that is allocated on the host. Host allocations are accessible by the host and one or more devices aocl_mmd_free Free memory that has been allocated by MMD aocl_mmd_shared_alloc Allocate shared memory between the host and the FPGA aocl_mmd_shared_migrate Handle migration of non-concurrent shared allocations any time the accessor of the allocation changes <p>The implementation of these APIs is in <code>oneapi-asp/common/source/host/mmd.cpp</code>. The functions used in the implementation are distributed across various source files. Table 5-10 provides details on source code files.</p> <p>Table 5-10: MMD Source Code Files</p> Files/Folder Description mmd.cpp This file has the implementation for all MMD API calls listed in table 5-9 fpgaconf.hfpgaconf.c Contains bitstream reconfiguration function declaration(.h) &amp; definition(.c) kernel_interrupt.h Contains <code>KernelInterrupt</code> class declaration; the class consists of functions to handle kernel interrupts kernel_interrupt.cpp Contains <code>KernelInterrupt</code> class constructor and function definitions mmd_device.h Contains <code>Device</code> class declaration, which stores device data and has functions to interact with the device mmd_device.cpp Contains <code>Device</code> class constructor and function definitions mmd_dma.hmmd_dma.cpp Contain DMA functions declaration(.h) &amp; definition(.cpp) zlib_inflate.hzlib_inflate.c Function declaration(.h) and definition(.c) for decompressing bitstream data CMakeLists.txt CMakeLists.txt file for building MMD source code <p>The build flow scripts build the MMD library, i.e. <code>libintel_opae_mmd</code>, and place them in <code>oneapi-asp/Platform-Name/linux64/lib</code> folder. The MMD library is specified as part of <code>mmdlib</code>, <code>linklibs</code> element in <code>board_env.xml</code> and used at runtime (refer to figure 5-1 for sample <code>board_env.xml</code> file and section 2.2 for more information about <code>board_env.xml</code> elements).</p> <p>Use of OPAE library in MMD</p> <p>The MMD layer uses API from OPAE SDK for various device operations. Hence, the MMD layers requires OPAE library to be loaded to execute successfully. The <code>mmdlib</code> element specifies the <code>libopae-c</code> library to be loaded before the MMD library (demonstrated in sample <code>board_env.xml</code> in figure 5-1).</p> <p>Note: Please refer to Software Reference Manual: Open FPGA Stack for more information about OPAE SDK API. The document also has information about linux-dfl driver.</p> <p>Use of Memory Properties Factory(MPF) library in MMD</p> <p>In addition to OPAE, the MMD also uses API from Memory Properties Factory(MPF) software for memory operations. This The <code>libMPF</code> library is compiled as part of <code>oneapi-asp</code> build flow and placed in <code>oneapi-asp/Platform-Name/linux64/lib</code>. This library is also loaded before the MMD library by specifying before <code>libintel_opae_mmd</code> in <code>mmdlib</code> element.</p> <p>Note: Memory Properties Factory(MPF) is a part of Intel\u00ae FPGA BBB. Please refer to Intel\u00ae FPGA BBB wiki for more information about MPF.</p>"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#54-oneapi-asp-utilities-implementation","title":"5.4 <code>oneapi-asp</code> Utilities Implementation","text":"<p>This section covers the implementation of board utilities (refer to section 4.2 for more information on board utilities) in <code>oneapi-asp</code> for OFS reference platforms.</p> <p>Table 5-11 shows the source code/script locations for the utilities.</p> <p>Table 5-11: <code>oneapi-asp</code> Utilities Source Code Locations</p> Utility Source Location diagnose <code>oneapi-asp/common/source/util/diagnostic</code> program <code>oneapi-asp/common/source/util/reprogram</code> installuninstallinitialize&gt; Note: These are executable scripts <code>oneapi-asp/Platform-Name/linux64/libexec/</code> <p><code>diagnose</code> and <code>program</code> are compiled as part of the <code>oneapi-asp</code> build flow and executables are placed in <code>oneapi-asp/Platform-Name/linux64/libexec/</code>. A <code>CMakeLists.txt</code> file is provided for building the utilities, located in <code>oneapi-asp/common/source/util</code> directory.</p> <p>The path to all of the above utility executables is used in <code>utilbinder</code> element in <code>board_env.xml</code> (demonstrated in sample <code>board_env.xml</code> in figure 5-1). The runtime uses this when the corresponding <code>aocl</code> utility is invoked.</p> <p>Brief descriptions for the source code files are given in table 5-12.</p> <p>Table 5-12: Brief Descriptions of <code>oneapi-asp</code> Utility Routines for OFS Reference Platforms</p> File Description setup_permissions.sh Helper script to configure correct device port permissions, make changes to allow users to lock pages in memory and set the hugepages required for the software stack to function correctly. The helper script is used by <code>install</code>, <code>initialize</code> routines install install routine invokes the <code>setup_permissions.sh</code> script after the FPGA Client Driver (FCD) is setup by the runtime uninstall uninstall routine reverts the port permission, memory locking and hugepage setting changes performed by <code>install</code> routine and is invoked by runtime after the FCD is removed by runtime initialize initialize routine performs the following steps: * looks for the initialization bitstreams for the board variant to be initialized * invokes the <code>setup_permissions.sh</code> script to set correct device permissions * performs partial reconfiguration of the FPGA device by invoking <code>program</code> routine with the initialization bitstream as an argument program <code>program</code> routine allocates memory and loads the supplied initialization bitstream in memory followed by a call to reprogramming function provided by <code>oneapi-asp's</code> MMD library. The MMD library uses <code>fpgaReconfigureSlot</code> API provided by OPAE library to perform device reconfiguration&gt; Note: Please refer to Software Reference Manual: Open FPGA Stack for more information about OPAE SDK API diagnose <code>diagnose</code> routine scans for the available devices for the installed platform and performs DMA transactions between host &amp; device. It also reports the PCIe bandwidth. <code>diagnose</code> routine uses functions provided by the MMD library for scanning &amp; opening connection to available devices"},{"location":"hw/common/reference_manual/oneapi_asp/oneapi_asp_ref_mnl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/","title":"oneAPI Accelerator Support Package (ASP): Getting Started User Guide","text":""},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#10-introduction","title":"1.0 Introduction","text":""},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#11-about-this-document","title":"1.1 About This Document","text":"<p>This document serves as a quick start guide for setting up Intel\u00ae oneAPI Base Toolkit (Base Kit) on Open FPGA Stack (OFS) using <code>oneapi-asp</code> repository. Please see Table 1-1 for OFS reference platforms targeted in this guide.</p> <p>Table 1-1 HLD Tools</p> Target Device for the oneAPI ASP Target Platform for the oneAPI ASP Intel\u00ae Agilex\u00ae FPGA Intel\u00ae FPGA SmartNIC N6001-PL Intel\u00ae Stratix 10\u00ae FPGA Intel\u00ae FPGA PAC D5005 <p>Attention: Intel is discontinuing the Intel FPGA SDK for OpenCL software product. Refer to the Product Discontinuation Notice PDN2219. Alternatively, Intel recommends using the Intel\u00ae oneAPI Base Toolkit (Base Kit), which provides core tools and libraries for developing high-performance data-centric applications across diverse architectures. It features an industry-leading C++ compiler that implements SYCL*, an evolution of C++ for heterogeneous computing. For more information, refer to the Intel\u00ae oneAPI Base Toolkit (Base Kit) web page. To migrate your OpenCL FPGA designs to SYCL, review Migrating OpenCL FPGA Designs to SYCL* guide that demonstrates important differences between OpenCL and SYCL for FPGA and provides steps to migrate your OpenCL designs.</p> <p>After reviewing the document you will be able to:</p> <ul> <li>Setup your host machine to develop HLD AFUs </li> </ul> <ul> <li>Compile and run sample HLD applications on OFS</li> </ul>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#12-terminology","title":"1.2 Terminology","text":"<p>This table defines some of the common terms used when discussing OFS.</p> <p>Table 1-2: Terminology</p> Term Abbreviation Description Open FPGA Stack OFS A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. Accelerator Functional Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside.  This AFU may or may not be a partial reconfiguration region. FPGA Interface Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs.  The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. High Level Design HLD For the purpose of this guide, this term refers to designing with Intel\u00ae oneAPI Base Toolkit (Base Kit). oneAPI Accelerator Support Package oneAPI ASP OR oneapi-asp A collection of hardware and software components that enable oneAPI kernels to communicate with oneAPI runtime as well as with OFS components. The hardware components of the oneAPI ASP along with the kernels lie in the AFU region. Open Programmable Acceleration Engine Software Development Kit OPAE SDK A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. Platform Interface Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Device Feature List DFL A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. Best Known Configuration BKC The exact hardware configuration Intel has optimized and validated the solution against. SYCL - SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL\u2122) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Installable Client Driver ICD Intel\u00ae FPGA Runtime for OpenCL\u2122 Software Technology supports the OpenCL ICD extension from the Khronos Group\u2122. The OpenCL ICD extension allows you to have multiple OpenCL implementations on your system. With the OpenCL ICD Loader Library, you may choose from a list of installed platforms and execute OpenCL API calls that are specific to your OpenCL implementation of choice. FPGA Client Driver FCD Intel\u00ae FPGA Runtime for OpenCL\u2122 Software Technology supports FPGA Client Driver(FCD) extension. FCD allows the runtime to automatically find and load the oneAPI ASP libraries at host run time"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#13-introduction-to-high-level-design-on-ofs","title":"1.3 Introduction to High Level Design on OFS","text":"<p>Intel currently provides Intel\u00ae oneAPI Base Toolkit (Base Kit) for FPGA application development using high level languages like Data Parallel C++(DPC++).</p> <p>Figure 1-1 shows how OFS components can be used with Intel HLD tool.</p> <p>Figure 1-1 HLD Tool on OFS Platforms </p> <p>For high level description and setup details for OFS components shown in figure above, please refer to the Getting Started guide for your target device.</p> <ul> <li>OFS Getting Started User Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</li> </ul> <ul> <li>OFS Getting Started User Guide.</li> </ul> <p>For a more detailed diagram and more information about the FPGA Interface Manager(FIM) shown in figure above, please refer to the FIM developer guides for your target device.</p> <ul> <li>Open FPGA Stack Technical Reference Manual for Intel Agilex FPGA PCIe Attach.</li> </ul> <ul> <li>Open FPGA Stack Technical Reference Manual.</li> </ul> <ul> <li>Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</li> </ul> <ul> <li>Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae.</li> </ul> <p>The oneAPI ASP is required for compiling and running HLD application kernel on OFS platforms using Intel oneAPI. It is a collection of hardware and software components that enable oneAPI kernels to communicate with oneAPI runtime as well as with other OFS components. The hardware components of the oneAPI ASP along with the kernel lie in the AFU region shown in the figure above. For more details about the components of the oneAPI ASP, please refer to oneAPI Accelerator Support Package(ASP) Reference Manual: Open FPGA Stack.</p> <p>Figure 1-2 shows the setup steps to use oneAPI base toolkit on OFS platforms.</p> <p>Figure 1-2 Setup Steps for oneAPI base toolkit on OFS Platforms </p> <p>The next section covers the setup steps in detail.</p> <p>Note: Administrative privileges are needed for multiple setup steps, ensure you have administrative/sudo privileges before proceeding.</p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#20-setup-flow-for-using-hld-tool-on-ofs","title":"2.0 Setup Flow for Using HLD Tool on OFS","text":""},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#21-setup-server-for-ofs","title":"2.1 Setup Server for OFS","text":"<p>As a first step, the server or host machine being used for developing HLD application needs to be setup for OFS. This involves setting up the FPGA card as well as installing OFS software stack including OPAE SDK and OFS DFL kernel driver.</p> <p>Please follow steps in Getting started guides for your target devices to setup Linux DFL kernel driver and install OPAE SDK.</p> <ul> <li>OFS Getting Started User Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</li> <li>OFS Getting Started User Guide: OFS for Intel\u00ae Stratix 10\u00ae FPGA.</li> </ul>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#22-clone-and-compile-fim","title":"2.2 Clone and Compile FIM","text":"<p>As shown in Figure 1-1, OFS components in the FPGA include the FIM and Accelerator Functional Unit(AFU). The oneAPI ASP is in the Partial Reconfiguration(PR) region of the AFU and relies on the compiled database of the static region(FIM) to interface with the host and board peripherals(e.g. on-board memory).</p> <p>Once the server is setup with OPAE SDK and DFL kernel driver, the next step is to clone and compile the static region of the design, i.e. FIM. You can use the default configuration of the FIM for both target platforms or just for Intel\u00ae Agilex\u00ae FPGA you have the option to create a minimal FIM which removes additional VFs and host exercisers in the design. Please follow steps in the Intel\u00ae FPGA Interface Manager Developer Guides for your target device to compile FIM supporting PR release.</p> <ul> <li>Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</li> </ul> <ul> <li>Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae.</li> </ul> <p>For more details on minimal FIM for Intel\u00ae Agilex\u00ae FPGA and how to create it, refer to Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</p> <p>A <code>pr_build_template</code> directory will be generated in the work directory specified as part of the FIM compile command (using <code>OFS/ofs-common/scripts/common/syn/build_top.sh</code> script with the '-p' option enable to create an out-of-tree PR release). The <code>pr_build_template</code> directory is required for successful setup of the oneAPI ASP.</p> <p>Once the FIM compile is complete, please program FIM using <code>fpgasupdate</code> and Remote System Update(<code>rsu</code>) command. Use of these commands has been demonstrated in section named <code>Program the Intel\u00ae FPGA SmartNIC N6001-PL with the hello_fim</code> in Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#23-prerequisites","title":"2.3 Prerequisites","text":"<p>In addition to server setup and FIM compilation, a few linux packages are needed to setup the oneAPI ASP and develop HLD applications.</p> <p>1) Install the following packages:</p> <pre><code>    sudo dnf install numactl-devel ncurses-compat-libs\n</code></pre> <p>2) Ensure that IOMMU is turned on as explained in section <code>Building and Installing the OFS DFL Kernel Drivers from Source</code> in Getting started guides for your target devices:</p> <ul> <li>OFS Getting Started User Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</li> </ul> <ul> <li>OFS Getting Started User Guide: OFS for Intel\u00ae Stratix 10\u00ae FPGA.</li> </ul> <p>You can verify this setting using <code>cat /proc/cmdline</code> command. The output must have <code>intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200</code>.</p> <pre><code>$ cat /proc/cmdline\nBOOT_IMAGE=(hd1,gpt2)/vmlinuz-5.15.52-dfl root=/dev/mapper/rhel-root ro crashkernel=auto resume=/dev/mapper/rhel-swap rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200\n</code></pre> <p>3) Install HLD development software. Please see Table 2-1 below for download link. Install the latest version.</p> <p>Table 2-1 Intel HLD Tool and Download Information</p> HLD Tool Target Platform for the oneAPI ASP Tool Download Information Intel\u00ae oneAPI Base Toolkit (Base Kit) <ul><li>Intel\u00ae FPGA SmartNIC N6001-PL</li><li>Intel\u00ae FPGA PAC D5005</li> Download here <p>Tool installation guide for your reference:</p> <ul> <li>Intel\u00ae oneAPI Toolkits Installation Guide for Linux* OS</li> </ul> <p>4) Ensure you have all the Quartus patches installed, refer to Table 2-3 for required Quartus version. </p> <p>Note: For Intel\u00ae Agilex\u00ae FPGA ensure Quartus patch 0.10 and 0.02iofs are installed. You can find it in the following links 0.10 and 0.02iofs. For Intel\u00ae Stratix 10\u00ae FPGA ensure Quartus patch 0.01iofs is installed. You can find it in the following link 0.01iofs.For quartus patches installation to work properly, you must have Git Large File Storage (LFS) installed when cloning the ofs-fim repository. Use following command to check Quartus version and installed patches.</p> <pre><code>    quartus_sh -v\n</code></pre> <p>5) After completing the tool installation, set the following environment variables required to execute build scripts successfully:</p> <pre><code>    # Adding Quartus to PATH\nexport PATH=$PATH:path-to-quartus-installation-dir/bin\n    export QUARTUS_ROOTDIR=path-to-quartus-installation-dir/quartus\n    export QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR\n# Other OFS environment variables\nexport OFS_ROOTDIR=path-to-directory-containing-cloned-ofs-fim-repo/#ofs-n6001 for Intel\u00ae Agilex\u00ae FPGA or ofs-d5005 for Intel\u00ae Stratix 10\u00ae FPGA\n    export WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification # This should be \"$OFS_ROOTDIR/verification\" for Intel Stratix 10 OFS\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\n    export OPAE_SDK_REPO_BRANCH=release/branch-tag # Refer to Table 2-3, for OPAE SDK branch tag\nexport OFS_PLATFORM_AFU_BBB=path-to-cloned-ofs-platform-afu-bbb-repo\n    export OPAE_PLATFORM_ROOT=path-to-ofs-fim-pr_build_template-directory # (see section 2.2 for more details)\nexport LIBOPAE_C_ROOT=/usr # (OPAE libraries are installed in /usr/lib64 by default if you followed the OPAE SDK steps covered in section 2.1 as is and installed OPAE rpm packages. If you have a different OPAE installation path, please point LIBOPAE_C_ROOT to your OPAE installation location that you specified using -DCMAKE_INSTALL_PREFIX=installation-path in cmake command for building OPAE)\n</code></pre> <p>Note: To re-use this environment setting, you can copy the above export statements to a shell script, update the paths to match your tool installations and source this script each time a new shell is started.</p> <p>6) Source initialization script for oneAPI, path is shown in table below.</p> <p>Table 2-2 Initialization Script for HLD tool</p> Tool Command to source initialization script Intel\u00ae oneAPI Base Toolkit (Base Kit) source path-to-intel-oneapi-toolkit-installation-directory/setvars.sh <p>Once the environment variables are set, you can check the tool version using the following commands:</p> <pre><code># Printing all (Quartus, OpenCL SDK, GCC, Python) versions for user info\nquartus_sh -v\nicpx --version (for Intel\u00ae oneAPI Base Toolkit (Base Kit))\ngcc --version\npython3 -V\n</code></pre> <p>Table 2-3 and 2-4 summarize the tool version/Best Known Configurations(BKC).</p> <p>Table 2-3 Best Known Configuration(BKC) for Intel\u00ae Agilex\u00ae FPGA OFS</p> Component/Tool Version FPGA Platform Intel\u00ae FPGA SmartNIC N6001-PL Operating System RHEL 8.6 , Kernel : 6.1.22-dfl linux-dfl (DFL Kernel Driver) Tag: ofs-2023.1-1 opae-sdk Branch: release/2.5.0, Tag: 2.5.0-2 ofs-fim Tag: ofs-2023.1-1 oneapi-asp Tag: ofs-2023.1-1  &gt; Note: Cloning and build of this repo is discussed in the section 2.4 Quartus Prime Pro Edition Version 23.1.0 Pro Edition with patches 0.10 and 0.02iofs Intel\u00ae oneAPI Base Toolkit (Base Kit) Latest version GCC 8.5.0 20210514 (Red Hat 8.5.0-10) Python 3.6.8  &gt; Note: The Python version may differ in Intel oneAPI environment (Python 3.9.10 :: Intel Corporation) cmake 3.26.3 <p>Table 2-4 Best Known Configuration(BKC) for Intel\u00ae Stratix 10\u00ae FPGA</p> Component/Tool Version FPGA Platform Intel\u00ae FPGA PAC D5005 Operating System RHEL 8.2 , Kernel : 6.1.22-dfl linux-dfl (DFL Kernel Driver) Tag: ofs-2023.1-6.1-1 opae-sdk Branch: release/2.5.0, Tag: 2.5.0-2 ofs-fim Tag: ofs-2023.1-1 oneapi-asp Tag: ofs-2023.1-1  &gt; Note: Cloning and build of this repo is discussed in the section 2.4 Quartus Prime Pro Edition Version 23.1.0 Pro Edition  with patch 0.01iofs Intel\u00ae oneAPI Base Toolkit (Base Kit) Latest version GCC 8.5.0 20210514 (Red Hat 8.5.0-10) Python 3.6.8  &gt; Note: The Python version may differ in Intel oneAPI environment (Python 3.9.10 :: Intel Corporation) cmake 3.26.3"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#24-build-and-install-oneapi-asp","title":"2.4 Build and Install <code>oneapi-asp</code>","text":"<p>Once all pre-requisites are installed and the environment variables are set, next step is to clone and build <code>oneapi-asp</code>.</p> <p>1) Clone <code>oneapi-asp</code> repository and checkout tag matching the BKC for your target platform (see Tables 2-3 and 2-4 for the BKCs).</p> <p>Note: You will need a personal access token (use the classic mode) to be used as the password to clone successfully. Please see more information about token authentication requirements for Git operations here.</p> <pre><code>    git clone https://github.com/OFS/oneapi-asp.git\n    cd oneapi-asp\n    git checkout tags/ofs-2023.1-1\n</code></pre> <p>Ensure the correct tag has ben checked out: </p> <pre><code>    git describe --tags\n</code></pre> <ul> <li>Output:</li> </ul> <pre><code>    ofs-2023.1-1\n</code></pre> <p>2) Ensure that <code>OPAE_PLATFORM_ROOT</code> and <code>LIBOPAE_C_ROOT</code> have been set as described in section 2.3. Generate the oneAPI ASP hardware and software using provided <code>build-bsp.sh</code> script. This script clones required repositories and builds the oneAPI ASP libraries required by HLD host application to run successfully.</p> <pre><code>    cd path-to-directory-containing-cloned-oneapi-asp-repo/oneapi-asp/platform-name\n    ./scripts/build-bsp.sh\n</code></pre> <p>The generated directory structure is shown below. For more details refer to the oneAPI Accelerator Support Package(ASP) Reference Manual: Open FPGA Stack.</p> <pre>\noneapi-asp/platform-name\n|--ase/\n|  |--base/\n|  |--hack_ip_files/\n|  |--compile-kernel.sh\n|  |--run-ase.sh\n|  |--setup.sh\n|  |--simulate-aocx.sh\n|--bringup/source/\n|  |--hello_world\n|--hardware/\n|  |--ofs_platform-name/\n|  |--ofs_platform-name_usm/\n|--linux64/libexec/\n|  |--flash\n|  |--initialize\n|  |--install\n|  |--setup_permissions.sh\n|  |--uninstall\n|--scripts/\n|  |--README.txt\n|  |--build-bsp-sw.sh\n|  |--build-bsp.sh\n|  |--build-default-aocx.sh\n|  |--build-mmd.sh\n|  |--build-opae.sh\n|  |--create-tarball.sh\n|  |--dedup-hardware.sh\n|  |--setup-bsp.py\n|--board_env.xml\n|--README.md\n</pre> <p>3) Once the oneAPI ASP is generated, add the following to <code>LD_LIBRARY_PATH</code>. You can add it to your script for setting environment variables (if you created one as noted in step 5 in section 2.3)</p> <pre><code>    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:path-to-oneapi-asp/platform-name/linux64/lib\n</code></pre> <p>4) Check if FPGA Client Driver(FCD) exists for any other version of oneAPI ASP or for any other board. You can check with  <code>aocl list-devices</code> command. It is recommended to run aocl list-devices as root user (login with sudo su) to see all installed ASPs on the host.</p> <p>A sample output when a oneAPI ASP FCD is installed is shown below:</p> <pre><code>--------------------------------------------------------------------\nDevice Name:\nacl0\n\nBSP Install Location:\n/home/ofsuser/oneapi-asp/platform-name\n\nVendor: Intel Corp\n\nPhysical Dev Name   Status            Information\n\nofs_ee00000         Uninitialized     OpenCL BSP not loaded. Must load BSP using command:\n                                      'aocl program &lt;device_name&gt; &lt;aocx_file&gt;'\n                                      before running OpenCL programs using this device\n\nDIAGNOSTIC_PASSED\n--------------------------------------------------------------------\n</code></pre> <p>If a oneAPI ASP/BSP is installed, uninstall using <code>aocl uninstall path-to-oneapi-asp-install-location</code>, where <code>path-to-oneapi-asp-install-location</code> is provided under <code>BSP Install Location:</code> in the output of <code>aocl list-devices</code>. If you are prompted with a question to unset the FCD, type <code>Y</code>. If you are prompted with a question to remove OpenCL BSP configuration settings, type <code>Y</code>.</p> <p>Sample output for <code>aocl uninstall</code> command:</p> <pre><code>$ aocl uninstall /home/ofsuser/oneapi-asp/platform-name\naocl uninstall: Removing the FPGA Client Driver (FCD) from the system\n[sudo] password for ofsuser:\naocl uninstall: Removing the board package /home/ofsuser/oneapi-asp/platform-name from the list of installed packages. This process may require admin privilege\naocl uninstall: Running uninstall from /home/ofsuser/oneapi-asp/platform-name/linux64/libexec\nDo you want to remove OpenCL BSP configuration settings [Y/n] Y\nDeleting OPAE config files\nRemoving configuration files\nOFS OpenCL BSP uninstall complete\n</code></pre> <p>5) Install FPGA Client Driver(FCD) file for the oneAPI ASP using <code>aocl install path-to-oneapi-asp/platform-name</code> command as shown below. The host program uses FCD to find and link to the platform Memory Mapped Device (MMD) library. For more information about MMD library, refer to oneAPI Accelerator Support Package(ASP) Reference Manual: Open FPGA Stack.</p> <pre><code>    aocl install path-to-directory-containing-oneapi-asp/oneapi-asp/platform-name\n</code></pre> <p>Notes:  1. Type <code>Y</code> when prompted to setup FCD at <code>/opt/Intel/OpenCLFPGA/oneAPI/Boards</code> (default location for Intel oneAPI). </p> <p>Sample output <code>aocl install</code> command in  Intel\u00ae oneAPI Base Toolkit (Base Kit) environment is shown below.</p> <pre><code>aocl install: Setting up the FPGA Client Driver (FCD) to the system. This process may require admin privilege\nInstall the FCD file to /opt/Intel/OpenCLFPGA/oneAPI/Boards\n[sudo] password for ofsuser:\naocl install: Adding the board package path-to-oneapi-asp/platform-name to the list of installed packages\nInstalling the board package driver to the system.\naocl install: Running install from path-to-oneapi-asp/platform-name/linux64/libexec\nConfiguring locked memory setting\nConfiguring udev rules for DFL FPGA device permission\nConfiguring system with 1024 2M hugepages\nFinished setup_permissions.sh script. All configuration settings are persistent.\nIntel OFS OpenCL BSP install complete.\nRun 'aocl diagnose' to list devices or 'aocl initialize &lt;dev_name&gt; to load default aocx\n</code></pre>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#25-board-initialization","title":"2.5 Board Initialization","text":"<p>OFS software stack expects boards to be initialized with a bitstream for the board variant intended to be used for development. OpenCL sample applications have been provided for generating initialization bitstreams for included board variants for both target devices.</p> <p><code>oneapi-asp</code> has two board variants (<code>oneapi-asp/platform-name/hardware</code> has the hardware design files for these).One OpenCL sample application has been provided in the <code>oneapi-asp</code> repository named <code>hello_world</code>, for both board variants. For more details on the architecture of the board variants, please refer to the oneAPI Accelerator Support Package(ASP) Reference Manual: Open FPGA Stack.</p> <p>Table 2-5 OpenCL Sample Applications</p> Board Variants Sample Application <ul><li>ofs_platform-name</li></ul> <ul><li>ofs_platform-name_usm</li></ul> hello_world <p>Note: platform-name is n6001 for Intel\u00ae Agilex\u00ae FPGA OFS and d5005 for Intel\u00ae Stratix 10\u00ae FPGA OFS</p> <p>All samples are located in <code>oneapi-asp/platform-name/bringup/source</code>.</p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#251-compile-initialization-bitstreams","title":"2.5.1 Compile Initialization Bitstreams","text":"<p>A script is provided in repo to compile OpenCL sample application. The script is <code>oneapi-asp/platform-name/scripts/build-default-aocx.sh</code>.</p> <p>Script usage is as follows:</p> <pre><code>    ./build-default-aocx.sh -b name-of-board-variant\n</code></pre> <p>Note: <code>name-of-board-variant</code> can be ofs_<code>platform-name</code> or ofs_<code>platform-name</code>_usm, where <code>platform-name</code> is <code>n6001</code> for Intel\u00ae Agilex\u00ae FPGA OFS and <code>d5005</code> for Intel\u00ae Stratix 10\u00ae FPGA OFS. Refer to Table 2-5 for board variants available for each target platform. Compilation will take a few hours to complete.</p> <p>The output directory of the sample application is written to <code>oneapi-asp/platform-name/build/bringup</code>. The generated bitstreams are also copied to <code>oneapi-asp/platform-name/bringup/aocxs/</code>. These are used in the initialization of the platform.</p> <p>Once the bitstreams are generated, create a VF and initialize the board as explained in following section. Ensure that the FIM has been programmed on the board as explained in section 2.2 Clone and Compile FIM</p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#252-create-vf","title":"2.5.2 Create VF","text":"<p>The oneAPI ASP is located in the PR region of the FIM and is accessed through PF/VF Mux. Refer to the FIM Reference Manual for your target platforms for more details about PF/VF mapping.</p> <ul> <li>Reference FIM for Intel\u00ae Agilex\u00ae FPGA OFS: VF0 is mapped to PR region and you can create 1 VF when using this FIM. See Open FPGA Stack Technical Reference Manual for Intel Agilex FPGA PCIe Attach for diagram showing VF mapping.</li> </ul> <ul> <li>Reference FIM for Intel\u00ae Stratix 10\u00ae FPGA OFS: VF1 is mapped to PR region and you must create 2 VFs when using this FIM. See Open FPGA Stack Technical Reference Manual for diagram showing VF mapping.</li> </ul> <ul> <li>Create a VF using PCIe ID obtained from the output of <code>fpgainfo fme</code> (PCIe s\\:b\\:d.f output)</li> </ul> <pre><code>    sudo pci_device s:b:d.f vf num_vf  #num_vf is 1 for Intel\u00ae Agilex\u00ae FPGA and 2 for Intel\u00ae Stratix 10\u00ae FPGA\n</code></pre> <ul> <li>Check that the VF is created using <code>sudo opae.io ls</code> command and note the PCIe ID for the VF(s) (the function number in s\\:b\\:d.f will be different for the VF). Sample output for Intel\u00ae Agilex\u00ae FPGA is shown below.</li> </ul> <pre><code>    $ sudo opae.io ls\n    [0000:b1:00.0] (0x8086, 0xbcce) Intel Acceleration Development Platform N6001 (Driver: dfl-pci)\n    [0000:b1:00.1] (0x8086, 0xbccf) Intel Acceleration Development Platform N6001 (Driver: None)\n</code></pre> <p> Sample output for Intel\u00ae Stratix 10\u00ae FPGA is shown below.</p> <pre><code>    $ sudo opae.io ls\n    [0000:d8:00.0] (0x8086, 0xbcce)  Intel FPGA Programmable Acceleration Card D5005 (Driver: dfl-pci)\n    [0000:d8:00.1] (0x8086, 0xbccf)  Intel FPGA Programmable Acceleration Card D5005 (Driver: dfl-pci)\n    [0000:d8:00.2] (0x8086, 0xbccf)  Intel FPGA Programmable Acceleration Card D5005 (Driver: dfl-pci)\n</code></pre> <p>Note:<code>sudo opae.io ls</code> will list the accelerators, respective PCIe ID as well as the driver it is currently bound to.</p> <ul> <li>Bind the created VF(s) to vfio-pci driver, use the PCIe ID for the VF(s) for this step. For example:</li> <li>From sample output for Agilex OFS target platform shown above, <code>s:b:d.vf</code> will be <code>0000:b1:00.1</code> in command below </li> </ul> <pre><code>    sudo opae.io init -d s:b:d.vf $USER\n</code></pre> <ul> <li>Sample output for Intel\u00ae Agilex\u00ae FPGA OFS target platform:</li> </ul> <pre><code>    $ sudo opae.io init -d 0000:b1:00.1 $USER\n    Binding (0x8086,0xbccf) at 0000:b1:00.1 to vfio-pci\n    iommu group for (0x8086,0xbccf) at 0000:b1:00.1 is 319\n    Assigning /dev/vfio/319 to ofsuser\n    Changing permissions for /dev/vfio/319 to rw-rw----\n\n    $ sudo opae.io ls\n    [0000:b1:00.0] (0x8086, 0xbcce) Intel Acceleration Development Platform N6001 (Driver: dfl-pci)\n    [0000:b1:00.1] (0x8086, 0xbccf) Intel Acceleration Development Platform N6001 (Driver: vfio-pci)\n\n    $ ls -lt /dev/vfio\n    total 0\n    crw-rw----. 1 ofsuser root 509,   0 Jul 20 20:41 319\n    crw-rw-rw-. 1 root    root  10, 196 Jul 20 20:41 vfio\n</code></pre> <ul> <li>Sample output for Intel\u00ae Stratix 10\u00ae FPGA OFS target platform:</li> </ul> <pre><code>$sudo opae.io init -d 0000:12:00.1 $USER\nBinding (0x8086,0xbccf) at 0000:12:00.1 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:12:00.1 is 149\nAssigning /dev/vfio/149 to ofsuser\nChanging permissions for /dev/vfio/149 to rw-rw----\n\n$sudo opae.io init -d 0000:12:00.2 $USER\nBinding (0x8086,0xbccf) at 0000:12:00.2 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:12:00.2 is 152\nAssigning /dev/vfio/152 to ofsuser\nChanging permissions for /dev/vfio/152 to rw-rw----\n\n$ sudo opae.io ls\n[0000:12:00.0] (0x8086:0xbcce) Intel FPGA Programmable Acceleration Card D5005 (Driver: dfl-pci)\n[0000:12:00.1] (0x8086:0xbccf) Intel FPGA Programmable Acceleration Card D5005 (Driver: vfio-pci)\n[0000:12:00.2] (0x8086:0xbccf) Intel FPGA Programmable Acceleration Card D5005 (Driver: vfio-pci)\n\n$ls -lt /dev/vfio\ntotal 0\ncrw-rw----. 1 ofsuser  root  235,   3 May 10 16:25 149\ncrw-rw----. 1 ofsuser  root  235,   0 May 10 16:22 152\ncrw-rw-rw-. 1 root     root   10, 196 May  3 07:28 vfio\n</code></pre> <p>If the driver fails to bind due to an error related to <code>iommu_group</code> (e.g. `No such file or directory: '/sys/bus/pci/devices/0000:b1:00.5/iommu_group'), ensure IOMMU is turned on as explained in step 2 in Section 2.3 Prerequisites.</p> <p>Note: For more information about <code>pci_device</code> and <code>opae.io</code> utilities, refer to the OPAE FPGA tools page here.</p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#253-initialize-board-and-run-diagnostic-test","title":"2.5.3 Initialize Board and Run Diagnostic Test","text":"<ul> <li>Before initializing the board, change permissions on <code>/dev/uio*</code> to allow all users to program the board by using the following command: </li> </ul> <pre><code>    sudo chmod 777 /dev/uio*\n</code></pre> <p> - Initialize the board with default bitstream using <code>aocl initialize</code> command</p> <pre><code>    aocl initialize device-name name-of-board-variant\n</code></pre> <p>Note: <code>device-name</code> in <code>aocl initialize</code> command is from the <code>BSP Diagnostics</code> section in the output of <code>aocl list-devices</code> (sample output is shown in Section 2.4). <code>device-name</code> is <code>acl0</code> if there is only 1 board connected to the server. <code>name-of-the-board-variant</code> can be one of the supported board variants listed in Table 2-5 provided the sample application bitstream of hello-world has been generated.</p> <p>Sample output for <code>aocl initialize acl0 ofs_n6001</code> is shown below. Output for Intel\u00ae Stratix 10\u00ae FPGA and USM board variant should be similar.</p> <pre><code>$ aocl initialize acl0 ofs_n6001\naocl initialize: Running initialize from path-to-oneapi-asp/n6001/linux64/libexec\nConfiguring locked memory setting\n[sudo] password for $USER:\nConfiguring udev rules for DFL FPGA device permission\nConfiguring system with 1024 2M hugepages\nFinished setup_permissions.sh script. All configuration settings are persistent.\nProgram succeed.\n</code></pre> <p>This initializes the board with <code>hello_world</code> sample application. To initialize the board for using USM board variant use <code>aocl initialize acl0 ofs_platform-name_usm</code>, where <code>platform-name</code> is <code>n6001</code> for Intel\u00ae Agilex\u00ae FPGA OFS and <code>d5005</code> for Intel\u00ae Stratix 10\u00ae FPGA OFS. For both board variants the board will be initialized using the same hello_world sample application.</p> <p>Notes:  1. <code>aocl initialize</code> command needs to be executed only one time unless you reboot the server. If the server is rebooted, change the permissions on /dev/uio* and initialize the board again as noted above.</p> <p>Run aocl diagnose to check that the board <code>Status</code> under <code>BSP Diagnostics</code> is equal to <code>Passed</code>.</p> <p>platform-name in command output below is n6001 for Intel\u00ae Agilex\u00ae FPGA OFS and d5005 for Intel\u00ae Stratix 10\u00ae FPGA OFS.</p> <pre><code>$ aocl diagnose\n--------------------------------------------------------------------\nICD System Diagnostics\n--------------------------------------------------------------------\n\nUsing the following location for ICD installation:\n        /etc/OpenCL/vendors\n\nFound 3 icd entry at that location:\n        /etc/OpenCL/vendors/intel64.icd\n        /etc/OpenCL/vendors/Altera.icd\n        /etc/OpenCL/vendors/Intel_FPGA_SSG_Emulator.icd\n\nThe following OpenCL libraries are referenced in the icd files:\n        /opt/intel/oneapi/compiler/latest/linux/lib/x64/libintelocl.so\n\nChecking LD_LIBRARY_PATH for registered libraries:\n        /opt/intel/oneapi/compiler/latest/linux/lib/x64/libintelocl.so was registered on the system.\n        /opt/intel/oneapi/compiler/latest/linux/lib/oclfpga/host/linux64/lib/libalteracl.so\n\nChecking LD_LIBRARY_PATH for registered libraries:\n        /opt/intel/oneapi/compiler/latest/linux/lib/oclfpga/host/linux64/lib/libalteracl.so was registered on the system.\n        /opt/intel/oneapi/compiler/latest/linux/lib/x64/libintelocl_emu.so\n\nChecking LD_LIBRARY_PATH for registered libraries:\n        /opt/intel/oneapi/compiler/latest/linux/lib/x64/libintelocl_emu.so was registered on the system.\n\nUsing OCL_ICD_FILENAMES to search for ICD clients, it is set to libintelocl_emu.so:libalteracl.so:/opt/intel/oneapi/compiler/2023.1.0/linux/lib/x64/libintelocl.so\n\nChecking LD_LIBRARY_PATH for registered libraries specified by OCL_ICD_FILENAMES\n        libintelocl_emu.so was registered on the system at /opt/intel/oneapi/compiler/2023.1.0/linux/lib/x64\n        libalteracl.so was registered on the system at /opt/intel/oneapi/compiler/2023.1.0/linux/lib/oclfpga/linux64/lib\n        /opt/intel/oneapi/compiler/2023.1.0/linux/lib/x64/libintelocl.so was registered on the system.\n\nUsing the following location for fcd installations:\n        /opt/Intel/OpenCLFPGA/oneAPI/Boards\n\nFound 1 fcd entry at that location:\n        /opt/Intel/OpenCLFPGA/oneAPI/Boards/ofs_platform-name_shim.fcd\n\nThe following OpenCL libraries are referenced in the fcd files:\n        libopae-c.so\n/home/ofsuser/oneapi-asp/platform-name/linux64/lib/libMPF.so\n/home/ofsuser/oneapi-asp/platform-name/linux64/lib/libintel_opae_mmd.so\n\nChecking LD_LIBRARY_PATH for registered libraries:\n        libopae-c.so was registered on the system at /usr/lib64\n        /home/ofsuser/oneapi-asp/platform-name/linux64/lib/libMPF.so was registered on the system.\n        /home/ofsuser/oneapi-asp/platform-name/linux64/lib/libintel_opae_mmd.so was registered on the system.\n\nNumber of Platforms = 4\n        1. Intel(R) FPGA Emulation Platform for OpenCL(TM)    | Intel(R) Corporation           | OpenCL 1.2 Intel(R) FPGA SDK for OpenCL(TM), Version 20.3\n        2. Intel(R) FPGA SDK for OpenCL(TM)                   | Intel(R) Corporation           | OpenCL 1.0 Intel(R) FPGA SDK for OpenCL(TM), Version 2023.1\n        3. Intel(R) OpenCL                                    | Intel(R) Corporation           | OpenCL 3.0 LINUX\n        4. Intel(R) FPGA SDK for OpenCL(TM)                   | Intel(R) Corporation           | OpenCL 1.0 Intel(R) FPGA SDK for OpenCL(TM), Version 2023.1\n--------------------------------------------------------------------\nICD diagnostics PASSED\n--------------------------------------------------------------------\n--------------------------------------------------------------------\nBSP Diagnostics\n--------------------------------------------------------------------\n--------------------------------------------------------------------\nDevice Name:\nacl0\n\nBSP Install Location:\n/home/ofsuser/oneapi-asp/platform-name\n\nVendor: Intel Corp\n\nPhysical Dev Name   Status            Information\n\nofs_ee00001         Passed            Intel OFS Platform (ofs_ee00001)\n                                    PCIe b1:00.0\n                                    FPGA temperature = 52 degrees C.\n\nDIAGNOSTIC_PASSED\n--------------------------------------------------------------------\n\nCall \"aocl diagnose &lt;device-names&gt;\" to run diagnose for specified devices\nCall \"aocl diagnose all\" to run diagnose for all devices\n</code></pre> <p>Run complete diagnostic using <code>aocl diagnose device-name</code> command. <code>device-name</code> is <code>acl0</code> if you have only 1 board in the server. The test reads and write data to the board to check the interfaces function correctly and report the measured bandwidth. The test must show <code>DIAGNOSTIC_PASSED</code> message at the end.</p> <pre><code>    aocl diagnose acl0\n</code></pre> <p>Next section you will build and run oneAPI host applications.</p> <p>Once you are done with your application testing, you can release the device from vfio-pci driver, the steps for this are provided in Section 2.7 Release VF.</p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#26-compile-and-run-oneapi-sample-applications","title":"2.6 Compile and Run oneAPI Sample Applications","text":"<p>DPC++ samples are provided in the oneAPI-samples repository. One of the samples that tests the board interfaces is board_test . Following section explains how to compile and run this sample with both target platforms.</p> <p>First clone the repository and then checkout to the tag according to the oneAPI version you are using. </p> <pre><code>    git clone https://github.com/oneapi-src/oneAPI-samples.git\n    cd oneAPI-samples\n    git checkout tags/oneAPI-compiler-version\n</code></pre> <p>Note:  Check your oneAPI compiler version with the command:</p> <pre>\n    icpx --version\n</pre> <p>Table 2-6 DPC++ Sample Application</p> Board Variants Sample Application Description ofs_platform-name board_test This sample measures kernel clock frequency, kernel launch latency and tests the different interfaces required by the oneAPI kernel to function correctly (e.g. host to kernel interface, kernel to EMIF as well as host to EMIF), . <p>Ensure you have sourced <code>setvars.sh</code> script located in the root of your oneAPI installation as explained in Table 2-2 Initialization Script for HLD tool.</p> <p>Follow steps below to compile and run oneAPI <code>board_test</code> binary. Use <code>-DFPGA_DEVICE</code> in <code>cmake</code> command to provide path to the oneAPI ASP and name of board variant being compiled. The location for <code>board_test</code> sample is the following:</p> <ul> <li>path-to-oneAPI-samples/oneAPI-samples/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/board_test</li> </ul> <pre><code>    cd path-to-oneAPI-samples/oneAPI-samples/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/board_test\n    mkdir build\n    cd build\n\n    cmake -DFPGA_DEVICE=full-path-to-oneapi-asp/platform-name:board_variant ..\n</code></pre> <p>Compile the design using the generated <code>Makefile</code>. The following build targets are provided:</p> <ul> <li>Compile for emulation (compiles quickly, targets emulated FPGA device):</li> </ul> <pre><code>    make fpga_emu\n</code></pre> <p> Emulation compile generates <code>board_test.fpga_emu</code> target, to run:</p> <pre><code>    ./board_test.fpga_emu\n</code></pre> <ul> <li>Generate the optimization report:</li> </ul> <pre><code>    make report\n</code></pre> <ul> <li>Compile for FPGA hardware (takes longer to compile, targets FPGA device):</li> </ul> <pre><code>    make fpga\n</code></pre> <p> Hardware compilation takes several hours to complete. Once complete, you should see <code>board_test.fpga</code> executable generated. Run the generated hardware executable as follows:</p> <pre><code>   ./board_test.fpga\n</code></pre> <p>Note: If your FPGA compile fails to meet timing requirements, the Intel oneAPI compiler prints an error message, returns an error code and deletes the generated binary. In case of timing failure, <code>*.failing_clocks.rpt</code> and <code>*.failing_paths.rpt</code> files are generated in compiled output directory <code>board_test.fpga.prj</code>. You can recompile with a different seed using <code>-Xsseed</code> option. You can pass this option using <code>USER_HARDWARE_FLAGS=-Xsseed=seed_value</code> in the <code>cmake</code> command above and recompile hardware image.</p> <p>To view test details and usage information using the binary, use the -help option.</p> <pre><code>    ./board_test.fpga -help\n</code></pre>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#27-release-vf","title":"2.7 Release VF","text":"<p>Once you are done with your application testing, you can release the device from vfio-pci driver using following command.</p> <pre><code>    $ sudo opae.io release -d s:b:d.vf\n</code></pre> <p> Sample output for Intel\u00ae Agilex\u00ae FPGA OFS target platform is shown below.The output for Intel\u00ae Stratix 10\u00ae FPGA target platform should be similar, just need to release an extra VF as for this target 2 Vfs were created. </p> <pre><code>$ sudo opae.io release -d 0000:b1:00.1\nReleasing (0x8086,0xbccf) at 0000:b1:00.1 from vfio-pci\nRebinding (0x8086,0xbccf) at 0000:b1:00.1 to dfl-pci\n\n$ sudo opae.io ls\n[0000:b1:00.0] (0x8086, 0xbcce) Intel Acceleration Development Platform N6001 (Driver: dfl-pci)\n[0000:b1:00.1] (0x8086, 0xbccf) Intel Acceleration Development Platform N6001 (Driver: dfl-pci)\n</code></pre>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#30-further-development","title":"3.0 Further Development","text":"<p>Once you have completed running the oneAPI sample application, you can start developing your own applications.</p> <p>For more information about developing FPGA applications with Intel oneAPI, refer to Intel\u00ae oneAPI Programming Guide and FPGA Optimization Guide for Intel\u00ae oneAPI Toolkits.</p> <p>If you want to customize the oneAPI ASP, you can refer to oneAPI Accelerator Support Package(ASP) Reference Manual: Open FPGA Stack.</p>"},{"location":"hw/common/user_guides/oneapi_asp/ug_oneapi_asp/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/","title":"Docker User Guide: Intel\u00ae Open FPGA Stack","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#1-introduction","title":"1 Introduction","text":"<p>This document is intended to help you get started in evaluating  Open FPGA Stack (Intel\u00ae OFS) using Docker for the Intel\u00ae Platforms. The Intel FPGA platforms  can be used as a starting point for evaluation and development. This document covers critical topics related to the initial setup of the Docker solution included with the OFS release.</p> <p>After reviewing the document, you shall be able to:</p> <ul> <li>Set up the Intel\u00ae Quartus\u2122 Prime Pro Edition Software in a host server</li> </ul> <ul> <li>Set up the Docker engine</li> </ul> <ul> <li>Build and load your Docker image to the Docker engine</li> </ul> <ul> <li>Run a Docker container with OFS preloaded</li> </ul> <p>The  Open FPGA Stack (OFS) Docker image has two main personas:</p> <ul> <li>Development: You can develop, simulate, and build any component of the OFS. The Docker image enables you to use your laptop or server without having drivers, FPGA  Platform, or specific Linux* distribution installed in your host computer. You can follow the development flow provided to run Docker on Linux.  </li> </ul> <ul> <li>Deployment: You can program, load binaries, or execute real-time testing using the OPAE and OFS. To do so, the host computer must have the specified software distribution and drivers installed. </li> </ul>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#12-background-information","title":"1.2 Background Information","text":"<p>A container is a fully functional and portable cloud or non-cloud computing environment that includes an application, associated libraries, and other dependencies. Docker containers do not require a hardware hypervisor, instead using the application layer of the host computer, which means they tend to be smaller, faster to setup, and require fewer resources when compared to a virtual machine (VM).</p> <p>The OFS provides the flexibility to support various orchestration or management systems, including bare metal, VM, and Docker.</p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#13-relevant-information","title":"1.3 Relevant information","text":"<ul> <li>What is a container?</li> <li>Docker vs. Virtual Machines </li> <li>Does the Docker container have its own Kernel?<ul> <li>No, Docker image or Container uses the application layer of the host computer; this functionality is the main reason for docker having lightweight and fast applications.</li> </ul> </li> <li>Does Docker run on Linux, macOS, and Windows?</li> <li>Intel Docker Image can use the PCIe card from the host server?<ul> <li>Yes, The drivers and additional information could be shared, but this could create potential security concerns (ensure your system is secure).</li> </ul> </li> <li>Docker security</li> <li>Docker subscription</li> </ul>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#20-prerequisites-and-scope","title":"2.0 Prerequisites and Scope","text":"<p>The OFS release targeting the compatible OFS Platform's is built upon tightly coupled software and firmware versions. Use this section as a general reference for the versions in this release.</p> <p>The following table highlights the hardware that comprises the Best-Known Configuration (BKC) for the OFS release. For a detailed explanation and safety information regarding the setup go to OFS Site select your desired platform and select Getting stated guide. This site walks you through the BIOS configuration changes needed to enable the OFS Platform's.</p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#30-development-installation","title":"3.0 Development Installation","text":"<p>Docker engines have cross-compatibility with multiple systems, but the host server does not require any specific distribution. However, the Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1 requires a specific version. For this guide, Red Hat Linux  is used for general instructions. </p> <p>The OFS Docker image includes all the libraries and tools required by the OFS and OPAE SDK (Python, Perl, CMake, and so on).</p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#31-intel-quartus-prime-software-installation","title":"3.1 Intel Quartus Prime Software Installation","text":"<p>Building AFUs with OFS for Intel Agilex FPGA requires the build machine to have at least 64 GB of RAM.</p> <p>Go to OFS Site select your desired platform and select Getting stated guide for a list of detailed steps for the Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1 installation.  </p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#32-docker-engine-installation","title":"3.2 Docker Engine installation","text":""},{"location":"hw/common/user_guides/ug_docker/ug_docker/#rhel-86","title":"RHEL 8.6","text":"<p>The Docker installation steps for RHEL 8.6 are the following:</p> <ol> <li> <p>Remove old versions; older versions of Docker were called <code>docker</code> or <code>docker-engine</code>. If these are installed, uninstall them, along with associated dependencies. Also, uninstall <code>Podman</code> and the related dependencies if installed already.</p> <pre><code> sudo dnf remove docker \\\ndocker-client \\\ndocker-client-latest \\\ndocker-common \\\ndocker-latest \\\ndocker-latest-logrotate \\\ndocker-logrotate \\\ndocker-engine \\\npodman \\\nrunc\n</code></pre> </li> <li> <p>Add the Docker repository to your system:</p> <pre><code>sudo dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo\n</code></pre> </li> <li> <p>Install the latest version of Docker Engine, containerd, and Docker Compose, or go to the next step to install a specific version.</p> <pre><code>sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\n</code></pre> </li> <li> <p>Start the Docker daemon:</p> <pre><code>sudo systemctl start docker\n</code></pre> </li> <li> <p>Enable the Docker daemon to start on boot:</p> <pre><code>sudo systemctl enable --now docker\nsudo systemctl enable --now containerd\n</code></pre> </li> <li> <p>Verify that Docker is installed and running:</p> <pre><code>sudo systemctl status docker\n</code></pre> <p>You should see a message indicating that the Docker daemon is active and running.</p> <p>Note: If you want to use Docker as a non-root user, you should add your user to the <code>docker</code> group:</p> <pre><code>sudo usermod -aG docker your-user\n</code></pre> <p>You will need to log out and back in for the changes to take effect.</p> </li> <li> <p>Ensure your proxies are setup in case you needed</p> <pre><code>sudo mkdir -p /etc/systemd/system/docker.service.d nano /etc/systemd/system/docker.service.d/http-proxy.conf\n\n[Service] Environment=\"HTTP_PROXY=http://proxy.example.com:80/\"\nEnvironment=\"HTTPS_PROXY=https://proxy.example.com:443/\"\n#save and close \nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre> </li> </ol>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#ubuntu-2204","title":"Ubuntu 22.04","text":"<p>The Docker installation steps for Ubuntu are the following:</p> <ol> <li> <p>Remove old versions; older versions of Docker were called <code>docker</code> or <code>docker-engine</code>. If these are installed, uninstall them, along with associated dependencies. </p> <pre><code>sudo apt-get remove docker docker-engine docker.io containerd runc\n</code></pre> </li> <li> <p>Install packages to allow apt to use a repository</p> <pre><code>sudo apt-get update\nsudo apt-get install \\\nca-certificates \\\ncurl \\\ngnupg \\\nlsb-release\n</code></pre> </li> <li> <p>Add Docker's official GPG key:</p> <pre><code>sudo mkdir -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n</code></pre> </li> <li> <p>The following command to set up the repository:</p> <pre><code>echo \\\n\"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n$(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> </li> <li> <p>Update the package manager index again:</p> <pre><code>sudo apt-get update\n</code></pre> </li> <li> <p>Install Docker:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n</code></pre> </li> <li> <p>Start the Docker daemon:</p> <pre><code>sudo systemctl start docker\n</code></pre> </li> <li> <p>Enable the Docker daemon to start on boot:</p> <pre><code>sudo systemctl enable --now docker\nsudo systemctl enable --now containerd\n</code></pre> </li> <li> <p>Verify that Docker is installed and running:</p> <pre><code>sudo systemctl status docker\n</code></pre> <p>You should see a message indicating that the Docker daemon is active and running.</p> <p>Note: If you want to use Docker as a non-root user, you should add your user to the <code>docker</code> group:</p> <pre><code>sudo usermod -aG docker your-user\n</code></pre> <p>You will need to log out and back in for the changes to take effect.</p> </li> <li> <p>Ensure your proxies are setup in case you needed</p> <pre><code>sudo mkdir -p /etc/systemd/system/docker.service.d nano /etc/systemd/system/docker.service.d/http-proxy.conf\n\n[Service] Environment=\"HTTP_PROXY=http://proxy.example.com:80/\"\nEnvironment=\"HTTPS_PROXY=https://proxy.example.com:443/\"\n#save and close \nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre> </li> </ol>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#33-load-docker-image-installation","title":"3.3 Load Docker Image installation","text":"<p>The Dockerfile is released in conjunction with the OFS stack release, and The file needs to be loaded into your host computer to start a docker container.</p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#build-the-image","title":"Build the image","text":"<ol> <li> <p>You can download the Dockefile from OFS GitHub Docker.</p> </li> <li> <p>Inside the Dockerfile folder, you will find the DockerFile edit and modify the following lines:</p> <pre><code>ENV no_proxy=   #you could use  github.com here\nENV http_proxy= #setup proxy\nENV https_proxy=  #setup proxy\nENV GITUSER= #setup github user\nENV GITTOKEN= #setup github token\nENV REDUSER= #redhat user \nENV REDPASS= #redhat password\nENV DW_LICENSE_FILE= #DW license\nENV SNPSLMD_LICENSE_FILE= #Synopsys license\nENV LM_LICENSE_FILE= #Quartus License\n</code></pre> <p>Save the file </p> </li> <li> <p>Create and load the image:</p> <pre><code>cd Docker_file\ndocker build -t ofs:latest . --no-cache\n</code></pre> <p>Note: Never remove --no-cache this could cause issues with your environmental variables inside of the container</p> </li> <li> <p>Use the following command to ensure the image is loaded correctly:</p> <pre><code>sudo docker images\nREPOSITORY    TAG                       IMAGE ID       CREATED          SIZE\nofs           latest                    fc80175d13a0   \u221e seconds ago   2.55GB\n</code></pre> </li> </ol>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#volumen-creation","title":"Volumen creation","text":"<ol> <li> <p>Docker requires a volume to move data from the host computer (Persistent data) to the docker container and vice versa. To create a docker volume, use the following command:</p> <pre><code>docker volume create --name DataOFS\n</code></pre> <p>For more information about Docker volume go here.</p> <p>Tip: Remember, The docker container has a limited lifecycle; the files and data are lost when the docker is Stopped-&gt; Deleted.</p> </li> <li> <p>Check where the docker volume is mapped in your host server:</p> <pre><code>docker volume inspect DataOFS\n[\n{\n\"CreatedAt\": \"xxxxxxxxxx\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/DataOFS/_data\",\n        \"Name\": \"DataOFS\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n}\n]\n</code></pre> </li> <li> <p>Inside of your docker container, you can use cp command to copy from your docker to your host:</p> <pre><code>cp /atmydocker/myfile.txt /dataofs\n</code></pre> <p>The docker container path is /dataofs the host path is /var/lib/docker/volumes/DataOFS/_data.</p> </li> </ol>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#34-create-a-container","title":"3.4 Create a container","text":"<p>Now you are ready to start the container, and you should be prepared to run it: 1. First, Let's create the template for the run  command, copy your Quartus installation path and paste it under -v (Don't Run the command yet):</p> <pre><code>docker run --rm -itd --name myOFS -v=&lt;yourintallationfolder&gt;:/home/intelFPGA_pro/:ro -v=DataOFS:/dataofs ofs:latest /bin/bash\n</code></pre> <p>Tip: you can change myOFS with any other value. The value is the given name of the container.</p> <ol> <li>Using the previous example now, you can execute the docker run command.    <pre><code>docker run --rm -itd --name myOFS -v=/home/intelFPGA_pro/23.1:/home/intelFPGA_pro/:ro -v=DataOFS:/dataofs ofs:latest /bin/bash\nbdc1289fb0813bb325b55dd11df4eeec252143d6745a6e5772638fbc107d0949\n</code></pre></li> <li> <p>Now the docker container should be available.</p> <pre><code># sudo docker ps\nCONTAINER ID   IMAGE                         COMMAND       CREATED          STATUS   PORTS     NAMES\nbdc1289fb081   ofs:latest                    \"/bin/bash\"   46 seconds ago   Up 45 seconds      myOFS\n</code></pre> </li> </ol> <p>Your Container ID is bdc1289fb081. </p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#35-evaluate-ofs-container","title":"3.5 Evaluate OFS container","text":"<p>The OFS container has two possible ways to interact with the container:</p> <ul> <li> <p>Interactive mode: </p> <p>This mode it takes you straight inside the container and uses the command terminal as a regular Linux console. </p> <ol> <li> <p>Enable the interactive mode:</p> <pre><code>docker attach myOFS\n[root@bdc1289fb081 /]#\n</code></pre> <p>The container id is shown when you are in interactive mode [root@bdc1289fb081 /]#.</p> </li> <li> <p>Now verify the variables and Quartus is appropriately set up and recognized:</p> <pre><code>quartus_syn --version\n\nQuartus Prime Synthesis\nVersion Quartus Prime Pro Version 23.1\n</code></pre> </li> <li> <p>Everything is set up correctly. Please go to the following link for more information related to the OFS Site select your desired platform and select Getting stated guide.</p> <p>Tip: If you need to de-attach without stopping the container, you can use Ctrl+P or Ctrl+Q. For custom combinations, for example, <code>docker attach --detach-keys=\"ctrl-a\"  myOFS</code> and if you press CTRL+A you will exit the container without killing it.</p> </li> </ol> </li> </ul> <ul> <li> <p>De-attach Mode:</p> <p>This mode runs your container in the background and allows you to run multiple commands without going inside of the docker container.</p> <ol> <li> <p>The OFS Docker image already includes the evaluation script.</p> </li> <li> <p>Let's use option 2   - Check versions of Operating System and Quartus Premier Design Suite (QPDS); remember multiple options could not be available if the DFL drivers and the FPGA Platform is not installed, This example uses the Intel\u00ae FPGA SmartNIC N6001-PL . </p> <pre><code>$ sudo docker exec -it myOFS /home/OFS_BUILD_ROOT/ofs-n6001_eval.sh 2\nGo to selection: 2\n###########################################################################################\n#################### Check versions of Operation System, Quartus ##########################\n###########################################################################################\nChecking Linux release\nLinux version 6.1.22-dfl .....\n\n....\n\ncycle complete exiting...\n</code></pre> </li> <li> <p>The Intel Docker image includes the script ofs_extratool.sh to allow you to change the seed value.    <pre><code>sudo docker exec -it myOFS /home/OFS_BUILD_ROOT/ofs_extratool.sh -s 5\n</code></pre>     Now you can control and compile the design. You can use the interactive or de-attach mode.</p> </li> <li> <p>If you need to save the log file and output files use the following command </p> <pre><code>sudo docker exec -it myOFS /home/OFS_BUILD_ROOT/ofs_extratool.sh -e\n</code></pre> <p>all the files are saved under the share volume, DataOFS , /var/lib/docker/volumes/DataOFS/_data</p> </li> </ol> </li> </ul>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#40-deployment","title":"4.0  Deployment","text":"<p>The OFS docker image allows you to connect with your FPGA Platform. The main difference from the development installation process is that you are able to test with real hardware, but you must have a specific requirement to have a fully compatible system. </p> <p>Information related to host setup please go to OFS Site select your desired platform and select Getting stated guide.</p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#41-installation-of-deployment-server","title":"4.1 Installation of Deployment server","text":"<p>Once you ensure the DFL drivers are installed, follow the below steps:</p> <ol> <li>Follow the steps listed in sections  2.1 to 2.3<ul> <li>2.1 Quartus installation</li> <li>2.2 Docker Engine installation</li> <li>2.3 Load Docker Image installation</li> </ul> </li> <li>The steps required for DFL driver installation are documented OFS Site select your desired platform and select Getting stated guide.</li> </ol> <p>Now you should have all the steps required, and you can run the docker image directly.</p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#42-create-a-container","title":"4.2 Create a container","text":"<p>Now you are ready to start the container, and should be prepared to run it (Note: now we are adding a new flag to allow us to access the PCIe devices \u201c\u2014privileged\u201d) :</p> <ol> <li> <p>First, copy your Quartus installation path and  paste it under -v:</p> <pre><code>docker run --rm --privileged -itd --name myOFS -v=&lt;yourintallationfolder&gt;:/home/intelFPGA_pro/:ro -v=DataOFS:/dataofs ofs:latest /bin/bash\n</code></pre> <p>Example, my Quartus installation is located at \"/home/intelFPGA_pro/23.1\" as a result, my  command should be </p> <pre><code>docker run --rm --privileged -itd --name myOFS -v=/home/intelFPGA_pro/23.1:/home/intelFPGA_pro/:ro -v=DataOFS:/dataofs ofs:latest /bin/bash\nbdc1289fb0813bb325b55dd11df4eeec252143d6745a6e5772638fbc107d0949\n</code></pre> <p>Tip: you can change myOFS with any other value. The value is the given name of the container.</p> <p>Important: The --privileged flag gives all capabilities to the container. When the operator executes <code>docker run --privileged</code>, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. Additional information about running with <code>--privileged</code> is available on the Docker Blog. </p> </li> </ol> <p>:warning: Only use --privileged under development infrastructure, never in production!</p> <ol> <li> <p>Execute the docker run command.</p> <pre><code>docker run --rm --privileged -itd --name myOFS -v=/home/intelFPGA_pro/23.1:/home/intelFPGA_pro/:ro -v=DataOFS:/dataofs ofs:latest /bin/bash\n25b41eb4d232de9c750b52ddc6b92a3db612200e5993f55733b59068898623d7\n</code></pre> </li> <li> <p>Now, the docker container should be available.</p> <pre><code># sudo docker ps\nCONTAINER ID   IMAGE                              COMMAND       CREATED     STATUS     PORTS     NAMES\n25b41eb4d232   ofs:latest                        \"/bin/bash\"   13 seconds ago   Up 12 seconds     myOFS\n</code></pre> </li> </ol> <p>\u200b       Your Container ID is 25b41eb4d232. </p>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#43-evaluate-ofs-container","title":"4.3 Evaluate OFS container","text":"<p>The OFS container has two possible ways to interact with the container:</p> <ul> <li> <p>Interactive mode: </p> <p>This mode it takes you straight inside the container and uses the command terminal as a regular Linux console. </p> <ol> <li> <p>Enable the interactive mode:</p> <pre><code>docker attach myOFS\n[root@25b41eb4d232 /]#\n</code></pre> <p>The container id is shown when you are in interactive mode [root@25b41eb4d232 /]#.</p> </li> <li> <p>Now verify the variables and Quartus is appropriately setup and recognized:</p> <pre><code>quartus_syn --version\n\nQuartus Prime Synthesis\nVersion 23.1\n</code></pre> </li> <li> <p>Everything is set up correctly. Please go to the following link for more information related to the OFS Site select your desired platform and select User Guide,  Technical Reference Manual, Developer Guide, or Getting Started Guide.</p> <p>Tip: If you need to de-attach without stopping the container you can use Ctrl+P or Ctrl+Q. For custom, combinations use for example <code>docker attach --detach-keys=\"ctrl-a\"  myOFS</code> and if you press CTRL+A you will exit the container, without killing it.</p> </li> </ol> </li> </ul> <ul> <li> <p>De-attach Mode:</p> <p>This mode runs your container in the background and allows you to run multiple commands without going inside of the docker container.</p> <ol> <li> <p>The OFS Docker image already includes the eval script.</p> </li> <li> <p>Run the script and make a selection, you can directly execute with the following command:</p> <p>Let's use option 3   - Identify  Platform Hardware via PCIe; remember the DFL drivers need be installed. </p> </li> </ol> <pre><code>$ sudo docker exec -it myOFS /home/OFS_BUILD_ROOT/ofs-n6001_eval.sh 3\nGo to selection: 3\nPCIe card detected as\n\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\nb1:00.2 Processing accelerators: Intel Corporation Device bcce\nb1:00.4 Processing accelerators: Intel Corporation Device bcce\n\nHost Server is connected to SINGLE card configuration\n\ncycle complete exiting...\n</code></pre> <ol> <li>The Intel Docker image includes the script ofs_extratool.sh to allow you to change the seed value.<pre><code>```sh\nsudo docker exec -it myOFS /home/OFS_BUILD_ROOT/ofs_extratool.sh -s 5\n```\n</code></pre> </li> </ol> <p>Now you can control and compile the design using the interactive or de-attach mode.</p> </li> </ul>"},{"location":"hw/common/user_guides/ug_docker/ug_docker/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/","title":"Virtual machine User Guide: Open FPGA Stack + KVM","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/#document-scope","title":"Document scope","text":"<p>The document describes setting up and configuring a virtual machine to use PCIe devices. Here are the steps that the document may include:</p> <ol> <li>Install the necessary tools, such as virt-manager, on the host machine. This may involve downloading and installing the software from the internet.</li> <li>Enable the virtualization feature on the host machine. This may involve going into the BIOS settings and enabling hardware-assisted virtualization or using a command-line tool to enable it in the operating system.</li> <li>Use virt-manager to create a new virtual machine and configure its settings. This may involve choosing a name and operating system for the virtual machine and setting the amount of memory and storage it will use.</li> <li>Install the OPAE (Open Programmable Acceleration Engine) tool on the virtual machine. This may involve downloading and installing the OPAE software.</li> <li>Install the DFL (Data Field Level) drivers on the virtual machine. These drivers allow the virtual machine to access and use the PCIe devices on the host machine. This may involve downloading and installing the drivers from the internet.</li> <li>Once all of the steps have been completed, you should be able to use the virtual machine to access and use the PCIe devices on the host machine. You may need to configure the virtual machine's settings to enable it to use the PCIe devices, such as by assigning a specific device to the virtual machine.</li> </ol>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/#operation-modes","title":"Operation Modes","text":"<p>Our current operational framework stipulates two distinct modes of operation:</p> <ol> <li> <p>Management Mode: This mode necessitates the passthrough of only the FME device (use fpgainfo fme to discover your port number, normally .0). The reason for this is that the Open FPGA Stack (OFS) depends on this address for management. Under this mode, the use of the exerciser and virtual functions is not feasible.</p> </li> <li> <p>Virtual Function Mode: This mode comes into effect when a user needs to utilize the Virtual Functions (VF). The user will convert (example) Physical Function 0 (PF0) to three Virtual Functions (VF). This means the PF will cease to function for management purposes. Once the VFs are set up, they essentially take over the role of the PF in communicating with the Virtual Machines (VMs).</p> <p>However, this mode is subject to a limitation. If the user needs to execute 'fpgainfo fme' or 'fpgaupdate', they will need to transition from Virtual Function Mode to Management Mode. Conversely, if the user intends to utilize the Virtual Functions, they would need to switch from Management Mode to Virtual Function Mode. It is imperative to bear this limitation in mind when operating within these modes.</p> </li> </ol>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/#1-verify-if-the-virtualization-is-enabled","title":"1. Verify if the virtualization is enabled.","text":"<p>To check if virtualization is enabled on a Red Hat system using <code>lscpu</code> and <code>grep</code>, you can use the following command:</p> <pre><code>lscpu -e | grep Virtualization\n</code></pre> <p>This command will run <code>lscpu</code> with the <code>-e</code> or <code>--extended</code> option, which displays information about the CPU and its available virtualization capabilities. Then, it pipes the output to <code>grep</code> with the search pattern \"Virtualization\". If the system has support for virtualization, the output will show the \"Virtualization\" field and its value, for example:</p> <pre><code>Virtualization: VT-x\n</code></pre> <p>In this example, the output shows that the system supports Intel VT-x virtualization technology. If the \"Virtualization\" field is empty, the system does not have support for virtualization. Keep in mind that even if the system has support for virtualization, it may not be enabled in the BIOS or the operating system itself. </p> <p>Check the following for the bios configuration, Enabling Intel VT-d Technology</p>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/#2-verify-if-the-virtualization-modules-are-loaded","title":"2. Verify if the virtualization modules are loaded","text":"<ol> <li>Open a terminal window and log in as a user with sudo privileges.</li> <li>Check if the virtualization kernel modules are loaded by running the following command:</li> </ol> <pre><code>lsmod | grep kvm\n</code></pre> <ol> <li> <p>If the command outputs a list of modules, the virtualization kernel modules are loaded, and virtualization is enabled on your system.</p> </li> <li> <p>The virtualization kernel modules are not loaded if the command does not output anything. You can try loading them manually by running the following command:</p> </li> </ol> <pre><code>sudo modprobe kvm\n</code></pre> <ol> <li>If the kernel modules are not loaded, and you cannot load them manually, it may be because virtualization is not supported or enabled in your system's BIOS or UEFI settings. You must reboot your system and enter the BIOS or UEFI settings menu to enable virtualization. The exact steps for doing this may vary depending on your system's hardware and BIOS/UEFI version, so consult your motherboard or system documentation for specific instructions.</li> </ol>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/#3-install-virtual-machine-manager","title":"3. Install Virtual Machine Manager","text":"<p>Virtual Machine Manager (also known as libvirt) on follow these steps:</p> <ol> <li>Open a terminal window and log in as a user with sudo privileges.</li> <li> <p>Update your system package index by running the following command:</p> <ul> <li>Redhat </li> </ul> <p><pre><code>sudo dnf update\n</code></pre>  * Ubuntu  <pre><code>sudo apt update\n</code></pre></p> </li> <li> <p>Install the libvirt package and any required dependencies by running the following command:</p> <ul> <li>Redhat </li> </ul> <pre><code>sudo dnf install @virtualization\n</code></pre> <ul> <li>Ubuntu</li> </ul> <pre><code>sudo apt install qemu-kvm libvirt-bin bridge-utils virt-manager\n</code></pre> </li> <li> <p>Start the libvirtd service and enable it to start automatically at boot time by running the following commands:</p> </li> </ol> <pre><code>sudo systemctl start libvirtd\nsudo systemctl enable libvirtd\n</code></pre> <ol> <li>Optional: Install the virt-manager package, which provides a GUI application for managing virtual machines, by running the following command:</li> </ol> <pre><code>sudo dnf install virt-manager\n</code></pre> <ol> <li>Optional: If you want to be able to run virtual machines as a non-root user, add your user to the libvirt group by running the following command, replacing \"USERNAME\" with your username:</li> </ol> <pre><code>sudo usermod -a -G libvirt USERNAME\n</code></pre> <ol> <li>You can now launch virt-manager by running the command <code>virt-manager</code> as the non-root user.</li> </ol> <p>Note: By default, virt-manager will only allow non-root users to create and manage virtual machines with limited resources, such as a limited amount of memory and CPU cores. To allow non-root users to create and manage virtual machines with more resources, you need to edit the <code>/etc/libvirt/qemu.conf</code> configuration file and set the <code>user</code> and <code>group</code> values for the <code>dynamic_ownership</code> option to <code>1</code>. For example:</p> <pre><code># Set user and group ownership of dynamic /dev/kvm device nodes\ndynamic_ownership = 1\nuser = \"root\"\ngroup = \"root\"\n</code></pre> <p>You will also need to restart the libvirtd service for the changes to take effect. You can do this by running the command. </p> <pre><code>sudo systemctl restart libvirtd\n</code></pre> <ol> <li>Reboot your server to apply the changes </li> </ol> <pre><code>reboot\n</code></pre> <p>After completing these steps, you should be able to use the virt-manager GUI application to manage virtual machines on your system. </p>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/#4-how-to-create-a-virtual-machine","title":"4. How to create a Virtual Machine?","text":"<p>Before creating the virtual machine, ensure the DFL drivers are installed in your host machine; the instructions are located here, OFS Site select your desired platform and select Getting stated guide.</p> <p>To create a Red Hat 8.2 or Ubuntu 22.04  virtual machine (VM) using <code>virt-manager</code> and share PCI devices with the VM, you will need to perform the following steps:</p> <ol> <li>Start the <code>virt-manager</code> GUI by running the following command:</li> </ol> <pre><code>sudo virt-manager&amp;\n</code></pre> <p></p> <ol> <li> <p>Create a new connection from the menu File-&gt; \"Add Connection,\" Use the default options and click \"Connect.\"</p> <p></p> <p></p> </li> <li> <p>In the <code>virt-manager</code> window, click the \"New virtual machine\" button.</p> <p></p> </li> <li> <p>In the \"New VM\" wizard, select \"Local install media (ISO image or CDROM)\" as the installation source, and then click \"Forward.\"</p> <p></p> <ul> <li> <p>Get the Red Hat image from the following link.</p> <p>https://developers.redhat.com/content-gateway/file/rhel-8.2-x86_64-dvd.iso</p> </li> </ul> <ul> <li> <p>Get the Ubuntu image from the following link.</p> <p>https://releases.ubuntu.com/22.04/ubuntu-22.04.1-desktop-amd64.iso</p> </li> </ul> </li> <li> <p>In the next step, Click Browse -&gt; Browse local, select the Red Hat 8.2 ISO image as the installation source and click \"Forward\".</p> <p></p> <p></p> <p>Note: if the system is not detected, disable \"Automatic detected from the installation media/source\" and type ubuntu and select 19.10 (this should be fine for the 22.04); this step is necessary to copy the default values for the specific OS</p> <p></p> </li> <li> <p>In the next step, specify a name and location for the VM, and select the desired memory and CPU configuration. in our case, 16 cores and 64 GB of RAM; Click \"Forward\" to continue.</p> <p></p> </li> <li> <p>Select \"enable storage for this virtual machine,\" Select \"Create a new disk for the virtual machine,\" and enter a size for the virtual disk (at least 200~300GB in case you need to compile the design) or create a custom storage.</p> <p></p> <ol> <li> <p>If you need to create custom storage, select \"Select or Create custom storage\" and click \"Manage.\"</p> <p></p> </li> <li> <p>Click on the \"+\" icon (Bottom left) to create the storage pool.</p> <p></p> </li> <li> <p>In the \"Create a new storage pool\" dialog, enter a name for the storage pool and select the type of storage pool you want to create; select the Target Path and Click \"Finish.\"</p> <p></p> </li> <li> <p>Select the pool and later click on the \"+\" icon (The Icon is on the right side of the Volume label) to create the New Storage Volume.</p> <p></p> </li> <li> <p>In the \"Create Storage Volume\" dialog, Define the name and format (keep with the default qcow2) and select the Max Capacity (at least 200~300GB  in case you need to compile the design); click \"Finish\" to create the disk.</p> <p></p> </li> <li> <p>Once the disk is created, it will appear in your virtual machine's list of storage devices. You can now use this disk just like any other disk. Select from the list and Click \"Choose Volume.\"</p> <p></p> </li> </ol> </li> <li> <p>In the next step, select the \"Customize configuration before install\" option and click \"Finish.\"</p> <p></p> </li> <li> <p>In the \"Overview\" tab, select \"Add Hardware,\" choose \"PCI Host Device\" from the drop-down menu and choose the PCI device you want to share with the VM. Click \"Apply\" to apply the changes, and then click \"Finish\" to create the VM.</p> <ol> <li>Option A - Management mode - This will only allow you to load the binaries to the FPGA, you only need to add the PF listed at the fpgainfo fme command<pre><code>fpgainfo fme\n\nfpgainfo fme\nIntel Acceleration Development Platform N6001\nBoard Management Controller NIOS FW version: xxxx Board Management Controller Build version: xxxx //****** FME ******//\nObject Id                        : 0xEE00000\nPCIe s:b:d.f                     : 0000:b1:00.0\n</code></pre> <p>Do you only need to add the 0000:b1:00.0 to the list</p> </li> </ol> <p></p> <p></p> <p></p> <p></p> <ol> <li>Option B - Deployment mode - The main idea of this mode is enable the Virtual function used by the Agilex PCIe Attach OFS under the Physical Function 0, This option will allow us to use the Host Exercises.<p>Note: assigning multiple devices to the same VM on a guest IOMMU, you may need to increase the hard_limit option in order to avoid hitting a limit of pinned memory. The hard limit should be more than (VM memory size x Number of PCIe devices)</p> <p>1. Create 3 VFs in the PR region.</p> <pre><code>   ```sh\n   sudo pci_device b1:00.0 vf 3 \n   ```\n\n   **1.1** Verify all 3 VFs were created.\n\n   ```sh\n   lspci -s b1:00 \n   b1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01) \n   b1:00.1 Processing accelerators: Intel Corporation Device bcce \n   b1:00.2 Processing accelerators: Intel Corporation Device bcce \n   b1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device \n   b1:00.4 Processing accelerators: Intel Corporation Device bcce \n   b1:00.5 Processing accelerators: Intel Corporation Device bccf \n   b1:00.6 Processing accelerators: Intel Corporation Device bccf \n   b1:00.7 Processing accelerators: Intel Corporation Device bccf \n   ```\n\n   **2.** **Bind** all of the PF/VF endpoints to the `vfio-pci` driver.\n\n   ```\n   sudo opae.io init -d 0000:b1:00.1 user:user\n   Unbinding (0x8086,0xbcce) at 0000:b1:00.1 from dfl-pci\n   Binding (0x8086,0xbcce) at 0000:b1:00.1 to vfio-pci\n   iommu group for (0x8086,0xbcce) at 0000:b1:00.1 is 187\n   Assigning /dev/vfio/187 to DCPsupport\n   Changing permissions for /dev/vfio/187 to rw-rw----\n\n   sudo opae.io init -d 0000:b1:00.2 user:user\n   Unbinding (0x8086,0xbcce) at 0000:b1:00.2 from dfl-pci\n   Binding (0x8086,0xbcce) at 0000:b1:00.2 to vfio-pci\n   iommu group for (0x8086,0xbcce) at 0000:b1:00.2 is 188\n   Assigning /dev/vfio/188 to DCPsupport\n   Changing permissions for /dev/vfio/188 to rw-rw----\n\n   ...\n\n   sudo opae.io init -d 0000:b1:00.7 user:user\n   Binding (0x8086,0xbccf) at 0000:b1:00.7 to vfio-pci\n   iommu group for (0x8086,0xbccf) at 0000:b1:00.7 is 319\n   Assigning /dev/vfio/319 to DCPsupport\n   Changing permissions for /dev/vfio/319 to rw-rw----\n   ```\n\n   **3.** Check that the accelerators are present using `fpgainfo`. *Note your port configuration may differ from the below.*\n\n   ```\n   sudo fpgainfo port \n   //****** PORT ******//\n   Object Id                        : 0xEC00000\n   PCIe s:b:d.f                     : 0000:B1:00.0\n   Vendor Id                        : 0x8086\n   Device Id                        : 0xBCCE\n   SubVendor Id                     : 0x8086\n   SubDevice Id                     : 0x1771\n   Socket Id                        : 0x00\n   //****** PORT ******//\n   Object Id                        : 0xE0B1000000000000\n   PCIe s:b:d.f                     : 0000:B1:00.7\n   Vendor Id                        : 0x8086\n   Device Id                        : 0xBCCF\n   SubVendor Id                     : 0x8086\n   SubDevice Id                     : 0x1771\n   Socket Id                        : 0x01\n   Accelerator GUID                 : 4dadea34-2c78-48cb-a3dc-5b831f5cecbb\n   //****** PORT ******//\n   Object Id                        : 0xC0B1000000000000\n   PCIe s:b:d.f                     : 0000:B1:00.6\n   Vendor Id                        : 0x8086\n   Device Id                        : 0xBCCF\n   SubVendor Id                     : 0x8086\n   SubDevice Id                     : 0x1771\n   Socket Id                        : 0x01\n   Accelerator GUID                 : 823c334c-98bf-11ea-bb37-0242ac130002\n   //****** PORT ******//\n   Object Id                        : 0xA0B1000000000000\n   PCIe s:b:d.f                     : 0000:B1:00.5\n   Vendor Id                        : 0x8086\n   Device Id                        : 0xBCCF\n   SubVendor Id                     : 0x8086\n   SubDevice Id                     : 0x1771\n   Socket Id                        : 0x01\n   Accelerator GUID                 : 8568ab4e-6ba5-4616-bb65-2a578330a8eb\n   //****** PORT ******//\n   Object Id                        : 0x80B1000000000000\n   PCIe s:b:d.f                     : 0000:B1:00.4\n   Vendor Id                        : 0x8086\n   Device Id                        : 0xBCCE\n   SubVendor Id                     : 0x8086\n   SubDevice Id                     : 0x1771\n   Socket Id                        : 0x01\n   Accelerator GUID                 : 44bfc10d-b42a-44e5-bd42-57dc93ea7f91\n   //****** PORT ******//\n   Object Id                        : 0x40B1000000000000\n   PCIe s:b:d.f                     : 0000:B1:00.2\n   Vendor Id                        : 0x8086\n   Device Id                        : 0xBCCE\n   SubVendor Id                     : 0x8086\n   SubDevice Id                     : 0x1771\n   Socket Id                        : 0x01\n   Accelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n   //****** PORT ******//\n   Object Id                        : 0x20B1000000000000\n   PCIe s:b:d.f                     : 0000:B1:00.1\n   Vendor Id                        : 0x8086\n   Device Id                        : 0xBCCE\n   SubVendor Id                     : 0x8086\n   SubDevice Id                     : 0x1771\n   Socket Id                        : 0x01\n   Accelerator GUID                 : 3e7b60a0-df2d-4850-aa31-f54a3e403501\n   ```\n</code></pre> </li> </ol> <p>The following table contains a mapping between each VF, Accelerator GUID, and component.</p> <p>###### Table 16: Accelerator PF/VF and GUID Mappings</p> Component VF Accelerator GUID Intel N6001-PL FPGA SmartNIC Platform base PF XXXX:XX:XX.0 N/A VirtIO Stub XXXX:XX:XX.1 3e7b60a0-df2d-4850-aa31-f54a3e403501 HE-MEM Stub XXXX:XX:XX.2 56e203e9-864f-49a7-b94b-12284c31e02b Copy Engine XXXX:XX:XX.4 44bfc10d-b42a-44e5-bd42-57dc93ea7f91 HE-MEM XXXX:XX:XX.5 8568ab4e-6ba5-4616-bb65-2a578330a8eb HE-HSSI XXXX:XX:XX.6 823c334c-98bf-11ea-bb37-0242ac130002 MEM-TG XXXX:XX:XX.7 4dadea34-2c78-48cb-a3dc-5b831f5cecbb <ol> <li>Now you need to ensure you add the desire VF in you PCIE devices list <p></p> <p></p> <p>Ensure to select your desire VF, in our case .5 HE-MEM</p> </li> </ol> </li> <li> <p>Edit the XML file for your machine and include the following</p> <ol> <li> <p>&lt; ioapic driver='qemu'/&gt; inside of features:</p> <pre><code>&lt;features&gt;\n&lt;acpi/&gt;\n&lt;apic/&gt;\n&lt;ioapic driver='qemu'/&gt;\n&lt;/features&gt;\n</code></pre> </li> <li> <p>Inside of devices</p> <pre><code>&lt;devices&gt;\n........\n    ......\n    &lt;iommu model='intel'&gt;\n&lt;driver intremap='on' caching_mode='on'/&gt;\n&lt;/iommu&gt;\n&lt;/devices&gt;\n</code></pre> </li> <li> <p>Ensure the hard limit is setup correctly otherwise you can only pass one device:</p> <pre><code>&lt;memtune&gt;\n&lt;hard_limit unit='G'&gt;64&lt;/hard_limit&gt;\n&lt;/memtune&gt;\n</code></pre> <p>Note: assigning multiple devices to the same VM on a guest IOMMU, you may need to increase the hard_limit option in order to avoid hitting a limit of pinned memory. The hard limit should be more than (VM memory size x Number of PCIe devices)</p> </li> <li> <p>Save the changes \"Apply\"</p> </li> </ol> </li> <li> <p>On the host machine append intel_iommu=on to the end of the GRUB_CMDLINE_LINUX line in the grub configuration file.     <pre><code>nano /etc/default/grub\n......\nGRUB_CMDLINE_LINUX=\"....... ... intel_iommu=on\"\n...\n#Refresh the grub.cfg file for these changes to take effect\ngrub2-mkconfig -o /boot/grub2/grub.cfg\nshutdown -r now\n</code></pre></p> </li> <li> <p>Ensure your devices are enumerated properly.</p> <p>1. Example in you host system should look like this:</p> <pre><code>1. Management Mode\n\n  B1:00.0\n\n2. Deployment Mode\n\n    B1:00.5\n</code></pre> <p>2. Under the virtual machine (The PCIe Address is an example you could get a different     number):</p> <pre><code>1. Management Mode\n\n  177:00.0\n\n2. Deployment Mode\n\n    177:00.0\n</code></pre> </li> <li> <p>Click on \"Begin Installation.\" and follow the wizard installation of the OS. </p> <p></p> </li> <li> <p>Once the VM is created, you can start it by selecting it in the <code>virt-manager</code> window and clicking the \"Run\" button. This will boot the VM and start the Red Hat 8.2/Ubuntu installation process. Follow the on-screen instructions to complete the installation.</p> <p></p> <p></p> </li> <li> <p>Under your virtual machine, configure your VM proxy:</p> <p>* Redhat How to apply a system-wide proxy?   * Ubuntu Define proxy settings   * Configure Git to use a proxy</p> </li> <li> <p>To include OPAE in your virtual machine, follow the instructions from the following link  OFS Site select your desired platform and select Getting stated guide. To install the DFL drivers, please follow the instructions from the following link  OFS Site select your desired platform and select Getting stated guide.</p> </li> <li> <p>Use the OPAE SDK tool opae.io (under your virtual machine) to check default driver binding using your card under test PCIe B:D.F (Management mode). </p> <pre><code>sudo fpgainfo fme\n\nIntel Acceleration Development Platform N6001\nBoard Management Controller NIOS FW version: xxx Board Management Controller Build version: xxx\n//****** FME ******//\nObject Id                        : 0xED00001\nPCIe s:b:d.f                     : 0000:177:00.0\n</code></pre> </li> <li> <p>Use the Virtual function (Not supported at management mode)</p> <p>1. Ensure the DFL kernel drivers is install in your VM system   2. Bind VFs to VFIO driver</p> <pre><code>$ sudo opae.io init -d 0000:177:00.0\n[sudo] password for dcpsupport: opae.io 0.2.3\nBinding (0x8086,0xbccf) at 0000:177:00.0 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:177:00.0 is 13\n</code></pre> <p>3. Verify the binding is correct </p> <pre><code>$ opae.io ls\nopae.io 0.2.3\n[0000:177:00.0] (0x8086, 0xbccf) Intel N6001 ADP VF (Driver: vfio-pci)\n</code></pre> <p>4. Test the  HE mem</p> <pre><code>  ```bash\n  host_exerciser mem\n      starting test run, count of 1\n  API version: 1\n  Frequency of AFU clock unknown. Assuming 350 MHz.\n  Allocate SRC Buffer\n  Allocate DST Buffer\n  Allocate DSM Buffer\n      Host Exerciser Performance Counter:\n      Host Exerciser numReads: 1024\n      Host Exerciser numWrites: 1025\n      Host Exerciser numPendReads: 0\n      Host Exerciser numPendWrites: 0\n      Host Exerciser numPendEmifReads: 0\n      Host Exerciser numPendEmifWrites: 0\n      Number of clocks: 6737\n      Total number of Reads sent: 1024\n      Total number of Writes sent: 1022\n      Bandwidth: 3.405 GB/s\n      Test mem(1): PASS\n  ```\n</code></pre> </li> </ol> <p>After the installation, you can use <code>virt-manager</code> to manage and configure the VM to move from Management mode to Deployment or vice versa, including setting up networking, attaching additional storage, and installing additional software. The shared PCI device will be available to the VM, allowing it to use it as if it were connected directly to the physical system.</p>"},{"location":"hw/common/user_guides/ug_kvm/ug_kvm/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/","title":"Accelerator Functional Unit Developer Guide: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae","text":""},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#1-introduction","title":"1. Introduction","text":"<p>This document is a design guide for creating an Accelerator Functional Unit (AFU) using Open FPGA Stack (OFS) for Intel\u00ae Stratix 10\u00ae FPGA. The AFU concept consists of separating the FPGA design development process into two parts, the FIM and AFU, as shown in the diagram below:</p> <p> </p> <p>This diagram shows the FPGA board interface development separation from the internal FPGA workload creation. This separation starts with the FPGA Interface Manager (FIM), which consists of the external interfaces and board management functions. The FIM is the base system layer typically provided by board vendors. The FIM interface is specific to a particular physical platform. The AFU uses the external interfaces with user-defined logic to perform a specific application. Separating the lengthy and complicated process of developing and integrating external interfaces for an FPGA into a board allows the AFU developer to focus on their workload needs.  Intel\u00ae OFS for Intel\u00ae Stratix 10\u00ae FPGA provides the following tools for rapid AFU development:</p> <ul> <li>Scripts for both compilation setup</li> <li>Integration with Open Programmable Acceleration Engine (OPAE) SDK for rapid software development for your AFU application</li> </ul> <p>Please notice that the AFU region consists of both static and PR logic in the above block diagram. Creating AFU logic for the static region is described in Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae . This guide covers logic in the AFU Main (PR) region.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#11-document-organization","title":"1.1 Document Organization","text":"<p>This document is organized as follows:</p> <ul> <li>Description of design flow</li> <li>Interfaces and functionality provided in the Intel\u00ae FPGA PAC D5005 FIM</li> <li>Downloading and installing Intel\u00ae OFSand OPAE SDK</li> <li>Hardware/Software co-simulation using ASE</li> <li>Testing the AFU example in Intel\u00ae FPGA PAC D5005</li> <li>Debugging an AFU with Remote Signal Tap</li> </ul> <p>This guide provides theory followed by tutorial steps to solidify your AFU development knowledge.</p> <p>This guide uses the Intel\u00ae FPGA PAC D5005 as the platform for all tutorial steps. Additionally, this guide and the tutorial steps can be used with other platforms; However, please consult the board and FIM supplier of other platforms for specific instructions on the use of custom FIM to develop  AFU design.</p> <p>If you have worked with previous Intel\u00ae Programmable Acceleration products, you will find OFS for Intel\u00ae Stratix 10\u00ae FPGA is similar; however, there are differences, and you are advised to carefully read and follow the tutorial steps to understand the design tools and flow fully.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#12-prerequisite","title":"1.2 Prerequisite","text":"<p>This guide assumes you understand the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows, including the  Intel\u00ae Quartus\u00ae Prime Pro Edition design flow.</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in  Intel\u00ae Quartus\u00ae Prime Pro Edition software, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on critical timing paths.</li> <li>RTL and coding practices to create synthesized logic.</li> <li>High-level synthesis (HLS) and Platform Designer design entry tools are supported.</li> <li>RTL simulation tools.</li> <li>Signal Tap Logic Analyzer tool in the  Intel\u00ae Quartus\u00ae Prime Pro Edition software.</li> </ul>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#121-development-environment","title":"1.2.1 Development Environment","text":"<p>To run the tutorial steps in this guide requires this development environment:</p> Item Version Operating System RHEL 8.2 Python 3.7.7 cmake 3.11.4 GCC 7.2.0 git 1.8.3.1 perl 5.8.8 <p>Verify your development has the above tools installed.</p> <p>The following server and Intel\u00ae PAC card are required to run the examples in this guide:</p> <ol> <li>Intel\u00ae FPGA PAC D5005 with root entry hash erased (Please contact Intel\u00ae for root entry hash erase instructions). The standard Intel\u00ae FPGA PAC D5005 card is programmed only to allow the FIM binary files signed by Intel\u00ae to be loaded. The root entry hash erases process will allow unsigned FIM binary files to be loaded.</li> <li>Qualified Server Models see Qualified Servers.</li> <li>Intel\u00ae FPGA PAC D5005 installed in the qualified server following instructions in OFS Getting Started User Guide</li> </ol>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#13-acceleration-functional-unit-afu-development-flow","title":"1.3 Acceleration Functional Unit (AFU) Development Flow","text":"<p>OFS Stack provides a rapid design methodology for creating complex FPGA applications. In addition, you are provided with the following:</p> <ul> <li>Hardware shell layer, known as FIM </li> <li>Software stack including tools for debug/diagnostics</li> <li>FPGA design flow  with full-stack simulation support</li> <li>AFU code samples demonstrating all interfaces</li> </ul> <p>For any non-Intel\u00ae platform, contact your board vendor for the above components specific to the platform. To start with AFU development, the first step should be to understand your platform capabilities. For example, what interface is the FPGA connected to the Host machine over PCI-E, if it is AXI like the Intel\u00ae Stratix 10\u00ae FPGA Platform, or CCIP or CXL. Does the platform provide an External Memory Interface or the HSSI interface? Once you know what the platform offers, you can develop your AFU requirements and architecture as the next step.  This document will cover example AFU architecture and things that will help build AFU for Intel\u00ae Stratix 10\u00ae FPGA reference platform and others coming in the future. In addition, this knowledge can be relatively applied for AFU development on other vendor-provided platforms.</p> <p>The figure below shows a typical AFU development process independent of the platform used. </p> <p></p> <pre><code>flowchart  TB;\n    A[Understand platform capabilities with OFS]--&gt;B[Review AFU requirements and code samples provided];\n    B[Review AFU requirements and code samples provided]--&gt;C[Define AFU architecture];\n    C[Define AFU architecture]--&gt;D[Design AFU hardware];\n    D[Design AFU hardware]--&gt;E[Develop AFU software to control hardware];\n    E[Develop AFU software to control hardware]--&gt;F{\"Simulate in AFU Simulation Enviroment (ASE)\"};\n    F:::if -- Pass --&gt; H[\"Compile AFU for synthesis, place &amp; route and timing (uses Quartus)\"];\n    H[\"Compile AFU for synthesis, place &amp; route and timing (uses Quartus)\"] --&gt; I[\"Analyze Quartus Compile reports\"];\n    I --&gt; J{\"Quartus reports clean? (e.g. timing closed)\"};\n    J:::if -- No --&gt; P2;\n    J -- Yes --&gt; K[\"Run/Validate design on OFS Platform\"];\n    K --&gt; L{\"Hardware validation pass?\"};\n    L == Yes ==&gt; M[\"AFU ready to deploy\"];\n    L -- No --&gt; N[\"Debug on hardware using traditional FPGA tools (e.g. SignalTab\"];\n    N --&gt; P2[\"Fix AFU design (e.g Design changes, timing closure constraints)\"];\n    P2 --&gt; O{\"Need functional validation?\"};\n    O:::if -- Yes --&gt;P[\"Fix AFU design (e.g Functional design changes, bug fixes)\"];\n    O -- No --&gt;H;    \n    F -- Fail --&gt; P;\n    P --&gt;D;      \n\n    classDef default color:#fff,fill:#0071c5,stroke:#71c5,stroke-width:1px\n    classDef if color:#0071c5,fill:#fff,stroke:#0071c5,stroke-width:2px</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#131-high-level-data-flow","title":"1.3.1. High Level Data Flow","text":"<p>The OFShigh-level data flow is shown below:  The control and data are composed of the following:</p> <ul> <li>Host Interface Adapter (PCIe)</li> <li>Low-Performance Peripherals<ul> <li>Slow speed peripherals (I2C, Smbus, etc)</li> <li>Management peripherals (FME)</li> </ul> </li> </ul> <ul> <li>High-Performance Peripherals<ul> <li>Memory peripherals</li> <li>Acceleration Function peripherals</li> <li>HPS Peripheral</li> </ul> </li> </ul> <ul> <li>Fabrics<ul> <li>Peripheral Fabric (multi-drop)</li> <li>AFU Streaming fabric (point to point)</li> </ul> </li> </ul> <p>Peripherals are connected using AXI or Avalon:</p> <ul> <li>Via the peripheral fabric (AXI4-Lite, multi-drop)</li> <li>Via the AFU streaming fabric (AXI-S, point to point)</li> </ul> <p>Peripherals are presented to software as:</p> <ul> <li>OFS managed peripherals that implement DFH CSR structure.  </li> <li>Native driver managed peripherals (i.e., Exposed via an independent PF, VF)</li> </ul> <p>The peripherals connected to the peripheral fabric are primarily OPAE managed resources, whereas the peripherals connected to the AFU are \"primarily\" driven by native OS drivers. The word \"primarily\" is used since the AFU is not mandated to expose all its peripherals to Intel\u00ae OPAE. Instead, it can be connected to the peripheral fabric but can choose to expose only a subset of its capability to OPAE.</p> <p>OFS uses a defined set of CSRs to expose the functionality of the FPGA to the host software. These registers are described in Open FPGA Stack Reference Manual - MMIO Regions section.</p> <p>If you make changes to the FIM that affect the software operation, Intel\u00ae OFS provides a mechanism to communicate that information to the proper software driver. The Device Feature Header (DFH) structure provides a mechanism to maintain compatibility with OPAE software. Please see FPGA Device Feature List (DFL) Framework Overview for an excellent description of DFL operation from the driver perspective.</p> <p>When planning your address space for your FIM updates, please be aware OFS FIM targeting Intel\u00ae FPGA PAC D5005, 256KB of MMIO region is allocated for external FME features, and 128kB of MMIO region is given for external port features. Each external feature must implement a feature DFH, and the DFH needs to be placed at the 4KB boundary. The last feature in the external feature list must have the EOL bit in its DFH set to 1 to mark the end of the external feature list. Since the FPGA address space is limited, consider using an indirect addressing scheme to conserve address space.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#132-considerations-for-pim-usage","title":"1.3.2. Considerations for PIM Usage","text":"<p>An early decision for your AFU development is determining if the PIM will be included in your design flow. The PIM is an abstraction layer, enabling partial AFU portability across hardware despite variations in hardware topology and native interfaces. Use of the PIM is optional for AFU development. The use of the PIM adds a level of logic between an accelerator (an AFU) and the platform (the FIM). It is a collection of System Verilog interfaces and shims. Please see Connecting an AFU to a Platform using PIM for details on using the PIM and its capabilities. Please see PIM Tutorial for a detailed tutorial on using PIM. The learning steps PIM Tutorial can be run with Intel\u00ae OFS for Intel\u00ae Stratix 10\u00ae FPGA FIM package after you have installed this package as described later in this guide.  </p> <p>If you choose not to use the PIM, please see Non-PIM AFU Development for instructions on using a traditional RTL design flow. Note, the example AFU provided in Intel\u00ae OFS does not include PIM.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#133-afu-interfaces-included-with-intel-fpga-pac-d5005","title":"1.3.3 AFU Interfaces Included with Intel\u00ae FPGA PAC D5005","text":"<p>The figure below shows the interfaces available to the AFU in this architecture. It also shows the design hierarchy with module names from the FIM (top.sv) to the PR  region AFU (afu_main.sv). One of the main differences from the previous Intel\u00ae Stratix 10\u00ae FPGA OFS architecture is a static port gasket region (port_gasket.sv) that has components to facilitate the AFU and also consists of the GBS region (afu_main.sv) via the PR  slot. The Port Gasket contains all the PR -specific modules and logic, e.g., PR  slot reset/freeze control, user clock, remote STP etc. Architecturally, a Port Gasket can have multiple PR  slots to which user workload can be programmed. However, only one PR  slot is supported for Intel\u00ae OFS Release for Intel\u00ae Stratix 10\u00ae FPGA. Therefore, everything in the Port Gasket until the PR  slot should be provided by the FIM developer. The task of the AFU developer is to add their desired application in the afu_main.sv module by stripping out unwanted logic and instantiating the target accelerator. As shown in the figure below, here are the interfaces connected to the AFU (highlighted in green) via Intel\u00ae FPGA PAC D5005 FIM:</p> <ul> <li>AXI Streaming (AXI-S) interface to the Host via PCIe Gen3x16</li> <li>Avalon Memory-Mapped Channels (4) to the DDR4 EMIF interface</li> <li>AXI Streaming (AXI-S) interface to the HSSI 10G Ethernet</li> </ul> <p></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#134-platform-capabilities","title":"1.3.4. Platform Capabilities","text":"<p>The FIM targets operation in the Intel\u00ae FPGA PAC D5005 card.  The block diagram of the Intel\u00ae FPGA PAC D5005 is shown below: </p> <p>The key Intel\u00ae FPGA PAC D5005 FPGA interfaces are:</p> <ul> <li>Host interface      - PCIe Gen3 x 16</li> <li>Network interface<ul> <li>2 - QSFP28 cages</li> <li>Current FIM supports 1 x 10 GbE, other interfaces can be created  </li> </ul> </li> <li>External Memory<ul> <li>2 or 4 channels of DDR4-2400 to RDIMM modules</li> <li>RDIMM modules =  8GB organized as 1 Gb X 72</li> </ul> </li> <li>Board Management<ul> <li>SPI interface</li> <li>FPGA configuration</li> </ul> </li> </ul>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#135-top-level-fpga","title":"1.3.5. Top Level FPGA","text":"<p>The internal FPGA architecture is shown below:</p> <p></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2-set-up-afu-development-environment","title":"2. Set Up AFU Development Environment","text":"<p>This section covers:</p> <ul> <li>Development environment set up</li> <li>Retrieving and installing OFS, OPAE SDK</li> <li>Building theIntel\u00ae FPGA PAC D5005 FIM</li> <li>Building a relocatable AFU tree</li> <li>Compiling the host_chan_mmio example AFU</li> </ul> <p>Additionally, this section includes steps to demonstrate loading and running the host_chan_mmio example AFU in an Intel\u00ae FPGA PAC D5005 equipped Linux server.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#21-prepare-afu-development-environment","title":"2.1. Prepare AFU development environment","text":"<p>Typical development and hardware test environments consist of a development server or workstation with installed FPGA development tools and a separate server installed with the target OFS-compatible FPGA PCIe card. The typical usage and flow of data between these two servers are shown below:</p> <p></p> <p>Please refer to Unit Level Simulation if you would like to make any simulation Unit Level Simulation.</p> <p>Note that both development and hardware testing can be performed on the same server if desired.</p> <p>This guide uses Intel\u00ae FPGA PAC D5005 as the target OFS-compatible FPGA PCIe card platform for demonstration steps. The Intel\u00ae FPGA PAC D5005 must be fully installed following OFS Getting Started User Guide If using a different OFS FPGA PCIe card, contact your supplier for instructions on how to install and operate a user-developed AFU.</p> <p>NOTE: </p> <p>The following chapters assume you use the same server for development and Deployment (Run the FIM/AFU/SW over the Intel\u00ae FPGA PAC D5005):</p> <p>Development: Modify the FIM/AFU/SW run simulation and compile the design (Generate the binaries).  Deployment: Program the binaries under the Intel\u00ae FPGA PAC D5005 and exercise the Hardware and Sw with real hardware</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#211-installation-of-quartus-and-ofs","title":"2.1.1. Installation of Quartus and OFS","text":"<p>Building AFU with OFS forIntel\u00ae Stratix 10\u00ae FPGA requires the build machine to have at least 64 GB of RAM.  </p> <p>The following is a summary of the steps to set up for AFU development:</p> <ol> <li>Install  Intel\u00ae Quartus\u00ae Prime Pro Edition  23.1 Linux with Intel\u00ae Stratix 10\u00ae FPGA device support.</li> <li>Make sure support tools are installed and meet version requirements.</li> <li>Clone the repository.</li> <li>Review the files provided in the repository.</li> <li>Build a relocatable PR  tree - this will be the base FIM for your AFU.</li> </ol> <p>Intel\u00ae Quartus\u00ae Prime Pro Edition version  23.1 is the currently verified version of  Intel\u00ae Quartus\u00ae Prime Pro Edition 23.1 used for building the AFU images. The recommended Best Known Configuration (BKC) OFS Version 2023.1:</p> Item Version Intel\u00ae Quartus\u00ae Prime Pro Edition 23.1 Operating System RHEL 8.2 OPAE SDK 2.5.0-3 OFS Release ofs-2023.1 Python 3.7.7 cmake 3.11.4 GCC 7.2.0 git 1.8.3.1 perl 5.8.8"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2111-installation-of-quartus","title":"2.1.1.1 Installation of Quartus","text":"<ol> <li> <p>Download Intel\u00ae Quartus\u00ae Prime Pro Edition Linux.</p> </li> <li> <p>After running the  Intel\u00ae Quartus\u00ae Prime Pro Edition version  23.1 installer, set the PATH environment variable to make utility <code>quartus</code>, <code>jtagconfig</code>, and <code>quartus_pgm</code> discoverable. Edit your bashrc file <code>~/.bashrc</code> to add the following line:</p> </li> </ol> <pre><code>export QUARTUS_MAINPATH=&lt;Quartus install directory&gt;\nexport QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ipexport\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld\nexport QSYS_ROOTDIR=$QUARTUS_MAINPATH/qsys/bin\nexport PATH=$PATH:$QUARTUS_ROOTDIR/bin\n</code></pre> <p>For example:</p> <pre><code>export QUARTUS_MAINPATH=/home/&lt;mylocaluser&gt;/intelFPGA_pro/23.1\nexport QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ipexport\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld\nexport QSYS_ROOTDIR=$QUARTUS_MAINPATH/qsys/bin\nexport PATH=$PATH:/home/intelFPGA_pro/23.1/quartus/bin\n</code></pre> <ol> <li>Verify that  Intel\u00ae Quartus\u00ae Prime Pro Edition is discoverable by opening a new shell:</li> </ol> <pre><code>$ which quartus\n/home/&lt;mylocaluser&gt;/intelFPGA_pro/23.1/quartus/bin/quartus\n</code></pre> <p>NOTE: </p> <p>Ensure your proxy is set up if you use an intranet network.</p> <p><pre><code>export no_proxy=&lt;yourproxy&gt;\nexport http_proxy=&lt;yourproxy&gt;\nexport https_proxy=&lt;yourproxy&gt;\n</code></pre> </p> <p>Useful resources</p> <p>Intel\u00ae FPGA Software Licenses \\ Intel\u00ae FPGA Software Installation and Licensing manual </p> <p>Cloning the repo using the HTTPS method requires a personal access token. Please see this blog post for information about obtaining a personal access token, Github Creating a personal access token.</p> <p>Console Output: <pre><code>quartus_syn --version\nQuartus Prime Synthesis\nVersion 23.1.0 Build 104 09/14/2022 SC Pro Edition\nCopyright (C) 2022  Intel Corporation. All rights reserved.\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2112-install-ofs","title":"2.1.1.2. Install OFS","text":"<ol> <li> <p>Retrieve OFS repositories:</p> <p>The Intel\u00ae OFS FIM source code is included in the OFS GitHub repository. First, create a new directory to store the retrieved files as a clean starting point. The following is a short description of each repository, followed by the git commands for cloning. The instructions section uses the HTTPS git method for cloning repositories.  </p> </li> <li> <p>Navigate to the location for storage of OFS source, create the top-level source directory, and clone OFS repositories.</p> </li> </ol> <p><pre><code>mkdir ofs_fim_build_root\ncd ofs_fim_build_root\n</code></pre> <pre><code>export OFS_BUILD_ROOT=$PWD\n</code></pre> <pre><code>git clone --recurse-submodules  https://github.com/OFS/ofs-d5005.git\n</code></pre></p> <p>Console Output: <pre><code>Cloning into 'ofs-d5005' ...\nUsername for 'https://github.com': &lt;&lt;Enter your git hub username&gt;&gt;\nPassword for 'https://&lt;&lt;Your username&gt;&gt;': &lt;&lt;Enter your personal access token&gt;&gt;\nremote: Enumerating objects:  ....\n...\n...\nResolving deltas  ..., done.\n</code></pre> </p> <p>Edit your bashrc file ~/.bashrc to add the following lines: <pre><code>export OFS_ROOTDIR=$OFS_BUILD_ROOT/ofs-d5005\nexport WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification\n</code></pre> <pre><code>cd ofs-d5005\n</code></pre></p> <p>Select the latest OFS Release <pre><code>git checkout tags/ofs-2023.1\n</code></pre></p> <p>Console Output: ```sh You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout.</p> <p>If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example:</p> <p>git checkout -b  HEAD is now at 7e4dc70 ofs-2023.1"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2113-directory-structure-of-ofs","title":"2.1.1.3. Directory Structure of OFS","text":"<p>Verify the following directories in the $OFS_BUILD_ROOT directory with the following command.  </p> <pre><code>cd  $OFS_ROOTDIR\nls\n</code></pre> <p>Console Output: <pre><code> eval_scripts ipss ofs-common license  LICENSE.md  README.md  sim  src  syn  verification\n</code></pre> </p> <p>The directories are arranged as shown below:</p> <pre><code>\u251c\u2500\u2500 eval_scripts\n\u2502   \u251c\u2500\u2500 ofs_d5005_eval.sh\n\u2502   \u251c\u2500\u2500 README_ofs_d5005_eval.txt\n|\n\u251c\u2500\u2500 ofs-common\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 verification\n|   \u251c\u2500\u2500 LICENSE.txt   \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 ipss        **Directory ipss consists of Platform Designer subsystems used in FIM**\n\u2502   \u251c\u2500\u2500 hssi\n\u2502   \u251c\u2500\u2500 mem\n\u2502   \u251c\u2500\u2500 pcie\n|   \u251c\u2500\u2500 pmic |   \u251c\u2500\u2500 spi  \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 license\n\u2502   \u2514\u2500\u2500 quartus-0.0-0.01iofs-linux.run    ** Quartus Patch with IP licenses.  \u2502                                         ** Note, these licenses are not used for Intel\u00ae FPGA PAC D5005** \u251c\u2500\u2500 sim             **Unit level simulation files**\n\u2502   \u251c\u2500\u2500 unit_test\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 bfm\n\u2502   \u251c\u2500\u2500 rp_bfm   \u2502   \u2514\u2500\u2500 readme.txt     \u2502    \u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 README.md\n|\n\u251c\u2500\u2500 src             **Source RTL files**\n\u2502   \u251c\u2500\u2500 afu_top\n\u2502   \u251c\u2500\u2500 includes\n\u2502   \u251c\u2500\u2500 pd_qsys\n\u2502   \u251c\u2500\u2500 top\n|   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 external\n\u2502   \u2514\u2500\u2500 ofs-platform-afu-bbb\n|\n\u251c\u2500\u2500 syn              **Quartus compilation settings**\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 setup\n\u2502   \u251c\u2500\u2500 syn_top\n\u2502   \u251c\u2500\u2500 readme.txt\n\u2502   \u2514\u2500\u2500 README\n</code></pre> <pre><code>\u251c\u2500\u2500 eval_scripts\n\u2502   \u251c\u2500\u2500 ofs_d5005_eval.sh\n\u2502   \u251c\u2500\u2500 README_ofs_d5005_eval.txt\n|\n\u251c\u2500\u2500 ofs-common\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 verification\n|   \u251c\u2500\u2500 LICENSE.txt   \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 ipss        **Directory ipss consists of Platform Designer subsystems used in FIM**\n\u2502   \u251c\u2500\u2500 hssi\n\u2502   \u251c\u2500\u2500 mem\n\u2502   \u251c\u2500\u2500 pcie\n|   \u251c\u2500\u2500 pmic |   \u251c\u2500\u2500 spi  \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 license\n\u2502   \u2514\u2500\u2500 quartus-0.0-0.01iofs-linux.run    ** Quartus Patch with IP licenses.  \u2502                                         ** Note, these licenses are not used for Intel\u00ae FPGA PAC D5005** \u251c\u2500\u2500 sim             **Unit level simulation files**\n\u2502   \u251c\u2500\u2500 unit_test\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 bfm\n\u2502   \u251c\u2500\u2500 rp_bfm   \u2502   \u2514\u2500\u2500 readme.txt     \u2502    \u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 README.md\n|\n\u251c\u2500\u2500 src             **Source RTL files**\n\u2502   \u251c\u2500\u2500 afu_top\n\u2502   \u251c\u2500\u2500 includes\n\u2502   \u251c\u2500\u2500 pd_qsys\n\u2502   \u251c\u2500\u2500 top\n|   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 external\n\u2502   \u2514\u2500\u2500 ofs-platform-afu-bbb\n|\n\u251c\u2500\u2500 verification     **Top level UVM simulation files**\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 README.d5005\n\u2502   \u2514\u2500\u2500 regress_d5005.pl\n\u251c\u2500\u2500 syn              **Quartus compilation settings**\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 setup\n\u2502   \u251c\u2500\u2500 syn_top\n\u2502   \u251c\u2500\u2500 readme.txt\n\u2502   \u2514\u2500\u2500 README\n--&gt;\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2114-license-installation-for-ofs","title":"2.1.1.4 License Installation for OFS","text":"<p>The required setup Intel\u00ae OFS License quartus-0.0-0.01iofs-linux.run, follow the following steps :</p> <pre><code>cd $OFS_ROOTDIR/license\nchmod +x quartus-0.0-0.01iofs-linux.run\nsudo ./quartus-0.0-0.01iofs-linux.run\n# Confirm the license instaltion using below command.\nquartus_syn --version\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2115-retrieve-pim-files","title":"2.1.1.5. Retrieve PIM Files","text":"<p>The ofs-platform-afu-bbb repository contains the PIM files and example AFU that can be used for testing and demonstration purposes. This guide will use the host_chan_mmio example in the remaining sections to demonstrate OFS capabilities.</p> <p><pre><code>cd $OFS_BUILD_ROOT\n</code></pre> <pre><code>git clone https://github.com/OFS/ofs-platform-afu-bbb.git\n</code></pre> Edit your bashrc file ~/.bashrc to add the following lines: <pre><code>export OFS_PLATFORM_AFU_BBB=$OFS_BUILD_ROOT/ofs-platform-afu-bbb\n</code></pre></p> <p>Verify the following directories are present in $OFS_BUILD_ROOT directory. <pre><code>cd $OFS_PLATFORM_AFU_BBB\n</code></pre> <pre><code>ls\n</code></pre></p> <p>Console Output: <pre><code> COPYING  plat_if_develop  plat_if_release  plat_if_tests  README.md\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#212-compiling-the-ofs-fim","title":"2.1.2. Compiling the OFS FIM","text":"<p>Intel\u00ae OFS provides a build script with the following FPGA image creation options:</p> <ul> <li>Flat compile, which combines the FIM and AFU into one FPGA image loaded into the entire FPGA device as a static image.</li> <li>A PR  compile that creates an FPGA image consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. Additional AFU may be loaded into the dynamic region using partial reconfiguration.  </li> </ul> <p>The build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested. Each build script step will take several hours to complete. Building in Quartus GUI is not supported - you must build with the provided scripts.</p> <p>The following sections describe how to set up the environment and build the provided FIM with a relocatable tree supporting PR . You will use this relocatable PR  tree for all example AFU simulation and compilation steps in this guide.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2121-setting-up-required-environment-variables","title":"2.1.2.1. Setting Up Required Environment Variables","text":"<p>Set required environment variables as shown below. These environment variables must be set before simulation or compilation tasks, so creating a simple script to set these variables saves time.</p> <p>Edit your bashrc file ~/.bashrc to add the following lines: <pre><code>export OPAE_SDK_REPO_BRANCH=release/2.5.0\n</code></pre></p> <p>Check point : Ensure you file ~/.bashrc have all the following lines:</p> <p><pre><code>export QUARTUS_MAINPATH=&lt;Quartus install directory&gt;\nexport QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ipexport\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld\nexport QSYS_ROOTDIR=$QUARTUS_MAINPATH/qsys/bin\nexport PATH=$PATH:$QUARTUS_ROOTDIR/bin\nexport OFS_BUILD_ROOT=&lt;root location&gt; ** Here should be located your ofs-d5005 and ofs-platform-afu-bbb\nexport OFS_ROOTDIR=$OFS_BUILD_ROOT/ofs-d5005\nexport WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification\nexport OFS_PLATFORM_AFU_BBB=$OFS_BUILD_ROOT/ofs-platform-afu-bbb\nexport OPAE_SDK_REPO_BRANCH=release/2.5.0\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2122-compiling-your-base-fim","title":"2.1.2.2. Compiling Your Base FIM","text":"<p>The usage of the compile build script is shown below:</p> <p><pre><code>ofs-common/scripts/common/syn/build_top.sh [-p] target_configuration work_dir \n\n      * target_configuration - Specifies the project  \n         For example: d5005\n\n      * work_dir - Work Directory for this build in the form a directory name. It is created in the &lt;local repo directory&gt;/ofs-d5005/&lt;work_dir&gt; \n          - NOTE: The directory name must start with \"work\". If the working directory exists, the script stops and asks if you want to overwrite the directory.\n            - e.g.\n                - ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005\n\n                work directory as a name will be created in &lt;local repo directory&gt;/ofs-d5005/work_d5005\n\n                The obmission of &lt;work_dir&gt; results in a default work directory (&lt;local repo  directory&gt;/ofs-d5005/work)\n\n        - compile reports and artifacts (.rpt, .sof, etc) are stored in &lt;work_dir&gt;/syn/&lt;OFS_PROJECT&gt;/&lt;OFS_FIM&gt;/&lt;OFS_BOARD&gt;/syn_top/output_files\n\n        - There is a log file created in ofs-d5005 directory.  \n        - [-p]  Optional switch for creating a relocatable PR  build tree supporting the creation of a PR -able AFU workload.   \n        The \"-p\" switch invokes generate_pr_release.sh at the end of the FIM build and writes the PR  build tree to the top of the working directory. More information on this option is provided below. \n</code></pre> In the following example, you will build the provided example design using a flat, non-PR  build flow. If you use the -p, you could avoid the section.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#21221-relocatable-pr-directory-tree","title":"2.1.2.2.1. Relocatable PR Directory Tree.","text":"<p>Build the provided base example design:</p> <p><pre><code>cd $OFS_ROOTDIR\n</code></pre> <pre><code>ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005\n</code></pre></p> <p>Console Output: <pre><code>    ... build takes ~5 hours to complete\nCompile work directory:     &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top\nCompile artifact directory: &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top/output_files\n\n***********************************\n***\n***        OFS_PROJECT: d5005\n***        Q_PROJECT:  d5005\n***        Q_REVISION: d5005\n***        SEED: 03\n***        Build Complete\n***        Timing Passed!\n***\n</code></pre> </p> <p>Pro Tip: if the timing report fails, try to go into the iofs_pr_afu.qsf and modify the seed number from 3 to 4, it will create multiple seed/starting points of your design to find the best timing/fit. <code>/home/&lt;myuser&gt;/&lt;mainfolderforOFS&gt;/ofs-d5005/work_d5005/syn/syn_top/iofs_pr_afu.qsf</code> <pre><code>set_global_assignment -name SEED 0 #0-4\n</code></pre> </p> <p>The build script copies the ipss, sim, src, and syn directories to the specified work directory, and then these copied files are used in the Quartus compilation process. Therefore, do not edit the files in the work directory; these files are copies of source files.</p> <p>Some of the critical output files are described below:</p> <p>$OFS_ROOTDIR//syn/syn_top <pre><code>\u251c\u2500\u2500 syn_top                    //Intel\u00ae FPGA PAC D5005 Quartus build area with Quartus files used this build\n\u2502  \u251c\u2500\u2500 d5005.ipregen.rpt       // IP regeneration report states the output of IP upgrade\n\u2502  \u251c\u2500\u2500 d5005.qpf               // Quartus Project File (qpf) mentions about Quartus version and project revision\n\u2502  \u251c\u2500\u2500 d5005.qsf               // Quartus Settings File (qsf) lists current project settings and entity level assignments\n\u2502  \u251c\u2500\u2500 d5005.stp               // Signal Tap file included in the d5005.qsf. This file can be modified as required\n\u2502  \u251c\u2500\u2500 fme_id.mif              // the fme id hex value is stored in a mif file format\n\u2502  \u251c\u2500\u2500 iofs_pr_afu.json        // PR JSON file\n\u2502  \u251c\u2500\u2500 iofs_pr_afu.qsf                // PR AFU qsf file\n\u2502  \u251c\u2500\u2500 iofs_pr_afu_sources.tcl        // AFU source file list\n</code></pre> <p>$OFS_ROOTDIR//syn/syn_top/output_files == Directory with build reports and FPGA programming files. <p>The programming files consist of the Quartus generated d5005.sof and d5005.pof. The Intel\u00ae FPGA PAC D5005 board hardware provides a 2 Gb flash device to store the FPGA programming files and a BMC CARD that reads this flash and programs the Intel\u00ae FPGA PAC D5005 Intel\u00ae Stratix 10\u00ae FPGA. The ./ofs-common/scripts/common/syn/build_top.sh script runs script file ./ofs-common/scripts/common/syn/build_top.sh which takes the Quartus generated d5005.sof and creates binary files in the proper format to be loaded into the 2 Gb flash device.  You can also run build_flash.sh by itself if needed. </p> <p>The build script will run PACSign and create an unsigned FPGA programming file for both user1 and user2 locations of the Intel\u00ae FPGA PAC D5005 flash. Please note, if the Intel\u00ae FPGA PAC D5005 has the root entry hash key loaded, then PACsign must be run to add the proper key to the FPGA binary file. Please see Security User Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA for details on the security aspects of Intel\u00ae Open FPGA Stack and refer to BMC User Guide for Flash partition.</p> <p>The following table provides further detail on the generated bin files.</p> File Description d5005.sof This is the Quartus generated programming file created by Quartus synthesis and place and route. This file can be used to program the FPGA using a JTAG  programmer. This file is the source file for the binary files used to program the FPGA flash. d5005.bin This is an intermediate raw binary image of the FPGA d5005_page1.bin This is the binary file created from the input file, d5005.sof. This file is used as the input file to the PACSign utility to generate d5005_page1_unsigned.bin binary image file. d5005_page1_unsigned.bin This is the unsigned PACSign output which can be programmed into the FPGA flash of an unsigned Intel\u00ae FPGA PAC D5005 using the OPAE SDK utility fpgasupdate mfg_d5005_reversed.bin A particular programming file for a third-party device used in board manufacturing. This file is typically not used. <p>build/output_files/timing_report == Directory containing clocks report, failing paths and passing margin reports</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#213-relocatable-pr-directory-tree","title":"2.1.3. Relocatable PR Directory Tree","text":"<p>If you are developing FIM to be used by another team developing the AFU workload, scripts are provided that create a relocatable PR  directory tree. ODM and board developers will use this capability to enable a broad set of AFU to be loaded on a board using PR . The relocatable PR  directory contains the Quartus *.qdb file that goes the FIM.</p> <p>Creating the relocatable PR  directory tree requires a clone of the Intel\u00ae Basic Building Blocks (BBB) repository. The OFS_PLATFORM_AFU_BBB environment variable must point to the repository, for example.</p> <p><pre><code>cd $OFS_BUILD_ROOT\n</code></pre> <pre><code>git clone https://github.com/OFS/ofs-platform-afu-bbb.git\n</code></pre> <pre><code>cd $OFS_ROOTDIR\n</code></pre></p> <p>You can create this relocatable PR  directory tree by either:</p> <ul> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh followed by running /syn/common/scripts/generate_pr_release.sh (section 2.1.3. Relocatable PR Directory Tree)</li> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh with optional -p switch included</li> </ul> <p>The generate_pr_release.sh has the following command structure:</p> <p><pre><code>ofs-common/scripts/common/syn/generate_pr_release.sh -t &lt;path to generated release tree&gt; *Board Build Target* &lt;work dir from build_top.sh&gt;\nWhere:\n-t &lt;path to generated release tree&gt; = location for your relocatable PR  directory tree\n*Board Build Target* is the name of the board target/FIM e.g. d5005\n&lt;work dir from build_top.sh&gt; \n</code></pre> Here is an example of running the generate_pr_release.sh script in user mode:</p> <pre><code>ofs-common/scripts/common/syn/generate_pr_release.sh -t work_d5005/build_tree d5005  work_d5005\n</code></pre> <p>Console Output: <pre><code>**********************************\n********* ENV SETUP **************\nFIM Project:\n  OFS_PROJECT = d5005\n  OFS_FIM     = .\n  OFS_BOARD   = .\n  Q_PROJECT   = d5005\n  Q_REVISION  = d5005\n  Fitter SEED = 03\nFME id\n  BITSTREAM_ID = 040100022c164db1\n  BITSTREAM_MD = 0000000002212053\n...\n...\n</code></pre> </p> <p>The resulting relocatable build tree has the following structure:</p> <pre><code>.\n\u251c\u2500\u2500 bin\n\u2502   \u251c\u2500\u2500 afu_synth\n\u2502   \u251c\u2500\u2500 build_env_config\n\u2502   \u251c\u2500\u2500 run.sh -&gt; afu_synth\n\u2502   \u2514\u2500\u2500 update_pim\n\u251c\u2500\u2500 hw\n\u2502   \u251c\u2500\u2500 blue_bits\n\u2502   \u2502   \u251c\u2500\u2500 d5005_page1_unsigned.bin\n\u2502   \u2502   \u2514\u2500\u2500 d5005.sof -&gt; ../lib/build/syn/syn_top/   output_files/d5005.sof\n\u2502   \u2514\u2500\u2500 lib\n\u2502       \u251c\u2500\u2500 build\n\u2502       \u251c\u2500\u2500 fme-ifc-id.txt\n\u2502       \u251c\u2500\u2500 fme-platform-class.txt\n\u2502       \u2514\u2500\u2500 platform\n\u251c\u2500\u2500 README\n</code></pre> <p>Edit your bashrc file ~/.bashrc to add the following line: <pre><code>export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_d5005/build_tree\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#214-programing-the-fim","title":"2.1.4. Programing the FIM","text":"<ol> <li>Run the following command to find the PCIe address for your card.</li> </ol> <pre><code>sudo fpgainfo fme\n</code></pre> <p>Console Output: <pre><code>Board Management Controller, MAX10 NIOS FW version: 2.0.13\nBoard Management Controller, MAX10 Build version: 2.0.8\n//****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nDevice Id                        : 0xBCCE\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 288511862659474365\nBitstream Version                : 4.0.1\nPr Interface Id                  : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461\nBoot Page                        : user\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2141-load-fim-into-the-flash-of-the-intel-fpga-pac-d5005","title":"2.1.4.1. Load FIM into the Flash of the Intel\u00ae FPGA PAC D5005","text":"<p>The base FIM used in AFU compilation must be loaded on the board. In this step, you will load the generated FIM binary into the Intel\u00ae FPGA PAC D5005 FPGA flash. By performing this step, subsequent AFU developed in this guide will use this base FIM and allow your newly created AFU to match the base FIM loaded on the board.</p> <p>More information related to fpgaupdate is located OFS Getting Started User Guide.</p> <p>Run fpgasupdate to load the image into the user location of the Intel\u00ae FPGA PAC D5005 FPGA flash and the RSU  command to reboot the PCIE Card:</p> <p><pre><code>sudo fpgasupdate $OFS_ROOTDIR/work_d5005/syn/syn_top/output_files/d5005_page1_unsigned.bin 3b:00.0\n</code></pre> Run rsu command to re-configure FPGA on Intel\u00ae FPGA PAC D5005. <pre><code>sudo rsu bmcimg 3b:00.0\n</code></pre></p> <pre><code>sudo fpgainfo fme\n</code></pre> <p>Console Output: ```sh</p> <p>Board Management Controller, MAX10 NIOS FW version: 2.0.13 Board Management Controller, MAX10 Build version: 2.0.8 //****** FME ******// Object Id                        : 0xF000000 PCIe s:b:d.f                     : 0000:3b:00.0 Device Id                        : 0xBCCE Socket Id                        : 0x00 Ports Num                        : 01 Bitstream Id                     : 288511862659474365 Bitstream Version                : 4.0.1 Pr Interface Id                  : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461 Boot Page                        : user </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#30-opae-software-development-kit","title":"3.0 OPAE Software Development Kit","text":"<p>The OPAE SDK software stack sits in user space on top of the Intel\u00ae OFS kernel drivers. It is a common software infrastructure layer that simplifies and streamlines the integration of programmable accelerators such as FPGAs into software applications and environments. OPAE consists of a set of drivers, user-space libraries, and tools to discover, enumerate, share, query, access, manipulate, and re-configure programmable accelerators. OPAE is designed to support a layered, common programming model across different platforms and devices. To learn more about OPAE, its documentation, code samples, an explanation of the available tools, and an overview of the software architecture, please visit the OPAE.io page.</p> <p>The OPAE SDK source code is contained within a single GitHub repository hosted at the OPAE GitHub. This repository is open source and should not require any permissions to access.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#31-opae-sdk-build-environment-setup","title":"3.1 OPAE SDK Build Environment Setup","text":"<p>This installation process assumes the user has access to an internet connection to pull specific GitHub repositories and satisfy package dependencies. If an offline install process is required, please reach out to your Intel\u00ae representative.</p> <p>1. Before OPAE SDK installation, the user must remove any prior OPAE frameworks. To remove these packages:</p> <pre><code>sudo dnf remove opae*\n</code></pre> <p>2. The user must enable the following repository changes in order to install all dependencies on CentOS 8.3:</p> <pre><code>sudo dnf config-manager --set-enabled powertools\nsudo dnf install epel-release\n</code></pre> <p>3. The following package dependencies must be satisfied by the user. Double check that all packages have been found and installed:</p> <pre><code>sudo dnf install autoconf automake bison boost boost-devel cmake doxygen dwarves elfutils-libelf-devel \\\nflex gcc gcc-c++ git hwloc-devel json-c-devel libarchive libedit libedit-devel libpcap libpng12 libuuid libuuid-devel libxml2 libxml2-devel make ncurses  \\\nncurses-devel ncurses-libs openssl-devel python2-pip python3-devel python3-jsonschema rsync tbb-devel libudev-devel\n</code></pre> <p>All steps in this installation will use a generic top-level directory at <code>$OFS_BUILD_ROOT</code>. If the user has created a different top-level directory, replace this path with the user's custom path.</p> <p>4. Initialize an empty git repository and clone the tagged OPAE SDK source code:</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#32-install-opae-sdk","title":"3.2 Install OPAE SDK","text":"<p>Perform the following steps to install OPAE SDK:</p> <p><pre><code>cd $OFS_BUILD_ROOT\ngit clone https://github.com/OFS/opae-sdk.git\ncd opae-sdk\ngit checkout tags/2.5.0-3 -b release/2.5.0\n</code></pre> Verify proper branch is selected</p> <pre><code>git describe\n  2.5.0-3\n\ngit branch\n  master\n  * release/2.5.0\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#33-building-and-installing-the-opae-sdk","title":"3.3 Building and Installing the OPAE SDK","text":"<p>1. Build the OPAE SDK source code, and pack it into several local RPM packages. Building the code into packages allows for easier installation and removal. This build script can use multiple processors to parallelize the build process. Display how many processors are available with the <code>nproc</code> command, and then specify how many make threads to utilize with the -j option. Note that the number of threads can exceed the number of processors. In this case, the number of threads is set to the number of processors in the system.</p> <pre><code>cd $OFS_BUILD_ROOT/opae-sdk\nmkdir install-opae-sdk\ncd install-opae-sdk\ncmake .. -DCPACK_GENERATOR=RPM -DOPAE_BUILD_FPGABIST=ON -DOPAE_BUILD_PYTHON_DIST=ON -DCMAKE_BUILD_PREFIX=/install-opae-sdk make -j `nproc`\nmake -j `nproc` package_rpm\n</code></pre> <p>The <code>install-opae-sdk</code> directory location was selected for ease of use. If the user wishes to build the OPAE SDK in a different location, they will need to replace the '..' in the above command with the direct or relative path to the opae-sdk repository.</p> <p>2. After a successful compile, there should be eight packages present:</p> <pre><code>cd $OFS_BUILD_ROOT/opae-sdk/install-opae-sdk\nls | grep rpm\nopae-2.5.0-3.x86_64.rpm                                                                                                    opae-PACSign-2.5.0-3.x86_64.rpm                                                                                            opae-devel-2.5.0-3.x86_64.rpm                                                                                              opae-libs-2.5.0-3.x86_64.rpm                                                                                               opae-opae.admin-2.5.0-3.x86_64.rpm                                                                                         opae-packager-2.5.0-3.x86_64.rpm                                                                                           opae-tests-2.5.0-3.x86_64.rpm                                                                                              opae-tools-2.5.0-3.x86_64.rpm                                                                                              opae-tools-extra-2.5.0-3.x86_64.rpm\n</code></pre> <p>3. Install the OPAE SDK packages:</p> <pre><code>cd $OFS_BUILD_ROOT/opae-sdk/install-opae-sdk\nsudo dnf localinstall -y opae*.rpm\n</code></pre> <p>4. check that all packages have been installed:</p> <pre><code>rpm -qa | grep opae\nopae-devel-2.5.0-3.x86_64                                                                                                  opae-packager-2.5.0-3.x86_64                                                                                               opae-2.5.0-3.x86_64                                                                                                        opae-tools-2.5.0-3.x86_64                                                                                                  opae-PACSign-2.5.0-3.x86_64                                                                                                opae-tools-extra-2.5.0-3.x86_64                                                                                            opae-opae.admin-2.5.0-3.x86_64                                                                                             opae-tests-2.5.0-3.x86_64                                                                                                  opae-libs-2.5.0-3.x86_64\n</code></pre> <p>5. Setup required environment variables</p> <p><pre><code>export PATH=$PATH:$OFS_BUILD_ROOT/opae-sdk/install-opae-sdk/bin\nexport LIBRARY_PATH=$OFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib\nexport LD_LIBRARY_PATH=$OFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib64\n</code></pre> <pre><code>cd ../lib/python*/site-packages\nexport PYTHONPATH=$PWD\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#4-compiling-an-afu","title":"4. Compiling An AFU","text":"<p>This section will use the FIM build tree created in the previous steps to compile an example AFU. This section will continue the work with the <code>host_chan_mmio</code> AFU.. You can perform the build steps listed below to demonstrate the ease in building and running a real example on the Intel\u00ae FPGA PAC D5005.</p> <p>To run the steps in this section, you must complete all steps in section 2. Set Up AFU Development Environment, and ensure the <code>OPAE_PLATFORM_ROOT</code> \"environment variable that points to the directory of the PR  build tree generated previously. </p> <p>Ensure your bashrc file ~/.bashrc have the following line: <pre><code>export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_d5005/build_tree\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#41-set-afu-synthesis-environment","title":"4.1. Set AFU Synthesis Environment","text":"<p>Here, you will create the synthesis environment to build the <code>host_chan_mmio</code> example. The PIM flow includes the synthesis environment creation script <code>afu_synth_setup</code> for this task. The usage of afu_synth_setup is shown below:</p> <pre><code>usage: afu_synth_setup [-h] -s SOURCES [-p PLATFORM] [-l LIB] [-f] dst\nGenerate a Quartus build environment for an AFU. A build environment is\ninstantiated from a release and configured for the specified AFU. AFU\nsource files are specified in a text file parsed by rtl_src_config,\nwhich is part of the OPAE base environment.\npositional arguments:\n  dst                   Target directory path (directory must not exist).\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA platform name.\n  -l LIB, --lib LIB     FPGA platform release hw/lib directory. If not\n                        specified, the environment variables OPAE_FPGA_HW_LIB\n                        and then BBS_LIB_PATH are checked.\n  -f, --force           Overwrite target directory if it exists.\n</code></pre> <p>Execute <code>afu_synth_setup</code> \"as follows to create the synthesis environment for a <code>host_chan_mmio</code> \"AFU that fits the Intel\u00ae FPGA PAC D5005 FIM previously constructed.</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/\nafu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_d5005_x16\n</code></pre> <p>Now, execute the <code>afu_synth</code> command that resides inside the <code>$OFS_ROOTDIR/work_d5005/build_tree/bin</code> directory, to actually build the <code>host_chan_mmio</code> AFU.</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/build_d5005_x16\n$OPAE_PLATFORM_ROOT/bin/afu_synth\n...\n...\nWrote host_chan_mmio.gbs\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\nDesign meets timing\n===========================================================================\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#411-loading-and-running-the-host_chan_mmio-example-afu","title":"4.1.1. Loading and Running the host_chan_mmio example AFU","text":"<p>Once the compilation completes successfully, load the new bitstream file, <code>host_chan_mmio.gbs</code>, into the partial reconfiguration region of the target Intel\u00ae FPGA PAC D5005. Keep in mind, that the loaded image is dynamic - this image is not stored in flash, and if the card is power cycled, then the PR  region is re-loaded with the default AFU.</p> <p>To load the image, perform the following steps:</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/build_d5005_x16\nsudo fpgasupdate host_chan_mmio.gbs 3b:00.0\n[sudo] password for &lt;&lt;Your username&gt;&gt;: [WARNING ] Update starting. Please do not interrupt.\n[INFO    ] Partial Reconfiguration OK\n[INFO    ] Total time: 0:00:01.88\n</code></pre> <p>Determine the BDF of the Intel\u00ae FPGA PAC D5005.</p> <p>The PCIe BDF address is initially determined when the server powers on. The user can determine the addresses of all Intel\u00ae FPGA PAC D5005 using lspci:</p> <pre><code>lspci -d :bcce\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <p>Set up your board to work with the newly loaded host_chan_mmio.gbs</p> <ol> <li> <p>Create the Virtual Functions (VFs): <pre><code>sudo pci_device 3b:00.0 vf 3\n</code></pre></p> </li> <li> <p>Verify that all three VFs have been created.</p> </li> </ol> <pre><code>$ lspci -s 3b:00\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.1 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.2 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.3 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <ol> <li>Bind the 3 VFs to the vfio-pci driver.</li> </ol> <p>sudo opae.io init -d  , e.g. <pre><code>$ sudo opae.io init -d 0000:3b:00.1 user:user\nBinding (0x8086,0xbccf) at 0000:3b:00.1 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.1 is 142\nAssigning /dev/vfio/142 to &lt;local user&gt;\nChanging permissions for /dev/vfio/142 to rw-rw----\n\n$ sudo opae.io init -d 0000:3b:00.2 user:user\nBinding (0x8086,0xbccf) at 0000:3b:00.2 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.2 is 143\nAssigning /dev/vfio/143 to &lt;local user&gt;\nChanging permissions for /dev/vfio/143 to rw-rw-----\n\n$ sudo opae.io init -d 0000:3b:00.3 user:user\nBinding (0x8086,0xbccf) at 0000:3b:00.3 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.3 is 144\nAssigning /dev/vfio/144 to &lt;local user&gt;\nChanging permissions for /dev/vfio/144 to rw-rw----\n</code></pre> <ol> <li>Verify the new AFU is loaded.  The host_chan_mmio AFU GUID is 76d7ae9c-f66b-461f-816a-5428bcebdbc5.</li> </ol> <pre><code>$ fpgainfo port\n//****** PORT ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x603B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : d15ab1ed-0000-0000-0210-000000000000\n//****** PORT ******//\nObject Id                        : 0x403B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 76d7ae9c-f66b-461f-816a-5428bcebdbc5\n//****** PORT ******//\nObject Id                        : 0x203B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n</code></pre> <p>Run the host_chan_mmio software application to demonstrate the newly loaded AFU image. You navigate to $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw and compile the software application and then run.</p> <p>If OPAE SDK libraries were not installed in the default systems directory <code>/usr/lib64/</code> \", define the OPAE_LOC environment variable to point to the directory where the OPAE SDK libraries were installed.</p> <p><pre><code>$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib64:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n</code></pre> <pre><code>cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw\nmake ./host_chan_mmio\n</code></pre></p> <p>Console Output: <pre><code>AFU ID:  76d7ae9cf66b461f 816a5428bcebdbc5\nAFU MMIO interface: AXI Lite\nAFU MMIO read bus width: 64 bits\n512 bit MMIO write supported: yes\nAFU pClk frequency: 250 MHz\n\nTesting 32 bit MMIO reads:\n  PASS - 4 tests\n\nTesting 32 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 64 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 512 bit MMIO writes:\n  PASS\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#412-loading-and-running-the-hello_world-example-afu","title":"4.1.2. Loading and running the hello_world example AFU","text":"<p>The platform-independent BBB repository, ofs-platform-afu-bbb, also provides some interesting [example AFUs]. In this section, you will compile and execute the PIM-based <code>hello_world</code> AFU. The RTL of the <code>hello_world</code> AFU receives from the host application an address via memory-mapped I/O (MMIO) write and generates a DMA write to the memory line at that address. The content written to memory is the string \"Hello world!\". The host application spins, waiting for the memory line to be updated. Once available, the software prints out the string.</p> <p>The <code>hello_world</code> example AFU consists of the following files. </p> <p><pre><code>hello_world\n\u251c\u2500\u2500 hw\n\u2502   \u2514\u2500\u2500 rtl\n\u2502       \u251c\u2500\u2500 avalon\n\u2502       \u2502   \u251c\u2500\u2500 hello_world_avalon.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502       \u2502   \u2514\u2500\u2500 sources.txt\n\u2502       \u251c\u2500\u2500 axi\n\u2502       \u2502   \u251c\u2500\u2500 hello_world_axi.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502       \u2502   \u2514\u2500\u2500 sources.txt\n\u2502       \u251c\u2500\u2500 ccip\n\u2502       \u2502   \u251c\u2500\u2500 hello_world_ccip.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502       \u2502   \u2514\u2500\u2500 sources.txt\n\u2502       \u2514\u2500\u2500 hello_world.json\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 hello_world.c\n    \u2514\u2500\u2500  Makefile\n</code></pre> The hw directory contains the RTL to implement the hardware functionality using CCIP, Avalon, and AXI interfaces. However, this guide will use the AXI version of the AFU to go through the compilation steps. The sw directory of the AFU contains the source code of the host application that communicates with the AFU hardware.</p> <p>The following instructions can be used to compile other AFU samples accompanying this repository.</p> <ol> <li>If not done already, download and clone the below repository.</li> </ol> <pre><code>   cd $OFS_BUILD_ROOT git clone ${{ env.D5005_url_intel-fpga-bbb }}\ngit clone https://github.com/OFS/examples-afu.git\n</code></pre> <ol> <li>Install the Basic Building Blocks include files and libraries. </li> </ol> <pre><code>   cd intel-fpga-bbb\n   mkdir build\n   cd build\n   cmake -DCMAKE_INSTALL_PREFIX=/usr ..\n   make\n   make install\n</code></pre> <p>By default, the Basic Building Blocks include and library files will be installed in <code>/usr/local</code>. You can change this installation prefix to another path by adding <code>-DCMAKE_INSTALL_PREFIX=&lt;&lt;custom_path&gt;&gt;</code> to the cmake command, as above. In most cases, you should choose the same prefix for both the OPAE SDK and the Basic Building Blocks.</p> <p>If OPAE and the Basic Building Blocks are installed to standard system directories, such as <code>/usr/</code> and <code>/usr/local</code>, they may already be found on C and C++ header and library search paths. Otherwise, their installation directories must be added explicitly.</p> <p>\u00a0\u00a0\u00a0\u00a0 * Header files from OPAE and BBB must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.</p> <p>\u00a0\u00a0\u00a0\u00a0 * OPAE and BBB libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.</p> <ol> <li>Make sure to set the next environment variables.</li> </ol> <pre><code>  # Set the FPGA_BBB_CCI_SRC variable to the full path of the intel-fpga-bbb directory created in the git clone step above.\n$ export FPGA_BBB_CCI_SRC=$OFS_BUILD_ROOT/examples-afu  # Header files from OPAE and MPF must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.\n$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\n\n# OPAE and MPF libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.  \n$ export OPAE_LOC=/usr\n  $ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n# OPAE_PLATFORM_ROOT points to a release tree that has been configured with the Platform Interface Manager (PIM).  \n$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_d5005/build_tree\n</code></pre> <ol> <li> <p>Compile the <code>hello_word</code> sample AFU.  <pre><code>  $ cd $OFS_ROOTDIR/work_d5005\n  $ afu_synth_setup -s $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/hello_world/hw/rtl/axi/sources.txt hello_world_synth\n  $ cd hello_world_synth\n  $ ${OPAE_PLATFORM_ROOT}/bin/afu_synth\n\n.\n.\n.\nInfo (19538): Reading SDC files took 00:00:06 cumulatively in this process.\nWrote hello_world.gbs\n\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'hello_world.gbs'\nDesign meets timing\n===========================================================================\n</code></pre></p> </li> <li> <p>To test the AFU in actual hardware, load the <code>hello_world.gbs</code> to the Intel\u00ae FPGA PAC D5005 card. For this step to be successful, the Intel\u00ae FPGA PAC D5005 FIM must have already been loaded to the Intel\u00ae FPGA PAC D5005 card following the steps described in Section 2 of this document.</p> </li> </ol> <pre><code>  $ cd $OFS_ROOTDIR/work_d5005/hello_world_synth\n  $ sudo fpgasupdate hello_world.gbs 3b:00.0\n  [sudo] password for &lt;&lt;Your username&gt;&gt;: [2022-12-06 13:25:10.22] [WARNING ] Update starting. Please do not interrupt.\n[2022-12-06 13:25:12.06] [INFO    ] Partial Reconfiguration OK\n[2022-12-06 13:25:12.06] [INFO    ] Total time: 0:00:01.83\n</code></pre> <p>Set up your Intel\u00ae FPGA PAC D5005 board to work with the newly loaded <code>hello_world.gbs</code> file.</p> <pre><code>#  Create the Virtual Functions (VFs):\n$ sudo pci_device 3b:00.0 vf 3\n# Verify:\n$ lspci -s 3b:00\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.1 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.2 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.3 Processing accelerators: Intel Corporation Device bccf (rev 01)\n# Bond VFs to VFIO driver.  Enter &lt;&lt;Your username&gt;&gt;\nsudo opae.io init -d 0000:3b:00.1 &lt;Your username&gt;\n Unbinding (0x8086,0xbcce) at 0000:3b:00.1 from dfl-pci\n Binding (0x8086,0xbccf) at 0000:3b:00.1 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:3b:00.1 is 142\nAssigning /dev/vfio/142 to &lt;Your username&gt;\n Changing permissions for /dev/vfio/142 to rw-rw----\n\nsudo opae.io init -d 0000:3b:00.2 &lt;Your username&gt;\n Unbinding (0x8086,0xbccf) at 0000:3b:00.2 from dfl-pci\n Binding (0x8086,0xbccf) at 0000:3b:00.2 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:3b:00.2 is 143\nAssigning /dev/vfio/143 to &lt;Your username&gt;\n Changing permissions for /dev/vfio/143 to rw-rw----\n\nsudo opae.io init -d 0000:3b:00.3 &lt;Your username&gt;\n Unbinding (0x8086,0xbccf) at 0000:3b:00.3 from dfl-pci\n Binding (0x8086,0xbccf) at 0000:3b:00.3 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:3b:00.3 is 144\nAssigning /dev/vfio/144 to &lt;Your username&gt;\n Changing permissions for /dev/vfio/144 to rw-rw----\n\n# &lt; Verify the new AFU is loaded.  The hello_world AFU GUID is \"c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\".\n$ fpgainfo port\n//****** PORT ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x603B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\n//****** PORT ******//\nObject Id                        : 0x403B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\n//****** PORT ******//\nObject Id                        : 0x203B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n</code></pre> <ol> <li>Compile and execute the host application of the <code>hello_world</code> AFU. You should see the application outputs the \"Hello world!\" message in the terminal.</li> </ol> <pre><code>  # Move to the sw directory of the hello_world AFU and run the following commands in user mode\ncd $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/hello_world/sw/\n\nmake\n\n# Launch the host application\n./hello_world\n   Hello world TLP!\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#413-modify-the-afu-user-clocks-frequency","title":"4.1.3. Modify the AFU user clocks frequency","text":"<p>An OPAE compliant AFU specifies the frequency of the <code>uclk_usr</code> and <code>uclk_usr_div2</code> clocks through the JSON file for AFU configuration located under the <code>&lt;afu_example&gt;/hw/rtl</code> directory of an AFU design. For instance, the AFU configuration file of the <code>host_chan_mmio</code> example is <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/host_chan_mmio.json</code>.</p> <p>The AFU specifies the frequency for uClk_usr in its platform configuration file using the following key:value pairs:</p> <pre><code>  \"clock-frequency-high\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n  \"clock-frequency-low\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n</code></pre> <p>These <code>key:value</code> tuples are used to configure the PLL of the target platform that provides the user clocks through the AFU clocks interface. In addition, the specified frequency affects the timing closure process on the user clocks during AFU compilation. </p> <p>Setting the value field to a float number (e.g., 315.0 to specify 315 MHz) drives the AFU generation process to close timing within the bounds set by the low and high values and sets the AFU's JSON metadata to specify the user clock PLL  frequency values.</p> <p>The following example shows the JSON file of the <code>host_chan_mmio</code> to set the AFU uClk to 300 MHz and uClk_div2 to 150 MHz.</p> <pre><code>{\n   \"version\": 1,\n   \"afu-image\": {\n      \"power\": 0,\n      \"clock-frequency-high\": 300,\n      \"clock-frequency-low\": 150,\n      \"afu-top-interface\":\n         {\n            \"class\": \"ofs_plat_afu\"\n         },\n      \"accelerator-clusters\":\n         [\n            {\n               \"name\": \"host_chan_mmio\",\n               \"total-contexts\": 1,\n               \"accelerator-type-uuid\": \"76d7ae9c-f66b-461f-816a-5428bcebdbc5\"\n            }\n         ]\n   }\n}\n</code></pre> <p>Save the changes to <code>host_chan_mmio.json</code> file, then execute the <code>afu_synth_setup</code> script to create a new copy of the AFU files with the modified user clock settigns.</p> <p><pre><code>  $ cd $OFS_ROOTDIR/work_d5005\n  $ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_d5005_afu_clks\n\nLoading platform database: /home/&lt;Your username&gt;/&lt;Your localpath&gt;/ofs-d5005/work_d5005/build_tree/hw/lib/platform/platform_db/ofs_d5005.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting platform/platform_afu_top_config.vh\nWriting platform/platform_if_addenda.qsf\nWriting ../hw/afu_json_info.vh\n</code></pre> Compile the <code>host_chan_mmio</code> AFU with the new frequency values.</p> <pre><code>   cd $OFS_ROOTDIR/work_d5005/build_d5005_afu_clks\n   $OFS_ROOTDIR/work_d5005/build_tree/bin/afu_synth\n</code></pre> <p>During the compilation phase, you will observe the Timing Analyzer uses the specified user clock frequency values as the target to close timing.</p> <p></p> <p>AFU developers must ensure the AFU hardware design meets timing. The compilation of an AFU that fails timing shows a message similar to the following.</p> <pre><code>.\n.\n.\n\nWrote host_chan_mmio.gbs\n\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\n*** Design does not meet timing\n  *** See build/syn/syn_top/output_files/timing_report\n\n===========================================================================\n</code></pre> <p>The previous output indicates the location of the timing reports for the AFU designer to identify the failing paths and perform the necessary design changes. Next, is a listing of the timing report files from a <code>host_chan_mmio</code> AFU that fails to meet timing after modifying the user clock frequency values.</p> <pre><code>  $ cd $OFS_ROOTDIR/work_d5005/build_d5005_afu_clks\n  $ ls build/syn/syn_top/output_files/timing_report\n\nclocks.rpt  clocks.sta.fail.summary  clocks.sta.pass.summary iofs_pr_afu_2_slow_900mv_0c_recovery.rpt\niofs_pr_afu_2_slow_900mv_0c_setup.rpt\niofs_pr_afu_2_slow_900mv_100c_recovery.rpt\niofs_pr_afu_2_slow_900mv_100c_setup.rpt\niofs_pr_afu_2_slow_vid2_0c_recovery.rpt\niofs_pr_afu_2_slow_vid2_0c_setup.rpt\niofs_pr_afu_2_slow_vid2_100c_recovery.rpt\niofs_pr_afu_2_slow_vid2_100c_setup.rpt\niofs_pr_afu_MIN_fast_900mv_0c_recovery.rpt\niofs_pr_afu_MIN_fast_900mv_0c_setup.rpt\niofs_pr_afu_MIN_fast_900mv_100c_recovery.rpt\niofs_pr_afu_MIN_fast_900mv_100c_setup.rpt\n</code></pre> <p>Warning: AFU developers must inform software developers of the maximum operating frequency (Fmax) of the user clocks to avoid any unexpected behavior of the accelerator and potentially of the overall system.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#5-simulating-an-afu-using-ase","title":"5. Simulating an AFU using ASE","text":"<p>The AFU Simulation Environment (ASE) is a hardware/software co-simulation environment for your AFU. See diagram below illustrating ASE operation:</p> <p></p> <p>ASE uses the simulator Direct Programming Interface (DPI) to provide HW/SW connectivity.  The PCIe connection to the AFU under testing is emulated with a transactional model.</p> <p>The following list describes ASE operation:</p> <ul> <li>Attempts to replicate the transactions that will be seen in real system.</li> <li>Provides a memory model to AFU, so illegal memory accesses can be identified early.</li> <li>Not a cache simulator.</li> <li>Does not guarantee synthesizability or timing closure.</li> <li>Does not model system latency.</li> <li>No administrator privileges are needed to run ASE.  All code is user level.</li> </ul> <p>The remainder of this section is a tutorial providing the steps on how to run ASE with either VCS or QuestaSim using an example AFU and the AFU build tree previously created in this guide.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#51-set-up-steps-to-run-ase","title":"5.1. Set Up Steps to Run ASE","text":"<p>In this section you will set up your server to support ASE by independently downloading and installing OPAE SDK and ASE. Then, set up the required environment variables.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#511-install-opae-sdk","title":"5.1.1. Install OPAE SDK","text":"<p>Follow the instructions documented in the Getting Started Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae FPGA PAC D5005, section 5.0 OPAE Software Development Kit to build and install the required OPAE SDK for the Intel\u00ae FPGA PAC D5005 PAC card.</p> <p>The Intel\u00ae FPGA PAC D5005 PAC card requires opae-2.5.0-3. Follow the instructions provided in the Getting Started Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae FPGA PAC D5005 section 5.0 OPAE Software Development Kit. However, just make sure to check out the cloned repository to tag 2.5.0-3 and branch release/2.5.0.</p> <pre><code>git checkout tags/2.5.0-3 -b release/2.5.0\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#512-install-ase-tools","title":"5.1.2 Install ASE Tools","text":"<p>ASE is an RTL simulator for OPAE-based AFUs. The simulator emulates both the OPAE SDK software user space API and the AFU RTL interface. The majority of the FIM as well as devices such as PCIe and local memory are emulated with simple functional models.</p> <p>ASE must be installed separatedly from the OPAE-SDK. However, the recommendation is to install it in the same target directory as OPAE-SDK.</p> <ol> <li> <p>If not done already, set the environment variables as described in section, Set Up AFU Development Environment.</p> </li> <li> <p>Clone the <code>ase-sim</code> repository.</p> </li> </ol> <p><pre><code>  $ cd $OFS_BUILD_ROOT\n$ git clone https://github.com/OFS/opae-sim.git\n  $ cd opae-sim  </code></pre> 2. Building ASE requires the include file <code>mock/opae_std.h</code>. If the OPAE-SDK was installed under the default system directories, the C_INCLUDE_PATH variable must be set as follows. </p> <pre><code>export C_INCLUDE_PATH=\"/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\"\n</code></pre> <ol> <li>Create a build directory and build ASE to be installed under the default system directories along with OPAE SDK.</li> </ol> <pre><code>   mkdir build\n   cd build\n   cmake  -DCMAKE_INSTALL_PREFIX=/usr ..\n   make\n</code></pre> <p>Optionally, if the desire is to install ASE binaries in a different location to the system's default, provide the path to CMAKE through the CMAKE_INSTALL_PREFIX switch, as follows.</p> <pre><code>   cmake -DCMAKE_INSTALL_PREFIX=&lt;&lt;/some/arbitrary/path&gt;&gt; ..  </code></pre> <ol> <li>Install ASE binaries and libraries under the system directory <code>/usr</code>.</li> </ol> <pre><code>   sudo make install  </code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#513-setup-required-ase-environment-variables","title":"5.1.3. Setup Required ASE Environment Variables","text":"<p>The values set to the following environment variables assume the OPAE SDK and ASE were installed in the default system directories below <code>/usr</code>. Setup these variables in the shell where ASE will be executed. You may wish to add these variables to the script you created to facilitate configuring your environment.</p> <pre><code>   cd /usr/bin\n   export PATH=$PWD:$PATH\ncd ../lib/python*/site-packages\n   export PYTHONPATH=$PWD\ncd /usr/lib\n   export LIBRARY_PATH=$PWD\ncd /usr/lib64\n   export LD_LIBRARY_PATH=$PWD\ncd $OFS_BUILD_ROOT/ofs-platform-afu-bbb\n   export OFS_PLATFORM_AFU_BBB=$PWD\ncd $OFS_ROOTDIR/work_d5005/build_tree\n   export OPAE_PLATFORM_ROOT=$PWD\n## For VCS, set the following:\nexport VCS_HOME=&lt;Set the path to VCS installation directory&gt;\n   export PATH=$VCS_HOME/bin:$PATH\n## For QuestaSIM, set the following:\nexport MTI_HOME=&lt;path to Modelsim installation directory&gt;\n   export PATH=$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$PATH\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#52-simulating-the-host_chan_mmio-afu","title":"5.2. Simulating the host_chan_mmio AFU","text":"<p>The <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio</code> is a simple example demonstrating both hardware and software access to an AFU. The <code>host_chan_mmio</code> example AFU consists of the following files:</p> <pre><code>host_chan_mmio\n\u251c\u2500\u2500 hw\n\u2502   \u2514\u2500\u2500 rtl\n\u2502       \u251c\u2500\u2500 avalon\n\u2502       \u2502   \u251c\u2500\u2500 afu_avalon512.sv\n\u2502       \u2502   \u251c\u2500\u2500 afu_avalon.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_avalon512.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_avalon_from_ccip.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_avalon_from_axi.sv\n\u2502       \u2502   \u2514\u2500\u2500 ofs_plat_afu_avalon.sv\n\u2502       \u251c\u2500\u2500 axi\n\u2502       \u2502   \u251c\u2500\u2500 afu_axi512.sv\n\u2502       \u2502   \u251c\u2500\u2500 afu_axi.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_axi512.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_axi_from_ccip.sv\n\u2502       \u2502   \u2514\u2500\u2500 ofs_plat_afu_axi.sv\n\u2502       \u251c\u2500\u2500 host_chan_mmio.json\n\u2502       \u251c\u2500\u2500 test_mmio_avalon0_from_ccip.txt\n\u2502       \u251c\u2500\u2500 test_mmio_avalon1.txt\n\u2502       \u251c\u2500\u2500 test_mmio_avalon2_512rw.txt\n\u2502       \u251c\u2500\u2500 test_mmio_axi0_from_ccip.txt\n\u2502       \u251c\u2500\u2500 test_mmio_axi1.txt\n\u2502       \u2514\u2500\u2500 test_mmio_axi2_512rw.txt\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 main.c\n    \u251c\u2500\u2500 Makefile\n</code></pre> <p>This example AFU contains examples using both Avalon and AXI interface buses. This guide will use the AXI version of the <code>host_chan_mmio</code> AFU.</p> <p>ASE uses client-server application architecture to deliver hardware/software co-simulation.  You require one shell for the hardware based simulation and another shell where the software application is running. The hardware is started first with a simulation compilation and simulator startup script, once the simulator has loaded the design, it will wait until the software process starts. Once the software process starts, the simulator proceeds.  Transaction logging and waveform capture is performed.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#521-set-up-and-run-the-hw-simulation-process","title":"5.2.1 Set Up and Run the HW Simulation Process","text":"<p>You will run the <code>afu_sim_setup</code> script to create the scripts for running the ASE environment.  The <code>afu_sim_setup</code> script has the following usage:</p> <pre><code>usage: afu_sim_setup [-h] -s SOURCES [-p PLATFORM] [-t {VCS,QUESTA,MODELSIM}]\n                     [-f] [--ase-mode ASE_MODE] [--ase-verbose]\n                     dst\n\nGenerate an ASE simulation environment for an AFU. An ASE environment is\ninstantiated from the OPAE installation and then configured for the specified\nAFU. AFU source files are specified in a text file that is parsed by\nrtl_src_config, which is also part of the OPAE base environment.\n\npositional arguments:\n  dst                   Target directory path (directory must not exist).\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA Platform to simulate.\n  -t {VCS,QUESTA,MODELSIM}, --tool {VCS,QUESTA,MODELSIM}\n                        Default simulator.\n  -f, --force           Overwrite target directory if it exists.\n  --ase-mode ASE_MODE   ASE execution mode (default, mode 3, exits on\n                        completion). See ase.cfg in the target directory.\n  --ase-verbose         When set, ASE prints each CCI-P transaction to the\n                        command line. Transactions are always logged to\n                        work/ccip_transactions.tsv, even when not set. This\n                        switch sets ENABLE_CL_VIEW in ase.cfg.\n</code></pre> <p>Run <code>afu_sim_setup</code> to create the ASE simulation environment for the <code>host_chan_mmio</code> example AFU. The <code>'-t VCS'</code> option indicates to prepare the ASE simulation environment for VCS.</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/\n\nafu_sim_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt -t VCS host_chan_mmio_sim\n\nCopying ASE from /opae-sdk/install-opae-sdk/share/opae/ase...\nCopying ASE from /usr/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\n\nTool Brand: VCS\nLoading platform database: /home/&lt;Your username&gt;/&lt;Your localpath&gt;/ofs-d5005/work_d5005/build_tree/hw/lib/platform/platform_db/ofs_d5005.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> creates the ASE scripts in the directory <code>host_chan_mmio_sim</code> where the <code>afu_sim_setup</code> script was run.  Start the simulator as shown below in user mode:</p> <pre><code>   cd host_chan_mmio_sim\n   make\n   make sim\n</code></pre> <p>This process launches the AFU hardware simulator. Before moving to the next section, pay attention to the simulator output highlighted in the image below.</p> <p></p> <p>The simulation artifacts are stored in host_chan_mmio/work and consist of:</p> <pre><code>log_ase_events.tsv\nlog_ofs_plat_host_chan.tsv \nlog_ofs_plat_local_mem.tsv \nlog_pf_vf_mux_A.tsv \nlog_pf_vf_mux_B.tsv \n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#522-set-up-and-run-the-sw-process","title":"5.2.2 Set Up and Run the SW Process","text":"<p>Open an additional shell to build and run the host application that communicates with the actual AFU hardware. Set up the same environment variable you have set up in the shell you have been working on until this point. </p> <p>Additionally, as indicated by the hardware simulator output that is currently executing in the \"simulator shell\", copy and paste the line <code>\"export ASE_WORKDIR=...\"</code>, into the new \"software shell\". See the last image of the previous section.</p> <p><pre><code>   export ASE_WORKDIR= &lt;&lt;as directed in HW simulation shell&gt;&gt;\n</code></pre> Then, go to the sw directory of the <code>host_chan_mmio</code> AFU example to compile the host application.</p> <pre><code>cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw  make\n\nafu_json_mgr json-info --afu-json=../hw/rtl/host_chan_mmio.json --c-hdr=obj/afu_json_info.h\nWriting obj/afu_json_info.h\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c main.c -o obj/main.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c test_host_chan_mmio.c -o obj/test_host_chan_mmio.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/connect.c -o obj/connect.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/csr_mgr.c -o obj/csr_mgr.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/hash32.c -o obj/hash32.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/test_data.c -o obj/test_data.o\ncc -o host_chan_mmio obj/main.o obj/test_host_chan_mmio.o obj/connect.o obj/csr_mgr.o obj/hash32.o obj/test_data.o  -z noexecstack -z relro -z now -pie -luuid -lopae-c\n</code></pre> <p>Now, launch the host application to exercise the AFU hardware running on the simulator shell. The next image shows the AFU hardware simulation process on the left side shell. The right hand shell shows the host application's output of a successful simulation.</p> <p></p> <p>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</p> <pre><code>   make wave\n</code></pre> <p>This brings up the VCS simulator GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the afu instance located under, <code>ase_top | ase_top_plat | ofs_plat_afu | afu</code> , as shown below.</p> <p></p> <p>Right click on the <code>afu (afu)</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#53-simulating-the-hello_world-afu","title":"5.3 Simulating the hello_world AFU","text":"<p>In this section, you will quickly simulate the PIM-based <code>hello_world</code> sample AFU accompanying the example_afu repository.</p> <ol> <li> <p>Set the environment variables as described in section 5.1. Set Up Steps to Run ASE.</p> </li> <li> <p>Prepare an RTL simulation environment for the AXI version of the <code>hello_world</code> AFU.</p> <p>Simulation with ASE requires two software processes, one to simulate the AFU RTL and the other to run the host software that exercises the AFU. To construct an RTL simulation environment under the directory <code>$OFS_ROOTDIR/work_d5005</code>, execute the following.</p> <pre><code>  $ cd $OFS_ROOTDIR/work_d5005\n  $ afu_sim_setup -s $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/hello_world/hw/rtl/axi/sources.txt -t VCS hello_world_sim\n\nCopying ASE from /usr/local/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\nTool Brand: VCS\nLoading platform database: /home/&lt;Your username&gt;/&lt;Your localpath&gt;/ofs-d5005/work_d5005/build_tree/hw/lib/platform/platform_db/ofs_d5005.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> script constructs an ASE environment in the <code>hello_world_sim</code> subdirectory. If the command fails, confirm that the path to the afu_sim_setup is on your PATH environment variable (in the OPAE SDK bin directory) and that your Python version is at least 3.7.</p> </li> <li> <p>Build and execute the AFU RTL simulator in user mode.</p> <pre><code>   cd $OFS_ROOTDIR/work_d5005/hello_world_sim\n   make\n   make sim  </code></pre> <p>The previous commands will build and run the VCS RTL simulator, which prints a message saying it is ready for simulation. The simulation process also prints a message instructing you to set the ASE_WORKDIR environment variable in a second shell.</p> <ol> <li> <p>Open a second shell where you will build and execute the host software. In this new \"software shell\", set up the environment variables you have set up so far in the \"hardware simulation\" shell.</p> </li> <li> <p>Also, set the ASE_WORKDIR environment variable following the instructions given in the \"hardware simulation\" shell.</p> </li> </ol> <p><pre><code>export ASE_WORKDIR=$OFS_ROOTDIR/work_d5005/hello_world_sim/work\n</code></pre> 6. Then, move to the sw directory of the <code>hello_world</code> AFU sample to build the host software.</p> <pre><code>cd $FPGA_BBB_CCI_SRC/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/sw\n   make      </code></pre> <ol> <li>Run the <code>hello_world</code> host application to resume the work of the RTL simulation. The host software process and the RTL simulation execute in lockstep. If successful, you should see the Hello world! output.</li> </ol> <pre><code>  $ with_ase ./hello_world\n\n[APP]  Initializing simulation session ...\nHello world!\n  [APP]  Deinitializing simulation session\n  [APP]         Took 43,978,424 nsec\n  [APP]  Session ended\n</code></pre> <p>The image below shows the simulation of the AFU hardware and the execution of the host application side-by-side.</p> <p></p> <p></p> <p></p> <ol> <li>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</li> </ol> <pre><code>   make wave\n</code></pre> <p>This brings up the DVE GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the AFU instance located under, <code>ase_top | ase_top_plat | ofs_plat_afu</code>, as shown below.</p> <p></p> <p>Right click on the <code>ofs_plat_afu</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p> </p> </li> </ol>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#6-adding-remote-signal-tap-logic-analyzer-to-debug-the-afu","title":"6. Adding Remote Signal Tap Logic Analyzer to debug the AFU","text":"<p>The OPAE SDK provides a remote Signal Tap facility. It also supports the following in system debug tools included with the Intel\u00ae  Intel\u00ae Quartus\u00ae Prime Pro Edition:</p> <ul> <li>In-system Sources and Probes</li> <li>In-system Memory Content Editor</li> <li>Signal Probe</li> <li>System Console</li> </ul> <p>This section is a short guide on adding remote Signal Tap instances to an AFU for in-system debugging. In order of execution, you can follow the steps in the following sections to create an instrumented AFU. The host_chan_mmio AFU is used in this guide as the target AFU to be instrumented.</p> <p>You need a basic understanding of Signal Tap. Please see the Signal Tap Logic Analyzer: Introduction &amp; Getting Started Web-Based Training for more information.</p> <p>You will run with a Signal Tap GUI running locally on the server with the Intel\u00ae FPGA PAC D5005 as shown below:</p> <p></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#61-adding-rstp-to-the-host_chan_mmio-afu","title":"6.1. Adding RSTP to the host_chan_mmio AFU","text":"<p>RSTP is added to an AFU by:</p> <ol> <li>Defining signals to be instrumented in Signal Tap. Create a new *.stp file.</li> <li>Modify ofs_top.qpf to include the new *.stp file</li> <li>Modify ofs_top.qsf</li> <li>Modify ofs_pr_afu.qsf </li> <li>Re-run afu_synth_setup to update project settings</li> <li>Re-run $OPAE_PLATFORM_ROOT/bin/afu_synth to build the PR -able image containing the RSTP instance</li> </ol> <p>The following steps use the previously built host_chan_mmio AFU example. You can use these detailed steps to instrument your AFU.</p> <ol> <li> <p>Navigate to host_chan_mmio AFU Quartus project and open the project using Quartus GUI.</p> <pre><code> cd $OFS_ROOTDIR/work_d5005/build_d5005_x16/build/syn/syn_top\n $ quartus d5005.qpf &amp;\n</code></pre> </li> <li> <p>Once the project is loaded in Quartus, review the project hierarchy as shown in the Project Navigator. This example will add Signal Tap probe points to the AFU region. Reviewing the code will give insight into the function of this block. You can up the code in the Project Navigator by expanding afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu, right-click, select Locate Node - Locate in Design File as shown below.</p> <p></p> </li> <li> <p>Bring up Signal Tap to create the *.stp file. In the Quartus GUI, go to Tools - Signal Tap Logic Analyzer. Click <code>Create</code> to accept the default template in the New File from Template pop-up. The Signal Tap Logic Analyzer window comes up.</p> </li> <li> <p>Set up the clock for the Signal Tap logic instance by clicking <code>...</code> button as shown below:</p> <p> 5. The Node Finder comes up, and you will click <code>...</code> as shown below to bring up the hierarchy navigator or copy-paste the following location at <code>Look in</code>:</p> </li> </ol> <pre><code>iofs_top|afu_top|port_gasket|pr_slot|afu_main|ofs_plat_afu|afu\n</code></pre> <p></p> <ol> <li> <p>In the Select Hierarchy Level, navigate to top - afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu and click <code>Ok</code>.</p> </li> <li> <p>Enter <code>*clk*</code> in the <code>Named:</code> box and click <code>Search</code>.  This brings up matching terms.  Click <code>mmio64_if.clk</code> and <code>&gt;</code>.  Verify your Node Finder is as shown below and then click <code>Ok</code>:    </p> </li> <li> <p>Double click the <code>Double-click to add nodes</code> and once again, click <code>...</code> and navigate to top - afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu and click <code>Ok</code>.  Enter <code>mmio64</code> then click <code>&gt;&gt;</code> to add these signals to the STP instance as shown below:     </p> <p>Then click <code>Insert</code> and <code>Close</code>.</p> </li> <li> <p>Save the newly created STP by clicking <code>File - Save As</code> in the save as navigate to $OFS_ROOTDIR/work_d5005/build_d5005_x16/build/syn/syn_top and save the STP file as <code>host_chan_mmio.stp</code> as shown below:       </p> </li> <li>Edit <code>ofs_top.qsf</code> to add host_chan_mmio.stp file and enable STP.  Open $OFS_ROOTDIR/work_d5005/build_d5005_x16/build/syn/syn_top/d5005.qpf in an editor and modify lines as shown below:</li> </ol> <pre><code>set_global_assignment -name ENABLE_SIGNALTAP ON\nset_global_assignment -name USE_SIGNALTAP_FILE host_chan_mmio.stp\nset_global_assignment -name SIGNALTAP_FILE host_chan_mmio.stp\n</code></pre> <p>Save the d5005.qpf and close Quartus.</p> <ol> <li>Edit <code>iofs_pr_afu.qsf</code> to add host_chan_mmio.stp file and enable STP.  Open $OPAE_PLATFORM_ROOT/hw/lib/build/syn/syn_top/iofs_pr_afu.qsf in an editor and ensure the lines are included as  below (note: the verilog macro <code>INCLUDE_REMOTE_STP</code> will already be present), also copy and paste the file <code>host_chan_mmio.stp</code> in this location:</li> </ol> <p>The updated lines are: <pre><code>set_global_assignment -name VERILOG_MACRO \"INCLUDE_REMOTE_STP\"\nset_global_assignment -name ENABLE_SIGNALTAP ON\nset_global_assignment -name USE_SIGNALTAP_FILE host_chan_mmio.stp\nset_global_assignment -name SIGNALTAP_FILE host_chan_mmio.stp\n</code></pre> Save the iofs_pr_afu.qsf and ensure Quartus is closed.</p> <ol> <li>The afu_synth script is run to create a new copy of AFU files. In your original build shell, enter the following commands:</li> </ol> <pre><code>    $ cd $OFS_ROOTDIR/build_d5005_x16\n    $ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_d5005_x16_stp\n\n    Notice that your previous build_d5005_x16_stp directory is preserved, and a new build_d5005_x16_stp directory is created. You will use build_d5005_x16_stp to build the STP-enabled image.\n\n    $ cd build_d5005_x16_stp\n    $ $OPAE_PLATFORM_ROOT/bin/afu_synth\n\n...\n...\nWrote host_chan_mmio.gbs\n\n===========================================================================\n PR AFU compilation complete\n AFU gbs file is 'host_chan_mmio.gbs'\n  Design meets timing\n===========================================================================\n</code></pre> <ol> <li>Once compilation completes, the new host_chan_mmio.gbs file that contains the Signal Tap instance can be loaded.</li> </ol> <pre><code>$ sudo fpgasupdate host_chan_mmio.gbs 3b:00.0\n[sudo] password for &lt;myuser&gt;: \n[WARNING ] Update starting. Please do not interrupt.\n [INFO    ] \nPartial Reconfiguration OK\n[INFO    ] Total time: 0:00:01.87\n</code></pre> <ol> <li>Use the OPAE SDK mmlink tool to create a TCP/IP connection to your Intel\u00ae Stratix 10\u00ae FPGA card under test. The mmlink command has the following format:</li> </ol> <pre><code>Usage:\nmmlink\n&lt;Segment&gt;             --segment=&lt;SEGMENT NUMBER&gt;\n&lt;Bus&gt;                 --bus=&lt;BUS NUMBER&gt;           OR  -B &lt;BUS NUMBER&gt;\n&lt;Device&gt;              --device=&lt;DEVICE NUMBER&gt;     OR  -D &lt;DEVICE NUMBER&gt;\n&lt;Function&gt;            --function=&lt;FUNCTION NUMBER&gt; OR  -F &lt;FUNCTION NUMBER&gt;\n&lt;Socket-id&gt;           --socket-id=&lt;SOCKET NUMBER&gt;  OR  -S &lt;SOCKET NUMBER&gt;\n&lt;TCP PORT&gt;            --port=&lt;PORT&gt;                OR  -P &lt;PORT&gt;\n&lt;IP ADDRESS&gt;          --ip=&lt;IP ADDRESS&gt;            OR  -I &lt;IP ADDRESS&gt;\n&lt;Version&gt;             -v,--version Print version and exit\n</code></pre> <p>ProTip: </p> <p>Open a new shell session for mmlink; this console needs to remain open to allow mmlink connection.</p> <p>Enter the command below to create a connection using port 3333:</p> <pre><code>$ sudo mmlink -P 3333 -B 0x3b\n\n------- Command line Input START ----\n\nSocket-id             : -1\n Port                  : 3333\nIP address            : 0.0.0.0\n ------- Command line Input END   ----\n\nPORT Resource found.\nServer socket is listening on port: 3333\n</code></pre> <p>Leave this shell open with the mmlink connection.</p> <ol> <li>In this step, you will open a new shell and enable JTAG over protocol. You must have Quartus Prime Pro \u00ae  23.1 Programmer loaded on the Intel\u00ae FPGA PAC D5005 server for local debugging.</li> </ol> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/127.0.0.1:3333/0\n\nVerify connectivity with jtagconfig --debug\n\n$ jtagconfig --debug\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/127.0.0.1:3333/0]\n(JTAG Server Version 23.1.0 Build 104 09/14/2022 SC Pro Edition)\n020D10DD   VTAP10 (IR=10)\nDesign hash    D41D8CD98F00B204E980\n    + Node 00406E00  Virtual JTAG #0\nCaptured DR after reset = (020D10DD) [32]\nCaptured IR after reset = (155) [10]\nCaptured Bypass after reset = (0) [1]\nCaptured Bypass chain = (0) [1]\n</code></pre> <ol> <li>Start Quartus Signal Tap GUI, connect to target, load stp file by navigating to  $OPAE_PLATFORM_ROOT/hw/lib/build/syn/syn_top/ . The Quartus Signal Tap must be the same version of Quartus used to compile the host_chan_mmio.gbs. Quartus Prime Pro \u00ae  23.1 Pro is used in the steps below:</li> </ol> <pre><code>cd $OPAE_PLATFORM_ROOT/hw/lib/build/syn/syn_top/\nquartus_stpw host_chan_mmio.stp\n</code></pre> <p>This command brings up Signal Tap GUI. Connect to the Signal Tap over protocol by selecting the <code>Hardware</code> button on the right side of the GUI and clicking the \"Please Select\" pull-down as shown below:</p> <p>JTAG  over protocol selected:</p> <p></p> <p>This connection process will take approximately 2-3 minutes for the Signal Tap instance to indicate \"Ready to acquire\".</p> <p>8) Set the trigger condition for a rising edge on signal <code>valid</code> signal. 9) In the Signal Tap window, enable acquisition by pressing key <code>F5</code>. The Signal Tap GUI will indicate \"Acquisition in progress\". Run the hello_world application and observe that the Signal Tap instance has triggered. You should see signals being captured in the Signaltap GUI.</p> <p>See captured image below:</p> <p></p> <p>To end your Signal Tap session, close the Signal Tap GUI, then in the mmlink shell, enter <code>ctrl c</code> to kill the mmlink process.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/","title":"Intel\u00ae FPGA Interface Manager Developer Guide: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#1-introduction","title":"1. Introduction","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#11-about-this-document","title":"1.1. About This Document","text":"<p>This document serves as a design guide for FPGA developers, system architects and hardware developers using OFS as a starting point for the creating the FPGA Interface Manager (FIM) for a custom FPGA acceleration board or Platform with Intel FPGAs.</p> <p>This development guide is organized as follows: </p> <ul> <li>Introduction</li> <li>Top Level Block Diagram description<ul> <li>Control and data flow</li> </ul> </li> <li>Description of Subsystems<ul> <li>Command/status registers (CSR) and software interface</li> <li>Clocking, resets and interfaces</li> <li>High speed interface (HSSI)</li> <li>External attached memory</li> </ul> </li> <li>High Level development flow description<ul> <li>Installation of OFS RTL and development packages</li> <li>Compiling FIM</li> <li>Simulation  </li> </ul> </li> <li>Demonstration steps illustrating how to change areas of the design</li> <li>Debugging using JTAG</li> </ul> <p>This document uses the Intel\u00ae FPGA PAC D5005 as an example platform to illustrate key points and demonstrate how to extend the capabilities provided in OFS (Open FPGA Stack) to custom platforms. The demonstration steps serves as a tutorial for the development of your OFS knowledge.</p> <p>This document covers OFS architecture lightly.  For more details on the OFS architecture, please see Open FPGA Stack Technical Reference Manual.</p> <p>You are encouraged to read OFS AFU Development Guide to fully understand how AFU Developers will use your newly developed FIM.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#12-introduction","title":"1.2. Introduction","text":"<p>Open FPGA Stack (OFS) addresses the scalability for FPGA acceleration boards and workloads by providing a powerful and systematic methodology for the rapid development of FPGA-based Acceleration systems.  This methodology addresses the key challenges of hardware, software and workload developers by providing a complete FPGA project consisting of RTL and simulation code, build scripts and software. The FPGA project released in OFS can be rapidly customized to meet new market requirements by adding new features, custom IPs and Intel interface subsystems IPs. </p> <p>A high-level overview of the OFS Intel\u00ae Stratix 10\u00ae FPGA hardware architecture on the Intel\u00ae Stratix 10\u00ae FPGA reference platform, Intel\u00ae FPGA PAC D5005 is shown in the below figure. The provided FPGA architecture is divided into two main components </p> <p>- The outer area in white, the FPGA Interface manager (or FIM)    - The inner area in green, the Acceleration Function Unit or AFU Region. </p> <p>The outer area, the FIM, provides the core infrastructure and interfaces within the FPGA. The AFU region is where a user\u2019s custom logic would reside for their specific workload. </p> <p>* FPGA external interfaces and IP cores (e.g. Ethernet, DDR-4, PCIe, etc)   * PLLs/resets   * FPGA - Board management infrastructure   * Interface to Acceleration Function Unit (AFU)</p> <p>The AFU region has both static and dynamic partial reconfiguration regions enabling a lot of customization. </p> <p>* Uses the FIM interfaces to perform useful work inside the FPGA   * Contains logic supporting partial reconfiguration   * Remote Signal Tap core for remote debugging of workload</p> <p>Outside of the FPGA is the Board Management Controller which provides board management, root of trust, board monitoring, and remote system updates. </p> <p>The overall architecture is built to be very composable and modular in blocks that can be modified while leaving the rest of the infrastructure intact so you may only need to modify a few of these blocks. </p> <p></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#12-release-capabilities","title":"1.2. Release Capabilities","text":"<p>This release of OFS FIM supports the following key features:</p> <ul> <li>1 - Host channel interface via PCIe Gen 3 x 16 SRIOV (1PF, 3 VF, AXI-S TLP packets)</li> <li>DDR4 SDRAM External memory interface (AXI-M)</li> <li>1 - 10G Ethernet interfaces (1x10G)</li> <li>MSI-X Interrupts (PF, VF)</li> <li>1 - AFU</li> <li>Exercisers demonstrating PCIe, external memory and Ethernet interfaces</li> <li>Port, FME CSR</li> <li>Remote Signal Tap</li> </ul> <p>OFS is extensible to meet the needs of a broad set of customer applications, however not all use cases are easily served.  The general uses cases listed below are examples where the OFS base design can be easily re-used to build a custom FIM: 1. Use OFS reference design as-is   - Porting the code to another platform that is identical to the OFS reference platform only changing target FPGA device and pinout   - Change I/O assignments without changing design 2. Update the configuration of peripheral IP in OFS reference design, not affecting FIM architecture   - External memory settings   - HSSI analog settings 3. Remove/update peripheral feature in OFS reference design, not affecting FIM architecture   - External memory speed/width change   - Change 10G Ethernet to 25 or 100G Ethernet IP    - Change number of VFs supported 4. Add new features as an extension to OFS reference design, not affecting FIM architecture   - Add/remove external memory interface to the design   - Add/remove user clocks for AFU   - Add/remove IP to the design with connection to AFU</p> <p>More advanced use cases requiring changes or additions to the host PCIe channel are not easily supported with this release of the OFS FIM.</p> <p>Reuse of the provided host management FPGA logic and software is the fastest and most simple approach to FIM customization.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#13-prerequisites","title":"1.3. Prerequisites","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#131-base-knowledge-and-skills-prerequisites","title":"1.3.1. Base Knowledge and Skills Prerequisites","text":"<p>OFS is an advanced application of FPGA technology. This guide assumes you have the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows using Intel\u00ae Quartus\u00ae Prime Pro Edition design flow.</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in Intel\u00ae Quartus\u00ae Prime Pro Edition, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on timing critical paths.</li> <li>RTL and coding practices for FPGA implementation.</li> <li>RTL simulation tools.</li> <li>Intel\u00ae Quartus\u00ae Prime Pro Edition Signal Tap Logic Analyzer tool software.</li> </ul>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#132-development-environment","title":"1.3.2. Development Environment","text":"<p>To run the tutorial steps in this guide requires this development environment:</p> Item Version Intel Quartus Prime Pro Intel Quartus Prime Pro 23.1 (with license patch) Target D5005 Sever Operating System RHEL 8.2 OPAE SDK 2.5.0-3  Linux DFL ofs-2023.1-6.1-1 Python 3.7.7 cmake 3.11.4 GCC 7.2.0 perl 5.8.8 <p>The following server and Intel PAC card are required to run the examples in this guide:</p> <ol> <li>Qualified Intel Xeon \u00ae server see Qualified Servers.</li> <li>Intel\u00ae FPGA PAC D5005 with root entry hash erased (Please contact Intel for root entry hash erase instructions).  The standard Intel\u00ae FPGA PAC D5005 card is programmed to only allow the FIM binary files signed by Intel to be loaded.  The root entry hash erase process will allow newly created, unsigned FIM binary files to be loaded.</li> <li>Intel\u00ae FPGA PAC D5005 installed in the qualified server following instructions in OFS Getting Started User Guide.</li> </ol> <p>The steps included in this guide have been verified in the Dell R740 and HPE ProLiant DL380 Gen10 servers.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#2-high-level-description","title":"2. High Level Description","text":"<p>The FIM targets operation in the Intel\u00ae FPGA PAC D5005 card.  The block diagram of the D5005 is shown below:</p> <p></p> <p>The key D5005 FPGA interfaces are:</p> <ul> <li>Host interface      - PCIe Gen3 x 16</li> <li>Network interface<ul> <li>2 - QSFP28 cages</li> <li>Current FIM supports 1 x 10 GbE, other interfaces can be created  </li> </ul> </li> <li>External Memory<ul> <li>2 or 4 channels of DDR4-2400 to RDIMM modules</li> <li>RDIMM modules =  8GB organized as 1 Gb X 72</li> </ul> </li> <li>Board Management<ul> <li>SPI interface</li> <li>FPGA configuration</li> </ul> </li> </ul>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#21-fpga-interface-manager-overview","title":"2.1. FPGA Interface Manager Overview","text":"<p>The FPGA Interface Manager architecture is shown in the below diagram:</p> <p></p> <p>The FIM consists of the following components    - PCIe Subsystem    - Memory Subsystem    - HSSI Subsystem    - Platform Management Component Intercommunications (PMCI)     - Board Peripheral Fabric (BPF)     - AFU Peripheral Fabric (APF)    - Port Gasket    - AXI-S PF/VF Demux/Mux    - Host Exerciser Modules - HE-MEM, HE-LB, HE-HSSI    - FPGA Management Engine (FME)</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#22-fim-fpga-resource-usage","title":"2.2. FIM FPGA Resource Usage","text":"<p>The FIM uses a small portion of the available FPGA resources.  The table below shows resource usage for a base FIM built with 2 channels of external memory, a small AFU instantiated that has host CSR read/write, external memory test and Ethernet test functionality.</p> <p></p> Entity ALMs Used % ALMS Used M20Ks % M20Ks used DSP Blocks Pins IOPLLs OFS_top 125009.4 13.0% 661 5.4% 0 630 15 afu_top 70522.7 7.0% 228 2.4% 0 0 1 auto_fab_0 1305.7 0.0% 9 0.1% 0 0 0 bpf_rsv_5_slv 0.6 0.0% 0 0.0% 0 0 0 bpf_rsv_6_slv 0.6 0.0% 0 0.0% 0 0 0 bpf_rsv_7_slv 0.4 0.0% 0 0.0% 0 0 0 bpf 241.9 0.0% 0 0.0% 0 0 0 emif_top_inst 10508.6 1.0% 0 0.0% 0 0 12 eth_ac_wrapper 6024.8 0.5% 9 0.1% 0 0 0 fme_top 615.5 0.2% 7 0.1% 0 0 0 pcie_wrapper 35424.7 3.5% 348 2.9% 0 0 1 pmci_top 318.5 0.1% 0 0.0% 0 0 0 rst_ctrl 40.2 0.0% 0 0.0% 0 0 0 sys_pll 0.5 0.0% 0 0.0% 0 0 1 Total ALMS 933,120 Total M20Ks 11,721 Summary FPGA Resource Utilization Logic utilization (in ALMs) 124,092 / 933,120 ( 13 % ) Total dedicated logic registers 282822 Total pins 630 / 912 ( 69 % ) Total block memory bits 3,425,120 / 240,046,080 ( 1 % ) Total RAM Blocks 661 / 11,721 ( 6 % ) Total DSP Blocks 0 / 5,760 ( 0 % ) Total eSRAMs 0 / 75 ( 0 % ) Total HSSI P-Tiles 17 / 48 ( 35 % ) Total HSSI E-Tile Channels 17 / 48 ( 35 % ) Total HSSI HPS 0 / 1 ( 0 % ) Total HSSI EHIPs 0 / 2 ( 0 % ) Total PLLs 36 / 104 ( 35 % )"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#23-ofs-directory-structure","title":"2.3. OFS Directory Structure","text":"<p>The OFS Git OFS repository ofs-d5005 directory structure is shown below:</p> <p></p> <pre><code>\u251c\u2500\u2500 eval_script\n|   \u251c\u2500\u2500 ofs_d5005_eval.sh\n|   \u2514\u2500\u2500 README_ofs_d5005_eval.txt\n\u251c\u2500\u2500 ipss\n\u2502   \u251c\u2500\u2500 hssi\n|   \u251c\u2500\u2500 mem\n|   \u251c\u2500\u2500 pcie\n|   \u251c\u2500\u2500 pmci\n|   \u251c\u2500\u2500 spi\n|   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 license\n\u2502   \u2514\u2500\u2500 quartus-0.0-0.01iofs-linux.run\n\u251c\u2500\u2500 ofs-common\n|   \u251c\u2500\u2500 scripts\n|   \u251c\u2500\u2500 src\n|   \u251c\u2500\u2500 verification\n|   \u251c\u2500\u2500 LICENSE.txt\n|   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 sim\n|   \u251c\u2500\u2500 bfm\n|   \u251c\u2500\u2500 rp_bfm\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 scripts\n|   \u251c\u2500\u2500 unit_test \u2502\u00a0\u00a0 \u2514\u2500\u2500 readme.txt\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 afu_top\n\u2502   \u251c\u2500\u2500 includes\n\u2502   \u251c\u2500\u2500 pd_qsys\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u2514\u2500\u2500 top\n\u251c\u2500\u2500 syn\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 setup\n\u2502   \u251c\u2500\u2500 syn_top\n\u2502   \u251c\u2500\u2500 readme.txt\n\u2502   \u2514\u2500\u2500 README\n\u251c\u2500\u2500 LICENSE.txt\n\u2514\u2500\u2500 README.md\n</code></pre> <p>The contents of each directory are described below:</p> <p>Eval Script - Contains scripts for evaluation of OFS for D5005 including compiling FIM/AFU from source, unit level test. Also includes resources to report and setup D5005 development environment</p> <p>ipss - Contains the code and supporting files that define or set up the IP subsystems (HSSI, PCIe, memory, PMCI, SPI, etc...) contained in the D5005 FPGA Interface Manager (FIM).   </p> <p>license - License file for the Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP core.</p> <p>ofs-common - This directory contains resources that may be used across the board-specific repositories. This directory is referenced via a link within each of the FPGA-specific repositories.</p> <p>sim - Contains the testbenches and supporting code for all the unit test simulations.     - Bus Functional Model code is contained here.    - Scripts are included for automating a myriad of tasks.    - All of the individual unit tests and their supporting code is also located here.</p> <p>src - SystemVerilog source and script files    - Contains all of the structural and behavioral code for the FIM.    - Scripts for generating the AXI buses for module interconnect.    - Top-level RTL for synthesis is located in this directory.    - Accelerated Functional Unit (AFU) infrastructure code is contained in this directory.</p> <p>syn - This directory contains all of the scripts, settings, and setup files for running synthesis on the FIM.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#3-description-of-sub-systems","title":"3. Description of Sub-Systems","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#31-host-control-and-data-flow","title":"3.1. Host Control and Data Flow","text":"<p>The host control and data flow are shown in the diagram below:</p> <p></p> <p>The control and data flow is composed of the following:</p> <ul> <li>Host Interface Adapter (PCIe)</li> <li>Low Performance Peripherals<ul> <li>Slow speed peripherals (I2C, Smbus, etc)</li> <li>Management peripherals (FME)</li> </ul> </li> </ul> <ul> <li>High Performance Peripherals<ul> <li>Memory peripherals</li> <li>Acceleration Function peripherals</li> <li>HPS Peripheral</li> </ul> </li> </ul> <ul> <li>Fabrics<ul> <li>Peripheral Fabric (multi drop)</li> <li>AFU Streaming fabric (point to point)</li> </ul> </li> </ul> <p>Peripherals are connected to one another using AXI:</p> <ul> <li>Via the peripheral fabric (AXI4-Lite, multi drop)</li> <li>Via the AFU streaming fabric (AXI-S, point to point)</li> </ul> <p>Peripherals are presented to software as:</p> <ul> <li>OFS managed peripherals that implement DFH CSR structure.  </li> <li>Native driver managed peripherals (i.e. Exposed via an independent PF, VF)</li> </ul> <p>The peripherals connected to the peripheral fabric are primarily Intel OPAE managed resources, whereas the peripherals connected to the AFU are \u201cprimarily\u201d managed by native OS drivers. The word \u201cprimarily\u201d is used since the AFU is not mandated to expose all its peripherals to Intel OPAE. It can be connected to the peripheral fabric, but can choose to expose only a subset of its capability to Intel OPAE.</p> <p>OFS uses a defined set of CSRs to expose the functionality of the FPGA to the host software.  These registers are described in Open FPGA Stack Reference Manual - MMIO Regions section.</p> <p>If you make changes to the FIM that affect the software operation, then OFS provides a mechanism to communicate that information to the proper software driver.  The Device Feature Header (DFH) structure provides a mechanism to maintain compatibility with OPAE software.  Please see FPGA Device Feature List (DFL) Framework Overview for an excellent description of DFL operation from the driver perspective.</p> <p>When you are planning your address space for your FIM updates, please be aware that the OFS FIM targeting Intel\u00ae FPGA PAC D5005, 256KB of MMIO region is allocated for external FME features and 128kB of MMIO region is allocated for external port features. Each external feature must implement a feature DFH, and the DFH needs to be placed at 4KB boundary. The last feature in the external feature list must have the EOL bit in its DFH set to 1 to mark the end of external feature list.  Since the FPGA address space is limited, consider using an indirect addressing scheme to conserve address space.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#4-fim-development-flow","title":"4. FIM Development Flow","text":"<p>OFS provides a framework of FPGA synthesizable code, simulation environment, and synthesis/simulation scripts.  FIM designers can take the provided code and scripts and modify existing code or add new code to meet their specific product requirements.</p> <p>FIM development for a new acceleration card consists of the following steps:</p> <ol> <li>Installation of OFS and familiarization with scripts and source code</li> <li>Development of high-level block diagram with your specific functionality<ol> <li>Determination of requirements and key performance metrics</li> <li>Selection of IP cores</li> <li>Selection of FPGA device</li> <li>Software memory map</li> </ol> </li> <li>Selection and implementation of FIM Physical interfaces including:<ol> <li>External clock sources and creation of internal PLL clocks</li> <li>General I/O</li> <li>Transceivers</li> <li>External memories</li> <li>FPGA programming methodology</li> </ol> </li> <li>Device physical implementation<ol> <li>FPGA device pin assignment</li> <li>Inclusion of logic lock regions</li> <li>Creation of timing constraints</li> <li>Create Quartus FIM test project and validate:<ol> <li>Placement</li> <li>Timing constraints</li> <li>Build script process</li> <li>Review test FIM FPGA resource usage</li> </ol> </li> </ol> </li> <li>Select FIM to AFU interfaces and development of PIM</li> <li>FIM design implementation<ol> <li>RTL coding</li> <li>IP instantiation</li> <li>Development of test AFU to validate FIM</li> <li>Unit and device level simulation</li> <li>Timing constraints and build scripts</li> <li>Timing closure and build validation</li> </ol> </li> <li>Creation of FIM documentation to support AFU development and synthesis</li> <li>Software Device Feature discovery</li> <li>Hardware/software integration, validation and debugging</li> <li>High volume production preparation</li> </ol> <p>The FIM developer works closely with the hardware design of the target board, software development and system validation.</p> <p>Understanding how the AFU developer utilizes the FIM is important for FIM development success.  Please read OFS AFU Development Guide for a detailed description of AFU development.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#41-installation-of-ofs","title":"4.1. Installation of OFS","text":"<p>In this section you set up a development machine for compiling the OFS FIM. These steps are separate from the setup for a deployment machine where the FPGA acceleration card is installed.  Typically, FPGA development and deployment work is performed on separate machines, however, both development and deployment can be performed on the same server if desired.  Please see OFS Getting Started User Guide for instructions on installing software for deployment of your FPGA FIM, AFU and software application on a server.  </p> <p>Building the OFS FIM requires the development machine to have at least 64 GB of RAM.</p> <p>The following is a summary of the steps to set up for FIM development:</p> <ol> <li>Install Quartus Prime Pro 23.1 Linux and setup environment</li> <li>Clone the github <code>ofs-d5005</code> repository</li> <li>Test installation by building the provided FIM</li> </ol> <p>Intel Quartus Prime Pro version 23.1 is the currently verified version of Quartus used for building the FIM and AFU images for this release.  Porting to newer versions of Quartus may be performed by developers.  Download Quartus Prime Pro Linux version 23.1 from Intel\u00ae Quartus\u00ae Prime Pro Edition Linux.</p> <p>After running the Quartus Prime Pro installer, set the PATH environment variable to make utilities <code>quartus</code>, <code>jtagconfig</code>, and <code>quartus_pgm</code> discoverable. Edit your bashrc file <code>~/.bashrc</code> to add the following line:</p> <pre><code>export PATH=$PATH:&lt;Quartus install directory&gt;/quartus/bin\n</code></pre> <p>For example, if the Quartus install directory is /home/intelFPGA_pro/23.1 then the new line is:</p> <pre><code>export PATH=$PATH:/home/intelFPGA_pro/23.1/quartus/bin\n</code></pre> <p>Verify, Quartus is discoverable by opening a new shell:</p> <p><pre><code>which quartus\n## Output\n/home/intelFPGA_pro/23.1/quartus/bin/quartus\n</code></pre> Note, for some Linux distributions such as RHEL 8.2, Quartus requires installation of the following libraries: <pre><code>sudo dnf install libnsl\nsudo dnf install ncurses-compat-libs\nsudo ln -s /usr/bin/python3 /usr/bin/python\n</code></pre></p> <p>You will need to obtain a license for Intel Quartus Prime Pro version 23.1 to compile the design.  This license is obtained from Intel.  Additionally, OFS for Intel\u00ae Stratix 10\u00ae FPGA requires a license for the Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP core.  This license is required to generate a programming file using the provided OFS source code.  The Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP core license patch installer is provided in the ofs-d5005 git repository in the /license directory.  After cloning the OFS release in step 4 below, you can install this IP license.  </p> <ol> <li>Install git and install git lfs to extract large files within the repository that are compressed with git lfs.  Please note, for proper operation of files retrieved from OFS repository, you will require git lfs. </li> </ol> <pre><code>sudo dnf install git\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#install-git-lfs","title":"Install git lfs:","text":"<pre><code>curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash\nsudo dnf install git-lfs\ngit lfs install\n</code></pre> <ol> <li>Retrieve OFS repositories:</li> </ol> <p>The OFS FIM source code is included in the GitHub repository. Create a new directory to use as a clean starting point to store the retrieved files.  </p> <ol> <li>Navigate to location for storage of OFS source, create the top-level source directory and clone OFS repositories.</li> </ol> <p><pre><code>mkdir OFS_fim_build_root\ncd OFS_fim_build_root\nexport OFS_BUILD_ROOT=$PWD\ngit clone --recurse-submodules  https://github.com/OFS/ofs-d5005.git\ncd ofs-d5005\ngit checkout tags/ofs-2023.1-1\n</code></pre> Verify proper tag is selected:</p> <p><pre><code>git describe --tags\nofs-2023.1-1\n</code></pre> 2. Install the Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP license by running provided license installer.</p> <pre><code>cd license\nchmod +x quartus-0.0-0.01iofs-linux.run\nsudo ./quartus-0.0-0.01iofs-linux.run\n</code></pre> <ol> <li>Verify patch installed <pre><code>quartus_sh --version\n##Output\nQuartus Prime Shell\nVersion 23.1 Pro Edition\n</code></pre></li> </ol>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#42-compiling-ofs-fim","title":"4.2. Compiling OFS FIM","text":"<p>OFS provides a build script with the following FPGA image creation options:</p> <ul> <li>Flat compile which combines the FIM and AFU into one FPGA image that is loaded into the entire FPGA device</li> </ul> <ul> <li>A PR compile which creates a FPGA image consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. Additional AFUs maybe loaded into the dynamic region using partial reconfiguration.</li> </ul> <p>The build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested. Each build script step will take several hours to completes, Please note, building directly in Quartus GUI is not supported - you must build with the provided scripts.</p> <p>The following sections describe how to set up the environment and build the provided FIM and AFU. Follow these steps as a tutorial to learn the build flow. You will use this environment and build scripts for the creation of your specialized FIM.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#421-setting-up-required-environment-variables","title":"4.2.1. Setting Up Required Environment Variables","text":"<p>Set required environment variables as shown below. These environment variables must be set prior to simulation or compilation tasks so creating a simple script to set these variables saves time.</p> <pre><code>cd $OFS_BUILD_ROOT/ofs-d5005\nexport OFS_ROOTDIR=$PWD\nexport QUARTUS_HOME=&lt;user_path&gt;/intelFPGA_pro/23.1/quartus\nexport QUARTUS_ROOTDIR=$QUARTUS_HOME\n##   *Note, OFS_ROOTDIR is the directory where you cloned the repo, e.g. /home/MyProject/ofs-d5005 *\nexport WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\n##   *Note, QUARTUS_ROOTDIR is your Quartus installation directory, e.g. $QUARTUS_ROOTDIR/bin contains Quartus executuable*\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport OPAE_SDK_REPO_BRANCH=release/2.5.0\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#422-compiling","title":"4.2.2. Compiling","text":"<p>The usage of the compile build script is shown below:</p> <p><pre><code>ofs-common/scripts/common/syn/build_top.sh [-p] target_configuration work_dir Usage: ofs-common/scripts/common/syn/build_top.sh [-k] [-p] &lt;build target&gt; [&lt;work dir name&gt;]\nBuild a FIM instance specified by &lt;build target&gt;. The target names an FPGA architecture, board and configuration.\n\nThe FIM is built in &lt;work dir name&gt;. If not specified, the target is ${OFS_ROOTDIR}/work.\n\nThe -k option preserves and rebuilds within an existing work tree instead of overwriting it.\n\nWhen -p is set, if the FIM is able then a partial reconfiguration template tree is generated at the end of the FIM build. The PR template tree is located in the top of the work directory but is relocatable\n  and uses only relative paths. See ofs-common/scripts/common/syn/generate_pr_release.sh for details.\n\nThe -e option runs only Quartus analysis and elaboration.\n\n* target_configuration - Specifies the project  For example: d5005\n\n* work_dir - Work Directory for this build in the form a directory name. It is created in the &lt;local repo directory&gt;/ofs-d5005/&lt;work_dir&gt; - NOTE: The directory name must start with \"work\".  If the work directory exists, then the script stops and asks if you want to overwrite the directory.\n            - e.g.\n                - ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005\n\nwork directory as a name will be created in &lt;local repo directory&gt;/ofs-d5005/work_d5005\n\nThe obmission of &lt;work_dir&gt; results in a default work directory (&lt;local repo  directory&gt;/ofs-d5005/work)\n- compile reports and artifacts (.rpt, .sof, etc) are stored in &lt;work_dir&gt;/syn/syn_top/output_files\n\n- There is a log file created in ofs-d5005 directory.  - [-p]  Optional switch for creation of a relocatable PR build tree supporting the creation of a PR-able AFU workload.   The \"-p\" switch invokes generate_pr_release.sh at the end of the FIM build and writes the PR build tree to the top of the work directory.  More information on this option is provided below. </code></pre> In the next example, you will build the provided example design using a flat, non-PR build flow.</p> <p>Build the provided base example design:</p> <pre><code>cd $OFS_BUILD_ROOT/ofs-d5005\n\nofs-common/scripts/common/syn/build_top.sh d5005 work_d5005\n</code></pre> <p><pre><code>    ... build takes ~5 hours to complete\nCompile work directory:     &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top\nCompile artifact directory: &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top/output_files\n\n***********************************\n***\n***        OFS_PROJECT: d5005\n***        Q_PROJECT:  d5005\n***        Q_REVISION: d5005\n***        SEED: 03\n***        Build Complete\n***        Timing Passed!\n***\n***********************************\n</code></pre> The build script copies the ipss, sim, src and syn directories to the specified work directory and then these copied files are used in the Quartus compilation process.  Do not edit the files in the work directory, these files are copies of source files.</p> <p>Some of the key files are described below:</p> <p>/syn/syn_top ==  <pre><code>\u251c\u2500\u2500 syn_top                    // D5005 Quartus build area with Quartus files used this build\n\u2502\u00a0\u00a0\u251c\u2500\u2500 d5005.ipregen.rpt       // IP regeneration report states the output of IP upgrade\n\u2502\u00a0\u00a0\u251c\u2500\u2500 d5005.qpf               // Quartus Project File (qpf) mentions about Quartus version and project revision\n\u2502  \u251c\u2500\u2500 d5005.qsf               // Quartus Settings File (qsf) lists current project settings and entity level assignments\n\u2502\u00a0\u00a0\u251c\u2500\u2500 d5005.stp               // Signal Tap file included in the d5005.qsf. This file can be modified as required if you need to add an Signal Tap instance\n\u2502\u00a0\u00a0\u251c\u2500\u2500 fme_id.mif              // the fme id hex value is stored in a mif file format\n\u2502  \u251c\u2500\u2500 Intel OFS_pr_afu.json        // PR JSON file\n\u2502\u00a0\u00a0\u251c\u2500\u2500 Intel OFS_pr_afu.qsf                // PR AFU qsf file\n\u2502\u00a0\u00a0\u251c\u2500\u2500 Intel OFS_pr_afu_sources.tcl        // AFU source file list\n\u2502\u00a0\u00a0\u251c\u2500\u2500 ip_upgrade_port_diff_reports   // IP upgrade report files for reference\n</code></pre> /syn/syn_top/output_files == Directory with build reports and FPGA programming files.  <p>The programming files consist of the Quartus generated d5005.sof and d5005.pof.  The D5005 board hardware provides a 2 Gb flash device to store the FPGA programming files and a MAX10 BMC that reads this flash and programs the D5005 Intel\u00ae Stratix 10\u00ae FPGA FPGA. The syn/build_top.sh script runs script file syn/syn_top/build_flash/build_flash.s which takes the Quartus generated d5005.sof and creates binary files in the proper format to be loaded into the 2 Gb flash device.  You can also run build_flash.sh by yourself if needed.  The build_flash  script runs PACSign (if installed) to create an unsigned FPGA programming file that can be stored in the D5005 FPGA flash. Please note, if the D5005 has the root entry hash key loaded, then PACsign must be run with d5005_page1.bin as the input with the proper key to create an authenticated FPGA binary file.  Please see Security User Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA for details on the security aspects of Intel\u00ae Open FPGA Stack.</p> <p>The following table provides further detail on the generated bin files.</p> File Description d5005.sof This is the Quartus generated programming file created by Quartus synthesis and place and route.  This file can be used to programming the FPGA using a JTAG programmer.  This file is used as the source file for the binary files used to program the FPGA flash. d5005.bin This is an intermediate raw binary image of the FPGA d5005_page1.bin This is the binary file created from input file, d5005.sof.  This file is used as the input file to the PACSign utility to generate d5005_page1_unsigned.bin binary image file. d5005_page1_unsigned.bin This is the unsigned PACSign output which can be programmed into the FPGA flash of an unsigned D5005 usign the OPAE SDK utility fpgasupdate mfg_d5005_reversed.bin A special programming file for a third party programming device used in board manufacturing.  This file is typically not used. <p>build/output_files/timing_report == Directory containing clocks report, failing paths and passing margin reports</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#423-relocatable-pr-directory-tree","title":"4.2.3. Relocatable PR Directory Tree","text":"<p>If you are developing a FIM to be used by another team developing the AFU workload, scripts are provided that create a relocatable PR directory tree. ODM and board developers will make use of this capability to enable a broad set of AFUs to be loaded on a board using PR.  The relocatable PR directory contains the Quartus *.qdb file that goes the FIM.</p> <p>The creation of the relocatable PR directory tree requires a clone of the Intel Basic Building Blocks (BBB) repository. The OFS_PLATFORM_AFU_BBB environment variable must point to the repository, for example.</p> <pre><code>cd $OFS_BUILD_ROOT\ngit clone https://github.com/OPAE/ofs-platform-afu-bbb\ncd ofs-platform-afu-bbb\nexport OFS_PLATFORM_AFU_BBB=$PWD\ncd $OFS_ROOTDIR\n</code></pre> <p>You can create this relocatable PR directory tree by either:</p> <ul> <li>Build FIM and AFU using /syn/build_top.sh followed by running./ofs-common/scripts/common/syn/generate_pr_release.sh</li> <li>Build FIM and AFU using /syn/build_top.sh with optional -p switch included</li> </ul> <p>The generate_pr_release.sh has the following command structure:</p> <p><pre><code>./ofs-common/scripts/common/syn/generate_pr_release.sh -t &lt;path to generated release tree&gt; *Board Build Target* &lt;work dir from build_top.sh&gt;\n\nWhere:\n\n-t &lt;path to generated release tree&gt; = location for your relocatable PR directory tree\n*Board Build Target* is the name of the board target/FIM e.g. d5005\n&lt;work dir from build_top.sh&gt; </code></pre> Here is an example of running the generate_pr_release.sh script:</p> <p><pre><code>ofs-common/scripts/common/syn/generate_pr_release.sh -t work_d5005/build_tree d5005  work_d5005\n</code></pre> <pre><code>**********************************\n********* ENV SETUP **************\n\nFIM Project:\n  OFS_PROJECT = d5005\n  OFS_FIM     = .\n  OFS_BOARD   = .\n  Q_PROJECT   = d5005\n  Q_REVISION  = d5005\n  Fitter SEED = 03\nFME id\n  BITSTREAM_ID = 04010002c7cab852\n  BITSTREAM_MD = 0000000002204283\n...\n...\n</code></pre> The resulting relocatable build tree has the following structure: <pre><code>.\n\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_synth\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 build_env_config\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 run.sh -&gt; afu_synth\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 update_pim\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 blue_bits\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 d5005_page1_unsigned.bin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 d5005.sof -&gt; ../lib/build/syn/syn_top/output_files/d5005.sof\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 lib\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 build\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 fme-ifc-id.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 fme-platform-class.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 platform\n</code></pre></p> <p>This build tree can be moved to a different location and used for AFU development of a PR capable AFU to be used with this board.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#424-unit-level-simulation","title":"4.2.4. Unit Level Simulation","text":"<p>Unit level simulation of key components is provided. These simulations provide verification of the following areas:</p> <ul> <li>HSSI</li> <li>PCIe</li> <li>External Memory</li> <li>FIM management</li> </ul> <p>These simulations use the Synopsys VCS simulator. Each simulation contains a readme file explaining how to run the simulation. Refer to Simulation User Guide: Open FPGA Stack for Intel Intel\u00ae Stratix 10\u00ae FPGA  for details of simulation examples. Your simulation shell requires Python, Quartus, and VCS to run.  To run a simulation of the dfh_walker that simulates host access to the internal DFH registers, perform the following steps:</p> <pre><code>Before running unit simulation, you must set environment variables as described below:\ncd $OFS_BUILD_ROOT/ofs-d5005\nexport OFS_ROOTDIR=$PWD\n##   *Note, OFS_ROOTDIR is the directory where you cloned the repo, e.g. /home/MyProject/ofs-d5005 *\nexport WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\n##   *Note, QUARTUS_ROOTDIR is your Quartus installation directory, e.g. $QUARTUS_ROOTDIR/bin contains Quartus executuable*\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport OPAE_SDK_REPO_BRANCH=release/2.5.0\n</code></pre> <p>To compile all IPs:</p> <p>To Generate Simulation Files &amp; compile all IPs, run the following command:</p> <p><pre><code>cd $OFS_ROOTDIR/ofs-common/scripts/common/sim\nsh gen_sim_files.sh d5005\n</code></pre> The RTL file list for unit_test is located here: $OFS_ROOTDIR/sim/scripts/rtl_comb.f</p> <p>The IPs are generated here: </p> <p><pre><code>$OFS_ROOTDIR/sim/scripts/qip_gen\n</code></pre> The IP simulation filelist is generated here: </p> <p><pre><code>$OFS_ROOTDIR/sim/scripts/ip_flist.f\n</code></pre> Once the IPs are generated, they can be used for any unit test.</p> <p>To run the simulation, run the following command:</p> <p><pre><code>cd $OFS_ROOTDIR/sim/unit_test/&lt;Unit Test Name&gt;/scripts\nsh run_sim.sh VCS=1\n</code></pre> Simulation files are located in the sim/unit_test//sim directory. <p>To view simulation waveform:</p> <pre><code>cd $OFS_ROOTDIR/sim/unit_test/&lt;test_name&gt;/script/sim/unit_test/&lt;test_name&gt;/scripts/sim_vcs\ndve -full64 -vpd vcdplus.vpd &amp;\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#4241-dfh-walking-unit-simulation-output","title":"4.2.4.1. DFH Walking Unit Simulation Output","text":"<pre><code>********************************************\n Running TEST(0) : test_fme_dfh_walking\n********************************************\nREAD64: address=0x00000000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x4000000010000000\n\nFME_DFH\n   Address   (0x0)\nDFH value (0x4000000010000000)\nREAD64: address=0x00001000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000020000001\n\nTHERM_MNGM_DFH\n   Address   (0x1000)\nDFH value (0x3000000020000001)\nREAD64: address=0x00003000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000010000007\n\nGLBL_PERF_DFH\n   Address   (0x3000)\nDFH value (0x3000000010000007)\nREAD64: address=0x00004000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x30000000c0001004\n\nGLBL_ERROR_DFH\n   Address   (0x4000)\nDFH value (0x30000000c0001004)\nREAD64: address=0x00010000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x300000010000000e\n\nSPI_DFH\n   Address   (0x10000)\nDFH value (0x300000010000000e)\nREAD64: address=0x00020000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000100000020\n\nPCIE_DFH\n   Address   (0x20000)\nDFH value (0x3000000100000020)\nREAD64: address=0x00030000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x300000010000100f\n\nHSSI_DFH\n   Address   (0x30000)\nDFH value (0x300000010000100f)\nREAD64: address=0x00040000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000500000009\n\nEMIF_DFH\n   Address   (0x40000)\nDFH value (0x3000000500000009)\nREAD64: address=0x00090000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000010001005\n\nFME_PR_DFH\n   Address   (0x90000)\nDFH value (0x3000000010001005)\nREAD64: address=0x00091000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x4000000010001001\n\nPORT_DFH\n   Address   (0x91000)\nDFH value (0x4000000010001001)\nREAD64: address=0x00092000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000010000014\n\nUSER_CLOCK_DFH\n   Address   (0x92000)\nDFH value (0x3000000010000014)\nREAD64: address=0x00093000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x30000000d0002013\n\nPORT_STP_DFH\n   Address   (0x93000)\nDFH value (0x30000000d0002013)\nREAD64: address=0x000a0000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000010000002010\n\nAFU_INTF_DFH\n   Address   (0xa0000)\nDFH value (0x3000010000002010)\nMMIO error count matches: x\n\nTest status: OK\n\n********************\n  Test summary\n********************\n   test_fme_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n</code></pre> <p>The simulation transcript is displayed while the simulation runs.  The transcript is saved to the file transcript.out for review after the simulation completes.  The simulation waveform database is saved as vcdplus.vpd for post simulation review. You are encouraged to run the additional simulation examples to learn about each key area of the OFS shell.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#43-compiling-the-ofs-fim-using-eval-script","title":"4.3. Compiling the OFS FIM using Eval Script","text":"<p>The Evaluation Script provides resources to setup and report D5005 development environment. You can use the evaluation script to compile and simulate the FIM. Refer to README_ofs_d5005_eval.txt) for details of using the evaluation script.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#44-debugging","title":"4.4. Debugging","text":"<p>For debugging issues within the FIM, Signal Tap can be used to gain internal visibility into your design.  This section describes the process of adding a Signal Tap instance to your FIM design</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#441-signal-tap-prerequisites","title":"4.4.1. Signal Tap Prerequisites","text":"<p>To use Signal Tap with OFS, you will need the following:</p> <ul> <li>Understanding of Signal Tap fundamentals - please review Quartus Prime Pro Edition User Guide: Debug Tools. section 2. Design Debugging with the Signal Tap Logic Analyzer.</li> </ul> <ul> <li>The Intel\u00ae FPGA PAC D5005 has a built in Intel FPGA Download Cable II allowing JTAG access to the S10 FPGA. You can access the D5005 built in Intel FPGA Download Cable II by connecting your server to the Micro USB connector as shown below:</li> </ul> <p></p> <ul> <li>If you are using a custom board without a built-in Intel FPGA Download Cable then an external Intel FPGA Download Cable II (see Download Cables for more information) can be used for Signal Tap access.  The custom board must have JTAG access to the target FPGA for the Intel FPGA Download Cable II.</li> </ul>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#442-adding-signal-tap","title":"4.4.2. Adding Signal Tap","text":"<p>The following steps guide you through the process of adding a Signal Tap instance to your design.  The added Signal Tap instance provides hardware to capture the desired internal signals and connect the stored trace information via JTAG.  Please be aware, the added Signal Tap hardware will consume FPGA resources and may require additional floorplanning steps to accommodate these resources.  Some areas of the FIM use logic lock regions and these regions may need to be re-sized. These steps assume the use of the Intel\u00ae FPGA PAC D5005.</p> <ol> <li>Perform a full compile using the script build_top.sh.</li> <li>Once the compile completes open the Quartus GUI using the FIM project.  The Quartus project is named d5005 and is located in the work directory syn/syn_top/d5005.qpf.  Once the project is loaded, go to Tools &gt; Signal Tap Logic Analyzer to bring up the Signal Tap GUI.</li> </ol> <p></p> <ol> <li>Accept the \"Default\" selection and click \"Create\".</li> </ol> <p></p> <ol> <li>This brings up Signal Tap Logic Analyzer window as shown below:</li> </ol> <p></p> <ol> <li>Set up clock for STP instance.  In this example, the EMIF CSR module is being instrumented.  If unfamiliar with code, it is helpful to use the Quartus Project Navigator to find the specific block of interest and open the design instance for review.  For example, see snip below using Project Navigator to open emif_csr block:</li> </ol> <p> </p> <ol> <li>After reviewing code, assign clock for sampling Signal Tap instrumented signals of interest.  Note, the clock selected and the signals you want to view should be the same for best trace fidelity.  Different clocks can be used however there maybe issues with trace inaccuracy due sampling time differences.  In the middle right of the Signal Tap window under Signal Configuration, Clock:  select \"\u2026\" as shown below: </li> </ol> <p></p> <ol> <li>After reviewing code, assign clock for sampling Signal Tap instrumented signals of interest.  In the middle right of the Signal Tap window under Signal Configuration, Clock:  select \"\u2026\" as shown below:   This brings up the Node Finder tool.  Input \"emif_csr\" into Named and select \"Search\".  This brings up all nodes from the pre-synthesis view.  Expand, \"mem\" and \"emif_csr\" and scroll through this list to become familiar with nodes, and then select csr_if.clk and click \"&gt;\"  to select this clock as shown below and click \"OK\": </li> </ol> <p></p> <ol> <li>Update the sample depth and other Signal Tap settings as needed for your debugging criteria.</li> </ol> <p></p> <ol> <li>In the Signal Tap GUI add nodes to be instrumented by double clicking on \"Double-click to add nodes\".</li> </ol> <p></p> <ol> <li>This brings up the Node Finder.  Add signals to be traced by the Signal Tap instance.  Click \"Insert\" to add the signals.</li> <li>To provide a unique name for your Signal Tap instance, select \"auto signaltap_0\", right click and select rename instance and provide a descriptive name for your instance.</li> <li>Save the newly created Signal Tap file and click \"Yes\" to add the new Signal Tap file to the project.</li> <li>Compile the project with the Signal Tap file added to the project.</li> <li>Once the compile successfully completes with proper timing, you can load the generated d5005.sof using the Intel FPGA Downloader cable.</li> </ol>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#443-signal-tap-trace-acquisition","title":"4.4.3. Signal Tap trace acquisition","text":"<p>To acquire signals using SignalTap, first load the Signal Tap instrumented SOF file into your target board, open the STP file in the Signal Tap GUI and start the signal acquisition. </p> <p>Avoid system hang during programming the sof file, mask AER regsiter using below steps </p> <p>Find Root complex - End Point mapping using the below command</p> <pre><code>lspci -vt\n</code></pre> <pre><code>+-[0000:3a]-+-00.0-[3b-3c]----00.0  Intel Corporation Device bcce\n |           +-05.0  Intel Corporation Sky Lake-E VT-d\n |           +-05.2  Intel Corporation Sky Lake-E RAS Configuration Registers\n |           +-05.4  Intel Corporation Sky Lake-E IOxAPIC Configuration Registers\n |           +-08.0  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-09.0  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.0  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.1  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.2  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.3  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.4  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.5  Intel Corporation Sky Lake-E LM Channel 1\n</code></pre> <p>Use the bus information from the lspci logs to mask the AER (Advanced Error Reporting) register</p> <pre><code>sudo su\n\nsetpci -s 0000:3b:00.0 ECAP_AER+0x08.L=0xFFFFFFFF setpci -s 0000:3b:00.0 ECAP_AER+0x14.L=0xFFFFFFFF\nsetpci -s 0000:3a:00.0 ECAP_AER+0x08.L=0xFFFFFFFF\nsetpci -s 0000:3a:00.0 ECAP_AER+0x14.L=0xFFFFFFFF\necho \"1\" &gt; /sys/bus/pci/devices/0000:3b:00.0/remove\n\nexit\n</code></pre> <ol> <li>The SOF file is located in the work directory work_d5005/syn/syn_top/output_files/d5005.sof.  If the target FPGA is on a different server, then transfer d5005.sof and STP files to the server with the target FPGA. Load the SOF using the Intel\u00ae FPGA PAC D5005 built-in Intel FPGA Download Cable II. </li> </ol> <pre><code>sudo su\necho \"1\" &gt; /sys/bus/pci/rescan\n</code></pre> <ol> <li>Make sure D5005 is present by checking expected bitstream ID using command:</li> </ol> <pre><code>sudo fpgainfo fme\nIntel FPGA Programmable Acceleration Card D5005\nBoard Management Controller, MAX10 NIOS FW version: 2.0.13 Board Management Controller, MAX10 Build version: 2.0.8 //****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x40100022C164DB1\nBitstream Version                : 4.0.1\nPr Interface Id                  : 210a4631-18bb-57d1-879f-2c3d59b26e37\nBoot Page                        : user\n</code></pre> <ol> <li>Once the SOF file is loaded, start the Quartus Signal Tap GUI.</li> </ol> <p><pre><code>quartus_stpw\n</code></pre> The Signal Tap GUI comes up.</p> <ol> <li>In the Signal Tap GUI, <code>Hardware:</code> selection box select the cable \"Stratix10 Darby Creek [ JTAG cable number ]\" as shown below:</li> </ol> <p></p> <ol> <li>In <code>File</code> open your STP file.  Your STP file settings will load.  If not already set, you can create the trigger conditions, then start analysis with <code>F5</code>.</li> </ol> <p></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#5-fim-modification-example","title":"5. FIM Modification Example","text":"<p>An example of FIM modification is provided in this section.  This example can be used in your specific application as a starting point.  This example shows the basic flow and listing of files that are to be changed.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#51-hello-fim-example","title":"5.1. Hello FIM example","text":"<p>If you intend to add a new module to the FIM area, then you will need to inform the host software of the new module.  The FIM exposes its functionalities to host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO).  This set of CSR registers and their operation is described in FIM MMIO Regions.</p> <p>See FPGA Device Feature List (DFL) Framework Overview for a description of the software process to read and process the linked list of Device Feature Header (DFH) CSRs within a FPGA.</p> <p>This example adds a simple DFH register set to the FIM. You can use this example as the basis for adding a new feature to your FIM.  </p> <p>The steps to add this simple DFH register are described below.</p> <ol> <li>Review current design documentation: OFS Tech Ref MMIO Regions</li> <li>Understand FME and Port regions, DFH walking, DFH register structure </li> <li>Run unit level simulations and review output:             i.  sim/unit_test/dfh_walker</li> <li>Note DFH link list order, see DFH Walker Unit Level Simulation Output</li> <li>Make code changes to top level FIM file to instantiate new DFH register</li> <li>The DFH registers follow a link list.  This example inserts the hello_fim DFH register after the EMIF DFH register, so the emif_csr.sv parameters are updated to insert the hello_fim DFH register as next register in the link list.</li> <li>Create the new hello_fim SystemVerilog files.</li> <li>Update and run the dfh_walker unit simulation files</li> <li>Update synthesis files to include the new hello_fim source files</li> <li>Build and test the new FIM</li> </ol> <p>The following sections describe changes to add the hello_fim DFH example to the Intel provided FPGA design.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#511-srctopiofs_topsv","title":"5.1.1. src/top/iofs_top.sv","text":"<ol> <li>Edit top level design module: src/top/iofs_top.sv<ol> <li>Instantiate new hello_fim module in OFS_top.sv at line 294</li> </ol> </li> </ol> <pre><code>//*******************************\n// FME\n//*******************************\nfme_top fme_top(\n.clk               (clk_1x                    ),\n.rst_n             (rst_n_d_1x       ),\n.pwr_good_n        (ninit_done                ),\n.i_pcie_error      ('0                        ),\n.axi_lite_m_if     (bpf_fme_mst_if            ),\n.axi_lite_s_if     (bpf_fme_slv_if            )\n);\n`ifdef INCLUDE_HELLO_FIM\nhello_fim_top hello_fim_top (\n.clk   (clk_1x),\n.rst_n                      (rst_n_d_1x),\n.csr_lite_if             (bpf_rsv_5_slv_if)\n);\n`endif\n//*******************************\n// AFU\n//*******************************\n</code></pre> <p>You will connect the Hello_FIM DFH register to the existing BPF reserved link 5.  The provided OFS reference design includes 3 reserved BPF interfaces available for custom usage such as new OPAE controlled modules.  The address map of BPF is shown below:</p> Address Size (Byte) Feature Master 0x00000 \u2013 0x0FFFF 64K FME (FME, Error, etc) Yes 0x10000 \u2013 0x1FFFF 64K PMCI Proxy (SPI Controller) Yes 0x20000 \u2013 0x2FFFF 64K PCIe CSR 0x30000 \u2013 0x3FFFF 64K HSSI CSR 0x40000 \u2013 0x4FFFF 64K EMIF CSR 0x50000 \u2013 0x5FFFF 64K Reserved 0x60000 \u2013 0x6FFFF 64K Reserved 0x70000 \u2013 0x7FFFF 64K Reserved <p>The BPF reserved link 5 is connected to a dummy connection to prevent this link from being optimized out the design during synthesis.  You will add a compiler `define that will cause this dummy connection to be removed when the variable INCLUDE_HELLO_FIM is defined by editing line 575 if iofs_top.sv as shown below:</p> <pre><code>    // Reserved address response\n`ifndef INCLUDE_HELLO_FIM\nbpf_dummy_slv\nbpf_rsv_5_slv (\n.clk            (clk_1x),\n.dummy_slv_if   (bpf_rsv_5_slv_if)\n);\n`endif\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#512-ipssmememif_csrsv","title":"5.1.2. ipss/mem/emif_csr.sv","text":"<p>The Hello_FIM DFH is inserted in the DFH link list after the EMIF CSR DFH and before the FME_PR DFH.  The file ipss/d5005/emif/emif_csr.sv contains a parameter defining the next address for the next DFH in in the link list chain.  You will change the next address offset to be 0x10000 so the reveserved BPF AXI lite link connected to the Hello_FIM DFH register is next in the DFH link list.</p> <pre><code>module emif_csr #(\nparameter NUM_LOCAL_MEM_BANKS = 1,\nparameter END_OF_LIST         = 1'b0,\n`ifndef INCLUDE_HELLO_FIM\nparameter NEXT_DFH_OFFSET     = 24'h05_0000\n`else\nparameter NEXT_DFH_OFFSET     = 24'h01_0000//New for Hello_FIM, next offset now at 0x50000\n`endif\n)\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#513-srchello_fimhello_fim_topsv","title":"5.1.3. src/hello_fim/hello_fim_top.sv","text":"<p>Create hello_fim_top.sv, and store it in src/hello_fim directory. The main purpose of this RTL is to convert AXI4-Lite interface to a simple interface to interface with the registers in hello_fim_com.sv.  This register sets the DFH feature ID to 0xfff which is undefined.  Since this for test purposes, using an undefined feature ID will result in no driver being used.  Normally, a defined feature ID will be used to associate a specific driver with the FPGA module.</p> <pre><code>// ***************************************************************************\n//                               INTEL CONFIDENTIAL\n//\n//        Copyright (C) 2021 Intel Corporation All Rights Reserved.\n//\n// The source code contained or described herein and all  documents related to\n// the  source  code  (\"Material\")  are  owned  by  Intel  Corporation  or its\n// suppliers  or  licensors.    Title  to  the  Material  remains  with  Intel\n// Corporation or  its suppliers  and licensors.  The Material  contains trade\n// secrets  and  proprietary  and  confidential  information  of  Intel or its\n// suppliers and licensors.  The Material is protected  by worldwide copyright\n// and trade secret laws and treaty provisions. No part of the Material may be\n// used,   copied,   reproduced,   modified,   published,   uploaded,  posted,\n// transmitted,  distributed,  or  disclosed  in any way without Intel's prior\n// express written permission.\n//\n// No license under any patent,  copyright, trade secret or other intellectual\n// property  right  is  granted  to  or  conferred  upon  you by disclosure or\n// delivery  of  the  Materials, either expressly, by implication, inducement,\n// estoppel or otherwise.  Any license under such intellectual property rights\n// must be express and approved by Intel in writing.\n//\n// You will not, and will not allow any third party to modify, adapt, enhance, \n// disassemble, decompile, reverse engineer, change or create derivative works \n// from the Software except and only to the extent as specifically required by \n// mandatory applicable laws or any applicable third party license terms \n// accompanying the Software.\n//\n// -----------------------------------------------------------------------------\n// Engineer     : \n// Create Date  : Nov 2021\n// Module Name  : hello_fim_top.sv\n// Project      : OFS\n// -----------------------------------------------------------------------------\n//\n// Description: \n// This is a simple module that implements DFH registers and \n// AVMM address decoding logic.\nmodule hello_fim_top  #(\nparameter ADDR_WIDTH  = 12, parameter DATA_WIDTH = 64, parameter bit [11:0] FEAT_ID = 12'hfff,\nparameter bit [3:0]  FEAT_VER = 4'h0,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h04_0000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput  logic    clk,\ninput  logic    rst_n,\n// -----------------------------------------------------------\n//  AXI4LITE Interface\n// -----------------------------------------------------------\nofs_fim_axi_lite_if.slave   csr_lite_if\n);\nimport ofs_fim_cfg_pkg::*;\nimport ofs_csr_pkg::*;\n//-------------------------------------\n// Signals\n//-------------------------------------\nlogic [ADDR_WIDTH-1:0]              csr_waddr;\nlogic [DATA_WIDTH-1:0]              csr_wdata;\nlogic [DATA_WIDTH/8-1:0]            csr_wstrb;\nlogic                               csr_write;\nlogic                               csr_slv_wready;\ncsr_access_type_t                   csr_write_type;\nlogic [ADDR_WIDTH-1:0]              csr_raddr;\nlogic                               csr_read;\nlogic                               csr_read_32b;\nlogic [DATA_WIDTH-1:0]              csr_readdata;\nlogic                               csr_readdata_valid;\nlogic [ADDR_WIDTH-1:0]              csr_addr;\nlogic [63:0]                        com_csr_writedata;\nlogic                               com_csr_read;\nlogic                               com_csr_write;\nlogic [63:0]                        com_csr_readdata;\nlogic                               com_csr_readdatavalid;\nlogic [5:0]                         com_csr_address;\n// AXI-M CSR interfaces\nofs_fim_axi_mmio_if #(\n.AWID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.AWADDR_WIDTH (ADDR_WIDTH),\n.WDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH),\n.ARID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.ARADDR_WIDTH (ADDR_WIDTH),\n.RDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH)\n) csr_if();\n// AXI4-lite to AXI-M adapter\naxi_lite2mmio axi_lite2mmio (\n.clk       (clk),\n.rst_n     (rst_n),\n.lite_if   (csr_lite_if),\n.mmio_if   (csr_if)\n);\n//---------------------------------\n// Map AXI write/read request to CSR write/read,\n// and send the write/read response back\n//---------------------------------\nofs_fim_axi_csr_slave #(\n.ADDR_WIDTH (ADDR_WIDTH),\n.USE_SLV_READY (1'b1)\n) csr_slave (\n.csr_if             (csr_if),\n.csr_write          (csr_write),\n.csr_waddr          (csr_waddr),\n.csr_write_type     (csr_write_type),\n.csr_wdata          (csr_wdata),\n.csr_wstrb          (csr_wstrb),\n.csr_slv_wready     (csr_slv_wready),\n.csr_read           (csr_read),\n.csr_raddr          (csr_raddr),\n.csr_read_32b       (csr_read_32b),\n.csr_readdata       (csr_readdata),\n.csr_readdata_valid (csr_readdata_valid)\n);\n// Address mapping\nassign csr_addr             = csr_write ? csr_waddr : csr_raddr;\nassign com_csr_address      = csr_addr[5:0];  // byte address\nassign csr_slv_wready       = 1'b1 ;\n// Write data mapping\nassign com_csr_writedata    = csr_wdata;\n// Read-Write mapping\nalways_comb\nbegin\ncom_csr_read             = 1'b0;\ncom_csr_write            = 1'b0;\ncasez (csr_addr[11:6])\n6'h00 : begin // Common CSR\ncom_csr_read       = csr_read;\ncom_csr_write      = csr_write;\nend   default: begin\ncom_csr_read       = 1'b0;\ncom_csr_write      = 1'b0;\nend\nendcase\nend\n// Read data mapping\nalways_comb begin\nif (com_csr_readdatavalid) begin\ncsr_readdata       = com_csr_readdata;\ncsr_readdata_valid = 1'b1;\nend\nelse begin\ncsr_readdata       = '0;\ncsr_readdata_valid = 1'b0;\nend\nend\nhello_fim_com  #(\n.FEAT_ID          (FEAT_ID),\n.FEAT_VER         (FEAT_VER),\n.NEXT_DFH_OFFSET  (NEXT_DFH_OFFSET),\n.END_OF_LIST      (END_OF_LIST)\n) hello_fim_com_inst (\n.clk                   (clk                     ),\n.rst_n                 (rst_n                  ),\n.writedata             (com_csr_writedata       ),\n.read                  (com_csr_read            ),\n.write                 (com_csr_write           ),\n.byteenable            (4'hF                    ),\n.readdata              (com_csr_readdata        ),\n.readdatavalid         (com_csr_readdatavalid   ),\n.address               (com_csr_address         )\n);\nendmodule\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#514-srchello_fimhello_fim_comsv","title":"5.1.4. src/hello_fim/hello_fim_com.sv","text":"<p>Create hello_fim_com.sv, and store it in src/hello_fim directory. This is the simple RTL to implement the Hello FIM registers. You may use this set of registers as the basis for your custom implementation.</p> <pre><code>// ***************************************************************************\n//                               INTEL CONFIDENTIAL\n//\n//        Copyright (C) 2021 Intel Corporation All Rights Reserved.\n//\n// The source code contained or described herein and all  documents related to\n// the  source  code  (\"Material\")  are  owned  by  Intel  Corporation  or its\n// suppliers  or  licensors.    Title  to  the  Material  remains  with  Intel\n// Corporation or  its suppliers  and licensors.  The Material  contains trade\n// secrets  and  proprietary  and  confidential  information  of  Intel or its\n// suppliers and licensors.  The Material is protected  by worldwide copyright\n// and trade secret laws and treaty provisions. No part of the Material may be\n// used,   copied,   reproduced,   modified,   published,   uploaded,  posted,\n// transmitted,  distributed,  or  disclosed  in any way without Intel's prior\n// express written permission.\n//\n// No license under any patent,  copyright, trade secret or other intellectual\n// property  right  is  granted  to  or  conferred  upon  you by disclosure or\n// delivery  of  the  Materials, either expressly, by implication, inducement,\n// estoppel or otherwise.  Any license under such intellectual property rights\n// must be express and approved by Intel in writing.\n//\n// You will not, and will not allow any third party to modify, adapt, enhance, \n// disassemble, decompile, reverse engineer, change or create derivative works \n// from the Software except and only to the extent as specifically required by \n// mandatory applicable laws or any applicable third party license terms \n// accompanying the Software.\n//\n// -----------------------------------------------------------------------------\n// Engineer     : \n// Create Date  : Nov 2021\n// Module Name  : hello_fim_com.sv\n// Project      : IOFS\n// -----------------------------------------------------------------------------\n//\n// Description: \n// This is a simple module that implements DFH registers and \n// AVMM address decoding logic.\nmodule hello_fim_com #(\nparameter bit [11:0] FEAT_ID = 12'h001,\nparameter bit [3:0]  FEAT_VER = 4'h1,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h1000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput clk,\ninput rst_n,\ninput [63:0] writedata,\ninput read,\ninput write,\ninput [3:0] byteenable,\noutput reg [63:0] readdata,\noutput reg readdatavalid,\ninput [5:0] address\n);\nreg [63:0] rdata_comb;\nreg [63:0] scratch_reg;\nalways @(posedge clk)  if (!rst_n) readdata[63:0] &lt;= 64'h0; else readdata[63:0] &lt;= rdata_comb[63:0];\nalways @(posedge clk)\nif (!rst_n) readdatavalid &lt;= 1'b0; else readdatavalid &lt;= read;\nwire wr = write;\nwire re = read;\nwire [5:0] addr = address[5:0];\nwire [63:0] din  = writedata [63:0];\nwire wr_scratch_reg = wr &amp; (addr[5:0]  == 6'h30)? byteenable[0]:1'b0;\n// 64 bit scratch register\nalways @( posedge clk)\nif (!rst_n)  begin\nscratch_reg &lt;= 64'h0;\nend\nelse begin\nif (wr_scratch_reg) begin scratch_reg &lt;=  din;  end\nend\nalways @ (*)\nbegin\nrdata_comb = 64'h0000000000000000;\nif(re) begin\ncase (addr)  6'h00 : begin\nrdata_comb [11:0]   = FEAT_ID ;  // dfh_feature_id  is reserved or a constant value, a read access gives the reset value\nrdata_comb [15:12]  = FEAT_VER ;  // dfh_feature_rev    is reserved or a constant value, a read access gives the reset value\nrdata_comb [39:16]  = NEXT_DFH_OFFSET ;  // dfh_dfh_ofst is reserved or a constant value, a read access gives the reset value\nrdata_comb [40]     = END_OF_LIST ;        //dfh_end_of_list\nrdata_comb [59:40]  = 20'h00000 ;  // dfh_rsvd1     is reserved or a constant value, a read access gives the reset value\nrdata_comb [63:60]  = 4'h3 ;  // dfh_feat_type  is reserved or a constant value, a read access gives the reset value\nend\n6'h30 : begin\nrdata_comb [63:0]   = scratch_reg; end\n6'h38 : begin\nrdata_comb [63:0]       = 64'h6626_0701_5000_0034;\nend\ndefault : begin\nrdata_comb = 64'h0000000000000000;\nend\nendcase\nend\nend\nendmodule\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#515-unit-level-simulations","title":"5.1.5. Unit Level Simulations","text":"<p>To run a unit level simulation test for the updated RTL files, make modifications to your cloned /my_ofs_project/ofs-d5005/sim/d5005/unit_test/dfh_walker files.  The following simulation files are updated to test the new hello_fim.</p> <ol> <li> <p>Edit sim/unit_test/dfh_walker/testbench/test_csr_defs.sv</p> <ol> <li>Update enum line 38</li> </ol> </li> </ol> <pre><code>       typedef enum {\nFME_DFH_IDX,\nTHERM_MNGM_DFH_IDX,\nGLBL_PERF_DFH_IDX,\nGLBL_ERROR_DFH_IDX,\nSPI_DFH_IDX,\nPCIE_DFH_IDX,\nHSSI_DFH_IDX,\nEMIF_DFH_IDX,\nHELLO_FIM_DFH_IDX,//New for HELLO_FIM\nFME_PR_DFH_IDX,\nPORT_DFH_IDX,\nUSER_CLOCK_DFH_IDX,\nPORT_STP_DFH_IDX,\nAFU_INTF_DFH_IDX,\nMAX_FME_DFH_IDX\n} t_fme_dfh_idx;\n</code></pre> <p>1. Edit function dfh_name line 78</p> <pre><code>function automatic dfh_name[MAX_FME_DFH_IDX-1:0] get_fme_dfh_names();\ndfh_name[MAX_FME_DFH_IDX-1:0] fme_dfh_names;\nfme_dfh_names[FME_DFH_IDX]         = \"FME_DFH\";\nfme_dfh_names[THERM_MNGM_DFH_IDX]  = \"THERM_MNGM_DFH\";\nfme_dfh_names[GLBL_PERF_DFH_IDX]   = \"GLBL_PERF_DFH\";\nfme_dfh_names[GLBL_ERROR_DFH_IDX]  = \"GLBL_ERROR_DFH\";\nfme_dfh_names[SPI_DFH_IDX]         = \"SPI_DFH\";\nfme_dfh_names[PCIE_DFH_IDX]        = \"PCIE_DFH\";\nfme_dfh_names[HSSI_DFH_IDX]        = \"HSSI_DFH\";\nfme_dfh_names[EMIF_DFH_IDX]        = \"EMIF_DFH\";\nfme_dfh_names[HELLO_FIM_DFH_IDX]        = \"HELLO_FIM_DFH\";//New for HELLO_FIM\nfme_dfh_names[FME_PR_DFH_IDX]      = \"FME_PR_DFH\";\nfme_dfh_names[PORT_DFH_IDX]        = \"PORT_DFH\";\nfme_dfh_names[USER_CLOCK_DFH_IDX]  = \"USER_CLOCK_DFH\";\nfme_dfh_names[PORT_STP_DFH_IDX]    = \"PORT_STP_DFH\";\nfme_dfh_names[AFU_INTF_DFH_IDX]    = \"AFU_INTF_DFH\";\nreturn fme_dfh_names;\nendfunction\n</code></pre> <p>1. Update get_fme_dfh_values</p> <pre><code>  function automatic [MAX_FME_DFH_IDX-1:0][63:0] get_fme_dfh_values();\nlogic[MAX_FME_DFH_IDX-1:0][63:0] fme_dfh_values;\nfme_dfh_values[FME_DFH_IDX]        = 64'h4000_0000_1000_0000;\nfme_dfh_values[THERM_MNGM_DFH_IDX] = 64'h3_00000_002000_0001;\nfme_dfh_values[GLBL_PERF_DFH_IDX]  = 64'h3_00000_001000_0007;\nfme_dfh_values[GLBL_ERROR_DFH_IDX] = 64'h3_00000_00C000_1004;  fme_dfh_values[SPI_DFH_IDX]        = 64'h3_00000_010000_000e;  fme_dfh_values[PCIE_DFH_IDX]       = 64'h3_00000_010000_0020;  fme_dfh_values[HSSI_DFH_IDX]       = 64'h3_00000_010000_100f;  fme_dfh_values[EMIF_DFH_IDX]       = 64'h3_00000_010000_0009; //Update to link to Hello_FIM \nfme_dfh_values[HELLO_FIM_DFH_IDX]  = 64'h3_00000_040000_0FFF;  //New for Hello_FIM\nfme_dfh_values[FME_PR_DFH_IDX]     = 64'h3_00000_001000_1005;  fme_dfh_values[PORT_DFH_IDX]       = 64'h4000_0000_1000_1001;\nfme_dfh_values[USER_CLOCK_DFH_IDX] = 64'h3_00000_001000_0014;\nfme_dfh_values[PORT_STP_DFH_IDX]   = 64'h3_00000_00D000_2013;\nfme_dfh_values[AFU_INTF_DFH_IDX]   = 64'h3_00001_000000_2010; return fme_dfh_values;\nendfunction\n</code></pre> <ol> <li>Update verification/scripts/Makefile_VCS.mk to set macro for INCLUDE_HELLO_FIM starting at line 56 to add +define+INCLUDE_HELLO_FIM <pre><code>VLOG_OPT += +define+SIM_MODE +define+VCS_S10 +define+RP_MAX_TAGS=64 +define+INCLUDE_DDR4 +define+INCLUDE_SPI_BRIDGE +define+INCLUDE_USER_CLOCK +define+INCLUDE_HSSI +define+SIM_USE_PCIE_DUMMY_CSR +define+INCLUDE_HELLO_FIM\n</code></pre></li> <li>Update sim/scripts/rtl_comb.f to add the path to your new hello_fim_top and hello_top_com SystemVerilog files.  The update is shown below as the new line - 329 below:</li> </ol> <pre><code>$WORKDIR/src/hello_fim/hello_fim_com.sv\n$WORKDIR/src/hello_fim/hello_fim_top.sv\n</code></pre> <p>After making these changes, run the unit level simulation using sim/unit_test/dfh_walker test.  Before running, ensure your shell has the environment variables set properly as defined in Setting Up Required Environment Variables.</p> <pre><code>cd verification/scripts\ngmake -f Makefile_VCS.mk cmplib\ngmake -f Makefile_VCS.mk build run [DUMP=1]\n</code></pre> <p>Expected output: <pre><code> ********************************************\n Running TEST(0) : test_fme_dfh_walking\n********************************************\nREAD64: address=0x00000000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x4000000010000000\n\nFME_DFH\n   Address   (0x0)\nDFH value (0x4000000010000000)\nREAD64: address=0x00001000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000020000001\n\nTHERM_MNGM_DFH\n   Address   (0x1000)\nDFH value (0x3000000020000001)\nREAD64: address=0x00003000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000010000007\n\nGLBL_PERF_DFH\n   Address   (0x3000)\nDFH value (0x3000000010000007)\nREAD64: address=0x00004000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x30000000c0001004\n\nGLBL_ERROR_DFH\n   Address   (0x4000)\nDFH value (0x30000000c0001004)\nREAD64: address=0x00010000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x300000010000000e\n\nSPI_DFH\n   Address   (0x10000)\nDFH value (0x300000010000000e)\nREAD64: address=0x00020000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000100000020\n\nPCIE_DFH\n   Address   (0x20000)\nDFH value (0x3000000100000020)\nREAD64: address=0x00030000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x300000010000100f\n\nHSSI_DFH\n   Address   (0x30000)\nDFH value (0x300000010000100f)\nREAD64: address=0x00040000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000100000009\n\nEMIF_DFH\n   Address   (0x40000)\nDFH value (0x3000000100000009)\nREAD64: address=0x00050000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000400000fff\n\nHELLO_FIM_DFH\n   Address   (0x50000)\nDFH value (0x3000000400000fff)\nREAD64: address=0x00090000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000010001005\n\nFME_PR_DFH\n   Address   (0x90000)\nDFH value (0x3000000010001005)\nREAD64: address=0x00091000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x4000000010001001\n\nPORT_DFH\n   Address   (0x91000)\nDFH value (0x4000000010001001)\nREAD64: address=0x00092000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000000010000014\n\nUSER_CLOCK_DFH\n   Address   (0x92000)\nDFH value (0x3000000010000014)\nREAD64: address=0x00093000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x30000000d0002013\n\nPORT_STP_DFH\n   Address   (0x93000)\nDFH value (0x30000000d0002013)\nREAD64: address=0x000a0000 bar=0 vf_active=0 pfn=0 vfn=0\nREADDATA: 0x3000010000002010\n\nAFU_INTF_DFH\n   Address   (0xa0000)\nDFH value (0x3000010000002010)\nMMIO error count matches: x\n\nTest status: OK\n\n********************\n  Test summary\n********************\n   test_fme_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#516-synsyn_topd5005qsf","title":"5.1.6. syn/syn_top/d5005.qsf","text":"<ol> <li> <p>Edit syn/syn_top/d5005.qsf      </p> <ol> <li> <p>Add new macro \"INCLUDE_HELLO_FIM\" line 107 <pre><code>        set_global_assignment -name VERILOG_MACRO \"INCLUDE_HELLO_FIM\"\n</code></pre></p> </li> <li> <p>Add new line 211 to source TCL script with new hello_fim files <pre><code>        set_global_assignment -name SOURCE_TCL_SCRIPT_FILE ../../../syn/setup/hello_fim_design_files.tcl\n</code></pre></p> </li> </ol> </li> </ol> <p>Create \"hello_fim_design_files.tcl\" file and store in the syn/setup directory. This tcl file is called from d5005.qsf.</p> <pre><code># Copyright 2021 Intel Corporation.\n#\n# THIS SOFTWARE MAY CONTAIN PREPRODUCTION CODE AND IS PROVIDED BY THE\n# COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# Hello FIM Files\n#--------------------\nset_global_assignment -name SYSTEMVERILOG_FILE src/hello_fim/hello_fim_com.sv\nset_global_assignment -name SYSTEMVERILOG_FILE src/hello_fim/hello_fim_top.sv\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#517-synsetuphello_fim_design_filestcl","title":"5.1.7. syn/setup/hello_fim_design_files.tcl","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#518-build-hello_fim-example","title":"5.1.8. Build hello_fim example","text":"<p>With the preceding changes complete, build the new hello_fim example using the following steps:</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh d5005 work_d5005_hello_fim\n</code></pre> <p>Verify the design successfully compiled and timing closure is achieved by checking work_d5005_hello_fim/syn/syn_top/output_files/timing_report/clocks.sta.fail.summary - this file should be empty.  If there are timing failures, then this file will list the failing clock domain(s).</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#519-test-the-hello_fim-on-a-d5005","title":"5.1.9. Test the hello_fim on a D5005","text":"<p>Load the built FPGA binary file using an unsigned image.  The FPGA image will be in work_d5005_hello_fim/syn/syn_top/output_files/d5005_page1_unsigned.bin</p> <p>Provide the file d5005_page1_unsigned.bin on the server with the Intel\u00ae FPGA PAC D5005.</p> <p><pre><code>sudo fpgasupdate d5005_page1_unsigned.bin &lt;D5005 PCIe B:D.F&gt;\nsudo rsu bmcimg &lt;D5005 PCIe B:D.F&gt;\n</code></pre> Verify FPGA image is loaded. <pre><code>sudo fpgainfo fme\n## Output\nIntel FPGA Programmable Acceleration Card D5005\nBoard Management Controller, MAX10 NIOS FW version: 2.0.13 Board Management Controller, MAX10 Build version: 2.0.8 //****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x40100022C164DB1\nBitstream Version                : 4.0.1\nPr Interface Id                  : 7d91e0d0-4dcd-58c3-a93d-b9295e6e29b0\nBoot Page                        : user\n</code></pre></p> <p>Use the OPAE SDK tool opae.io to check default driver binding using your card under test PCIe B:D.F.  The steps below will use 0000:12:00.0 as the card under test PCIe B:D.F.</p> <p><pre><code> sudo opae.io init -d 0000:12:00.0 $USER\n##Output\n[0000:12:00.0] (0x8086, 0xbcce) Intel D5005 ADP (Driver: dfl-pci)\n</code></pre> The dfl-pci driver is used by OPAE SDK fpgainfo commands.  The next steps will bind the card under test to the vfio driver to enable access to the registers.</p> <p><pre><code> sudo opae.io init -d 0000:12:00.0 $USER\n##Output\nopae.io 0.2.3\nUnbinding (0x8086,0xbcce) at 0000:12:00.0 from dfl-pci\nBinding (0x8086,0xbcce) at 0000:12:00.0 to vfio-pci\niommu group for (0x8086,0xbcce) at 0000:12:00.0 is 35\nAssigning /dev/vfio/35 to $USER\n</code></pre> Confirm the vfio driver is bound to the card under test.</p> <p><pre><code>opae.io ls\n## Output\nopae.io 0.2.3\n[0000:12:00.0] (0x8086, 0xbcce) Intel D5005 ADP (Driver: vfio-pci)\n</code></pre> Run the following command to walk DFH link list.  The new hello_fim register is located at offset 0x50000.</p> <p><pre><code>opae.io walk -d 0000:12:00.0\n## Output\nopae.io 0.2.3\noffset: 0x0000, value: 0x4000000010000000\n    dfh: id = 0x0, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4\noffset: 0x1000, value: 0x3000000020000001\n    dfh: id = 0x1, rev = 0x0, next = 0x2000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x3000, value: 0x3000000010000007\n    dfh: id = 0x7, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x4000, value: 0x30000000c0001004\n    dfh: id = 0x4, rev = 0x1, next = 0xc000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x10000, value: 0x300000010000000e\n    dfh: id = 0xe, rev = 0x0, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x20000, value: 0x3000000100000020\n    dfh: id = 0x20, rev = 0x0, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x30000, value: 0x300000010000100f\n    dfh: id = 0xf, rev = 0x1, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x40000, value: 0x3000000100000009\n    dfh: id = 0x9, rev = 0x0, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x50000, value: 0x3000000400000fff\n    dfh: id = 0xfff, rev = 0x0, next = 0x40000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x90000, value: 0x3000000010001005\n    dfh: id = 0x5, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x91000, value: 0x4000000010001001\n    dfh: id = 0x1, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4\noffset: 0x92000, value: 0x3000000010000014\n    dfh: id = 0x14, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x93000, value: 0x30000000d0002013\n    dfh: id = 0x13, rev = 0x2, next = 0xd000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0xa0000, value: 0x3000010000002010\n    dfh: id = 0x10, rev = 0x2, next = 0x0, eol = 0x1, reserved = 0x0, feature_type = 0x3\n</code></pre> Read the default values from the hello_fim registers:</p> <p><pre><code>$ opae.io -d 0000:12:00.0 -r 0 peek 0x50000\nopae.io 0.2.3\n0x3000000400000fff\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50030\nopae.io 0.2.3\n0x0\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50038\nopae.io 0.2.3\n0x6626070150000034\n</code></pre> Write the scratchpad register at 0x50030</p> <pre><code>$ opae.io -d 0000:12:00.0 -r 0 poke 0x50038 0x123456789abcdef\nopae.io 0.2.3\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50038\nopae.io 0.2.3\n0x6626070150000034\n$ opae.io -d 0000:12:00.0 -r 0 poke 0x50030 0x123456789abcdef\nopae.io 0.2.3\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50030\nopae.io 0.2.3\n0x123456789abcdef\n$ opae.io -d 0000:12:00.0 -r 0 poke 0x50030 0xfedcba9876543210\nopae.io 0.2.3\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50030\nopae.io 0.2.3\n0xfedcba9876543210\n$ opae.io -d 0000:12:00.0 -r 0 poke 0x50030 0x55550000aaaaffff\nopae.io 0.2.3\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50030\nopae.io 0.2.3\n0x55550000aaaaffff\n</code></pre> <p>Release the card under test from the vfio driver to re-bind to the dfl-pci driver:</p> <pre><code>sudo opae.io release -d 0000:12:00.0\n## Output\nopae.io 0.2.3\nReleasing (0x8086,0xbcce) at 0000:12:00.0 from vfio-pci\nRebinding (0x8086,0xbcce) at 0000:12:00.0 to dfl-pci\n$ sudo opae.io ls\nopae.io 0.2.3\n[0000:12:00.0] (0x8086, 0xbcce) Intel D5005 ADP (Driver: dfl-pci)\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#52-memory-subsystem-modification","title":"5.2. Memory Subsystem Modification","text":"<p>OFS enables modifications on the different subsystems that encompass the FIM. To customize the Memory Subsystem follow these instructions.</p> <ol> <li> <p>Set up the environment variables as described in section 4.2.1. Setting Up Required Environment Variables</p> </li> <li> <p>Modify the NUM_MEM_CH parameter in src/afu_top/mux/top_cfg_pkg.sv Change NUM_MEM_CH from 4 to 2 as shown in below code </p> </li> </ol> <pre><code>//=========================================================================================================================\n//                         OFS Configuration Parameters                                                                 \n//=========================================================================================================================\nparameter NUM_MEM_CH     = 2                                                 ,// Number of Memory/DDR Channel         \nNUM_HOST       = 1                                                 ,// Number of Host/Upstream Ports        \nNUM_PORT       = 4                                                 ,// Number of Functions/Downstream Ports \nDATA_WIDTH     = 512                                               ,// Data Width of Interface              \nTOTAL_BAR_SIZE = 20                                                ,// Total Space for APF/BPF BARs (2^N) \n//------------+-------------+-------------+-----------------+           //--------------------------------------\n// VF Active  |     PF #    |     VF #    |  Mux Port Map   |           //  PF/VF Mapping Parameters            \n//------------+-------------+-------------+-----------------+           //--------------------------------------\nCFG_VA = 0  , CFG_PF = 0  , CFG_VF =  0 ,  CFG_PID = 3    ,           //  Configuration Register Block        \nHLB_VA = 1  , HLB_PF = 0  , HLB_VF =  0 ,  HLB_PID = 0    ,           //  HE Loopback Engine                  \nPRG_VA = 1  , PRG_PF = 0  , PRG_VF =  1 ,  PRG_PID = 1    ,           //  Partial Reconfiguration Gasket      \nHSI_VA = 1  , HSI_PF = 0  , HSI_VF =  2 ,  HSI_PID = 2    ;           //  HSSI interface \n</code></pre> <p>Compile a new FIM that incorporates the newly configured Memory Subsystem. </p> <pre><code>cd $OFS_BUILD_ROOT/ofs-d5005\nofs-common/scripts/common/syn/build_top.sh d5005 work_d5005_mem_2channel\n</code></pre> <pre><code>***********************************\n***\n***        OFS_PROJECT: d5005\n***        Q_PROJECT:  d5005\n***        Q_REVISION: d5005\n***        SEED: 03\n***        Build Complete\n***        Timing Passed!\n***\n***********************************\n</code></pre> <p>Program d5005_page1_unsigned.bin file using below command</p> <pre><code>sudo fpgasupdate d5005_page1_unsigned.bin 3b:00.0\n</code></pre> <p>Run rsu command <pre><code>sudo rsu bmcimg 3b:00.0\n</code></pre></p> <p>Check if binary was loaded correctly <pre><code>fpgainfo fme\n## Output\nIntel FPGA Programmable Acceleration Card D5005\nBoard Management Controller, MAX10 NIOS FW version: 2.0.13\nBoard Management Controller, MAX10 Build version: 2.0.8\n//****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 288511862659474365\nBitstream Version                : 4.0.1\nPr Interface Id                  : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461\nBoot Page                        : user\n</code></pre></p> <p>Run Host Excersiser to check Memory Subsystem performance</p> <pre><code>sudo host_exerciser mem\n## Output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5365\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.054 GB/s\n    Test mem(1): PASS\n</code></pre> <p>Verify Memory controller placement in syn/syn_top/output_files/d5005.fit.place.rpt file. Open fitter place stage report in any text editor of your choice, find keyword emif in the file. You should see emif[0] &amp; emif[1] for Memory channel 0 &amp; 1 respectively.</p> <pre><code>|emif[0].ddr4_pr_freeze_sync|                ; 0.4 (0.0)            ; 0.5 (0.0)                        ; 0.1 (0.0)                            ;\n|resync_chains[0].synchronizer_nocut|        ; 0.4 (0.4)            ; 0.5 (0.5)                        ; 0.1 (0.1)                            ;\n|emif[0].ddr4_softreset_sync|                ; 0.5 (0.0)            ; 0.7 (0.0)                        ; 0.2 (0.0)                            ;\n|resync_chains[0].synchronizer_nocut|        ; 0.5 (0.5)            ; 0.7 (0.7)                        ; 0.2 (0.2)                            ;\n|emif[0].pr_frz_afu_avmm_if|                 ; 647.5 (647.5)        ; 917.3 (917.3)                    ; 272.8 (272.8)                        ;\n|emif[1].ddr4_pr_freeze_sync|                ; 0.4 (0.0)            ; 0.8 (0.0)                        ; 0.4 (0.0)                            ;\n|resync_chains[0].synchronizer_nocut|        ; 0.4 (0.4)            ; 0.8 (0.8)                        ; 0.4 (0.4)                            ;\n|emif[1].ddr4_softreset_sync|                ; 0.4 (0.0)            ; 1.0 (0.0)                        ; 0.6 (0.0)                            ;\n|resync_chains[0].synchronizer_nocut|        ; 0.4 (0.4)            ; 1.0 (1.0)                        ; 0.6 (0.6)                            ;\n|emif[1].pr_frz_afu_avmm_if|                 ; 641.1 (641.1)        ; 914.0 (914.0)                    ; 272.9 (272.9)                        ;\n|p[0].pr_frz_fn2mx_a_port|                   ; 435.4 (0.0)          ; 476.2 (0.0)                      ; 40.8 (0.0)                           ;\n|r.axis_pl_stage[0].axis_reg_inst|           ; 435.4 (435.4)        ; 476.2 (476.2)                    ; 40.8 (40.8)                          ;\n|p[0].pr_frz_fn2mx_b_port|                   ; 434.6 (0.0)          ; 494.3 (0.0)                      ; 59.6 (0.0)                           ;\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#6-conclusion","title":"6. Conclusion","text":"<p>Using the OFS reference design and OPAE SDK enables the rapid creation of market leading FPGA based Acceleration systems. OFS facilitates customization of the FIM area for your custom board or platforms. </p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/d5005/doc_modules/Glossary/","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/doc_modules/links/","title":"Links","text":"<p>example AFUs</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/","title":"FPGA Interface Manager Technical Reference Manual: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1-overview","title":"1 Overview","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document describes the hardware architecture of the\u200b Open FPGA Stack (OFS) targeting the Intel\u00ae Stratix 10 FPGA.  After reviewing this document you should understand the features and functions of the components that comprise the FPGA Interface Manager (FIM), also known as the \"shell.\"</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12-introduction-to-the-open-fpga-stack","title":"1.2 Introduction to the Open FPGA Stack","text":"<p>The Open FPGA Stack (OFS) is a modular collection of hardware platform components, open source upstreamed software, and broad ecosystem support that enables an efficient path to develop a custom FPGA platform.  OFS Provides a framework of FPGA synthesizable code, simulation environment and synthesis/simulation scripts.  The key components of OFS include: -   Target development platforms such as Intel-branded Programmable Acceleration Cards (PACs), Acceleration Development Platforms (ADPs) and third-party platforms.</p> <ul> <li>Board Management Controller RTL and firmware that supports telemetry monitoring, remote configuration updates and most importantly a root of trust for the platform.</li> </ul> <ul> <li>Source accessible, modular FPGA Interface  manager (FIM) RTL with unit tests that can be leveraged for your own custom FIM design</li> </ul> <ul> <li>Basic building blocks for interconnect and PF/VF translation and arbitration; Platform Interface Manager (PIM) which provides Avalon\u00ae bus compliant interfaces.</li> </ul> <ul> <li>AFU examples both in the git repository and workload examples provided by 3rd party vendors</li> </ul> <ul> <li>The OneAPI shim provides a layer that is used by the OneAPI runtime to communicate with the kernel.</li> </ul> <ul> <li>OPAE software development kit (APIs, upstreamed Linux drivers and software tools)</li> </ul> <ul> <li>Support for other frameworks to be built on top of the OPAE such as DPDK </li> </ul> <p>The OFS hardware repository supports hardware development and simulation.  Repositories for OFS high level design support and board management controller RTL and firmware source code are also provided.  These repositories can be found in the Intel Opensource Technology GitHub location, which requires entitlement access.  To request access, please contact your local Intel sales representative.</p> <p>Table 1-2 OFS GitHub Repositories (https://github.com/OFS/)</p> Repository Contains ofs-fim-common Contains common modules shared by all OFS designs.  This repository is a submodule of each platform repository. ofs-d5005 Contains FIM or shell RTL design, automated compilation scripts, unit tests. <p> The OPAE software GitHub site is fully opensource and contains resources for both software and workload developers.</p> <p>Table 1-3 OPAE Public Git Repositories (https://github.com/OFS)</p> OPAE Git Repository Folder Contains linux-dfl Contains OFS Linux drivers that are being upstreamed to the Linux kernel. linux-dfl-backport Backport versions of the linux-dfl to older kernel versions. opae-sdk Contains the files for building and installing OPAE SDK from source. opae-sim Contains an AFU/Workload simulator for software/hardware co-simulation. examples-afu Contains simple AFU tutorials. <p>Providing the hardware and software source code and supporting test frameworks in a GitHub repository allows you to easily customize your own designs with the latest versions.</p> <p>Most hardware and software ingredients are available in our OFS GitHub location.  For access to the board management controller firmware and RTL or our security guide for OFS, please contact a local Intel sales representative. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#13-ofs-features","title":"1.3 OFS Features","text":"<p>The OFS architecture within the FPGA comprises two partitions:</p> <ul> <li>FPGA Interface Manager (FIM)</li> </ul> <ul> <li>Accelerator Functional Unit (AFU)</li> </ul> <p>The FIM or shell provides platform management functionality, clocks, resets and interface access to the host and peripheral features of the acceleration platform. The FIM architecture along with the supporting OPAE software supports features such as partial reconfiguration and virtualization. The FIM provides a standard Arm* AMBA* 4 AXI4 datapath interface. The FIM resides in the static region of the FPGA.</p> <p>The AFU partition is provided for custom acceleration workloads and may contain both static and partial reconfiguration regions.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#131-fpga-interface-manager-fim","title":"1.3.1 FPGA Interface Manager (FIM)","text":"<p>The updated OFS architecture for Intel\u00ae Stratix 10\u00ae FPGA devices improves upon the modularity, configurability and scalability of the first release of the OFS architecture while maintaining compatibility with the original design.  The primary components of the FPGA Interface Manager or shell of the reference design are: </p> <ul> <li>PCIe Subsystem</li> <li>HSSI Subsystem</li> <li>Memory Subsystem</li> <li>Reset Controller</li> <li>FPGA Management Engine</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from Host or AFU</li> <li>SPI Interface to BMC controller</li> </ul> <p>The AFU Region provides design space for custom workloads and contains both static and partial reconfiguration regions.  Partial reconfiguration allows you to update your specific logic blocks or entire workload while the rest of your static design is still in operation.</p> <p>Note that as discussed previously, the BMC RTL and firmware, the OFS OPAE software stack and support for building your own customer board support package are also provided in separate OFS repositories.</p> <p>Figure 1-2 OFS for Intel Stratix 10 Block Diagram</p> <p></p> <p>The table below details the features of the OFS release targeting the Intel\u00ae Stratix 10\u00ae FPGA .</p> <p>Table 1-4 Features</p> Key Feature OFS Update Comments PCIe H-tile PCIe Gen3x16 Interface Integrates PCIe TLP adapter for new data mover packet format. MSI-X vector and PBA tables are located in the PCIe subsystem. Interrupts from  FME as well as four user interrupts coming from PF0.VF1 are supported. Memory Two Avalon Memory Mapped channels provided as default with capability to compile design with four channels support. - HSSI 1 Arm* AMBA* 4 AXI4-Stream channel of 10G Ethernet, using the low latency Ethernet 10G MAC Intel FPGA IP interfacing to an E-tile PHY.  - Manageability SPI interface to Board Management Controller targeting Intel FPGA PAC D5005 - CoreFIM Flexible configuration support using Arm* AMBA* 4 AXI4-Stream Physical Function/Virtual Function (PF/VF) Demux/Mux and AFU Peripheral Fabric (APF) and Board Peripheral (BPF) Fabric Interconnects.   APF and BPF fabrics are Platform Designer generated IPs. The Arm* AMBA* 4 AXI4-Stream PF/VF Demux/Mux is a new component.  Physical Function/Virtual 1 PF/3VF configuration is provided as an example but the architecture now supports full virtualization with the ability to expand to whatever the PCIe tile supports. - Partial Reconfiguration 1 Partial Reconfiguration region supported in hardware and software - Sample test PR AFUs Host exerciser modules provided to exercise interfaces.  These modules are provided in both the flat and PR AFU examples. - OneAPI Yes Available Q1 2023 Software Support OFS software stack with support for full virtualization. -"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#fpga-management-engine-fme","title":"FPGA Management Engine (FME)","text":"<p>The FIM contains only one FME, regardless of the number of host interfaces to the FIM. The FME provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link.  For more information about DFHs, refer to the Device Feature Header (DFH) structure.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#streaming-datapath","title":"Streaming Datapath","text":"<p>The FIM implements an AXI4-Stream bus protocol for data transfer in the FIM. AXI4-Stream channels send data packets to and from the host channel IP without data abstraction. Memory-mapped I/O (MMIO) CSR accesses are routed to the ST2MM module which converts the AXI4-Stream to an AXI4 memory mapped protocol.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#virtualization","title":"Virtualization","text":"<p>This design supports virtualization by making use of the virtualization functionality in the PCIe Hard IP and mapping packets to the appropriate physical or virtual function through a PF/VF multiplexer.  This reference FIM supports 1 PF and 3 VFs as an example; however, you may extend your configuration to whatever the PCIe Hard IP can support or what your application requires.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#132-afu","title":"1.3.2 AFU","text":"<p>An AFU is an acceleration workload that interfaces to the FIM. The AFU boundary in this design comprises both static and partial reconfiguration (PR) regions.  You can decide how you want to partition these two areas or if you want your AFU region to only be a partial reconfiguration region.  A port gasket within the design provides all the PR specific modules and logic required partial reconfiguration. Only one partial reconfiguration region is supported in this design.</p> <p>Similar to the FME, the port gasket exposes its capability to the host software driver through a DFH register placed at the beginning of the port gasket CSR space. In addition, only one PCIe link can access the port register space.  The port is part of the FPGA Interface Unit (FIU) that resides in the FIM.</p> <p>You can compile your design in one of the following ways: * Your entire AFU resides in a partial reconfiguration region of the FPGA  * The AFU is part of the static region and is compiled a flat design</p> <p>In this design, PF0.VF1 and PF0.VF2 map to host exerciser modules (HEM) that map to HE-LB and HE-HSSI respectively.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#133-platform-interface-manager","title":"1.3.3 Platform Interface Manager","text":"<p>The PIM provides a way to abstract the AXI4-Stream interface to the AFU by providing a library of shims that convert the host channel native packet into other protocols such as CCI-P, AXI4 memory-mapped, Avalon\u00ae streaming (Avalon-ST) or Avalon\u00ae memory-mapped (Avalon-MM). The FPGA or AFU developer implement these interface abstractions in the AFU region of the design.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#134-opae-sdk-fpga-platform-feature-discovery","title":"1.3.4 OPAE SDK FPGA Platform Feature Discovery","text":"<p>The OPAE C library in the OPAE software development kit is built on top of the OPAE Intel FPGA driver stack that abstracts the hardware and operating system specific details of the platform to the host. The FIM implements a DFH linked list to allow an FPGA platform driver running on the host to discover FME, port and AFU features. This model is similar to how PCIe enumeration occurs. You must implement a 64-bit DFH Device Feature Header register at the beginning (first 8B aligned address) of the feature CSR space for a new feature to be discovered or enumerated by a driver.</p> <p>A driver starts the traversing by reading the DFH of the first feature from the first address on PF0 BAR0. Based on the information in the DFH, a driver can determine the CSR address range of the feature and other associated details of the feature. The end of the DFH contains a \"next DFH offset\" field that points the driver to the DFH of the next feature. The software must continue traversing the linked list until it sees the EOL (End-Of-List) bit set to 1 in the \"next DFH offset\" field it is inspecting. A 1 indicates this is the last feature in the feature set. Figure below gives a simple illustration of the feature discovery by traversing the DFH registers.</p> <p>Figure 1-3 Device Feature Header Linked List Traversal </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#135-ofs-reference-design","title":"1.3.5 OFS Reference Design","text":"<p>OFS provides FIM designs you can use as a starting point for your own custom design. These designs target a specific programmable acceleration card or development kit and exercise key FPGA device interfaces. The Intel Stratix\u00ae 10 code line for OFS targets the Intel FPGA PAC D5005.  FIM designs are released to OFS D5005 FIM Github Branch for evaluation and use.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#136-fim-simulation","title":"1.3.6 FIM Simulation","text":"<p>OFS provides a UVM environment for the FIM and a framework for new feature verification. UVM provides a modular, reusable, and scalable testbench structure by providing an API framework that can be deployed across multiple projects. The FIM testbench is UVM compliant and integrates third-party verification IPs from Synopsys that require license to use. Verification components include:</p> <ul> <li>FIM monitor to detect correct design behavior</li> </ul> <ul> <li>FIM assertions for signal level integrity testing</li> </ul> <ul> <li>Arm AMBA AXI4 scoreboards to check data integrity</li> </ul> <ul> <li>FIM coverage to collect functional data</li> </ul> <p>The verification infrastructure can be in the verification folder here OFS D5005 FIM Github Branch  for evaluation and use. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#2-ofs-high-level-architecture","title":"2 OFS High Level Architecture","text":"<p>OFS provides distinct datapaths that simplifies the design and integration process for add or for removing interface modules:</p> <ul> <li>High Bandwidth datapath for AFU-attached high performance peripherals (HSSI, Memory, HPS, workload).</li> <li>Low Bandwidth datapath for OFS management and slow peripheral components (JTAG, I2C, SMBus).</li> <li>AFU Peripheral Fabric (APF) to Board Peripheral Fabric (BPF) path to communicate with interface control and status registers (CSRs) and board components.</li> <li>Peer-to-peer datapath between AFU components.</li> <li>Peer-to-peer datapath between BPF components.</li> </ul> <p>Depending on your design goals, you can present peripherals to software as:</p> <ul> <li>OFS managed peripherals with a device feature header that is part of a device feature list.</li> <li>Native driver managed peripherals that are exposed through an independent physical function or virtual function.</li> </ul> <p>Figure 2-1 OFS Datapath Structure</p> <p></p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#3-pcie-interface","title":"3 PCIe Interface","text":"<p>The FIM's H-tile PCIe* hard IP is a Gen3x16 design.  The IP supports SR-IOV and is configured to provide one PF and three VFs.  Native PCIe TLP packets are sent through the PCIe using Arm AMBA 4 AXI-4 Stream Protocol.  Before they reach the AFU, however, the packets go through an adapter that converts any headers to a data mover format that is forward compatible with Intel Agilex FPGA devices and beyond.   </p> <p>Figure 3-1 OFS FIM RX-TX Datapath</p> <p></p> <p>Some key features of the PCIe interface are:</p> Feature OFS for Intel Stratix 10 Configuration Mode PCIe Gen3x16 Port Mode Native Endpoint SR-IOV 1 PF, 3 VFs MSI-X Support Yes Functional Mode Data Mover Profile Virtual+ TLP Bypass No Header Packing Scheme Simple Data Width 512-bit (64-byte) PLD Clock Frequency 250 MHz Tags Supported 128 Reordering No reordering of requests, no completion reordering Maximum Payload Size 256 Bytes Memory Requests Supported 1CL, 2CL, 4CL MMIO transaction Size 4B, 8B"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#31-receiver-datapath","title":"3.1 Receiver Datapath","text":"<p>The path of data received by the FIM is as follows:</p> <ol> <li> <p>The PCIe Hard IP receives TLP packets from the host.  Host response types can be:</p> <p>* MMIO read or response   * Memory write request   * Interrupt response   * Memory read request or response</p> </li> <li> <p>The PCIe IP routes the TLP packets to the PCIe bridge interface in     the FIM, where they get buffered into the RX FIFO.</p> </li> <li> <p>The TLP checker in the bridge examines the packets and filters     erroneous packets including packets with unsupported requests or fields.     Errors are sent to the error logger and are logged as advance error     reporting (AER). Error status is sent to the PCIe hard IP and to the     FIM error status registers. Appropriate action is taken for the     errors as described in the Reliability, Accessibility, Serviceability (RAS) and Error Handling section. The TLP checker also     maintains RX buffer credits for TLP completions with data (CplD)     that are received from the host in response to a memory read request     (MRd request sent by the AFU). The TLP checker notifies the PCIe TX bridge when there are not enough RX buffer credits available in the PCIe RX bridge. If there are not enough credits, the PCIe TX bridge pauses MRd requests from the AFU to Host until there     is availability.</p> </li> <li> <p>The TLP checker forwards packets that pass TLP checking to an AXI4     adapter which moves the packets into an Arm AMBA 4 AXI4-Stream bus.</p> </li> <li> <p>AXI4-Stream packets are sent downstream to datamover AXI4-Stream adapter to be modified into the new datamover packet format.</p> </li> <li> <p>Datamover packets are sent to the PF/VF Mux in the AFU.</p> </li> <li> <p>The AXI4-Stream to Memory Mapped (ST2MM) module in the AFU region routes MMIO requests targeting FIM CSRs (FME, peripherals and AFU).</p> </li> </ol>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#32-transmit-datapath","title":"3.2 Transmit Datapath","text":"<p>The Transmit (TX) datapath refers to all TLP packet types that originate in the FPGA.  A single Arm AMBA 4 AXI4-Stream channel at the port interface boundary of the FIM carries PCIe TLP packets and interrupt requests upstream from the AFU.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#33-data-handshaking","title":"3.3 Data Handshaking","text":"<p>The Arm AMBA 4 AXI4 interfaces to the AFU use the <code>VALID</code> and <code>READY</code> signal for handshaking and backpressure management.  The FIM holds the <code>DATA</code> and <code>VALID</code> asserted until the receiver asserts the <code>READY</code> signal.  The AFU accepts the data when both the <code>VALID</code> and <code>READY</code> signals are asserted. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#34-arm-amba-4-axi4-stream-interface","title":"3.4 Arm AMBA 4 AXI4-Stream Interface","text":"<p>The table below shows the high-level signal mapping of the channels for the OFS for Intel Stratix 10 FPGA.  If you have previously used the OFS EA architecture, that mapping is provided as a comparison as well in this table.  </p> <p>Table 3-1 AXI4-Stream RX Channel</p> AXI4-Stream Signal Source OFS Stratix 10 Mapping OFS Early Access Mapping ACLK Clock Source PCLK = 250 MHz PCLK = 250 MHz AResetn Reset Source System Reset System Reset TVALID Master Data Valid Data Valid TREADY Slave Ready Ready TDATA Master Width=512 bits When packet includes a header (32 bytes) and data the packing scheme is: 16B data mover header: 4B prefix PF NumberVM Number VF Active Slot Number Memory Mapped Number8B Address/Metadata Data: 32B If the packet is only data then all 64 bytes comprise data [TLP_CH] [8n]  n=49 (392 bits)TLP_CH=2 (2TLP data streams)Mapping of each TLP data stream [391:136] payload (32-byte data payload) [135:8]: hdr (16 byte header) [7:3]: rsvd0 (reserved bits)[2]: end of packet (eop)  [1]: start of packet (sop)  [0]: valid (TLP packet on data stream is valid) TLAST Master Set to 1'b1 when end of packet is sent; otherwise TLAST is 1'b0 Set to 1'b1 when end of packet is sent; otherwise TLAST is 1'b0 TKEEP Byte Qualifier Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. TUSER Master WIDTH = 10  Bit 0 is always equal to 1'b1 to indicate data mover header format [4:1] - Indicates header position on the TDATA bus and is always equal to 4'b0001 indicating that the header starts from Byte0.All other bits of TUSER are unused. [TLP_CH][u-1:0] u=21 Sideband of each TLP data stream[20]: ummio_rd (Unsupported MMIO request)[19:0]: destination routing ID, where:[19:17]= BAR offset[2:0][16:4]=VF number[12:0][3:1]=PF number[2:0][0]=vf_active, indicating if the virtual function feature is enabled <p>Figure 3-3 AXI4-Stream RX Request Cycle Header Format</p> <p></p> <p>All Host requests sent to the AFU are memory-mapped I/O requests.  Of the fields below, the following are not supported in the design: * Prefix * Slot number (set to 0) * Local Address</p> <p>Figure 3-4 AXI4-Stream RX Completion Header Format</p> <p></p> <p>All completions in the RX direction are data completions.  Of the fields below, the following are not supported in the design: * Prefix * MM mode * Slot number (set to 0) * Meta Data</p> <p>Note that: * VF Active, VF Num and PF Num are obtained from TUSER. * Data packet responses (for memory read requests from the AFU) from the PCIe may come out of order when the size is greater than 64 bytes.</p> <p>Table 3-2 AXI4-Stream TX Channel</p> AXI4-Stream Signal Source OFS Stratix 10 Mapping OFS Early Access Mapping ACLK Clock Source PCLK = 250 MHz PCLK = 250 MHz AResetn Reset Source System Reset System Reset TVALID Master Data Valid Data Valid TREADY Slave Ready ReadyOnly 1 ready signal for the two channels TDATA Master Width=512 bits When packet includes a header (32 bytes) and data the packing scheme is: 16B data mover header: 4B prefix PF NumberVM Number VF Active Slot Number Memory Mapped Number8B Address/Metadata Data: 32B If the packet is only data then all 64 bytes comprise data [TLP_CH] [8n]  n=49 (392 bits)TLP_CH=2 (2TLP data streams)Mapping of each TLP data stream [391:136] payload (32 byte data payload) [135:8]: hdr (16 byte header) [7:3]: rsvd0 (reserved bits)[2]: end of packet (eop)  [1]: start of packet (sop)  [0]: valid (TLP packet on data stream is valid) TLAST Master Per protocol Set to 1'b1 TKEEP Byte Qualifier Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. TUSER Master WIDTH = 10  Bit 0 \u2013 Indicates Header Format: 0 \u2013 Power user mode header format 1 \u2013 Data mover header format Bit [4:1] - Indicates header position on the TDATA bus and is always equal to 4'b0001 indicating that the header starts from Byte0.All other bits of TUSER are unused. [TLP_CH][u-1:0] u=2Sideband of each TLP data stream[0]=vf_active, indicating if the virtual function feature is enabled[0]: afu_irq (AFU interrupt) <p>Table 3-3 Interrupt Response Channel</p> AXI4-Stream Signal Source Mapping ACLK Clock Source PCLK AResetn Reset Source System Reset TVALID Master Valid TREADY Slave Ready TDATA [8n-1:0]  n=3 (24 bits) Master [23:16]: 8-bit interrupt ID  [15:0]: Requester ID <p>Figure 3-5:  AXI4-Stream TX Request Cycle Header Format</p> <p></p> <p>All requests in the TX direction are Memory Read/Write. The requester ID does not come from the AFU; the AXI-Stream adapter supplies it.  The tag must come from the AFU.  Of the fields below, the following are not used in the H-Tile PCIe subsystem design: * Prefix * MM Mode * Slot number (set to 0) * Local Address</p> <p>Note that VF Active, VF Num and PF Num are obtained from the header packet.</p> <p>Figure 3-4 AXI4-Stream TX Completion Header Format</p> <p></p> <p>All completions in the TX direction are for MMIO.  Of the fields below, the following are not supported in the design: * Prefix * MM mode * Slot number (set to 0) * Meta Data</p> <p>Note that: * VF Active, VF Num and PF Num are obtained from TUSER.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#4-platform-interface-manager","title":"4 Platform Interface Manager","text":"<p>The FIM interfaces to an AFU through AXI4-Stream channels.  This format allows the AFU to access the host channel's raw interface without any translation. As a FIM developer, you have the option to provide the raw data format associated with the host interface channel to the workload or AFU developer or you can provide an intermediate protocol using Platform Interface Manager Components or your own custom interface. If you expose the raw AXI4-Stream interface of the FIM, workload developers also have the option to convert to a desired protocol using the PIM resources as well.  </p> <p>Refer to https://github.com/OPAE/ofs-platform-afu-bbb for more information on options for implementing the PIM.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#5-afu-interface-handler","title":"5 AFU Interface Handler","text":"<p>The AFU Interface Handler resides inline between the PCIe AXI4-Stream Adapter and the AXI4-Stream PF/VF Demux/Mux logic. Its main function is to provide:  * Unique PCIe tags \u2013 Each PCIe transaction shares the 128 tags across all VFs in the AFU region * AFU error logging for all VFs in the AFU region</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#51-afu-error-handling","title":"5.1 AFU Error Handling","text":"<p>In this OFS design, the AFU Interface Handler handles error logging for all VFs in the AFU. Errors handled are as follows</p> Checker Field Description AFU protocol checker (PCIe TLP) TxReqCounterOverflow Pending memory write or memory read requests exceed the predefined limit TxFifoOverflow Tx FIFO in the port that buffers TLP packets from AFU is overflow Malformed TLP AFU PCIe TLP contains unsupported format type MaxPayloadError AFU memory write payload size exceeds max_payload_length limit MaxReadReqSizeError AFU memory read payload size exceeds max_read_request_size limit MaxTagError AFU memory read request tag value exceeds the maximum supported tag count TagOccupiedErr AFU sends out memory read request using a tag that is already used for a pending memory read request UnalignedAddrErr The address field in AFU memory write/read request TLP is not DW-aligned. UnexpMMIOResp AFU is sending a MMIO read response with no matching MMIO read request. MMIOTimedOutAFU is not responding to a MMIO read request within the pre-defined response timeout period.  MMIODataPayloadOverrunThe number of data payload sent by AFU for a MMIO response (cplD) is more than the data length specified in the response. MMIOInsufficientDataThe number of data payload sent by AFU for a MMIO response (cplD) is less than the data length specified in the response. TxMWrDataPayloadOverrun    The number of data payload sent by AFU for a memory write request is more than the data length specified in the request. TxMWrInsufficientData  The number of data payload sent by AFU for a memory write request is less than the data length specified in the request. AFU Protocol Checker (AXI4-Stream)TxValidViolationThree checkers are implemented in the FIM to catch errors and protocol violations. <p>To view the CSR space for the AFU interface handle, go to the src/afu_top/AFU_INTF_CSR.xls file OFS D5005 FIM Github Branch.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#6-interconnect-fabric","title":"6 Interconnect Fabric","text":"<p>There are three types of interconnect fabric in the OFS FIM design:  * AXI4-Stream mux/demux fabric  * AFU Periheral Fabric (APF)  * Board Peripheral Fabric (BPF)</p> <p>Figure 6-1 Interonnect Fabric Diagram</p> <p></p> <p>TLP packets sent from upstream PCIe Subsystem on AXI4-Stream channel are demultiplexed in the AXI4-Stream PF/VF mux/demux fabric and routed to the respective PF/VF function based on the PF/VF information in the TLP header, such as vf_active or the PF/VF number. On the opposite direction, TLP packets from downstream PF/VF function are muxed in the fabric and sent to PCIe subsystem over AXI4-Stream channel.</p> <p>All host MMIO requests targeting PF0 BAR0 are routed to the ST2MM module. The ST2MM converts MMIO TLP packets into AXI-Lite memory requests and places the requests onto AFU Peripheral Fabric (APF). AFU peripherals, such as OFS managed AFU features and ST2MM) and Board Peripheral Fabric (BPF) are interconnected by APF. The BPF is the interconnect fabric one hiearchy below APF which connects all the board peripherals. Both APF and BPF allow multiple AXI4-Lite master and slave interconnect topology.</p> <p>The following table summarizes the mechanism for configuring PF/VF functions:</p> <p>Table 6-1 Interconnect Configuration Methods </p> InterconnectConfiguration Mechanism APF or BPFEither:Use Platform Designer (PD) to generate the fabrics directly, or  Specify desired cfg in iofs_dfl.txt and run dfh2tcl.pl script to generate the necessary HW TCL scripts as needed by PD. This PERL script also takes care of invoking PD in script mode to generate the end result of RTL design Verilog files. This is the preferred method for generation. AXI-S PF/VF Demux/MuxUpdate parameters in these RTL files: * src/includes/top_cfg_pkg.sv * src/common/pf_vf_mux.sv Then make the corresponding update to AFU top level instantiation and connections: * src/FIMs/.../afu_top.sv <p>Note:</p> <p>In all cases, you must configure and regenerate the PCIe IP to match the new PF/VF configuration if it deviates from the reference FIM provided.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#61-fabric-generation-flow","title":"6.1 Fabric Generation Flow","text":"<p>You have two options to generate APF/BPF IPs.</p> <ul> <li>Use Quartus Platform Designer.  This method requires familiarity with Quartus Platform Designer.  With this option, you manually enter each address space and define the associated master and slave interface in a table provided by the Platform Designer.  The parameters and attributes such as data width, address width, number of outstanding cycles, \u2026 etc. are also set to the desired values.  After this is completed, you then connect each master and slave interface in the table.  Platform Designer then generates the RTL files according to the table.  For more details, please refer to the Intel Quartus Prime Pro Edition User Guide.</li> </ul> <ul> <li>Use the APF/BPF script that reads in <code>iofs_dfl.txt</code> and automatically generates APF/BPF IPs.  Both APF and BPF are generated from Platform Designer using hardware TCL scripts. To provide a more user friendly experience to OFS Rel 1 and AC ADP customers, a perl script <code>dfh2tcl.pl</code> has been developed to provide a higher level of abstraction. The below figure illustrates the high level flow:</li> </ul> <p>Figure 6-2 APF/BPF Generation</p> <p></p> <p>Note that the only input required is the <code>iofs_dfl.txt</code> text file which allows you to specify how many ports, which fabric, type of AXI4-Lite port (master, slave, or both), port addresses and sizes.  Using <code>iofs_dfl.txt</code> and <code>dfh2tcl.pl</code> to generate the APF and BPF is the preferred method.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#62-iofs_dfltxt-format","title":"6.2   iofs_dfl.txt Format","text":"<p>The following table describes the format of the <code>iofs_dfl.txt</code> input file:</p> <p>Table 6-2 iofs_dfl.txt Format Types</p> ColumnDescription REGISTERName of the port on the APF/BPF fabrics. Note that each entry must be unique. FABRICAllows the user to specify which fabric this port is connected to, and also the type of AXI4-Lite port (master, slave, or both). The format is FABRIC-PORT_TYPE, where: * FABRIC = APF or PBF * PORT_TYPE = MST, SLV, or BID (Master, Slave, or Bi-Directional) BASE_ADDRSpecifies the address offset of the AXI4-Lite port. BAR_SIZE=2^N   Specifies the size of the port. For simplicity reasons, all AXI4-Lite ports are configured as 64KB. i.e. 2^16 <p>Additional AXI4-Lite ports can be easily created by adding more rows in the <code>iofs_dfl.txt file</code>. </p> <p>Note that there are several reserved ports in both APF and BPF so it might not be necessary for you to regenerate the fabrics if the design does not exceed the number of ports as implemented in the APF/BPF in the reference FIMs.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#63-afu-peripheral-fabric-apf","title":"6.3   AFU Peripheral Fabric (APF)","text":"<p>The AFU Peripheral Fabric (APF) is a 64-bit AXI4-lite compliant interconnect fabric that connects AFU peripheral modules to board peripheral modules through the Board Peripheral Fabric (BPF).  The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time. </p> <p>The address mapping for components interconnected by the APF is listed below. All components are mapped to PF0 BAR0 and implement AXI-lite slave interface. The Master column indicates if a component also implements AXI4-lite master interface which can send request to APF.</p> <p>Table 6-3 APF Address Mapping</p> AddressSize (Byte)FeatureMaster 0x00000 \u2013 0x7FFFF512KBoard Peripherals (See BPF address mapping)   No AFU Peripherals 0x80000 \u2013 0x8FFFF64KST2MMYes (Send MMIO request to all the peripherals) 0x90000 \u2013 0x9FFFF64KPort GasketYes 4KPR Control &amp; Status 4KUser clock 16KRemote STP 0xA0000 \u2013 0xAFFFF64KAFU Interface HandlerNo 0xB0000 \u2013 0xBFFFF64KRSV_b_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xC0000 \u2013 0xCFFFF64KRSV_c_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xD0000 \u2013 0xDFFFF64KRSV_d_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xE0000 \u2013 0xEFFFF64KRSV_e_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xF0000 \u2013 0xFFFFF64KRSV_f_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. <p>The five reserved regions have associated ports available in the APF for customer use.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#64-board-peripheral-fabric-bpf","title":"6.4   Board Peripheral Fabric (BPF)","text":"<p>The Board Peripheral Fabric is the 64-bit AXI4-Lite compliant interconnect fabric that connects board peripheral modules to APF. The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time.</p> <p>The address mapping for components interconnected by BPF is listed below. All components are mapped to PF0 BAR0 and implement AXI4-lite slave interface. The Master column indicates if a component also implements AXI4-lite master interface which can send request to BPF.</p> <p>Table 6-4 BPF Address Mapping</p> AddressSize (Byte)FeatureMaster 0x00000 \u2013 0x0FFFF64KFME (FME, Error, etc)Yes 0x10000 \u2013 0x1FFFF64KSPI ControllerYes 0x20000 \u2013 0x2FFFF64KPCIe CSR- 0x30000 \u2013 0x3FFFF64KHSSI CSR- 0x40000 \u2013 0x4FFFF64KEMIF CSR- 0x50000 \u2013 0x5FFFF64KReservedAvailable for customer use.Dependent on user programming 0x60000 \u2013 0x6FFFF64KReservedAvailable for customer use.Dependent on user programming 0x70000 \u2013 0x7FFFF64KReservedAvailable for customer use.Dependent on user programming <p>The three reserved regions have associated ports available in the BPF for customer use.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#65-axi4-stream-pfvf-muxdemux","title":"6.5   AXI4-Stream PF/VF Mux/Demux","text":"<p>The AXI4-Stream PF/VF Mux/Demux routes the PCIe TLP packets from the PCIe subsytem AXI4-Stream RX channel to downstream PF/VF based on the pf_num and vf_num information in the PCIe TLP header.</p> <p>The AXI4-Stream PF/VF mux arbitrates PCIe TLP packets from downstream PF/VF to the PCIe SS AXI-S TX channel. The PF/VF Mux/Demux is an M x N switch that allows any M port to target any N port, and any N port to target any M port, where M is the number of host/upstream ports, and N is the numbers functions/downstream ports.  M and N values are parameterized in the RTL for adding, removing, or remapping of FPGA functional units/modules to PF/VF.  </p> <p>The fpga top package file, found in the src/includes/ofs_fim_cfg_pkg.sv file OFS D5005 FIM Github Branch  contains these parameters as well as the mapping of N port\u2019s PF/VF.</p> <p>Structurally, M x N switch is composed of M number of N:1 mux, and N number of M:1 mux.  Each mux output has an arbiter that perform round robin priority arbitration of its inputs.  At the mux output is a FIFO with depth greater than the handshake round trip delay.  The FIFO allows the switch to arbitrarily insert pipeline/register stages for timing.</p> <p>Note that M x N switch is design for AXI streaming, but it can be easily converted to AVST.  The protocol signals pass through switch intact \u2013 only ready, valid, and last (common between AVST and AXI) effect switch operation.  The data width of the switch is also parameterized in the src/includes/ofs_fim_cfg_pkg.sv file OFS D5005 FIM Github Branch.  </p> <p>The default mapping is shown below:</p> <p>Table 6-5 PF/VF Mapping</p> DevicePhysical Function #Virtual Function #Switch Port ID APF/BPF0x3 HE Loopback000 Port Gasket011 HSSI022 <p>For information on how to modify the PF/VF mapping for your own design, refer to the Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#66-unified-tag-remapping","title":"6.6 Unified Tag Remapping","text":"<p>When a FPGA function sends out a read cycle, it allocates a unique tag which is subsequently used to identify the read completion.  The tag is considered busy; it cannot be assigned to another read cycle until read completion.  While a tag may be unique within a unit, two different units could unknowingly send out two read cycles of the same tag.  The PCIe subsystem requires unique tags for all read cycles irrespective of their origins.  Therefore, a mechanism is needed to uniquify tag globally across different units.</p> <p>OFS contains a tag remapper (tag_remap) that intercepts the read cycle, finds a globally unique tag, and replaces the original tag value.  It also restores the original tag value when returning completion to the read requester.  tag_remap is placed between the AXI4-Stream interface of the PCIE subsystem and the PF/VF Mux/Demux.</p> <p>The logic is described as follows:</p> <ol> <li>A sub-module (ofs_fim_tag_pool) maintains a pool of available tags.</li> <li>TX read requests are held until a tag is available from the pool by setting tvalid=0 to the host, and tready=0 to the PF/VF Mux/Demux.</li> <li>When a TX read is dispatched, the tag is marked busy in the pool.</li> <li>The original tag is stored in tag_reg, so it can be recovered when returning a completion to the unit/function.</li> <li>Since completion to a read request can split into multiple smaller transfer sizes, responses are monitored and the final completion is detected using PCIe TLP rules.</li> <li>Tags are released in the pool only when all requested data are transferred.</li> <li>When the completion returns, the original tag is restored from tag_reg.</li> </ol>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#67-tlp-to-axi4-lite-memory-mapped-bridge-st2mm","title":"6.7 TLP to AXI4-Lite Memory Mapped Bridge (ST2MM)","text":"<p>ST2MM implements the following key features: * Host MMIO bridge     * Maps MMIO TLP packets received from the PCIe Subsystem over streaming interface to AXI4-Lite memory-mapped request. The memory-mapped request is sent to AFU or Board peripherals over APF and BPF.     * Maps AXI4-lite MM response received from AFU or Board peripherals to TLP packets and send the packets over ST streaming channel to host HIA subsystem. * Sends MMIO response of all 0\u2019s for MMIO read to unused BAR region. * Interrupt     * Sends interrupt packets to the PCIe subsystem when interrupt requests are received from the peripherals. Interrupts can be requested by a peripheral through a memory write to interrupt CSR registers in the ST2MM.</p> <p>Figure 6-2 APF/BPF Generation</p> <p></p> <p>ST2MM implements both AXI4-lite master and slave interfaces that are connected to the designated slave and master port on APF. Host memory requests are sent on the ST2MM master interface to AFP where the requests are routed to the targeted peripherals. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#7-mmio-regions","title":"7 MMIO Regions","text":"<p>The FIM and AFU expose their functionalities to the host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO). An MMIO region is an address space within a base address register (BAR) region to which features are memory mapped.  For example, when a feature is mapped to an MMIO region, the CSR registers of that feature are located within the address range of that region. There can be multiple MMIO regions within a BAR region. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#71-base-address-register-bar-layout","title":"7.1 Base Address Register (BAR) Layout","text":"<p>The function, BAR and external feature region starting address are put into a platform specific parameter SystemVerilog package file src/includes/ofs_fim_cfg_pkg.sv file OFS D5005 FIM Github Branch.  </p> <p>You can modify the parameterization according to your platform requirements, however you must ensure the corresponding software driver is also updated to align with the new assignment. </p> <p>Table 7-1 BAR Layouts</p> PF VF Feature BAR BAR Size PF0 - OFS Managed Peripherals BAR 0 512K AFU PeripheralsBoard Peripherals 256K256K VF0 HE-LB BAR0 4K VF1 HE-MEM in PR slot BAR0 4K VF2 HE-HSSI BAR0 4K"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#72-feature-region","title":"7.2 Feature Region","text":"<p>A group of related CSRs can be categorized as a feature region. For example, a DMA engine has queue management function and quality of service (QoS) function; these are two different features of the DMA engine. A feature region is contained within a single PCIe BAR and cannot span across two BAR region boundaries.   You can view the PF0 BAR0 MMIO mapping by referencing thesrc/common/fme/fme_csr_pkg.sv file OFS D5005 FIM Github Branch file.</p> <p>A Device Feature Header (DFH) register marks the start of the feature region and sub-feature region, and you must place it at the first address of the region. Each DFH starts at 4KB boundary. A DFH register contains information that OPAE software requires to enumerate the feature. It also has an offset field that points to the next DFH in a feature list. OPAE software traverses the linked list of DFHs in each BAR region to discover all the features implemented on the platform. The <code>EOL</code> field in a DFH marks the end of a DFH list and is only set in the DFH of the last feature in the feature list. The feature type field in the DFH is used to differentiate between the different types of feature region. Basic building blocks (BBB) and private features are always a child of an AFU or FPGA Interface Unit (FIU) and must be contained within an AFU or FIU, respectively.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#721-device-feature-header-dfh-structure","title":"7.2.1 Device Feature Header (DFH) Structure","text":"<p>All DFHs must follow the following structure to be compatible with OPAE software.</p> <p>Table 7-2: DFH Structure</p> Bitfield Name Range Access Description FeatureType 63:60 RO 4\u2019b0000 \u2013 Reserved 4\u2019b0001 \u2013 AFU4\u2019b0010 \u2013 BBB4\u2019b0011 \u2013 Private Feature4'b0100 \u2013 FIU/FIM Reserved 59:41 Rsvd Reserved EOL 40 RO End of DFH List1'b0=No other feature header beyond this one1'b1=This is the last feature header NextDFHByteOffset 39:16 RO Next DFH byte offsetNext DFH Address= Current DFH address + Next DFH byte offset.  You can also use this value as an indication of the maximum size of the MMIO region occupied by this feature. FeatureRev 15:12 RO For AFU Feature type= AFU major version number that is user defined.All other feature types= Feature revision number FeatureID 11:0 RO For AFU feature type= CoreFIM version numberFor BBB feature type= Intel defined ID for BBBFor private feature type= User-defined ID to identify within an AFU For FIU type=ID for FIU unit (ex. 0 for FME, 1 for Port) <p>You must increment a feature revision number if a feature changes.  This change requires a corresponding change in the software to detect the new version and report mismatches between the hardware and software revision number. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#73-control-and-status-registers","title":"7.3 Control and Status Registers","text":"<p>All the Control and Status Registers (CSRs) in the FIM are 64-bit registers with the following MMIO write and MMIO read support.</p> <p>Table 7-3: CSR MMIO Read and Write Support</p> Request Memory Attribute Payload size Memory Ordering MMIO Write UC 4B or 8B Strongly ordered MMIO Read UC 4B or 8B Strongly ordered <p>The FIM does not reorder the MMIO requests or responses. For MMIO writes, there is no reordering of requests in FIM, and UC ordering rules are followed. Similarly, for MMIO reads, there is no re-ordering of requests or responses in the FIM. An AFU may opt to re-order the MMIO read responses but the FIM does not enforce read response ordering. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#731-software-access-to-registers","title":"7.3.1    Software Access to Registers","text":"<ul> <li>Software accesses 64-bit registers as aligned quadwords. For example, to modify a field (bit or byte) in a 64-bit register, the entire quadword is read, the appropriate field(s) are modified, and the entire quadword is written back.</li> <li>When updating registers through multiple accesses (whether in software or due to hardware disassembly), certain registers may have specific requirements on how the accesses must be ordered for proper behavior. These are documented as part of the respective register descriptions.</li> <li>For compatibility with future extensions or enhancements, software must assign the last read value to all \u201cReserved and Preserved\u201d (RsvdP) fields when written. In other words, any updates to a register must be read so that the appropriate merge between the RsvdP and updated fields occurs. Also, software must assign a value of zero for \u201cReserved and Zero\u201d (RsvdZ) fields when written.</li> <li>PCIe locked operations to FPGA hardware registers are not supported. Software must not issue locked operations to access FPGA hardware registers.</li> </ul> <p>In the following two cases, the FIM terminates MMIO Read requests by sending a completion with the data (CplD) specified below: * MMIO Timeout:  This occurs when the AFU does not respond within a set timeout. The timeout value is currently configured to 512 pclks (clk_2x). In this case, the FIM returns all 1s.</p> <ul> <li>Illegal MMIO Accesses: This occurs when the read is accessing undefined registers in the FIM or if an AFU access violation.  An example of an access violation is when a PF attempts to access the AFU when it is set to VF mode, or when a VF attempts to access the AFU when it is set to PF mode. In this case, the FME will return all 0s.</li> </ul>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#732-register-attribute-definition","title":"7.3.2    Register Attribute Definition","text":"<p>Table 7-4: OFS Register Attribute Definitions</p> Attribute Expansion Description RW Read/Write This bit can be read or written by software. RO Read Only The bit is set by hardware only. Software can only read this bit. Writes do not have any effect. RW1C Read/ Write 1 to Clear Software can read or clear this bit. The software must write 1 to clear this bit. Writing zero to RW1C bit has no effect. Note that a multi-bit RW1C field may exist. In this case, all bits in the field are cleared if a 1 is written to any of the bits. RW1S Read/ Write 1 to Set Software can read this bit. Writing a 1 to the bit sets it to 1. Writing a 0 has no effect. It is not possible for software to set this bit to 0. The 1 to 0 transition can only be performed by HW. RW1CS Read/Write 1 to Clear Sticky Software can read and clear this bit. Writing a 1 to a bit clears it, while writing a 0 to a bit has no effect. This bit is only reinitialized to its default value by a power-on reset. RWD Read/Write Sticky across Hard Reset The bit can be read or written by SW. This bit is sticky or unchanged by any reset type, including Hard Reset. The bit gets cleared only with power on. *S Sticky across Soft Reset The bit will be sticky or unchanged by soft reset. These bits are only re-initialized to their default value by a power-on reset. *D Sticky across Hard Reset The bit is sticky or unchanged by or unchanged by any reset type, including hard reset. The bit gets cleared only with power on. Rsvd Reserved Reserved for future definitions. Currently don\u2019t care bits. RsvdP Reserved and Protected Reserved for future RW implementations. The software must preserve the value of this bit by read modify write. RsvdZ Reserved and Zero Reserved for future RW1C implementations. The software must write zero to this bit."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#733-csr-offset-in-bars","title":"7.3.3 CSR Offset in BARs","text":"<p>The table below captures the FIM and AFU features in the supported BAR regions. The offset highlighted in red indicates the first DFH in the DFH list of a BAR region where device driver starts the DFH traversal.</p> <p>Table 3-6: PF0 BAR0 Features</p> Offset Feature CSR set <code>0x00000</code> <code>FME</code> 0x03000 Global Performance 0x04000 Global Error 0x10000 SPI Controller 0x20000 PCIe CSR Interface 0x30000 HSSI CSR Interface 0x40000 EMIF CSR Interface 0x80000 Reserved for ST2MM Bridge 0x90000 PR Control &amp; Status (Port Gasket) 0x91000 Port CSRs (Port Gasket) 0x92000 User Clock (Port Gasket) 0x93000 Remote SignalTap (Port Gasket) 0xA000 AFU Errors (AFU Interface Handler) <p>Table 3-7: PF0 BAR4 Features</p> Offset Feature CSR set 0x02000 MSI-X 0x03000 MSI-X PBA Tables <p>Table 3-8: PF0-VF0 BAR0 Features</p> Offset Feature CSR set 0x00000 HE-LBK <p>Table 3-9: PF0-VF1 BAR0 Features</p> Offset Feature CSR set 0x00000 HE-MEM <p>Table 3-10: PF0-VF2 BAR0 Features</p> Offset Feature CSR set 0x00000 HE-HSSI"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#8-fim-clocks","title":"8 FIM Clocks","text":"<p>The following table provides the clocks available in the OFS reference design that targets the Intel FPGA PAC D5005.  Clocks that the high speed serial interface (HSSI) or external memory interface provide to the FIM may be different depending on if you modify your external features with different components.</p> <p>Table 8-1: External Clock Source</p> Clock Frequency Description SYS_RefClk 100 MHz Reference clock to system IOPLL (sys_pll) which provides FIM system clocks. qsfp*_644_53125_clk 644.5312 5MHz HSSI reference clocks ddr4_mem*.ref_clk 150 MHz Reference clocks to DDR4 interfaces PCIE_REFCLK 100MHz PCIe reference clock <p>Table 8-2: Internal Clocks</p> Clock Frequency Description clk_1x 250 MHz Generated by the system IOPLL (sys_pll). This clock drives CoreFIM datapath and the AFU interface. clk_div2 125 MHz Generated by the system IOPLL, synchronous to clk_1x. This clock drives IM datapath and AFU interface. clk_100 100 MHz Generated by the system IOPLL, synchronous to clk_1x.  This clock also supplies the HSSI reconfiguration clock. avl_clk 250 MHz PCIe H-tile Hard IP clock output. This clock is not synchronous to Clk_* DDR4x_USERCLK 299.76 MHz Each of the four DDR interfaces generates one of these clocks, which provides the the clock to the  DDR4* Avalon Memory Mapped interfaces.  Your memory clock output may be different depending on the memory interface you are implementing in your design. uclk_usr User defined Provides an AFU user clock running at a user specified frequency. Generated by user IOPLL. Not synchronous to clk_*. uclk_usr_div2 uclk_usr/2 Second user clock to AFU running at half the frequency of uclk_usr. Synchronous to uclk_usr. Generated by user IOPLL. hssi[*].f2a_tx_parallel_clk_x1 156.2 MHz 1x TX clock generated from fPLL in the HSSI module in FIM, used to clock the HSSI TX datapath in AFU. hssi[*].f2a_tx_parallel_clk_x2 312.5 MHz 2x TX clock generated from fPLL in the HSSI module in FIM, used to clock the HSSI TX datapath in AFU. hssi[*].f2a_rx_clkout 322.265625MHz RX parallel clock from the HSSI PHY channels, used to clock the HSSI RX data datapath in AFU."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#9-reset","title":"9 Reset","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#91-reset-signals","title":"9.1   Reset Signals","text":"<p>The system reset of OFS reference platform is driven by <code>nPERST</code> pin, <code>pcie_reset_status</code> signal from the PCIe hard IP, the <code>INIT_DONE</code> and <code>nCONFIG</code> pins of the FPGA, and the locked signal of the SYS IOPLL that provides system clocks to FIM.  </p> <p>Upon power-on, the reset module in the FIM holds the FIM in reset until all the reset conditions are de-activated:</p> <ul> <li><code>nPERST</code> signal is asserted.</li> <li>The <code>INIT_DONE</code> pin is driven high to indicate core configuration is complete.</li> <li>The SYS IOPLL is locked.</li> <li>The reset status from PCIe hard IP is de-asserted indicating the IP is ready for transfer. </li> </ul> <p>The reset module places the FIM back into reset if any of these conditions becomes active again. The only way to invoke a system reset to the FIM after power-up is to deassert the <code>nPERST</code> pin either by performing a warm reboot or through PCIe driver intervention. There are soft reset signals set aside to allow software to reset the Port, AFU and partial reconfiguration IP. </p> <p>Table 9-1: FIM System Resets</p> Reset Description <code>nPERST</code> pin Active low PCIe reset pin that serves as the system reset pin on the platform. <code>nCONFIG</code> pin Active low input to the FPGA that causes the FPGA to lose its configuration data, enter a reset state, and tri-state all I/O pins. Host software must reload the FPGA FIM after nCONFIG is activated. <code>ninit_done</code> Active low signal derived from the INIT_DONE pin which indicates the FPGA core configuration is complete and has entered usermode. <code>pcie_reset_status</code> Active high reset status from PCIe hard IP. When driven high, this signal indicates that the PCIe IP core is not ready for usermode. <code>pll_locked</code> Active high SYS IOPLL locked signal <p>Table 9-2: Soft Resets</p> Soft Reset Bitfield Register Description <code>PortSoftReset</code> PORT_CONTROL[0] Resets Port and AFU. <code>FlrPortReset</code> PORT_CONTROL[3] PCIe function level reset that resets Port and AFU when SR-IOV is enabled. <code>PRReset</code> FME_PR_CTRL[0] Resets the partial reconfiguration (PR) controller."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#92-platform-power-up-sequence","title":"9.2   Platform Power up Sequence","text":"<p>Upon power up, the HSSI interfaces of the FIM go through an internal reset and calibration sequence. After the <code>nPERST</code> is de-activated, the PCIe interface and EMIF interfaces are first released from reset, followed by SYS IOPLL when the <code>ninit_done</code> is de-asserted. The rest of the FIM logic is still being hold in reset. The <code>nPOR</code> signal to the PCIe hard IP de-activates following <code>nPERST</code> assertion, which releases PCIe hard IP from reset. The PCIe hard IP asserts <code>pld_clk_inuse</code> to indicate to the application layer that the HIP transaction layer is using the <code>pld_clk</code> as its clock and is ready for operation with the Application layer (<code>pld_clk</code> is stable). Finally, <code>reset_status</code> from PCIe IP is de-asserted. When SYS IOPLL is locked and the <code>reset_status</code> from the PCIe interface is de-asserted, the FIM is released from reset while the Port and AFU is still held in reset by the <code>PortSoftReset</code> register bit (PORT_CONTROL[0]) that is held high until software writes a 0 to this bit to de-activate port reset. At this point, the platform is fully released from reset and PCIe link is going through link training and PCIe enumeration. Once the platform is successfully enumerated, driver can then be loaded to start the device feature discovery process and provision the platform for AFU application usage.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#10-interrupts","title":"10 Interrupts","text":"<p>The OFS platform supports interrupt through MSI-X feature. The OFS reference platform supports at least 4 FME interrupts (PF only) and 4 AFU interrupts (PF and VF). </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#101-msi-x","title":"10.1 MSI-X","text":"<p>In the default implementation the MSI-X feature that handles FME and AFU interrupts is inside the PCIe Subsystem.  The MSI-X vector table and Pending Bit Array (PBA) table for PF0 and PF0/VF1 are provided as an example.  FME interrupts are primarily used to notify the host of error events occurring in the FIM. </p> <p>All interrupt requests arrive inband through the AXI4-Stream interface to the TX AXI4-stream adapter inside the PCIe Subsystem.  </p> <p>An AFU sends an interrupt to the MSI-X module on the AXI interrupt request channel. After the interrupt request is serviced, the MSI-X module sends an interrupt response back to the AFU on the AXI interrupt response channel. The AFU has the flexibility to define the use of each AFU interrupt.</p> <p>The following interrupts are supported: PF supports 7 interrupt vectors: - 0-3:  User AFU triggered  - 4:    Port error triggered - 6:    FME error triggered</p> <p>VF supports 5 interrupt vectors: - 0-3:  User AFU triggered  - 4:    Port error triggered</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#11-external-memory-interface-emif","title":"11 External Memory Interface (EMIF)","text":"<p>There are four DDR4 external memory interfaces on the OFS EA FIM that targets the Intel FPGA PAC D5005 FIM for each of the four DDR4 banks (DDR4a, DDR4b, DDR4c, and DDR4d). Two of the DDR4 external memory interfaces and the associated clocks are directly exposed to AFU except for two Avalon Memory Mapped pipeline bridges to facilitate timing closure across PR boundary. The Avalon Memory Mapped interfaces of each external memory interface are connected to an Avalon-MM pipeline bridge (avmm_bridge) in the FIM, which is then connected to another Avalon-MM pipeline bridge in the PR or AFU region.  An AFU should use the USER_CLK associated with a memory interface when interfacing with the memory interface for better timing performance.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#111-emif-csr","title":"11.1 EMIF CSR","text":"<p>The CSR for the EMIF feature is memory mapped to the FME BAR region. Following table captures the EMIF CSR registers.</p> <p>Table 9-1: EMIF CSR Registers</p> EMIF_DFH 0x40000 0x3000000050000009 EMIF Management DFH FIELD NAMERANGEACCESSDEFAULT DESCRIPTION FeatureType [63:60] RO 0x3 Feature Type = Private Feature Reserved40 [59:40] RsvdZ 0x0 Reserved NextDfhByteOffset [39:16] RO 0x050000 Next DFH Byte offset FeatureRev [15:12] RO 0x0 Feature Revision FeatureID [11:0] RO 0x9 Feature Id EMIF_STAT 0x40008 0x0000000000000000 EMIF Status FIELD NAMERANGEACCESSDEFAULT DESCRIPTION Reserved [63:16] RsvdZ 0x0 Reserved Reserved [15:12] RsvdZ 0x0 Reserved EmifCalFail [11:8] RO 0x0 EMIF PHY Calibration Failure (1 bit per interface) Reserved [7:4] RsvdZ 0x0 Reserved EmifCalSuccess [3:0] RO 0x0 EMIF PHY Calibration Successful (1 bit per interface) <p>\u200b          \u200b               </p> EMIF_CTRL 0x40010 0x0000000000000000 EMIF Control FIELD NAMERANGEACCESSDEFAULT DESCRIPTION Reserved [63:0] RsvdZ 0x0 Reserved"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#92-afu-emif-interface","title":"9.2 AFU EMIF Interface","text":"<p>The FIM exposes 576-bits of Avalon Memory-Mapped data to the AFU, with 512-bit data and additional 64 bits that can either be used for additional metadata, parity or ECC. The AFU has the flexibility to decide the use of the extra 64 bits of data.  The ECC soft IP is not enabled in the EMIF IP to allow for the afore-mentioned flexibility. AFU developers can implement the ECC logic in the AFU by making use of the extra 64-bit of data.  Avalon Memory-Mapped is the native interface protocol used by Intel EMIF IP. AFU developers who desire other interface protocol in their designs over Avalon Memory-Mapped, such as AXI4 Memory-Mapped, can leverage the bridge in the PIM library. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12-hssi-subsystem","title":"12 HSSI Subsystem","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#121-hssi-subsystem-overview","title":"12.1 HSSI Subsystem Overview","text":"<p>The high speed serial interface (HSSI) subsystem architecture provides portability to different Ethernet configurations across platforms and generations and reusability of the hardware framework and software stack. This reference FIM contains the Low Latency Ethernet 10G MAC IP and provides a Linux driver that can be leveraged for customization. </p> <p>The HSSI design is leveraged from our OFS EA release so prior customers can easily maintain compatibility with past designs.</p> <p>A host exerciser, named he-hssi, is provided in the pr_slot of the AFU partition. The Ethernet interface to the AFU has an AXI4-Stream data and sideband interface. The HSSI control and status registers in the FIM are accessible by the AXI4-Stream memory mapped interface. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#122-ofs-hssi-subsystem-interfaces","title":"12.2 OFS HSSI Subsystem Interfaces","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1221-hssi-subsystem-fim-interfaces","title":"12.2.1 HSSI Subsystem FIM Interfaces","text":"<p>There are three interfaces to the HSSI Subsystem that is part of the FIM:</p> <ol> <li>AXI4 Memory Mapped to access HSSI-CSR (to FIM)</li> <li>AXI4-Stream Ethernet Data Interface (from FIM)</li> <li>AXI4-Stream Ethernet Sideband Interface (from FIM)</li> </ol> <p>The PCIe subystem uses AXI Memory Mapped accesses to read and write HSSI Control and Status Registers in the FIM. The Ethernet MAC interface typically has a data streaming interface which is mapped to standard AXI4-Stream.</p> <p>Figure 12-1: HSSI Subsystem</p> <p></p> <p>Additionally, the Ethernet MAC interface has an interface for status and flow control. Status and flow control signals vary across IPs and operating modes so for this design we group the signals into a AXI4-Stream sideband interface which provides a standard interface to the AFU along with platform customizations if needed. The Avalon to Arm AMBA 4 AXI4 bridge (av_axi_st_bridge) converts native Avalon interfaces to an AXI4 Stream interface.</p> <p>The following flow control are implemented in the Ethernet MAC: * IEEE 802.3 flow control: this flow control implements the IEEE 802.3 Annex 31B standard to manage congestion. When the Low Latency Ethernet 10G MAC IP experiences congestion, the core sends a pause frame to request its link partner to suspend transmission for a given period of time. This flow control is a mechanism to manage congestion at the local or remote partner. When the receiving device experiences congestion, it sends an XOFF pause frame to the emitting device to instruct the emitting device to stop sending data for a duration specified by the congested receiver. Data transmission resumes when the emitting device receives an XON pause frame (pause quanta = zero) or when the timer expires. </p> <p>\u2022 Priority-based flow control (PFC): this flow control implements the IEEE 802.1Qbb standard. PFC manages congestion based on priority levels. It supports up to 8 priority queues. When the receiving device experiences congestion on a priority queue, it sends a PFC frame requesting the emitting device to stop transmission on the priority queue for a duration specified by the congested receiver. When the receiving device is ready to receive transmission on the priority queue again, it sends a PFC frame instructing the emitting device to resume transmission on the priority queue</p> <p>To use flow control, set the following registers:</p> <p>On the TX datapath:  1. Set tx_pfc_priority_enable[7:0] (Address :0x0046 -&gt; 11A0) to 0 to disable the PFC. The rest of the bits are unused. 2. Set tx_pauseframe_enable[0] (Address :0x0044 -&gt; 1142) to 1 to enable the flow control. </p> <p>On the RX datapath:</p> <p>\u2022   Set rx_pfc_control[7:0] (Address :0x00C0 -&gt; 818) to 1 to disable the PFC. The rest of the bits are mostly unused. \u2022   Set the IGNORE_PAUSE (Address :0x00AC -&gt; 800) bit in the rx_frame_control register to 0 to enable the flow control.</p> <p>To use Priority-Based Flow Control Follow these steps to use the priority-based flow control (PFC):  1. Enable the Priority-based flow control (PFC) parameter and specify the number of priority levels using the Number of PFC priorities parameter. You can specify between 2 to 8 PFC priority levels.  2. Set the following registers. </p> <p>On the TX datapath: * Set tx_pauseframe_enable (Address :0x0044 -&gt; 1142) to 0 to disable the flow control. * Set tx_pfc_priority_enable[n] (Address :0x0046 -&gt; 11A0) to 1 to enable the PFC for priority queue n. </p> <p>On the RX datapath:  * Set the IGNORE_PAUSE bit in the rx_frame_control (Address :0x00AC -&gt; 800) register to 1 to disable the flow control. * Set the rx_pfc_control[7:0] (Address :0x00C0 -&gt; 818) register bits to 0 to enable the PFC. Most of the rest of the bits are unused.  * Set PFC Quanta bit for the appropriate queue. Eg: pfc_pause_quanta_0 (0x048 -&gt; 1180) for queue0 and so on. *  Connect the avalon_st_tx_pfc_gen_data signal to the corresponding RX client logic and the avalon_st_rx_pfc_pause_data signal to the corresponding TX client logic.  * You have the option to configure the MAC RX to forward the PFC frame to the client by setting the rx_pfc_control[16] register to 1. By default, the MAC RX drops the PFC frame after processing it</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1222-hssi-subsystem-afu-interfaces","title":"12.2.2 HSSI Subsystem AFU Interfaces","text":"<p>The HSSI subsystem provides the following interfaces to the AFU region:</p> <ol> <li>AXI4-Memory Mapped access to the HSSI CSR (to FIM)</li> <li>AXI4-Stream Ethernet Data Interface (from FIM)</li> <li>AXI4-Stream Ethernet Sideband Interface (from FIM)</li> <li>Ethernet Clock Interface (eth_clock) (from FIM)</li> </ol> <p>The he-hssi uses the APF interface for HSSI CSR (MMIO) accesses. The AXI4-Stream Ethernet data and side band interface along with Ethernet clocks communicate directly to the he-hssi module in the AFU region through platform independent data structures provided by the PIM.  Even if you implement a different MAC you typically can leverage these data structures defined in the hssi/inc/ofs_fim_eth_avst_if.sv file here without modification.</p> <p>While the platform-independent interfaces in ofs_fim_eth_if.sv are convenient containers for passing data streams through the design hierarchy, both the MAC and AFU traffic generator require platform-specific data types. The payloads of the streams in ofs_fim_eth_if.sv are defined in platform-specific structures, with fields that are MAC-specific. In this 10GbE reference design, the payload datatypes are defined in the ipss/hssi/s10/includes/ofs_fim_eth_plat_if_pkg.sv file hhere. Implementers connecting a new MAC should generally edit only ofs_fim_eth_plat_if_pkg.sv when defining payloads.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1223-hssi-sideband-interface","title":"12.2.3 HSSI Sideband Interface","text":"<p>The AXI4-Stream sideband interface has been been defined to allow for time sensitive status and flow control information. It does not have the optional <code>tready</code> signal and assumes the slave always accepts  information.  The Ethernet sideband interface varies widely across IPs and operating modes and device generations. In OFS Stratix 10 FIM, the Ethernet sideband signals are mapped to the AXI4-Stream interface and interface variations can be accommodated by customizing the <code>tdata</code> signals of the sideband interface in platform specific interface packages using the PIM. </p> <p>As an example, please refer to ofs_fim_eth_sideband_tx_axis_if interface in the ipss/hssi/inc/ofs_fim_eth_if.sv found OFS D5005 FIM Github Branch.</p> <p>The t_axis_eth_sideband_tx and t_axis_eth_sideband_rx structures are found in the ipss/hssi/s10/includes/ofs_fim_eth_plat_if_pkg.sv file OFS D5005 FIM Github Branch.</p> <p>Platform specific details for the 10GbE example are from the ipss/hssi/s10/includes/ofs_fim_eth_plat_if_pkg.sv file OFS D5005 FIM Github Branch.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1224-reconfiguration-interfaces","title":"12.2.4 Reconfiguration Interfaces","text":"<p>The reconfiguration interface in the OFS EA design consists of abstracted and consolidated memory-mapped transceiver reconfiguration interfaces that are exposed to the HSSI CSRs. The reconfiguration interface directly exposes the address space of the MAC and PHY IPs in order to allow a software driver to perform dynamic reconfiguration of those IPs (i.e. read/write access to the Native PHY CSRs). Therefore, to use this interface you must be familiar with the CSR memory maps of the corresponding Intel IP cores. </p> <p>The table below summarizes all the ports associated with Reconfiguration Interfaces. </p> Name Width Domain Description i_xcvr_reconfig_cmd 2 i_reconfig_clk Command port used to specify a read or write access operation to a MAC/PHY CSRs on a selected CSR_interface i_xcvr_reconfig_addr 20 i_reconfig_clkCSR access address of  MAC/PHY IP. Note that only the lower 16 bits are used, i_xcvr_reconfig_addr[15:0]. The remaining upper bits, i_xcvr_reconfig_addr[20:16], should be set to zero.  i_xcvr_reconfig_writedata  32 i_reconfig_clk CSR data to be written on a write command.  o_xcvr_reconfig_readdata 32 i_reconfig_clk CSR data that was read on a read command. o_xcvr_reconfig_ack 1 i_reconfig_clk Reconfiguration acknowledgement bit. Asserted when Reconfiguration Controller is finished performing an Avalon-MM read or write request (i.e. waitrequest is low). Deasserted when i_xcvr_reconfig_cmd is all-zero (i.e. command is invalidated). Note that the controller assumes a valid command when i_xcvr_reconfig_cmd is non-zero."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12241-reconfiguration-sequence","title":"12.2.4.1 Reconfiguration Sequence","text":"<p>The diagram below explains the sequence of operation and handshaking between software and a memory-mapped dynamic reconfiguration interface.</p> <p>Figure 12-2: Sequence of Operation and Handshaking between Software and a Memory-Mapped Dynamic Reconfiguration Interface.</p> <p></p> <p>(0)  Idle state \u2013 command and address buses are cleared (all-zero). 1.  Software sets a desired non-zero command and address to initiate reconfiguration.</p> <pre><code>a.  Memory-Mapped Reconfiguration Controller (MM CTRL) converts the command and address to a single Avalon Memory Mapped read or write request and handles Avalon Memory Mapped protocol details.\n\nb. MM CTRL completes the Avalon Memory Mapped transaction when the `waitrequest` signal of a given Avalon Memory Mapped interface is deasserted.\n\nc. MM CTRL sets the reconfiguration acknowledgment bit and `readdata` (in case of a read command) back to the FME and waits for command and address ports to be cleared by software. \n1.\n</code></pre> <ol> <li> <p>Meanwhile, software continuously polls the reconfiguration acknowledgment bit and waits for it to get asserted. Assertion of the acknowledgment bit confirms that the MM CTRL has completed the current Avalon Memory Mapped read/write request. </p> </li> <li> <p>Software reads <code>readdata</code> from the  HSSI_RCFG_DATA CSR that was returned by the MM CTRL (in case of a read command). </p> </li> <li> <p>Software clears the command and address buses to communicate back to the MM CTRL that the operation is finished from the CPU\u2019s perspective. </p> <p>a.  MM CTRL gets cleared (all-zero) command and address signals from the HSSI_CSR.    b.  MM CTRL clears (deasserts) the reconfiguration acknowledgment bit back to the HSSI_CSR and is finished / back to idle state.  5.  Meanwhile, software continuously polls the reconfiguration acknowledgment bit and waits for it to get deasserted. Deassertion of the acknowledgment bit confirms that the MM CTRL has completed its handshake and is now back to idle state. </p> </li> </ol> <p>NOTE</p> <p>Reads and writes cannot be performed at the same time. Remember that when multiple CSRs are at the same address, a Read-Modify-Write operation may be required to change the desired CSR without changing the CSRs in the same address.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1225-hssi-control-and-status-register-csr-map","title":"12.2.5   HSSI Control and Status Register (CSR) Map","text":"<p>The HSSI CSR Map structure is designed to scale according to IP capabilities.</p> <ul> <li>HSSI_DFH allows for identifying HSSI as an external FME feature.</li> <li>HSSI_CAPABILITY register exposes design capabilities and provides direction to SW/Driver. The fields num_channels, Num_channels_CSR interface, Num_CSR_interface indicate to the software how many CSR interfaces are exposed by the design and how to use mailbox registers (HSSI_RCFG_CMD and HSSI_RCFG_DATA). The number of mailbox registers(HSSI_RCFG_CMD and HSSI_RCFG_DATA) must scale to the number of CSR interfaces exposed by the design. This implementation facilitates flexibility in the design and reuse of the software stack. If you are modifying the HSSI interface, you must update these CSR fields according to HW configuration .  </li> </ul> <p>Example: If Num_CSR_interface=2 &amp; Num_channels_CSR_interface=2 then channel(0,1) are behind CSR interface 0 handled by HSSI_RCFG_CMD0/DATA0 , channel (2,3) are behind CSR interface 1 handled by HSSI_RCFG_CMD1/DATA1 HSSI_CTRL, HSSI_STATUS0, HSSI_STATUS1 provide control and status information and can scale upto 8 channels.  HSSI_RCFG_CMD0, HSSI_RCFG_DATA0 registers are for the reconfiguration interface,  and additional mailbox registers could be added depending on the number of CSR interfaces the design exposes. </p> <p>The HSSI CSR Map can be found in the ipss/hssi/s10/hssi_ss_csr.xls file OFS D5005 FIM Github Branch.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1226-hssi-host-exercisier-he-hssi","title":"12.2.6 HSSI Host Exercisier (HE-HSSI)","text":"<p>HE-HSSI is an Ethernet AFU that handles client side ethernet traffic. The reference HE-HSSI has following features:</p> <ul> <li>HE-HSSI wraps the 10G Ethernet AFU that was provided in the OFS EA FIM with a wrapper that provides an E-tile compatible interface with OFS for Intel Stratix 10 and Intel Agilex FPGAs.</li> <li>Includes 10GbE traffic generator and checker (monitor)</li> <li>Provides pause signals to the HSSI subsystem for XON and XOFF generation</li> <li>It can generate traffic or incoming traffic that can be looped back into transmit path by enabling loopback mode, which will bypass traffic generator</li> <li>At the HE-HSSI interface boundary the Ethernet data interface is AXI4-Stream with 64-bit data at eth_clk clock</li> <li>An AXI4-Stream to Avalon-ST bridge converts Avalon-ST Ethernet traffic from the HE-HSSI traffic generator to AXI4-Stream traffic and AXI4-Stream RX data from the FIM to Avalon-ST for the HE-HSSI traffic checker. The data width for all the interfaces in this bridge is 64 bits at eth_clk clock.</li> <li>The Traffic generator and checker modules have a 64-bit data interface at eth_clk clock.</li> <li>The traffic generator supports the following modes:     * Fixed length or Random Length     * Incremental pattern or Random pattern</li> <li>The traffic checker does a 32-bit CRC check</li> <li>The CSR of this AFU is accessible through AXI4-Stream PCIe TLP interfac</li> <li>The PCIe TLP to CSR Interface Conversion module converts PCIe TLPs into simple CSR interface</li> <li>The CSR space of the traffic generator and checker modules are accessed in an indirect way using mailbox registers</li> <li>Though the default configuration for this reference HE-HSSI is 1x10GbE, it can be scaled up to eight 10G ethernet traffic generators and checkers in one HE-HSSI</li> <li>If used for more than one channel, each channel has a separate traffic generator and traffic checker with separate CSR space.</li> <li>Reads and Writes to individual traffic controller CSR spaces can be done by selecting that particular channel using channel select register.</li> </ul> <p>The HE-HSSI Ethernet block diagram is below. </p> <p>Figure 12-6: HE-HSSI Block Diagram Block Diagram</p> <p></p> <p>Figure 12-7: 10G Ethernet AFU Clock Domains</p> <p></p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12261-he-hssi-csr-map","title":"12.2.6.1 HE-HSSI CSR Map","text":"<p>The reference HSSI AFU contains the following registers and a similar arrangement of register space can be implemented for other usecase specific HSSI AFUs. * AFU DFH Register: Device feature header for the AFU (AFU_DFH) * AFU ID Registers: 128-bit UUID for the AFU which occupies two 64-bit registers (AFU_ID_L, AFU_ID_H) * Mailbox Registers: Command and Data register for traffic controller register access. It follows the standard access method defined for OFS. Access method and implementation is same as Reconfiguration Interface defined for the HSSI FIM. (TRAFFIC_CTRL_CMD, TRAFFIC_CTRL_DATA) * Channel Select Register: Channel select register for traffic controller mailbox access. It is used in cases where more than one channel is in the AFU, else it defaults to zero, meaning channel-0 is selected. (TRAFFIC_CTRL_PORT_SEL) * Scratchpad Register: Scratchpad register for CSR access checking. (AFU_SCRATCHPAD) </p> <p>The CSR excel for the 10G HSSI reference AFU can be found ipss/hssi/s10/hssi_ss_csr.xls OFS D5005 FIM Github Branch.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#123-hssi-software","title":"12.3 HSSI Software","text":"<p>There are two pieces of software related to running the HSSI Subsystem and the HE-HSSI host exerciser: The Linux* dfl network driver and a user space application.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1231-hssi-linux-driver","title":"12.3.1 HSSI Linux Driver","text":"<p>The HSSI subystem is exposed as a feature in the PCIe PF BAR0 region.  It has a Device Feature Header (DFH) indicating the HSSI interface. The feature ID in the DFH causes the following driver to be instantiated for the HSSI interface: drivers/net/ethernet/intel/s10hssi.c Kernel Driver Branch</p> <p>The primary functionality of the driver is to interact with the ethernet MAC and PHY through an indirect register access mailbox implemented by the HSSI_RCFG_CMD0, HSSI_RCFG_DATA0 registers described above. To aid in RTL bringup, the driver provides a debugfs interface directly to the indirect register access mailbox. For each HSSI interface in the system there would be a directory with the following form containing two files, regaddr and regval: /sys/kernel/debug/dfl-fme.X.Y</p> <p>To read a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then read the value as string out of regval file. To write a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then write the value as a C hex string to regval file.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1232-hssi-user-space-tool","title":"12.3.2   HSSI User Space Tool","text":"<p>The HSSI user space application exports a control interface to the HSSI AFU's packet generator logic. Context-sensitive help is given by the --help option, doc/src/fpga_tools/hssi/hssi.md,  OPAE SDK Branch.</p> <pre><code>$ hssi --help\n\n<p></p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#124-user-guidelines","title":"12.4 User Guidelines","text":"<p>You can either leverage Ethernet example designs from platform designer or use your own custom IP\u2019s. However below recommendations would help leverage the infrastructure of the OFS stack:\n* Follow the Ethernet-GBS interface standard, customize platform specific sideband and clock intefaces.\n* Follow the reconfiguration interface example and reuse the hssi_csr block by modifying the memory map (change address decoder map accordingly as well.)</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#13-partial-reconfiguration","title":"13 Partial Reconfiguration","text":"<p>Partial Reconfiguration (PR) is an Intel FPGA technology that allows user to reconfigure parts of the FPGA device dynamically, while the remainder of the device continues to operate. In a non-partial reconfiguration flow, any change to the design requires full reprogramming of the entire configuration RAM (CRAM) arrays in the device. With partial reconfiguration, you can dynamically reprogram one or more CRAM frames. A partial reconfiguration design has a static region, and one or more PR regions, which can be modified to implement new logic. The portion of the CRAM on the chip to be reconfigured is contained within a PR region.\nFor the PR flow, the design should be partitioned into static region and reconfigurable region. The static region is the area of your FPGA that is not reconfigured without reprogramming the entire FPGA. An area of the chip that you plan to partially reconfigure is a PR region. </p>\n<p>The Port Gasket contains all the PR specific modules and logic, such as PR slot reset/freeze control, user clock, remote STP etc. For this reference example only one PR slot is supported.\nThe following figure depicts the high level view of the Port Gasket:</p>\n<p>Figure 13-1 Partial Reconfiguration Gasket\n</p>\n<p></p>\n<p>The isolation logic is provided on the output signals of the PR region to ensure they don\u2019t glitch and affect the interfacing logic in the Static Region (SR). The isolation logic is controlled by the PR Freeze logic during PR operation.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14-reliability-accessibility-serviceability-ras-and-error-handling","title":"14 Reliability, Accessibility, Serviceability (RAS) and Error Handling","text":"<ol>\n<li>Downstream AFU checker: Identifies AFU violations.  For example, this checker flags violations of the interface specification. </li>\n<li>Upstream software or PCIe link checker: Identifies invalid traffic from PCIe that violates either FIM specifications or PCIe specifications. For example, this checker flags an application sending traffic if it violates the FIM specification or creates a PCIe link issue by causing completion timeout or malformed TLP. </li>\n<li>FIM - Checks for bugs in the FIM fabric.</li>\n</ol>\n<p>Errors reported by the checker are logged in either the FME error registers or Port error registers, or both, as shown in the table below.  For more details on each of the registers, please refer to src/common/protocol_checker/protocol_checker_csr.xml file OFS FIM_COMMON Github Branch or the SystemVerilog file src/common/fme/xls/d5005/FME_CSR.xls found OFS FIM_COMMON Github Branch .</p>\n<p>Table 14-1: Error Registers</p>\nMMIO Region\nArea\nRegister\nDescription\nFME\nCoreFIM\nFME_ERROR\nFME Error Status Register 0.  Registers parity errors, underflow or overflow errors and access mismatches.\nFME\nCoreFIM\nFME_ERROR0_MASK\nFME Error Mask Register 0.  Write a 0 to mask errors in the FME Error Status Register 0.\nFME\nExternal\nPCIE0_ERROR\nPCIe0 Error Status Register.\nFME\nExternal\nPCIE0_ERROR_MASK\nPCIe0 Error Mask Register 0.  Write a 0 to mask errors in the PCIe0 Error Status Register 0.\nFME\nCoreFIM\nFME_FIRST_ERROR\nFirst FME Error Register.\nFME\nCoreFIM\nFME_NEXT_ERROR\nFME Next Error Register.\nFME\nCoreFIM\nRAS_NOFAT_ERR_STAT\nReliability/Accessibility/Serviceability (RAS) Non-Fatal Error Status Register.\nFME\nCoreFIM\nRAS_NOFAT_ERR_MASK\nRAS Non-Fatal Error Mask Register. Write 0 to mask error fields in RAS_NOFAT_ERR_STAT Register.\nFME\nCoreFIM\nRAS_CATFAT_ERR_STAT\nRAS Catastrophic and Fatal Errors Status Register.\nFME\nCoreFIM\nRAS_CATFAT_ERR_MASK\nRAS Catastrophic and Fatal Errors Mask Register. Write 0 to mask error fields in the RAS_CATFAT_ERR_STAT Register.\nFME\nCoreFIM\nRAS_ERROR_INJ\nRAS error Injection Register.\nPORT\nCoreFIM\nPORT_ERROR\nPort Error Status Register.\nPORT\nCoreFIM\nPORT_FIRST_ERROR\nPort First Error Register .\nPORT\nCoreFIM\nPORT_MALFORMED_REQ0\nPort Malformed Request Register 0.  Provides malformed request header LSBs.\nPORT\nCoreFIM\nPORT_MALFORMED_REQ1\nPort Malformed Request Register 1.  Provides malformed request header MSBs."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#141-fme-errors","title":"14.1 FME Errors","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1411-fme_error0","title":"14.1.1   FME_ERROR0","text":"<p>The FME_ERROR0 register flags CoreFIM FME errors in the Global Error (GLBL_ERROR) private feature. The error bits in this register are sticky bits. You can only clear these bits through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in FME_ERROR0_MASK register masks the error.</p>\n<p>Table 14-2: FME Error Types</p>\nError Type\nDescription\nFabric errors\nFIFO underflow/overflow condition in CoreFIM. These errors only occur if you have introduced bugs into the FIM or during very rare single event upset (SEU) or SEU-like events.\nInvalid port access\nA port can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the Port. If it finds a PF is trying to access a port that is mapped to a VF or vice-versa, an error will be reported.\nInvalid AFU access\nAn AFU can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the AFU associated with the Port. If it finds a PF is trying to access an AFU that is mapped to a VF or vice-versa, an error is reported and a fake response is sent back to the requester to avoid a completion timeout on the host."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1412-pcie0_error","title":"14.1.2 PCIE0_ERROR","text":"<p>The PCIe Avalon-ST to AXI4-Stream bridge monitors the PCIe link for errors and logs any such errors in the PCIE0_ERROR register (in PCIE0 feature region) and PCIE0_ERROR register in the GLBL_ERR private feature.    The error bits in the PCIE0_ERROR register are sticky bits that you can only clear through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in PCIE0_ERROR0_MASK masks the error.  </p>\n<p>If you have other external FME features, you can add similar _ERROR registers to this space. Please refer to the following spreadsheet, bbs/csr/stratix10/pac_d5005/fme_csr_pcie.xls,  OFS D5005 FIM Github Branch or the SystemVerilog file the SystemVerilog file src/common/fme/xls/d5005/FME_CSR.xls found OFS FIM_COMMON Github Branch for more details on this register. \n<p>NOTE</p>\n<p>The PCIE0_ERROR register is located in both the Global Error external feature memory space and a separate PCIe external feature memory space.  OPAE software supports the PCIe external feature memory space beginning at offset 0x40000 for OFS EA and going forward.  PCIe registers beginning at 0x4000 in the Global Error external feature memory space is there for backward compatibility to the Intel FPGA PAC D5005 v2.0.1 Acceleration Stack.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1413-fme_first_error-fme_next_error","title":"14.1.3   FME_FIRST_ERROR, FME_NEXT_ERROR","text":"<p>The FME_FIRST_ERROR register flags which of the FME error reporting registers, such as FME_ERROR0, PCIE0_ERROR0, has reported the first error occurrence. The error fields of the first error register are then continuously logged into the FME_FIRST_ERROR register until a system reset or software clears all the errors in that first error register.\nLikewise, the FME_NEXT_ERROR indicates which of the FME error reporting registers (except the first error register) has reported the next occurrence of error after the first error register. The error fields of the next error register are continuously logged into the FME_NEXT_ERROR register until a system reset or software clears all the errors in the second error register.</p>\n<p>Please refer tobbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls, OFS D5005 FIM Github Branch for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv, OFS D5005 FIM Github Branch</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1414-reliability-accessibility-serviceability-ras-error-status","title":"14.1.4   Reliability, Accessibility, Serviceability (RAS) Error Status","text":"<p>The RAS feature in CoreFIM labels errors as non-fatal, fatal or catastrophic based on their impact to the system. \n* A non-fatal error usually originates from software or an AFU.  With a non-fatal error, the user application may still be able to recover from the error by performing a soft reset on the AFU, fixing the user application software if necessary, and clearing the error. On the other hand, a fatal or catastrophic error is non-recoverable and requires the platform to be reset.\n* Non-fatal errors are logged in the RAS_NOFAT_ERR_STAT register and fatal or catastrophic errors are logged in the RAS_CATFAT_ERR_STAT register.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14141-non-fatal-errors","title":"14.1.4.1    Non-Fatal Errors","text":"<p>The RAS_NOFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It logs the high-level status of non-fatal errors in the hardware.  Unlike the error bits in the PCIE0_ERROR and FME_ERROR0 registers which are RW1C (software can write a 1 to clear the error), the error bits in this register are read-only and can only be cleared by system reset. Software has an option to mask the error using RAS_NOFAT_ERR_MASK.\nPlease refer to bbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls, OFS D5005 FIM Github Branch for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv, OFS D5005 FIM Github Branch.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14142-catastrophic-fatal-errors","title":"14.1.4.2    Catastrophic &amp; Fatal Errors","text":"<p>The RAS_CATFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It captures the high-level status of errors that can only be recovered with a system reset. Therefore, the error bits in the RAS_CATFAT_ERR_STAT register are read-only and can only be cleared by system reset or masked through RAS_CATFAT_ERR_MASK.\nPlease refer to bbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls, OFS D5005 FIM Github Branch for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv OFS D5005 FIM Github Branch.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1415-ras-error-injection","title":"14.1.5   RAS Error Injection","text":"<p>For software testing purposes, you can inject non-fatal, fatal and catastrophic errors into the platform through the RAS_ERROR_INJ register.  These errors are reported in the RAS_CATFAT_ERR_STAT and RAS_NOFAT_ERR_STAT registers.\nPlease refer to bbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls OFS D5005 FIM Github Branch for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv OFS D5005 FIM Github Branch.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1416-fme-error-interrupts","title":"14.1.6   FME Error Interrupts","text":"<p>In an event of an FME error, the MSI-X module in the FIM generates an interrupt so the host can decide on the next course of action. The FIM does not stall upstream and downstream traffic after the FME error. However, a port error triggered by invalid request from a user AFU stalls all the traffic going from AFU to PCIe.\nThe interrupt capability is discoverable by querying the <code>NumbSuppInterrupt</code> field of the PORT_CAPABILITY register in the Port private feature.  The MSI-X vector number is recorded in the <code>InterruptVectorNumber</code> field of the GLBL_ERROR_CAPABILITY register of the Global Error external feature.</p>\n<p>An FME error interrupt is generated in response to the FME_ERROR0, PCIE0_ERROR0, RAS_NOFAT_ERR_STAT or RAS_CATFAT_ERR_STAT registers recording a new, unmasked, error per the rules defined by CoreFIM interrupt feature.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14161-msi-x-masking-pending-bit-array-pba-clearing","title":"14.1.6.1    MSI-X Masking &amp; Pending Bit Array (PBA) Clearing","text":"<p>If the MSI-X vector corresponding to the FME error interrupt is masked, events are recorded in the PBA array.  Clearing the FME error status registers clears the corresponding MSI-X PBA entries.  If only some events are cleared, the normal interrupt triggering rules apply and a new pending interrupt is registered.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1417-fme-error-handling","title":"14.1.7   FME Error Handling","text":"<p>When the host receives an FME error interrupt, it must take the recommended actions described below to bring the system back to its normal operation.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14171-catastrophicfatal-error","title":"14.1.7.1    Catastrophic/Fatal Error","text":"<p>A system reset is mandatory for any catastrophic or fatal error.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14172-non-fatal-error","title":"14.1.7.2    Non-Fatal Error","text":"<p>When software receives a non-fatal error interrupt which does not require a system reset, it can take the following steps to clear the error after software handles the error:\n1.  Set the *_ERROR_MASK register to all 1\u2019s to mask all errors\n2. Clear the *_FIRST_ERROR register\n3. Clear the *_ERROR register\n4. Set *_ERROR_MASK register to all 0\u2019s to enable all errors</p>\n<ul>\n<li>Result: The *_ERROR &amp; *_FIRST_ERROR registers begin capturing new errors.</li>\n</ul>\n<p>NOTE</p>\n<p>A system reset can only clear RAS Error status registers.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#142-mmio-requests","title":"14.2   MMIO Requests","text":"<p>The FIM is designed to gracefully handle MMIO request scenarios.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1421-unsupported-functions-and-bars","title":"14.2.1 Unsupported Functions and BARs","text":"<p>The OFS FIM EA has only one PCIe link and all MMIO requests from the host are sent through this link. The PCIe hard IP in the FIM guarantees that only TLP packets for the functions and BARs supported by the FIM (as configured in PCIe HIP IP instantiation) are sent to the FIM on the PCIe Avalon Streaming interface.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1422-mmio-request-decoding","title":"14.2.2   MMIO Request Decoding","text":"<p>The packet router and memory decoder in the FIM ensure that only legal MMIO requests are forwarded to the targeted MMIO region. Full address and BAR decoding is done both in the packet router and the memory decoder to ensure the requests are forwarded to the designated CSR region as defined in the MMIO Regions chapter.  Any unsolicited/illegal MMIO request is dropped, and an error is reported back to host through the FME error register.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1423-unused-fmeport-csr-regions","title":"14.2.3   Unused FME/Port CSR Regions","text":"<p>All the CSR slaves in FIM which are mapped to the FME or Port CSR regions must always respond to MMIO read requests targeting its associated CSR region. A CSR slave must return all 0s for MMIO reads to its unused CSR region such as a reserved space or a region where no CSR register is implemented for the address.\nThe FIM ensures MMIO reads to FME or Port CSR regions that are not mapped to any CSR slave always gets a response of all 0s. The memory decoder module and fake responder module in the FIM provide this guaranteed response.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1424-unsupported-mmio-request","title":"14.2.4   Unsupported MMIO Request","text":"<p>Any MMIO request targeting FME or Port CSR regions with a length or address alignment that are not  supported by the FIM is dropped, and an error is logged in PCIE0_ERROR register. The MMIO checker module in the FIM guarantees this response. When an unsupported MMIO read request to the FIM CSR region is detected, the FIM sends back a CPL (completion without data) with error status (UR) back to host.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1425-afu-access-violation","title":"14.2.5   AFU Access Violation","text":"<p>AFU access violations refer to the scenarios where a PF is attempting to access the MMIO region of an AFU bound to a VF (virtualization enabled), or when a VF is trying to access the MMIO region of an AFU bound to a PF (virtualization disabled). When such a violation is detected, the FIM drops the request and logs the error in the FME_ERROR0 register. If the request is an MMIO read request, the FIM returns a fake response to the host.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1426-afu-mmio-response-timeout","title":"14.2.6   AFU MMIO Response Timeout","text":"<p>An AFU MMIO Response timeout functions in the same manner described in the MMIO Response Timeout section.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#15-design-guidance","title":"15 Design Guidance","text":"<p>The OFS FIM is designed with configurability and scalability in mind.  At a high level, these are the necessary steps for a user to customize the design.  Please refer to the FPGA Interface Manager Developer Guide: Open FPGA Stack for Intel Stratix 10</p>\n<p>Table 15-1 Features</p>\nStep\n            Description\n            Comments  \n        1\n            Re-configure PCIe HIP for additional VFs (if necessary)\n            * PF0 is mandatory for running OPAE software* Only modification of the VFs (added or subtracted) by the user is recommended.\n\u2022   Default configuration supports 1 PF and 3 VFs.\n        \n        2\n            Update AXI4-Stram PF/VF MUX-DEMUX configuration (if necessary)\n\n            * The PF/VF MUX-DEMUX is parameterized for flexibility.  You can change, add or delete PF or VF functions by updating the top_cfg_pkg.sv file.\n* You also have the option of keeping the default configuration and tying off the unused VFs if needed.\n\n        3\n            Update top level and AFU level as necessary\n\n     * If you integrating additional external interfaces, make the edits at the top level (iofs_top.sv) and propagate the interface down to the AFU level (afu_top.sv)\n 4\n            Add user implemented function(s) in AFU\n            * All of your implemented functions must have the required AXI4-Stream interface for both the data path and the MMIO control path to CSRs. * All CSRs in the user implemented function must have the required DFH layout. * See host exerciser CSRs for reference.\n   \n        \n\n\nFor more information on modifying the FIM, refer to the [Open FPGA Stack Technical Reference Manual](https://ofs.github.io/hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/).\n\n\n\n## Notices &amp; Disclaimers\n\nIntel\u00ae technologies may require enabled hardware, software or service activation.\nNo product or component can be absolutely secure. \nPerformance varies by use, configuration and other factors.\nYour costs and results may vary. \nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein.\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document.\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request.\nIntel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade.\nYou are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \n\u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. \n\nOpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   \n\n\n\n\n\n\n\n*[AFU]: Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region\n*[BBB]: Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID.\n*[BKC]: Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against.\n*[BMC]: Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors.\n*[DFL]: Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\n*[FIM]: FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring.\n*[FME]: FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform.\n*[HEM]:  Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc.\n*[JTAG]:  Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology.\n*[OFS]: Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs.\n*[OPAE SDK]: Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE.\n*[PIM]: Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols.\n*[PR]: Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page.\n*[RSU]: Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration.\n*[UVM]: Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework.\n*[TB]: Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output.\n*[Intel VT-d]: Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization.\n*[SR-IOV]: Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance.\n*[MMIO]: Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators.\n*[VFIO]: Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace.\n*[IOCTL]: Input/Output Control, System calls used to manipulate underlying device parameters of special files.\n*[AER]: Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting.\n*[PAC]: Programmable Acceleration Card: FPGA based Accelerator card"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/","title":"Platform Evaluation Script: Open FPGA Stack for Intel Stratix 10 FPGA","text":""},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#1-overview","title":"1 Overview","text":""},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a set-up and user guide for the checkout and evaluation of an Intel\u00ae FPGA PAC D5005 development platform using Open FPGA Stack (OFS). After reviewing the document, you will be able to:</p> <ul> <li>Set-up and modify the script to your environment</li> </ul> <ul> <li>Compile and simulate an OFS reference design</li> </ul> <ul> <li>Run hardware and software tests to evaluate the complete OFS flow</li> </ul>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#12-table-software-version-summary","title":"1.2 Table : Software Version Summary","text":"Component Version Description FPGA Platform Intel\u00ae FPGA PAC D5005 Intel platform you can use for your custom board development OFS FIM Source Code Branch: ofs-d5005, Tag: release/ofs-2023.1 OFS Shell RTL for Intel Stratix 10 FPGA (targeting Intel\u00ae FPGA PAC D5005) OFS FIM Common Branch: ofs-2023.1, Tag: ofs-2023.1 Common RTL across all OFS-based platforms AFU Examples Branch: examples-afu , Tag: ofs-examples-ofs-examples-afu-1.0.0 Tutorials and simple examples for the Accelerator Functional Unit region (workload region) OPAE SDK Branch: 2.5.0-3, Tag: 2.5.0-3 Open Programmable Acceleration Engine Software Development Kit Kernel Drivers Branch: ofs-2023.1-6.1-1, Tag: ofs-2023.1-6.1-1 OFS specific kernel drivers OPAE Simulation Branch: opae-sim, Tag: 2.5.0-3 Accelerator Simulation Environment for hardware/software co-simulation of your AFU (workload) Intel Quartus Prime Pro Edition Design Software 23.1 Intel\u00ae Quartus\u00ae Prime Pro Edition Linux Software tool for Intel FPGA Development Operating System RHEL 8.2 Operating system on which this script has been tested <p>A download page containing the release and already-compiled FIM binary artifacts that you can use for immediate evaluation on the Intel\u00ae FPGA PAC D5005 can be found on the OFS 2023.1 official release drop on GitHub.</p> <p></p> Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#2-introduction-to-ofs-evaluation-script","title":"2 Introduction to OFS Evaluation Script","text":"<p>By following the setup steps and using the OFS evaluation script you can quickly evaluate many features that the OFS framework provides and also leverage this script for your own development.  </p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#21-pre-requisites","title":"2.1 Pre-Requisites","text":"<p>This script uses the following set of software tools which should be installed using the directory structure below. Tool versions can vary.</p> <ul> <li>Intel Quartus\u00ae Prime Pro Software</li> <li>Synopsys\u00ae VCS Simulator</li> <li>Siemens\u00ae Questa\u00ae Simulator</li> </ul> <p>Figure 2-1 Folder Hierarchy for Software Tools</p> <p></p> <ol> <li> <p>You must create a directory named \"ofs-X.X.X\" where the X represents the current release number, for example ofs-2023.1. </p> </li> <li> <p>You must clone the required OFS repositories as per Figure 2-2 . Please refer to the BKC table for locations., Please go to OFS Getting Started User Guide for the instructions for the BKC installation.</p> </li> <li> <p>Once the repositories are cloned, copy the evaluation script (ofs_d5005_eval.sh) which is located at [eval_scripts] beneath the ofs-2023.1 directory location as shown in the example below:</p> </li> </ol> <p>Figure 2-2 Directory Structure for OFS Project</p> <pre><code>## ofs-2023.1\n##  -&gt; examples-afu\n##  -&gt; linux-dfl\n##  -&gt; ofs-d5005\n##  -&gt; oneapi-asp\n##  -&gt; oneAPI-samples\n##  -&gt; opae-sdk\n##  -&gt; opae-sim\n##  -&gt; ofs_d5005_eval.sh\n</code></pre> <ol> <li>Open the README file named (README_ofs_d5005_eval.txt) which is located at [eval_scripts] which informs the user which sections to modify in the script prior to building the FIM and running hardware, software and simulation tests. </li> </ol>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#22-intel-fpga-pac-d5005-evaluation-script-modification","title":"2.2 Intel\u00ae FPGA PAC D5005 Evaluation Script modification","text":"<p>To adapt this script to the user environment please follow the instructions below which explains which line numbers to change in the ofs_d5005_eval.sh script.</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#user-directory-creation","title":"User Directory Creation","text":"<p>The user must create the top-level source directory and then clone the OFS repositories</p> <pre><code>mkdir ofs-2023.1\n</code></pre> <p>In the example above we have used ofs-2023.1 as the directory name</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#set-up-proxy-server-lines-65-67","title":"Set-Up Proxy Server (lines 65-67)","text":"<p>Please enter the location of your proxy server to allow access to external internet to build software packages.</p> <p>Note: Failing to add proxy server will prevent cloning of repositories and the user will be unable to build the OFS framework.</p> <pre><code>export http_proxy=&lt;user_proxy&gt;\nexport https_proxy=&lt;user_proxy&gt;\nexport no_proxy=&lt;user_proxy&gt;\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#license-files-lines-70-72","title":"License Files (lines 70-72)","text":"<p>Please enter the the license file locations for the following tool variables</p> <pre><code>export LM_LICENSE_FILE=&lt;user_license&gt;\nexport DW_LICENSE_FILE=&lt;user_license&gt;\nexport SNPSLMD_LICENSE_FILE=&lt;user_license&gt;\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#tools-location-line-85-86-87-88","title":"Tools Location (line 85, 86, 87, 88)","text":"<p>Set Location of Quartus, Synopsys, Questasim and oneAPI Tools</p> <pre><code>export QUARTUS_TOOLS_LOCATION=/home\nexport SYNOPSYS_TOOLS_LOCATION=/home\nexport QUESTASIM_TOOLS_LOCATION=/home\nexport ONEAPI_TOOLS_LOCATION=/opt\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#quartus-tools-version-line-93","title":"Quartus Tools Version (line 93)","text":"<p>Set version of Quartus</p> <pre><code>export QUARTUS_VERSION=23.1\n</code></pre> <p>In the example above \"23.1\" is used as the Quartus tools version</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#opae-tools-line-106","title":"OPAE Tools (line 106)","text":"<p>change OPAE SDK VERSION</p> <pre><code>export OPAE_SDK_VERSION=2.5.0-3\n</code></pre> <p>In the example above \"2.5.0-3\" is used as the OPAE SDK tools version</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#pcie-bus-number-lines-231-and-238","title":"PCIe (Bus Number) (lines 231 and 238)","text":"<p>The Bus number must be entered by the user after installing the hardware in the chosen server, in the example below \"b1\" is the Bus Number for a single card as defined in the evaluation script.</p> <pre><code>export ADP_CARD0_BUS_NUMBER=b1\n</code></pre> <p>The evaluation script uses the bus number as an identifier to interrogate the card. The command below will identify the accelerator card plugged into a server. </p> <pre><code>lspci | grep acc\n\n86:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <p>The result identifies the card as being assigned \"86\" as the bus number so the entry in the script changes to</p> <pre><code>export ADP_CARD0_BUS_NUMBER=86\n</code></pre> <p>The user can also run the following command on the ofs_d5005_eval.sh script to automatically change the bus number to 86 in the ofs_d5005_eval.sh script.</p> <p>grep -rli '86' * | xargs -i@ sed -i '86' @</p> <p>if the bus number is 85 for example </p> <p>85:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)</p> <p>the command to change to 85 in the evaluation script would be</p> <p>grep -rli '86' * | xargs -i@ sed -i '85' @</p> <p>The ofs_d5005_eval.sh script has now been modified to the server set-up and the user can proceed to build, compile and simulate the OFS stack</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#3-using-the-evaluation-script","title":"3 Using the Evaluation Script","text":""},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#31-overview","title":"3.1 Overview","text":"<p>The evaluation script focuses on different evaluation areas. Each of these menu options is described in the next section.  </p> <p>The figure below shows a snapshot of the full evaluation script menu showing all 57 options and each one of 10 sub-menus which focus on different areas of evaluation. Each of these menu options is described in the next section.</p> <p>Figure 3-1 ofs_d5005_eval.sh Evaluation Menu</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#311-tools-menu","title":"3.1.1 TOOLS MENU","text":"<p>By selecting \"List of Documentation for ADP Intel\u00ae FPGA PAC D5005 Project,\" a list of links to the latest OFS documentation appears. Note that these links will take you to documentation for the most recent release which may not correspond to the release version you are evaluating. To find the documentation specific to your release, ensure you clone the intel-ofs-docs tag that corresponds to your OFS version.</p> <p>By selecting \"Check Versions of Operating System and Quartus Premier Design Suite\", the tool verifies correct Operating System, Quartus version, kernel parameters, license files and paths to installed software tools.</p> <p></p> Menu Option Example Output 1 - List of Documentation for ADP d5005 Project Open FPGA Stack Overview Guides you through the setup and build steps to evaluate the OFS solution https://ofs.github.io 2 - Check versions of Operating System and Quartus Premier Design Suite (QPDS) Checking Linux release Linux version 6.1.22-dfl Checking RedHat release Red Hat Enterprise Linux release RHEL 8.2  Checking Ubuntu release cat: /etc/lsb-release: No such file or directory  Checking Kernel parameters BOOT_IMAGE=(hd0,msdos1)/vmlinuz-6.1.22-dfl-2023.1-1 root=/dev/mapper/rhel-root ro crashkernel=auto resume=/dev/mapper/rhel-swap rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200  Checking Licenses LM_LICENSE_FILE is set to port@socket number:port@socket number DW_LICENSE_FILE is set to port@socket number:port@socket number SNPSLMD_LICENSE_FILE is set to port@socket number:port@socket number  Checking Tool versions QUARTUS_HOME is set to /home/intelFPGA_pro/23.1/quartus QUARTUS_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus IMPORT_IP_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus/../ip QSYS_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus/../qsys/bin  Checking QPDS Patches Quartus Prime Shell Version 23.1"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#312-hardware-menu","title":"3.1.2 HARDWARE MENU","text":"<p>Identifies card by PCIe number, checks power, temperature and current firmware configuration.</p> <p></p> Menu Option Example Output 3 - Identify Acceleration Development Platform (ADP) d5005 Hardware via PCIe PCIe card detected as 86:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01) Host Server is connected to SINGLE card configuration 4 - Identify the Board Management Controller (BMC) Version and check BMC sensors Intel FPGA Programmable Acceleration Card d5005Board Management Controller, MAX10 NIOS FW version: 2.0.13Board Management Controller, MAX10 Build version: 2.0.8//****** BMC SENSORS ******//Object Id : 0xF000000PCIe s:b:d.f : 0000:86:00.0Vendor Id : 0x8086Device Id : 0xBCCESubVendor Id : 0x8086SubDevice Id : 0x138DSocket Id : 0x00Ports Num : 01Bitstream Id : 288511862659474365Bitstream Version : 4.0.1Pr Interface Id : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461 5 - Identify the FPGA Management Engine (FME) Version Intel FPGA Programmable Acceleration Card d5005Board Management Controller, MAX10 NIOS FW version: 2.0.13Board Management Controller, MAX10 Build version: 2.0.8//****** FME ******//Object Id : 0xF000000PCIe s:b:d.f : 0000:86:00.0Vendor Id : 0x8086Device Id : 0xBCCESubVendor Id : 0x8086SubDevice Id : 0x138DSocket Id : 0x00Ports Num : 01Bitstream Id : 288511862659474365Bitstream Version : 4.0.1Pr Interface Id : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461Boot Page : user 6 - Check Board Power and Temperature Intel FPGA Programmable Acceleration Card d5005Board Management Controller, MAX10 NIOS FW version: 2.0.13Board Management Controller, MAX10 Build version: 2.0.8//****** POWER ******//Object Id : 0xF000000PCIe s:b:d.f : 0000:86:00.0Vendor Id : 0x8086Device Id : 0xBCCESubVendor Id : 0x8086SubDevice Id : 0x138DSocket Id : 0x00Ports Num : 01Bitstream Id : 288511862659474365Bitstream Version : 4.0.1Pr Interface Id : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461( 1) VCCERAM Voltage : 0.90 Voltsetc ......................Intel FPGA Programmable Acceleration Card d5005Board Management Controller, MAX10 NIOS FW version: 2.0.13Board Management Controller, MAX10 Build version: 2.0.8//****** TEMP ******//Object Id : 0xF000000PCIe s:b:d.f : 0000:86:00.0Vendor Id : 0x8086Device Id : 0xBCCESubVendor Id : 0x8086SubDevice Id : 0x138DSocket Id : 0x00Ports Num : 01Bitstream Id : 288511862659474365Bitstream Version : 4.0.1Pr Interface Id : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461( 1) VCCT Temperature : 57.00 Celsiusetc ...................... 7 - Check Accelerator Port status //****** PORT ******// Object Id : 0xEF00000PCIe s:b:d.f : 0000:86:00.0Vendor Id : 0x8086Device Id : 0xBCCESubVendor Id : 0x8086SubDevice Id : 0x138DSocket Id : 0x00 8 - Check MAC and PHY status Intel FPGA Programmable Acceleration Card d5005Board Management Controller, MAX10 NIOS FW version: 2.0.13Board Management Controller, MAX10 Build version: 2.0.8//****** MAC ******//Object Id : 0xF000000PCIe s:b:d.f : 0000:86:00.0Vendor Id : 0x8086Device Id : 0xBCCESubVendor Id : 0x8086SubDevice Id : 0x138DSocket Id : 0x00Ports Num : 01Bitstream Id : 288511862659474365Bitstream Version : 4.0.1Pr Interface Id : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461MAC address : 64:4c:36:f:44:1fIntel FPGA Programmable Acceleration Card d5005Board Management Controller, MAX10 NIOS FW version: 2.0.13Board Management Controller, MAX10 Build version: 2.0.8//****** PHY ******//Object Id : 0xF000000PCIe s:b:d.f : 0000:86:00.0Vendor Id : 0x8086Device Id : 0xBCCESubVendor Id : 0x8086SubDevice Id : 0x138DSocket Id : 0x00Ports Num : 01Bitstream Id : 288511862659474365Bitstream Version : 4.0.1Pr Interface Id : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#313-fimpr-build-menu","title":"3.1.3 FIM/PR BUILD MENU","text":"<p>Builds FIM, Partial Reconfiguration Region and Remote Signal Tap</p> <p></p> Menu Option Description 9 - Check ADP software versions for ADP Intel\u00ae FPGA PAC D5005 Project OFS_ROOTDIR is set to /home/user_area/ofs-2023.1/ofs-d5005OPAE_SDK_REPO_BRANCH is set to release/2.5.0-3 OPAE_SDK_ROOT is set to /home/user_area/ofs-2023.1/ofs-d5005/../opae-sdk LD_LIBRARY_PATH is set to /home/user_area/ofs-2023.1/ofs-d5005/../opae-sdk/lib64: 10 - Build FIM for Intel\u00ae FPGA PAC D5005 Hardware This option builds the FIM based on the setting for the $ADP_PLATFORM, $FIM_SHELL environment variable. Check these variables in the following file ofs_d5005_eval.sh 11 - Check FIM Identification of FIM for Intel\u00ae FPGA PAC D5005 Hardware The FIM is identified by the following file fme-ifc-id.txt located at $OFS_ROOTDIR/$FIM_WORKDIR/syn/syn_top/ 12 - Build Partial Reconfiguration Tree for Intel\u00ae FPGA PAC D5005 Hardware This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development and also for the OneAPI build flow 13 - Build Base FIM Identification(ID) into PR Build Tree template This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU and OneAPI workloads 14 - Build Partial Reconfiguration Tree for Intel\u00ae FPGA PAC D5005 Hardware with Remote Signal Tap This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development and also for the OneAPI build flow and for the Remote Signal Tap flow 15 - Build Base FIM Identification(ID) into PR Build Tree template with Remote Signal Tap This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree for Remote Signal Tap to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU and OneAPI workloads"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#314-hardware-programmingdiagnostic-menu","title":"3.1.4 HARDWARE PROGRAMMING/DIAGNOSTIC MENU","text":"<p>The following submenu allows you to: * Program and check flash  * Perform a remote system update (RSU) of the FPGA image into the FPGA * Bind virtual functions to VFIO PCIe driver  * Run host exerciser (HE) commands such as loopback to test interfaces VFIO PCI driver binding * Read the control and status registers (CSRs) for bound modules that are part of the OFS reference design.</p> <p></p> Menu Option Description 16 - Program BMC Image into Intel\u00ae FPGA PAC D5005 Hardware The user must place a new BMC flash file in the following directory $OFS_ROOTDIR/bmc_flash_files. Once the user executes this option a new BMC image will be programmed. A remote system upgrade command is initiated to store the new BMC image 17 - Check Boot Area Flash Image from Intel\u00ae FPGA PAC D5005 Hardware This option checks which location area in FLASH the image will boot from, the default is user1  Boot Page : user1 18 - Program FIM Image into user1 area for Intel\u00ae FPGA PAC D5005 Hardware This option programs the FIM image \"d5005_page1_unsigned.bin\" into user1 area in flash 19 - Initiate Remote System Upgrade (RSU) from user1 Flash Image into Intel\u00ae FPGA PAC D5005 Hardware This option initiates a Remote System Upgrade and soft reboots the server and re-scans the PCIe bus for the new image to be loaded  2022-12-13 07:31:33,244 - [[pci_address(0000:86:00.0), pci_id(0x8086, 0xbcce, 0x8086, 0x138d)]] performing RSU operation 2022-12-13 07:31:33,249 - [[pci_address(0000:85:00.0), pci_id(0x8086, 0x2030, 0x1590, 0x00ea)]] removing device from PCIe bus 2022-12-13 07:31:34,333 - waiting 10.0 seconds for boot 2022-12-13 07:31:44,344 - rescanning PCIe bus: /sys/devices/pci0000:85/pci_bus/0000:85 2022-12-13 07:31:44,377 - RSU operation complete 20 - Check PF/VF Mapping Table, vfio-pci driver binding and accelerator port status This option checks the current vfio-pci driver binding for the PF's and VF's 21 - Unbind vfio-pci driver This option unbinds the vfio-pci driver for the PF's and VF's 22 - Create Virtual Functions (VF) and bind driver to vfio-pci Intel\u00ae FPGA PAC D5005 Hardware This option creates vfio-pci driver binding for the PF's and VF's Once the VF's have been bound to the driver the user can select menu option 20 to check that the new drivers are bound 23 - Run HE-LB Test This option runs 5 tests  1) checks and generates traffic with the intention of exercising the path from the AFU to the Host at full bandwidth 2) run a loopback throughput test using one cacheline per request 3) run a loopback read test using four cachelines per request 4) run a loopback write test using four cachelines per request 5) run a loopback throughput test using four cachelines per request 24 - Run HE-MEM Test This option runs 2 tests  1) Checking and generating traffic with the intention of exercising the path from FPGA connected DDR; data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host 2) run a loopback throughput test using one cacheline per request 25 - Run HE-HSSI Test This option runs 1 test  HE-HSSI is responsible for handling client-side ethernet traffic. It wraps the 10G and 100G HSSI AFUs, and includes a traffic generator and checker. The user-space tool hssi exports a control interface to the HE-HSSI's AFU's packet generator logic  1) Send traffic through the 10G AFU 26 - Read from CSR (Command and Status Registers) for Intel\u00ae FPGA PAC D5005 Hardware This option reads from the following CSR's HE-LB Command and Status Register Default Definitions HE-MEM Command and Status Register Default Definitions HE-HSSI Command and Status Register Default Definitions"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#315-hardware-afu-testing-menu","title":"3.1.5  HARDWARE AFU TESTING MENU","text":"<p>This submenu tests partial reconfiguration by building and loading an memory-mapped I/O example AFU/workload, executes software from host, and tests remote signal tap.</p> <p></p> Menu Option Description 27 - Build and Compile host_chan_mmio example This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB_EXTERNAL/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS (Green Bit Stream) binary file ready for hardware programming 28 - Execute host_chan_mmio example This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test 29 - Modify host_chan_mmio example to insert Remote Signal Tap This option inserts a pre-defined host_chan_mmio.stp Signal Tap file into the OFS code to allow a user to debug the host_chan_mmio AFU example 30 - Build and Compile host_chan_mmio example with Remote Signal Tap This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB_EXTERNAL/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS (Green Bit Stream) binary file ready for hardware programming with Remote Signal tap enabled 31 - Execute host_chan_mmio example with Remote Signal Tap This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test. The user must open the Signal Tap window when running the host code to see the transactions in the Signal Tap window"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#316-hardware-afu-bbb-testing-menu","title":"3.1.6 HARDWARE AFU BBB TESTING MENU","text":"<p>This submenu tests partial reconfiguration using a hello_world example AFU/workload, executes sw from the host</p> <p></p> Menu Option Description 32 - Build and Compile hello_world example This option builds the hello_ world example from the following repo $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/$AFU_BBB_TEST_NAME, where AFU_BBB_NAME=hello_world. This produces a GBS (Green Bit Stream) file ready for hardware programming 33 - Execute hello_world example This option builds the host code for hello_world example and programs the GBS file and then executes the test"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#317-adp-oneapi-project-menu","title":"3.1.7 ADP ONEAPI PROJECT MENU","text":"<p>Builds OneAPI kernel, executes the software from host and runs diagnostic tests</p> <p></p> Menu Option Result 34 - Check oneAPI software versions for Intel\u00ae FPGA PAC D5005 Project This option checks the setup of the oneAPI software and adds the relevant oneAPI environment variables to the terminal. This option also informs the user to match the oneAPI software version to the oneAPI-samples version 35 - Build and clone shim libraries required by oneAPI host This option builds the oneAPI directory structure 36 - Install OneAPI Host Driver This option Installs the oneAPI Host driver at the following location /opt/Intel/OpenCLFPGA/oneAPI/Boards/, and requires sudo permission 37 - Uninstall One API Host Driver This option Uninstall's the oneAPI Host driver, and requires sudo permissions 38 - Diagnose oneAPI Hardware This option Checks ICD (Intel Client Driver) and FCD (FPGA Client Driver), oneAPI library locations and detects whether oneAPI BSP is loaded into the FPGA 39 - Build oneAPI BSP ofs-d5005 Default Kernel (hello_world) This option Builds the oneAPI BSP using hello_world kernel 40 - Build oneAPI MakeFile Environment This option Builds the oneAPI environment using a Makefile for kernel insertion 41 - Compile oneAPI Sample Application (board_test) for Emulation This option compiles the board_test kernel for Emulation 42 - Run oneAPI Sample Application (board_test) for Emulation This option executes the board_test kernel for Emulation 43 - Generate oneAPI Optimization report for (board_test) This option generates an optimization report for the board_test kernel 44 - Check PF/VF Mapping Table, vfio-pci driver binding and accelerator port status This option checks the current vfio-pci driver binding for the PF's and VF's 45 - Unbind vfio-pci driver This option unbinds the vfio-pci driver for the PF's and VF's 46 - Create Virtual Function (VF) and bind driver to vfio-pci Intel\u00ae FPGA PAC D5005 Hardware This option creates vfio-pci driver binding for the PF's and VF's Once the VF's have been bound to the driver the user can select menu option 45 to check that the new drivers are bound 47 - Program oneAPI BSP ofs-d5005 Default Kernel (hello_world) This option programs the FPGA with a aocx file based on the hello_world kernel 48 - Compile oneAPI Sample Application (board_test) for Hardware This option compiles the board_test kernel for Hardware 49 - Run oneAPI Sample Application (board_test) for Hardware This option builds the host code for board_test kernel and executes the program running through kernel and host bandwidth tests"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#318-unit-test-project-menu","title":"3.1.8 UNIT TEST PROJECT MENU","text":"<p>Builds, compiles and runs standalone simulation block tests. More unit test examples are found at the following location ofs-d5005/sim/unit_test </p> <p></p> Menu Option Result 50 - Generate Simulation files for Unit Test This option builds the simulation file set for running a unit test simulation 51 - Simulate Unit Test dfh_walker and log waveform This option runs the dfh_walker based on the environment variable \"UNIT_TEST_NAME=dfh_walker\" in the evaluation script. A user can change the test being run by modifying this variable"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#319-adp-uvm-project-menu","title":"3.1.9 ADP UVM PROJECT MENU","text":"<p>Builds, compiles and runs full chip simulation tests. The user should execute the options sequentially ie 52, 53, 54 and 55</p> <p></p> Menu Option Description 52 - Check UVM software versions for Intel\u00ae FPGA PAC D5005 Project DESIGNWARE_HOME is set to /home/synopsys/vip_common/vip_Q-2020.03A UVM_HOME is set to /home/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm VCS_HOME is set to /home/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel VERDIR is set to /home/user_area/ofs-2023.1/ofs-d5005/verification VIPDIR is set to /home/user_area/ofs-2023.1/ofs-d5005/verification 53 - Compile UVM IP This option compiles the UVM IP 54 - Compile UVM RTL and Testbench This option compiles the UVM RTL and Testbench 55 - Simulate UVM ofs_mmio_test and log waveform This option runs the dfh_walking test based on the environment variable \"UVM_TEST_NAME=dfh_walking_test\" in the evaluation script. A user can change the test being run by modifying this variable 56 - Simulate all UVM test cases (Regression Mode) This option runs the Intel\u00ae FPGA PAC D5005 regression mode, cycling through all UVM tests defined in /ofs-d5005/verification/tests/test_pkg.svh file"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#3110-adp-build-all-project-menu","title":"3.1.10 ADP BUILD ALL PROJECT MENU","text":"<p>Builds the complete OFS flow, good for regression testing and overnight builds</p> <p>For this menu, a user can run a sequence of tests (compilation, build and simulation) and executes them sequentially. After the script is successfully executed, a set of binary files is produced which a you can use to evaluate your hardware. Log files are also produced which checks whether the tests passed.</p> <p>A user can run a sequence of tests and execute them sequentially. In the example below when the user selects option 57 from the main menu the script will execute 23 tests ie (main menu options 2, 9, 10, 11, 12, 13, 14, 15, 27, 29, 30, 32, 34, 35, 39, 40, 48, 50, 51, 52, 53, 54 and 55. These 23 menu options are chosen to build the complete OFS flow covering build, compile and simulation.</p> <p></p> Menu Option Result 57 - Build and Simulate Complete Intel\u00ae FPGA PAC D5005  Project Generating Log File with date and timestamp Log file written to /home/user_area/ofs-2023.1/log_files/d5005_log_2022_11_10-093649/ofs-d5005_eval.log <p>Definition of Multi-Test Set-up</p> <p>Menu Option 57 above in the evaluation script can be refined to tailor the number of tests the users runs. The set-up is principally defined by the variable below</p> <p>MULTI_TEST[A,B]=C</p> <p>where</p> <p>A= Total Number of menu options in script B= Can be changed to a number to select the test order C= Menu Option in Script</p> <p>Example 1 MULTI_TEST[57,0]=2</p> <p>A= 57 is the total number of options in the script B= 0 indicates that this is the first test to be run in the script C= Menu option in Script ie 2- List of Documentation for ADP Intel\u00ae FPGA PAC D5005 Project</p> <p>Example 2 MULTI_TEST[57,0]=2 MULTI_TEST[57,1]=9</p> <p>In the example above two tests are run in order ie 0, and 1 and the following menu options are executed ie 2- List of Documentation for ADP Intel\u00ae FPGA PAC D5005 Project and 9 - Check ADP software versions for ADP Intel\u00ae FPGA PAC D5005 Project</p> <p>The user can also modify the build time by de-selecting options they do not wish to use, see below for a couple of use-case scenarios.</p> <p>Default User Case</p> <p>A user can run a sequence of tests and execute them sequentially. In the example below when the user selects option 57 from the main menu the script will execute 23 tests ie (main menu options 2, 9, 10, 11, 12, 13, 14, 15, 27, 29, 30, 32, 34, 35, 39, 40, 48, 50, 51, 52, 53, 54 and 55. All other tests with an \"X\" indicates do not run that test</p> <p></p> <p>User Case for ADP FIM/PR BUILD MENU</p> <p>In the example below when the user selects option 57 from the main menu the script will only run options from the ADP FIM/PR BUILD MENU (7 options, main menu options 9, 10, 11, 12, 13, 14 and 15). All other tests with an \"X\" indicates do not run that test.</p> <p></p> <p></p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#4-common-test-scenarios","title":"4 Common Test Scenarios","text":"<p>This section will describe the most common compile build scenarios if a user wanted to evaluate an acceleration card on their server. The Pre-requisite column indicates the menu commands that must be run before executing the test eg To run Test 5 then a user needs to have run option 10, 12 and 13 before running options 20, 21, 22, 27 and 28.</p> Test Test Scenario Pre-Requisite Menu Option Menu Option Test 1 FIM Build - 10 Test 2 Partial Reconfiguration Build 10 12 Test 3 Program FIM and perform Remote System Upgrade 10 18, 19 Test 4 Bind PF and VF to vfio-pci drivers - 20, 21, 22 Test 5 Build, compile and test AFU on hardware 10, 12, 13 20, 21, 22, 27, 28 Test 6 Build, compile and test AFU Basic Building Blocks on hardware 10, 12, 13 20, 21, 22, 32, 33 Test 7 Build, compile and test oneAPI on hardware 10, 12, 13 34, 35, 36, 39, 40, 44, 45, 46, 47, 48, 49 Test 8 Build and Simulate Unit Tests - 50, 51 Test 9 Build and Simulate UVM Tests - 52, 53, 54, 55"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/","title":"Getting Started Guide: Open FPGA Stack for Intel Stratix 10","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#10-introduction","title":"1.0 Introduction","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#11-about-this-document","title":"1.1 About This Document","text":"<p>This document helps users get started in evaluating Open FPGA Stack (OFS) for Intel\u00ae Stratix 10\u00ae FPGA targeting the Intel\u00ae FPGA PAC D5005. After reviewing the document a user shall be able to:</p> <ul> <li>Set up a development environment with all OFS ingredients</li> <li>Build and install the OFS Linux Kernel drivers</li> <li>Build and install the Open Programmable Acceleration Engine Software Development Kit (OPAE SDK) software on top of the OFS Linux kernel drivers</li> <li>Flash an OFS FIM binary onto the Intel\u00ae FPGA PAC D5005</li> <li>Verify the functionality of OFS on an Intel\u00ae FPGA PAC D5005 board</li> <li>Know where to find additional information on all OFS ingredients</li> </ul> <p>The following flow charts show a high level overview of the initial bringup process, split into three sequential diagrams.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#diagram-1-installing-the-opae-sdk","title":"Diagram 1: Installing the OPAE SDK","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#diagram-2-installing-the-linux-dfl-drivers","title":"Diagram 2: Installing the Linux DFL Drivers","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#diagram-3-bringing-up-the-intel-d5005","title":"Diagram 3: Bringing up the Intel D5005","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#12-terminology","title":"1.2 Terminology","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#13-introduction-to-ofs","title":"1.3 Introduction to OFS","text":"<p>Each OFS reference FIM targets a specific platform, but the modular hardware, software, simulation and test infrastructure allows you to modify each part of the design and test environment for your own custom acceleration platform card. The current OFS reference FIM for Stratix 10 FPGA targets the Intel\u00ae FPGA PAC D5005 board. This document focuses exclusively on the OFS release targeting the Intel\u00ae FPGA PAC D5005 board.</p> <p>The OFS repositories (in OFS ) on GitHub provide the following components targeting an Intel\u00ae FPGA PAC D5005:</p> <ul> <li>opae-sdk: Contains the Open Programmable Acceleration Software Development Kit source code and build scripts. The following submodule repositories are contained within <code>opae-sdk</code></li> <li>linux-dfl: Contains Linux kernel-level driver source code and build scripts.</li> <li>intel-ofs-fim: Contains the source code, build scripts and verification suite for FPGA RTL source code</li> <li>ofs-hld-shim: Contains the necessary files to generate Shim/BSP for OFS Cards, using OPAE SDK Interfaces.</li> </ul>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#14-intended-audience","title":"1.4 Intended Audience","text":"<p>The information in this document is intended for customers evaluating the Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA on the Intel PAC D5005. This document will cover key topics related to initial setup and development, with links for deeper dives on the topics discussed therein.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#15-reference-documents","title":"1.5 Reference Documents","text":"<p>Please refer to the README on the OFS GitHub for an updated list of collateral on the OFS GitHub page.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#16-component-version-summary","title":"1.6 Component Version Summary","text":"<p>The OFS 2023.1 Release targeting the Intel\u00ae Stratix 10\u00ae FPGA is built upon tightly coupled software and firmware versions. Use this section as a general reference for the versions which comprise this release.</p> <p>The following table highlights the hardware which makes up the Best Known Configuration (BKC) for the OFS 2023.1 release.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-1-2-hardware-bkc","title":"Table 1-2: Hardware BKC","text":"Component 1 x Intel\u00ae FPGA PAC D5005 1 x Supported Server Model 1 x Intel FPGA Download Cable II   **(Optional, only required if loading images via JTAG)* <p>The following table highlights the versions of the software which comprise the OFS stack. The installation of the user-space OPAE SDK on top of the kernel-space linux-dfl drivers is discussed in subsequent sections of this document.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-1-3-software-version-summary","title":"Table 1-3: Software Version Summary","text":"Component Version FPGA Platform Intel\u00ae FPGA PAC D5005 OPAE SDK Tag: 2.5.0-3 Kernel Drivers Tag: ofs-2023.1-6.1-1 OFS FIM Source Code Branch: release/ofs-2023.1 Intel Quartus Prime Pro Edition Design Software 23.1 Intel\u00ae Quartus\u00ae Prime Pro Edition Linux Operating System RHEL 8.2 <p>A download page containing the release and already-compiled FIM binary artifacts that you can use for immediate evaluation on the Intel\u00ae FPGA PAC D5005 can be found on the OFS 2023.1 official release drop on GitHub.</p> <p>Note: If you wish to freeze your Red Hat operating system version on the RHEL 8.2, refer to the following solution provided in the Red Hat customer portal.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#20-ofs-stack-architecture-overview-for-reference-platform","title":"2.0 OFS Stack Architecture Overview for Reference Platform","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#21-hardware-components","title":"2.1 Hardware Components","text":"<p>The OFS hardware architecture decomposes all designs into a standard set of modules, interfaces, and capabilities. Although the OFS infrastructure provides a standard set of functionality and capability, the user is responsible for making the customizations to their specific design in compliance with the specifications outlined in the Open FPGA Stack Technical Reference Manual.</p> <p>OFS is a blanket term which can be used to collectively refer to all ingredients of the OFS reference design, which includes the core hardware components discussed below and software.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#211-fpga-interface-manager","title":"2.1.1 FPGA Interface Manager","text":"<p>The FPGA Interface Manager (FIM) or 'shell' provides platform management functionality, clocks, resets, and interface access to the host and peripheral features on the acceleration platform. The FIM is implemented in a static region of the FPGA device.</p> <p>The primary components of the FIM reference design are:</p> <ul> <li>PCIe Subsystem</li> <li>Transceiver Subsystem</li> <li>Memory Subsystem</li> <li>FPGA Management Engine</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from host or AFU</li> <li>Interface to Board Management Controller (BMC)</li> </ul> <p>The FPGA Management Engine (FME) provides management features for the platform and the loading/unloading of accelerators through partial reconfiguration.</p> <p>For more information on the FIM and its external connections, please refer to the Open FPGA Stack Technical Reference Manual, and the Intel FPGA Programmable Acceleration Card D5005 Data Sheet. Below is a high-level block diagram of the FIM.</p> <p>Figure 2-1 FIM Overview</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#212-afu","title":"2.1.2 AFU","text":"<p>An AFU is an acceleration workload that interfaces to the FIM. The AFU boundary in this reference design comprises both static and partial reconfiguration (PR) regions. You can decide how you want to partition these two areas or if you want your AFU region to only be a partial reconfiguration region. A port gasket within the design provides all the PR specific modules and logic required for partial reconfiguration. Only one partial reconfiguration region is supported in this design.</p> <p>Similar to the FME, the port gasket exposes its capabilities to the host software driver through a DFH register placed at the beginning of the port gasket CSR space. In addition, only one PCIe link can access the port register space.</p> <p>You can compile your design in one of the following ways:</p> <ul> <li>Your AFU resides in a partial reconfiguration (PR) region of the FPGA.</li> <li>Your AFU is a part of the static region (SR) and is a compiled flat design.</li> <li>Your AFU contains both static and PR regions.</li> </ul> <p>The AFU provided in this release is comprised of the following functions:</p> <ul> <li>AFU interface handler to verify transactions coming from the AFU region.</li> <li>PV/VF Mux to route transactions to and from corresponding AFU components, including the ST2MM module, PCIe loopback host exerciser (HE-LB), HSSI host exerciser (HE-HSSI), and Memory Host Exerciser (HE-MEM).</li> <li>AXI4 Streaming to Memory Map (ST2MM) Module that routes MMIO CSR accesses to FME and board peripherals.</li> <li>Host exercisers to test PCIe, memory and HSSI interfaces (these can be removed from the AFU region after your FIM design is complete to provide more resource area for workloads).</li> <li>Port gasket and partial reconfiguration support.</li> </ul> <p>For more information on the Platform Interface Manager (PIM) and AFU development and testing, please refer to the OFS AFU Development Guide.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#22-ofs-software-overview","title":"2.2 OFS Software Overview","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#221-kernel-drivers-for-ofs","title":"2.2.1 Kernel Drivers for OFS","text":"<p>OFS DFL driver software provides the bottom-most API to FPGA platforms. Libraries such as OPAE and frameworks like DPDK are consumers of the APIs provided by OFS. Applications may be built on top of these frameworks and libraries. The OFS software does not cover any out-of-band management interfaces. OFS driver software is designed to be extendable, flexible, and provide for bare-metal and virtualized functionality. An in depth look at the various aspects of the driver architecture such as the API, an explanation of the DFL framework, and instructions on how to port DFL driver patches to other kernel distributions can be found on the DFL Wiki page.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#30-intel-fpga-pac-d5005-card-and-server-requirements","title":"3.0 Intel FPGA PAC D5005 Card and Server Requirements","text":"<p>Currently OFS for Intel\u00ae Stratix 10\u00ae FPGA targets the Intel\u00ae FPGA PAC D5005. Because the Intel\u00ae FPGA PAC D5005 is a production card, you must prepare the card in order to receive a new non-production bitstream. For these instructions, please contact an Intel representative.</p> <p>In addition, refer to sections 2.1-2.3 of the Intel Acceleration Stack Quick Start Guide: Intel FPGA Programmable Acceleration Card D5005 for a complete overview of the physical installation process and ESD precautions for the D5005 platform.</p> <p>Note: Ensure that the system meets all the following requirements   before proceeding to install the Intel\u00ae FPGA PAC D5005 into a server.</p> <p>Table 3-1 Server Requirements for Intel D5005</p> Component Description Server Qualified Servers Main Board PCI Express 3.0 compliant motherboard with at least one dual-width x16 PCIe slot available for card installation Board Power Supply* Auxiliary Power (12V) <p>* For more information on the required auxiliary power supply, refer to section 2.2.2 of the Intel FPGA Programmable Acceleration Card D5005 Data Sheet.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#31-supported-processors-for-intel-d5005","title":"3.1 Supported Processors for Intel D5005","text":"<p>OFS requires that the deployment machine's Xeon processor must support the following technologies. These options must also be enabled in the BIOS and as kernel parameters. The process to enable these parameters will be discussed in the section on driver installation:</p> <ul> <li>Intel VT-d (Intel Virtualization Technology for IA-32 and Intel 64 Processors)</li> <li>Intel VT-x (Intel Virtualization Technology for Directed I/O)</li> <li>Intel IOMMU</li> </ul>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#32-cooling-requirements-for-the-intel-fpga-pac-d5005","title":"3.2 Cooling Requirements for the Intel FPGA PAC D5005","text":"<p>Please refer to sections 8.1 and 8.2 of the Intel FPGA Programmable Acceleration Card D5005 Data Sheet for guidance on cooling specifications that must be met when using the D5005 card. Failure to adhere to these guidelines may result in thermal runaway and/or performance degradation.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#40-ofs-dfl-kernel-drivers","title":"4.0 OFS DFL Kernel Drivers","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#41-ofs-dfl-kernel-driver-environment-setup","title":"4.1 OFS DFL Kernel Driver Environment Setup","text":"<p>All OFS DFL kernel driver code resides in the Linux DFL GitHub repository. This repository is open source and does not require any permissions to access. It includes a snapshot of the latest best-known configuration (BKC) Linux kernel with the OFS driver included in the drivers/fpga/* directory. Downloading, configuration, and compilation will be discussed in this section. Please refer to Table 1-3 for the latest supported OS.</p> <p>It is recommended you boot into your operating system's native 4.18.x kernel  before attempting to upgrade to the dfl enabled 6.1.22 You may experience issues when moving between two dfl enabled 6.1.22  kernels.</p> <p>This installation process assumes the user has access to an internet connection in order to pull specific GitHub repositories, and to satisfy package dependencies.</p> <p>1. You must make the following changes in order to install all dependencies on the latest BKC Operating System. These are required to both build and install the drivers from source, and to install them from pre-built packages:</p> <p></p> <pre><code>subscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\nsudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n</code></pre> <p>2. You must satisfy the following package dependencies if building and installing the drivers from source. Double check that all packages have been found and installed:</p> <p></p> <pre><code>sudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libuuid-devel rpm-build systemd-devel sudo nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\nspdlog-devel cli11-devel python3-pyyaml hwloc-devel libedit-devel openssl-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install --upgrade setuptools --prefix=/usr\n\n# To Install pybind11 following are the steps\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm' --output ./python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm' --output ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n</code></pre> <p>It is recommended you create an empty top-level directory for their OFS related repositories to keep the working environment clean. All steps in this installation will use a generic top-level directory at <code>/home/user/OFS/</code>. If you have created a different top-level directory, replace this path with your custom path.</p> <p>3. Initialize an empty git repository and clone the LTS tagged DFL driver source code: </p> <pre><code>cd /home/user/OFS/\ngit init\ngit clone https://github.com/OPAE/linux-dfl\ncd /home/user/OFS/linux-dfl\ngit checkout tags/ofs-2023.1-6.1-1 -b fpga-ofs-dev-6.1.22\n</code></pre> <p>4. Verify that the correct tag has been checkout out.</p> <pre><code>git describe ofs-2023.1-6.1-1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#42-building-and-installing-the-ofs-dfl-kernel-drivers-from-source","title":"4.2 Building and Installing the OFS DFL Kernel Drivers from Source","text":"<p>1. The following set of instructions walk you through copying an existing kernel configuration file on your machine and changing the minimal required configuration settings:</p> <pre><code>cd /home/user/OFS/linux-dfl\ncp /boot/config-`uname -r` .config\ncat configs/dfl-config &gt;&gt; .config\necho 'CONFIG_LOCALVERSION=\"-dfl\"' &gt;&gt; .config\necho 'CONFIG_LOCALVERSION_AUTO=y' &gt;&gt; .config\nsed -i -r 's/CONFIG_SYSTEM_TRUSTED_KEYS=.*/CONFIG_SYSTEM_TRUSTED_KEYS=\"\"/' .config\nsed -i '/^CONFIG_DEBUG_INFO_BTF/ s/./#&amp;/' .config\necho 'CONFIG_DEBUG_ATOMIC_SLEEP=y' &gt;&gt; .config\nexport LOCALVERSION=\nmake olddefconfig\n</code></pre> <p>(Optional) To use the built-in GUI menu for editing kernel configuration parameters, you can opt to run <code>make menuconfig</code>.</p> <p>2. Linux kernel builds take advantage of multiple processors to parallelize the build process. Display how many processors are available with the <code>nproc</code> command, and then specify how many make threads to utilize with the -j option. Note that number of threads can exceed the number of processors. In this case, the number of threads are set to the number of processors in the system.</p> <p></p> <pre><code>cd /home/user/OFS/linux-dfl\nmake -j `nproc`\nmake -j `nproc` modules\n</code></pre> <p>3. The user has two options for installation from source:</p> <ul> <li>Using the built-in install option from the kernel Makefile.</li> <li>Locally building a set of RPM/DEB packages.</li> </ul> <p>3.a This first flow will directly install the kernel and kernel module files without the need to create a package first:</p> <pre><code>cd /home/user/OFS/linux-dfl\nsudo make -j `nproc` modules_install\nsudo make -j `nproc` install\n</code></pre> <p>3.b This second flow will locally build a set of packages. The package options for this flow as as follows:</p> <ul> <li>rpm-pkg: Build both source and binary RPM kernel packages</li> <li>binrpm-pkg: Build only the binary kernel RPM package</li> <li>deb-pkg: Build both source and binary deb kernel packages</li> <li>bindeb-pkg: Build only the binary kernel deb package</li> </ul> <p>If you are concerned about the size of the resulting package and binaries, you can significantly reduce the size of the package and object files by using the make variable INSTALL_MOD_STRIP. If this is not a concern, feel free to skip this step. The below instructions will build a set of binary RPM packages:</p> <pre><code>cd /home/user/OFS/linux-dfl\nmake INSTALL_MOD_STRIP=1 binrpm-pkg\n</code></pre> <p>3.b.1 By default a directory is created in your <code>home</code> directory called <code>rpmbuild</code>. This directory will house all of the kernel packages which have been built. You need to navigate to the newly built kernel packages and install them. The following files were generated using the build command executed in the previous step:</p> <pre><code>cd ~/rpmbuild/RPMS/x86_64\nls\nkernel-6.1.22_dfl-1.x86_64.rpm  kernel-headers-6.1.22_dfl-1.x86_64.rpm\nsudo dnf localinstall kernel*.rpm\n</code></pre> <p>4. The system will need to be rebooted for changes to take effect. After a reboot, select the newly built kernel as the boot target. This can be done pre-boot using the command <code>grub2-reboot</code>, which removes the requirement for user intervention. After boot, verify that the currently running kernel matches expectation.</p> <pre><code>uname -r\n6.1.22-dfl\n</code></pre> <p>5. Verify the DFL drivers have been successfully installed. If an Intel\u00ae FPGA PAC D5005 card with the appropriate FIM is on the local system, the kernel driver modules will have been loaded. In the <code>lsmod</code> output the second column corresponds to the size of the kernel module in bytes, the third column displays the number of devices registered to that driver, and the fourth column displays the names of the devices using it. Verify their versions against the below.</p> <pre><code>lsmod | grep -e fpga -e dfl\n#output\nuio_dfl                20480  0\nspi_altera_dfl         20480  0\nuio                    20480  1 uio_dfl\ndfl_emif               16384  0\nspi_altera_core        16384  1 spi_altera_dfl\ndfl_fme_region         20480  0\ndfl_fme_br             16384  0\ndfl_fme_mgr            20480  0\ndfl_afu                36864  0\ndfl_fme                49152  0\ndfl_pci                20480  0\ndfl                    40960  8 dfl_pci,s10hssi,uio_dfl,dfl_fme,dfl_fme_br,dfl_afu,spi_altera_dfl,dfl_emif\nfpga_region            20480  3 dfl_fme_region,dfl_fme,dfl\nfpga_bridge            20480  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br\nfpga_mgr               24576  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme\n</code></pre> <p>If an Intel\u00ae FPGA PAC D5005 card is not installed in the system and/or does not have the appropriate FIM configured, the user may read version information of the DFL drivers directly from <code>/lib/modules</code>:</p> <pre><code>cd /usr/lib/modules/`uname -r`/kernel/drivers/fpga\nmodinfo dfl* fpga* | grep ^name\n#output\nname:           dfl_afu\nname:           dfl_fme_br\nname:           dfl_fme\nname:           dfl_fme_mgr\nname:           dfl_fme_region\nname:           dfl_hssi\nname:           dfl\nname:           dfl_n3000_nios\nname:           dfl_pci\nname:           fpga_bridge\nname:           fpga_mgr\nname:           fpga_regions\n</code></pre> <p>6. Four kernel parameters must be added to the boot command-line for the newly installed kernel. First, open the file <code>grub</code>:</p> <pre><code>sudo vim /etc/default/grub\n</code></pre> <p>7. In the variable GRUB_CMDLINE_LINUX add the parameters shown after <code>quiet</code>:</p> <pre><code>GRUB_CMDLINE_LINUX=\"crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200\"\n</code></pre> <p>Note: If you wish to instead set hugepages on a per session basis, you can perform the following step. These settings will be lost on reboot.</p> <pre><code>mkdir -p /mnt/huge mount -t hugetlbfs nodev /mnt/huge echo 2048 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages echo 2048 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages </code></pre> <p>8. Save your edits, then apply them to the GRUB2 configuration file.</p> <pre><code>sudo grub2-mkconfig  -o /boot/efi/EFI/redhat/grub.cfg\n</code></pre> <p>9. Warm reboot. Your kernel parameter changes should have taken affect.</p> <pre><code>cat /proc/cmdline\nBOOT_IMAGE=(hd0,gpt2)/vmlinuz-6.1.22-dfl root=/dev/mapper/rhel_bapvedell028-root ro crashkernel=auto resume=/dev/mapper/rhel_bapvedell028-swap rd.lvm.lv=rhel_bapvedell028/root rd.lvm.lv=rhel_bapvedell028/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#50-opae-software-development-kit","title":"5.0 OPAE Software Development Kit","text":"<p>The OPAE SDK software stack sits in user space on top of the OFS kernel drivers. It is a common software infrastructure layer that simplifies and streamlines integration of programmable accelerators such as FPGAs into software applications and environments. OPAE consists of a set of drivers, user-space libraries, and tools to discover, enumerate, share, query, access, manipulate, and reconfigure programmable accelerators. OPAE is designed to support a layered, common programming model across different platforms and devices. To learn more about OPAE, its documentation, code samples, an explanation of the available tools, and an overview of the software architecture, please visit the OPAE GitHub page.</p> <p>The OPAE SDK source code is contained within a single GitHub repository hosted at the OPAE GitHub. This repository is open source.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#51-opae-sdk-build-environment-setup","title":"5.1 OPAE SDK Build Environment Setup","text":"<p>Ensure the local environment matches the supported Operating System discussed in section Table 1-3: Software Version Summary. This installation process assumes you have access to an internet connection in order to pull specific GitHub repositories, and to satisfy package dependencies.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#511-building-and-installing-the-opae-sdk-from-source","title":"5.1.1 Building and Installing the OPAE SDK from Source","text":"<p>1. Before OPAE SDK installation the user must remove any prior OPAE frameworks.  To remove these packages:  <pre><code>sudo dnf remove opae*\n</code></pre></p> <p>2. You must make the following changes to install all dependencies on RHEL 8.2:  <pre><code>subscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\nsudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n</code></pre></p> <p>3. You must satisfy the following package dependencies. Double check that all packages have been found and installed:</p> <p></p> <pre><code>sudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libarchive libuuid-devel rpm-build systemd-devel sudo nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\nspdlog-devel cli11-devel python3-pyyaml hwloc-devel libedit-devel openssl-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install --upgrade setuptools --prefix=/usr\n\n# To Install pybind11 following are the steps\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm' --output ./python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm' --output ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n</code></pre> <p>It is recommended you create an empty top-level directory for their OFS related repositories to keep the working environment clean. All steps in this installation will use a generic top-level directory at <code>/home/user/OFS/</code>. If you have created a different top-level directory, replace this path with your custom path.</p> <p>4. Initialize an empty git repository and clone the tagged OPAE SDK source code:  <pre><code>cd /home/user/OFS/\ngit init\ngit clone https://github.com/OPAE/opae-sdk.git\ncd opae-sdk\ngit checkout tags/2.5.0-3 -b release/2.5.0\n</code></pre></p> <p>5. Verify that the correct tag has been checkout out:  <pre><code>git describe --tags\n2.5.0-3\n</code></pre></p> <p>6. Build the OPAE SDK source code, and pack it into several local RPM packages. Building the code into packages allows for easier installation and removal.  <pre><code>cd packaging/opae/rpm\n./create fedora\n</code></pre></p> <p>7. After a successful compile there should be 8 packages present:  <pre><code>ls | grep rpm\n#output\nopae-2.5.0-3.el8.src.rpm\nopae-2.5.0-3.el8.x86_64.rpm\nopae-debuginfo-2.5.0-3.el8.x86_64.rpm\nopae-debugsource-2.5.0-3.el8.x86_64.rpm\nopae-devel-2.5.0-3.el8.x86_64.rpm\nopae-devel-debuginfo-2.5.0-3.el8.x86_64.rpm\nopae-extra-tools-2.5.0-3.el8.x86_64.rpm\nopae-extra-tools-debuginfo-2.5.0-3.el8.x86_64.rpm\n</code></pre> Remove the opae-2.5.0-3.el8.src.rpm file as it is not used. <pre><code>rm opae-2.5.0-3.el8.src.rpm\n</code></pre></p> <p>7.a Install the user-built OPAE SDK packages:</p> <pre><code>sudo dnf clean all\n\nsudo dnf localinstall -y opae*.rpm\n</code></pre> <p>8. Check that all packages have been installed:</p> <pre><code>rpm -qa | grep opae\n#output\nopae-extra-tools-2.5.0-3.el8.x86_64\nopae-debugsource-2.5.0-3.el8.x86_64\nopae-2.5.0-3.el8.x86_64\nopae-extra-tools-debuginfo-2.5.0-3.el8.x86_64\nopae-debuginfo-2.5.0-3.el8.x86_64\nopae-devel-2.5.0-3.el8.x86_64\nopae-devel-debuginfo-2.5.0-3.el8.x86_64\n</code></pre> <p>You can query information about each installed package using <code>rpm -qi &lt;package__name&gt;</code>.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#52-opae-tools-overview","title":"5.2 OPAE Tools Overview","text":"<p>The OPAE SDK user-space tools sit upon the kernel-space DFL drivers. In order to use OPAE SDK functionality the user needs to complete the steps outlined in the previous section 4.1 OFS DFL Kernel Driver Environment Setup before attempting to run any OPAE commands or flows. You must have at least one D5005 card with the appropriate FIM present in your system. The steps to read and load a new FIM version are discussed in section 6.1 Programming the OFS FIM. After both the DFL kernel-space drivers have been installed and the FIM has been upgraded, you may proceed to test the OPAE commands discussed below.</p> <p>This section covers basic functionality of the commonly used OPAE tools and their expected results. These steps may also be used to verify that all OFS software installation has been completed successfully. A complete overview of the OPAE tools can be found on the OPAE GitHub and in your cloned GitHub repo at <code>&lt;your path&gt;/opae-sdk/doc/src/fpga_tools</code>. More commands are listed than are defined in the list below - most of these are called by other tools and do not need to be called directly themselves.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#521-fpgasupdate","title":"5.2.1 <code>fpgasupdate</code>","text":"<p>The fpgasupdate tool updates the Intel Max10 BMC image and firmware, root entry hash, and FPGA Static Region (SR) and user image (PR). The fpgasupdate will only accept images that have been formatted using PACsign. If a root entry hash has been programmed onto the board, then the image will also need to be signed using the correct keys. Please refer to the [Security User Guide: Intel Open FPGA Stack] for information on created signed images and on programming and managing the root entry hash.</p> <p>The Intel FPGA PAC ships with a factory and user programmed image for both the FIM and BMC FW and RTL on all cards.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-5-1-fpgasupdate-overview","title":"Table 5-1: <code>fpgasupdate</code> Overview","text":"<p>Synopsis:</p> <pre><code>fpgasupdate [--log-level=&lt;level&gt;] file [bdf]\n</code></pre> <p>Description: The fpgasupdate command implements a secure firmware update.</p> Command args (optional) Description --log-level  Specifies the <code>log-level</code> which is the level of information output to your command tool. The following seven levels  are available: <code>state</code>, <code>ioctl</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, <code>critical</code>. Setting <code>--log-level=state</code> provides the most verbose output. Setting <code>--log-level=ioctl</code> provides the second most information, and so on. The default level is <code>info</code>. file Specifies the secure update firmware file to be programmed. This file may be to program a static region (SR), programmable region (PR), root entry hash, key cancellation, or other device-specific firmware. bdf The PCIe address of the PAC to program. <code>bdf</code> is of the form <code>[ssss:]bb:dd:f</code>, corresponding to PCIe segment, bus, device, function. The segment is optional. If you do not specify a segment, the segment defaults to <code>0000</code>. If the system has only one PAC you can omit the <code>bdf</code> and let <code>fpgasupdate</code>  determine the address automatically."},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#522-fpgainfo","title":"5.2.2 <code>fpgainfo</code>","text":"<p>Synopsis:</p> <pre><code>   fpgainfo [-h] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\n{errors,power,temp,fme,port,bmc,mac,phy,security}\n</code></pre> <p>Description:  Displays FPGA information derived from sysfs files. The command argument is one of the following: errors, power, temp, port, fme, bmc, phy or mac, security. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p> Command args (optional) Description --help, -h Prints help information and exits. --version, -v Prints version information and exits. -S, --segment PCIe segment number of resource. -B, --bus PCIe bus number of resource. -D, --device PCIe device number of resource. -F, --function PCIe function number of resource. errors {fme, port, all} --clear, -c First agument to the errors command specifies the resource type to display in human readable format. The second optional argument clears errors for the given FPGA resource. power Provides total power in watts that the FPGA hardware consumes temp Provides FPGA temperature values in degrees Celsius port Provides information about the port fme Provides information about the FME bmc Provides BMC sensors information mac Provides information about MAC ROM connected to FPGA security Provides information about the security keys, hashes, and flash count, if available. <p>Note: Your Bitstream ID and PR Interface Id may not match the below examples.</p> <p>The following examples walk through sample outputs generated by <code>fpgainfo</code>.</p> <pre><code>sudo fpgainfo fme\n#output\nOpen FPGA Stack Platform\nBoard Management Controller, MAX10 NIOS FW version: 2.0.13\nBoard Management Controller, MAX10 Build version: 2.0.8\n//****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 288511862659474365\nBitstream Version                : 4.0.1\nPr Interface Id                  : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461\nBoot Page                        : user\n</code></pre> <pre><code>sudo fpgainfo bmc\n#output\nOpen FPGA Stack Platform\nBoard Management Controller, MAX10 NIOS FW version: 2.0.13\nBoard Management Controller, MAX10 Build version: 2.0.8\n//****** BMC SENSORS ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 288511862659474365\nBitstream Version                : 4.0.1\nPr Interface Id                  : 2b5c1c35-9ec4-54ec-8835-94ce6b6c3461\n( 1) VCCERAM Voltage                                    : 0.90 Volts\n( 2) VCCT Temperature                                   : 29.00 Celsius\n( 3) 12v Backplane Voltage                              : 12.17 Volts\n( 4) VCCERAM Current                                    : 0.18 Amps\n( 5) FPGA Transceiver Temperature                       : 36.50 Celsius\n( 6) QSFP1 Supply Voltage                               : 0.00 Volts\n( 7) 3.3v Temperature                                   : 29.00 Celsius\n( 8) 12v Backplane Current                              : 2.28 Amps\n( 9) RDIMM3 Temperature                                 : 25.50 Celsius\n(10) VCCR Voltage                                       : 1.12 Volts\n(11) Board Inlet Air Temperature                        : 24.50 Celsius\n(12) 1.8v Temperature                                   : 27.50 Celsius\n(13) 12v AUX Voltage                                    : 12.14 Volts\n(14) VCCR Current                                       : 0.55 Amps\n(15) RDIMM0 Temperature                                 : 24.50 Celsius\n(16) FPGA Core Voltage                                  : 0.88 Volts\n(17) VCCERAM Temperature                                : 27.50 Celsius\n(18) 12v AUX Current                                    : 1.19 Amps\n(19) QSFP0 Temperature                                  : N/A\n(20) VCCT Voltage                                       : 1.12 Volts\n(21) FPGA Core Current                                  : 11.60 Amps\n(22) FPGA Core Temperature                              : 42.50 Celsius\n(23) 12v Backplane Temperature                          : 24.00 Celsius\n(24) VCCT Current                                       : 0.14 Amps\n(25) RDIMM1 Temperature                                 : 24.00 Celsius\n(26) 3.3v Voltage                                       : 3.30 Volts\n(27) VCCR Temperature                                   : 33.50 Celsius\n(28) 1.8v Voltage                                       : 1.80 Volts\n(29) 3.3v Current                                       : 0.32 Amps\n(30) Board Exhaust Air Temperature                      : 26.00 Celsius\n(31) 12v AUX Temperature                                : 25.00 Celsius\n(32) QSFP0 Supply Voltage                               : 0.00 Volts\n(33) QSFP1 Temperature                                  : N/A\n(34) 1.8v Current                                       : 0.54 Amps\n(35) RDIMM2 Temperature                                 : 26.00 Celsius\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#523-rsu","title":"5.2.3 <code>rsu</code>","text":"<p>The rsu performs a R**emote **S**ystem **U**pdate operation on a device, given its PCIe address. A **rsu operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either the BMC or FPGA.</p> <p>The Intel FPGA PAC contains a region of flash the user may store their FIM image. After an image has been programmed with fpgasupdate the user may choose to perform rsu to update the image on the device.</p> <p>Note: The D5005 platform only supports storing and configuring a single user image from flash for the FPGA. It does not include support for the user1/user2 partitions as shown in other OFS related acceleration boards.</p> <p><code>rsu</code> Overview</p> <p>Synopsis</p> <pre><code>rsu [-h] [-d] {bmc,bmcimg,retimer,sdm,fpgadefault} [PCIE_ADDR]\n</code></pre> <pre><code>rsu bmc --page=(user) [PCIE_ADDR]\nrsu retimer [PCIE_ADDR]\nrsu sdm [PCIE_ADDR]\n</code></pre> <p>Perform RSU (remote system update) operation on PAC device given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.</p> <p>Note: As a result of using the rsu command, the host rescans the PCI bus and may assign a different Bus/Device/Function (B/D/F) value than the originally assigned value.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#525-bitstreaminfo","title":"5.2.5 <code>bitstreaminfo</code>","text":"<p>Displays authentication information contained with each provided <code>file</code> on the command line. This includes any JSON header strings, authentication header block information, and a small portion  of the payload. The binary is installed by default at <code>/usr/bin/bitstreaminfo</code>.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#526-hssi","title":"5.2.6 <code>hssi</code>","text":"<p>The hssi application provides a means of interacting with the 10G and with the 100G HSSI AFUs. In both 10G and 100G operating modes, the application initializes the AFU, completes the desired transfer as described by the mode-specific options. Only the <code>hssi_10g</code> MODE is currently supported. An example of this command's output can be found in section 5.2.9 Running the Host Exerciser Modules. The binary is installed by default at <code>/usr/bin/hssi</code>.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#527-opaeio","title":"5.2.7 <code>opae.io</code>","text":"<p>Opae.io is a interactive Python environment packaged on top of libopaevfio.so, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device. opae.io has two operating modes: command line mode and interactive mode. An example of this command's output can be found in section 5.2.9 Running the Host Exerciser Modules. The binary is installed by default at <code>/usr/bin/opae.io</code>.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#528-host_exerciser","title":"5.2.8 <code>host_exerciser</code>","text":"<p>The host exerciser is used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc. An example of this command's output can be found in section 5.2.9 Running the Host Exerciser Modules. The binary is installed by default at <code>/usr/bin/host_exerciser</code>. For more information refer to - Host Exerciser</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#529-running-the-host-exerciser-modules","title":"5.2.9 Running the Host Exerciser Modules","text":"<p>The reference FIM and unchanged compilations contain Host Exerciser Modules (HEMs). These are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. </p> <p>Note: Before continuing, if huge pages are not set refer to section 4.2</p> <p>There are three HEMs present in the OFS FIM - HE-LPBK, HE-HSSI, and HE-MEM. These exercisers are tied to three different VFs that must be enabled before they can be used. The user should enable the VF for each HEM using the below steps:</p> <p>1. Determine the BDF of the Intel\u00ae FPGA PAC D5005 card.</p> <p>The PCIe BDF address is initially determined when the server powers on. The user can determine the addresses of all Intel\u00ae FPGA PAC D5005 boards using <code>lspci</code>:</p> <pre><code>lspci -d :bcce\n#output\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <p>Note: Before continuing, if you updated your OFS installation, please also update your PAC FIM to run HEM</p> <p>2. Enable three VFs.</p> <p>In this example, the BDF address is 0000:3b:00.0. With this information the user can now enable three VFs with the following:</p> <pre><code>sudo pci_device 0000:3b:00.0 vf 3\n</code></pre> <p>3. Verify that all three VFs have been created.</p> <pre><code>lspci -s 3b:00\n#output\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.1 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.2 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.3 Processing accelerators: Intel Corporation Device bccf (rev 01)\n</code></pre> <p>4. Bind the 3 VFs to the vfio-pci driver.</p> <p>sudo opae.io init -d PCI_ADDR USER[:GROUP]]</p> <pre><code>sudo opae.io init -d 0000:3b:00.1 $USER\n#output\nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:3b:00.1 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:3b:00.1 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.1 is 142\nAssigning /dev/vfio/142 to $USER:$USER\nChanging permissions for /dev/vfio/142 to rw-rw----\n\nsudo opae.io init -d 0000:3b:00.2 $USER\n#output \nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:3b:00.2 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:3b:00.2 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.2 is 143\nAssigning /dev/vfio/143 to $USER:$USER\nChanging permissions for /dev/vfio/143 to rw-rw----\n\nsudo opae.io init -d 0000:3b:00.3 $USER\n#output\nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:3b:00.3 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:3b:00.3 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.3 is 144\nAssigning /dev/vfio/144 to $USER:$USER\nChanging permissions for /dev/vfio/144 to rw-rw----\n</code></pre> <p>5. Check that the accelerators are present using fpgainfo. Note your port configuration may differ from the below.</p> <pre><code>sudo fpgainfo port\n#output\n//****** PORT ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x603B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 823c334c-98bf-11ea-bb37-0242ac130002\n//****** PORT ******//\nObject Id                        : 0x403B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 8568ab4e-6ba5-4616-bb65-2a578330a8eb\n//****** PORT ******//\nObject Id                        : 0x203B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-5-5-vf-to-hem-mappings","title":"Table 5-5 VF to HEM Mappings","text":"VF BDF HEM BBBB:DD.1 HE-LB BBBB:DD.2 HE-MEM BBBB:DD.3 He-HSSI <p>HE-MEM / HE-LB</p> <p>HE-LB is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth. HE-MEM is used to exercise the DDR interface; data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller. Both exercisers rely on the user-space tool <code>host_exerciser</code>. The following commands are supported by the HE-LB/HE-MEM OPAE driver program. They may need to be run using <code>sudo</code> privileges, depending on your server configuration.</p> <p>Basic operations:</p> <pre><code>sudo host_exerciser lpbk\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5342\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.067 GB/s\n    Test lpbk(1): PASS\n\nsudo host_exerciser --mode lpbk lpbk\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5358\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.058 GB/s\n    Test lpbk(1): PASS\n\nsudo host_exerciser --mode write lpbk\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 0\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 2592\nTotal number of Reads sent: 0\nTotal number of Writes sent: 1024\nBandwidth: 6.321 GB/s\n    Test lpbk(1): PASS\n\nsudo host_exerciser --mode trput lpbk\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 512\nHost Exerciser numWrites: 513\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 3384\nTotal number of Reads sent: 512\nTotal number of Writes sent: 512\nBandwidth: 4.842 GB/s\n    Test lpbk(1): PASS\n</code></pre> <p>Number of cachelines per request 1, 2, and 4. The user may replace <code>--mode lpbk</code> with <code>read, write, trput</code>. The target <code>lpbk</code> can be replaced with <code>mem</code>:</p> <pre><code>sudo host_exerciser --mode lpbk --cls cl_1 lpbk\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5475\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 2.993 GB/s\n    Test lpbk(1): PASS\n\nsudo host_exerciser --mode lpbk --cls cl_2 lpbk\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5356\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.059 GB/s\n    Test lpbk(1): PASS\n\nsudo host_exerciser --mode lpbk --cls cl_4 lpbk\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 4481\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.656 GB/s\n    Test lpbk(1): PASS\n</code></pre> <p>Interrupt tests (only valid for mode <code>mem</code>):</p> <pre><code>sudo host_exerciser --interrupt 0 mem\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\nUsing Interrupts\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1026\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5140\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.188 GB/s\n    Test mem(1): PASS\n\nsudo host_exerciser --interrupt 1 mem\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\nUsing Interrupts\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1026\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5079\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.226 GB/s\n    Test mem(1): PASS\n\nsudo host_exerciser --interrupt 2 mem\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\nUsing Interrupts\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1026\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 5525\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.439 GB/s\n    Test mem(1): PASS\n\nsudo host_exerciser --interrupt 3 mem\n#output\nstarting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\nUsing Interrupts\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1026\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 4735\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.460 GB/s\n    Test mem(1): PASS\n</code></pre> <p>HE-HSSI</p> <p>HE-HSSI is responsible for handling client-side ethernet traffic. It wraps the 10G ethernet AFU and includes a 10G traffic generator and checker. The user-space tool <code>hssi</code> exports a control interface to the HE-HSSI's AFU's packet generator logic. Context sensitive information is given by the <code>hssi --help</code> command. Help for the 10G specific test is given by <code>hssi hssi_10g --help</code> Example useage:</p> <pre><code>sudo hssi --pci-address 3b:00.3 hssi_10g --eth-ifc s10hssi0 --eth-loopback on --he-loopback=off  --num-packets 100\n#output\n10G loopback test\nport: 0\neth_loopback: on\n  he_loopback: off\n  num_packets: 100\npacket_length: 64\nsrc_address: 11:22:33:44:55:66\n    (bits):  0x665544332211\n  dest_address: 77:88:99:aa:bb:cc\n    (bits): 0xccbbaa998877\n  random_length: fixed\n  random_payload: incremental\n  rnd_seed0: 5eed0000\n  rnd_seed1: 5eed0001\n  rnd_seed2: 25eed\n  eth: s10hssi0\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#60-compiling-ofs-fim","title":"6.0 Compiling OFS FIM","text":"<p>Pre-Compiled FIM binaries are at OFS 2023.1 release page and to compile the OFS FIM for Intel\u00ae FPGA PAC D5005 follow the below steps :</p> <p>1) Compile OFS FIM manually - Steps are provided in the developer guide to compile FIM and generate binaries. Refer to Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae.</p> <p>2) Compile OFS FIM using evaluation script - The script guides you to the steps required for compilation via selecting options from the menu. Refer to evaluation script</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/","title":"Simulation User Guide: Open FPGA Stack for Intel Intel\u00ae Stratix 10\u00ae FPGA","text":""},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#1-overview","title":"1 Overview","text":""},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a set-up and user guide for the UVM simulation tool using OFS. After reviewing the document, you will be able to:</p> <ul> <li>Set-up the UVM verification tool suite</li> <li>Run pre-existing UVM unit tests and also create new UVM tests for your design</li> </ul>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#2-introduction-to-uvm","title":"2 Introduction to UVM","text":"<p>OFS (Open FPGA Stack) provides a UVM (Universal Verification Methodology) environment for the FIM (FPGA Interface Manager) with a modular, reusable, and scalable testbench structure via an API framework.</p> <p>The framework consists of a FIM Testbench which is UVM compliant and integrates third party VIPs from Synopsys for PCI Express, Arm\u00ae AMBA\u00ae 4 AXI4-Streaming interface and Arm\u00ae AMBA\u00ae 4 AXI4-Memory Mapped interface for comprehensive verification. The user will need to acquire licenses for these VIPs to use this Testbench. UVM RAL (Register Abstaction Layer) is used for CSR (Command and Status Registers) verification.</p> <p>The qualified verification IPs will help to detect incorrect protocol behavior, help to focus on FIM features and accelerate the verification process.</p> <p>Verification components include:</p> <ul> <li>FIM monitor to detect correct design behavior</li> <li>FIM assertions for signal level integrity testing</li> <li>Arm AMBA Arm\u00ae AMBA\u00ae 4 AXI4 scoreboards to check data integrity</li> <li>FIM coverage to collect functional data</li> </ul>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#3-testbench-architecture","title":"3 Testbench Architecture","text":"<p>The testbench connects to the full chip that includes major RTL blocks depicted in Figure 1.</p> <p></p> <p>Figure 1 Testbench Diagram</p> <p>The major interface is between the Xeon and FPGA where PCIe Verification IP is connected to PCIe Subsystem. Therefore, as a full chip simulation environment, PCIe host VIP is the sole VIP/BFM used. PCIe host VIP connects to PCIe device which resides in FPGA in serial mode. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#4-testbench-infrastructure","title":"4 Testbench Infrastructure","text":""},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#41-traffic-flow","title":"4.1 Traffic Flow","text":"<p>PCIe Host, as the master of FPGA, initiates MMIO read/write requests to FPGA to program registers. The PCIe host also passively receives memory requests from FPGA to read from or write to host memory. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#42-link-up-and-enumeration","title":"4.2 Link Up and Enumeration","text":"<p>With serial mode connection between PCIe host and device, link training and enumeration has to be done before the regular traffic starts. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#421-link-up","title":"4.2.1 Link Up","text":"<p>Linkup sequence(pcie_device_bring_up_link_sequence) is part of configure sequence(ofs_config_seq), which is started in UVM configure phase. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#422-enumeration","title":"4.2.2 Enumeration","text":"<p>PCIe host driver needs to retrieve information from the device hard IP and program necessary configuration space registers, such as PF/VF BAR values. This is done in enumerate_seq, which follows link up sequence in configure sequence(ofs_config_seq). </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#423-pfvf-bar","title":"4.2.3 PF/VF BAR","text":"<p>PF0 BAR0 is set in the base sequence and can be randomized. During enumeration, PF0 BAR0, along with PCIe device hard IP configuration, derives other PF and VF BAR values. These BAR values are stored into base sequence variables and can be used throughout any test sequences that extend the base sequence. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#43-mmio-apis","title":"4.3 MMIO APIs","text":"<p>The base sequence provides APIs for 32-bit and 64-bit MMIO read/write accesses, as well as blocking or non-blocking for MMIO read as described in Table 1. The users can use MMIO APIs without knowing the underlining PCIe sequence items.</p> Name API 32-bit MMIO Write task mmio_write32(input bit [63:0] addr_, input bit [31:0] data_); 64-bit MMIO Write task mmio_write64(input bit [63:0] addr_, input bit [63:0] data_); 32-bit MMIO Read task mmio_read32(input bit [63:0] addr_, output bit [31:0] data_, input blocking_ = 1); 64-bit MMIO Read task mmio_read64(input bit [63:0] addr_, output bit [63:0] data_, input blocking_ = 1); <p>Table 1 MMIO APIs</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#44-ral","title":"4.4 RAL","text":"<p>UVM RAL is integrated in the testbench providing alternative ways of accessing CSRs in test sequences. RAL is generated from an excel format CSR specification where register name, field, offset, bitmap, attribute, and description are specified.</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#45-vip-dut-connection","title":"4.5 VIP DUT Connection","text":"<p>PCIe host verification IP and DUT connection is achieved by connecting 16 bits lanes. The module for connection from VIP is svt_pcie_device_agent_serdes_x16_x8g_hdl.  </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#5-test-plan","title":"5 Test Plan","text":"<p>The test plan consists of four major categories: MMIO path, HE-LB, HE-MEM, HE-HSSI and interrupt tests. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#51-mmio-path","title":"5.1 MMIO Path","text":"<p>The tests under this category exercise MMIO path including all destination functions or blocks as well as PF/VF mux and different fabrics. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#52-he-lb","title":"5.2 HE-LB","text":"<p>The tests under this category target HE-LB function only. Software which test sequences needs to configure HE-LB CSRs before starting it. These CSRs include SRC_ADDR, DST_ADDR, DSM_ADDR, NUM_LINES, CFG etc.   </p> <p>If HE-LB is configured to have memory read transactions, PCIe host memory has to be initialized before HE-LB is started. This is done by svt_pcie_mem_target_service sequence. In other words, PCIe host VIP programs its internal memory model entries in backdoor way. The same process applies to DSM memory entry. </p> <p>Once HE-LB is started, HE-LB will function based on what it is programmed to do. When HE-LB is done with all necessary memory transactions, it will perform a final memory write to DSM memory entry. Since the software does not know when hardware is done, software polls DSM memory entry periodically until the DSM status bit is asserted. </p> <p>For loopback mode, data is compared between source buffer and destination buffer in host memory. </p> <p>RTL statistic counters are also compared against the corresponding variables inside the test sequence at the end of the simulation. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#53-he-mem","title":"5.3 HE-MEM","text":"<p>HE-MEM tests are duplicates from HE-LB with MMIO to CSRs targeting HE-MEM instead of HE-LB. </p> <p>The DDR simulation model is inside memory controller IP when being generated.  </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#54-he-hssi","title":"5.4 HE-HSSI","text":"<p>HE-HSSI has indirect registers that are associated with HSSI subsystem, MMIO for indirect registers is different from other functions. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#541-indirect-registers","title":"5.4.1 Indirect Registers","text":"<p>To obtain access to indirect registers, either reading or writing, a MMIO write must be performed.</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#542-tx-loopback","title":"5.4.2 TX Loopback","text":"<p>In TX loopback, HE-HSSI initiates ethernet packets to HSSI subsystem and the packets are looped back to HE-HSSI. The loopback is achieved by hard-wiring HSSI TX and RX lanes. This is done inside RTL and for simulation purposes only. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#55-interrupt-test","title":"5.5 Interrupt Test","text":"<p>The test plan covers the basic interrupt flow for FME error, PORT error and user AFU interrupts. The MSI-X table must be programmed in PF0 BAR4. Corresponding PBA bit is expected to be asserted. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#56-performance-test","title":"5.6 Performance Test","text":"<p>Performance tests are derived from HE-LB tests and they are directed tests. At the end of the simulation, performance number is calculated and printed to terminal and a log file. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#57-csr-test","title":"5.7 CSR Test","text":"<p>CSR consists of two parts. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#571-reset-value-check","title":"5.7.1 Reset Value Check","text":"<p>Front-door MMIO read data is compared against RAL register reset value out of reset. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#572-rw-attribute-csr","title":"5.7.2 RW Attribute CSR","text":"<p>MMIO write-read-compare is performed after reset value check for RW attribute CSRs. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#6-checking-mechanism","title":"6 Checking Mechanism","text":"<p>Since there is only PCIe host verification component in testbench, data checking is done by a self-checking mechanism in the test sequence.  </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#61-protocol-violation","title":"6.1 Protocol Violation","text":"<p>PCIe host VIP has built-in protocol checking on TLP received from FPGA. Abnormal responses are also flagged by the VIP. </p> <p>Internal AXI Streaming interface has integrated RTL assertion to check AXI Streaming protocol violations. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#62-data-checking","title":"6.2 Data Checking","text":"<p>Data checking is done by self-checking inside a test sequence. MMIO write/read/compare to read-writable CSRs is done inside a sequence. </p> <p>For memory transactions initiated by functions, backdoor reads from host memory on source buffer and destination buffer is done inside a sequence. Data is compared in case of loopback mode. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#63-counter-checking","title":"6.3 Counter Checking","text":"<p>RTL statistic counters records the number of transactional information that can be read at the end of the simulation and compared against the test expected number. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#64-afu-error-csr","title":"6.4 AFU Error CSR","text":"<p>AFU interface handler provides an error log for illegal transactions that can be read at the end of the simulation. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#7-uvm-set-up","title":"7 UVM set-up","text":"<p>To run the tutorial steps in this guide requires the following development environment:</p> Item Version Intel Quartus Prime Pro Intel Quartus Prime Pro 23.1 Simulator (VCS) Synopsys VCS P-2019.06-SP2-5 or newer for UVM simulation of top level FIM Simulator (Questasim) Questasim 2021.4 or newer for UVM simulation of top level FIM"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#71-uvm-prerequisite","title":"7.1 UVM Prerequisite","text":"<p>Retrieve OFS repositories.</p> <p>The OFS FIM source code is included in the GitHub repository. Create a new directory to use as a clean starting point to store the retrieved files.  The following is a short description of each repository, followed by the git commands for cloning.  The instructions section uses the HTTPS git method for cloning repositories.  Cloning the repo using the HTTPS method requires a personal access token.  Please see this blog post for information about obtaining a personal access token Token authentication requirements for Git operations.</p> <p>Navigate to the location for storage of OFS source, create the top-level source directory and clone OFS repositories.</p> <pre><code>$ mkdir ofs-2023.1\n$ cd ofs-2023.1\n$ export OFS_BUILD_ROOT=$PWD\n$ git clone --recurse-submodules https://github.com/OFS/ofs-d5005.git\n\nCloning into 'ofs-d5005' ...\nUsername for 'https://github.com': &lt;&lt;Enter your git hub username&gt;&gt;\nPassword for 'https://&lt;&lt;Your username&gt;&gt;': &lt;&lt;Enter your personal access token&gt;&gt;\nremote: Enumerating objects:  ....\n...\n...\nResolving deltas  ..., done.\n\n$ cd ofs-d5005\n$ git checkout tags/release/ofs-2023.1\n</code></pre> <p>Verify that the correct tag/branch have been checked out        </p> <pre><code>$ git describe --tags\n\n$ release/ofs-2023.1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#72-license-requirements","title":"7.2 License Requirements","text":"<p>The FIM Testbench is UVM compliant and integrates third party VIPs from Synopsys for PCI Express, Arm\u00ae AMBA\u00ae 4 AXI4-Streaming interface and Arm\u00ae AMBA\u00ae 4 AXI4-Memory Mapped interface for comprehensive verification. The user will need to acquire licenses for these VIPs to use this TB. UVM RAL (Register Abstraction Layer) is used for CSR Verification.</p> <p>The Qualified Verification IPs will help to detect incorrect protocol behavior easily, help to focus on BBS features and accelerate the verification process.</p> <ul> <li>VCS &amp; DVE</li> <li>SNPS-Assertions</li> <li>Verdi</li> <li>VerdiCoverage</li> <li>VerdiSimDB</li> <li>VerdiTransactionDebugUltra</li> <li>VIP-AMBA-AXI-SVT</li> <li>VIP-AMBA-STREAM-SVT</li> <li>VIP-PCIE-SVT</li> <li>VIP-PCIE-TS-SVT</li> <li>VIP-PCIE-G3-OPT-SVT</li> </ul>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#73-software-tools-requirements","title":"7.3 Software Tools Requirements","text":"<p>The following tools are required for successful UVM set-up</p> <ul> <li>Python 3.7.7</li> <li>Synopsys PCIE and AMBA AXI UVM VIP Q-2020.03A License</li> <li>Synopsys Verdi R-2020.12-SP2 License         Note: Makefile can be modified to use DVE instead of Verdi</li> </ul> <ul> <li>VCS R-2020.12-SP2 License </li> </ul>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#74-creating-a-software-tools-script","title":"7.4 Creating a Software Tools Script","text":"<p>The UVM tool set-up is best done by creating a simple set-up script so all applicable tools are sourced before running the tests.</p> <p>The following environment variables can be pasted into a script and used prior to running the UVM verification environment</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#license-files","title":"License Files","text":"<pre><code>export LM_LICENSE_FILE=\nexport SNPSLMD_LICENSE_FILE=\n</code></pre> <p>The license environment variables LM_LICENSE_FILE and SNPSLMD_LICENSE_FILE can point to a server license on your system.</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#general-environment-variables","title":"General Environment Variables","text":"<pre><code>export OFS_BUILD_ROOT=$PWD\nexport OFS_ROOTDIR=&lt;user_path&gt;/ofs-d5005\nexport WORKDIR=$OFS_ROOTDIR\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#quartus-tools","title":"Quartus Tools","text":"<pre><code>export QUARTUS_HOME=&lt;user_path&gt;/intelFPGA_pro/23.1/quartus\nexport QUARTUS_ROOTDIR=$QUARTUS_HOME\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport QSYS_ROOTDIR=$QUARTUS_ROOTDIR/../qsys/bin\nexport PATH=$QUARTUS_HOME/bin:$QUARTUS_HOME/qsys/bin:$QUARTUS_HOME/sopc_builder/bin/:$PATH\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#synopsys-verification-tools","title":"Synopsys Verification Tools","text":"<pre><code>export DESIGNWARE_HOME=&lt;user_path&gt;/synopsys/vip_common/vip_Q-2020.03A\nexport PATH=$DESIGNWARE_HOME/bin:$PATH\nexport UVM_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm\nexport VCS_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel\nexport PATH=$VCS_HOME/bin:$PATH\nexport VERDIR=$OFS_ROOTDIR/verification\nexport VIPDIR=$VERDIR\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#questasim-verification-tools","title":"QuestaSIM Verification Tools","text":"<pre><code>export MTI_HOME=&lt;user_path&gt;/mentor/questasim/2021.4/linux64\nexport PATH=$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$PATH\nexport QUESTA_HOME=$MTI_HOME\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#8-running-a-uvm-simulation-test-and-analysing-results","title":"8 Running a UVM Simulation Test and Analysing Results","text":""},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#81-simulation","title":"8.1 Simulation","text":"<p>The default simulator used in this document is Synopsys VCS-MX but there will be references to Questasim. Users can refer to the options and adopt the options for other simulators. </p> <p>The script is a makefile that calls vlogan, vcs and simv for compilation, elaboration and simulation, respectively</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#82-file-structure","title":"8.2 File Structure","text":"<p>After cloning the repo, the verification and ofs-common directories contain all UVM verification related files. The directory structure is shown in Figure 2 below.</p> <p></p> <p>Figure 2 UVM Verification Directory File Structure</p> <p>ofs-d5005/testbench has a testbench, uvm env, virtual sequencer, RAL etc. </p> <p>ofs-d5005/verification/tests contains all uvm tests and sequences. </p> <p>Users can run the simulation under \"ofs-d5005/verification/scripts\" directory and the simulation result is outputted to a \"sim\" directory for Synopsys VCS or \"sim_msim\" for Questasim.</p> <p>The simulation result folder is named after the test name with increasing suffix number. If user runs the same test multiple times, the suffix is incremented by 1 each time.</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#83-uvm-test-suite","title":"8.3 UVM Test Suite","text":"<p>The UVM environment contains a variety of tests that have been developed to test out the FIM portion of OFS.</p> <p>The table below lists out the \"Test Name\" which will be used on the command line to execute the test, the \"Test Scenario\" and the \"Checking Criteria\".</p> <p>Tests are located at ofs-d5005/verification/tests</p> Test Name DUT Scope Test Scenario Checking Criteria dfh_walking_test DFH DHF walking offset checking, eol checking flr_reset_test FLR Reset FLR reset to all PFs Reset checking flr_vf0_reset_test FLR Reset FLR reset to VF0 Reset checking flr_vf1_reset_test FLR Reset FLR reset to VF1 Reset checking flr_vf2_reset_test FLR Reset FLR reset to VF2 Reset checking fme_csr_test FME CSR CSR accesses data checking fme_hemem_intr_test Interrupt FME and HE MEM interrupt Interrupts assertion, PBA bits check fme_intr_test Interrupt FME error interrupt Interrupts assertion, PBA bits check he_hssi_csr_test HE-HSSI CSR accesses for HSSI data checking he_hssi_err_test HE-HSSI Error Cases counter checking he_hssi_rx_lpbk_test HE-HSSI RX loopback data checking he_hssi_tx_lpbk_test HE-HSSI TX loopback counter checking he_lpbk_cont_test HE-LPBK Continuous mode/LPBK mode, random num_lines, addresses, req_len data checking he_lpbk_long_rst_test HE-MEM Multiple iterations of he_lpb_seq with soft reset HE-LB in middle data checking, counter checking he_lpbk_long_test HE-MEM Multiple iterations of he_lpb_seq with STOP HE-LB in middle data checking, counter checking he_lpbk_port_rst_test HE-LPBK Loopback mode. Randomize num_lines, addresses, req_len with port rst data checking he_lpbk_rd_cont_test HE-LPBK Read only mode/ Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_lpbk_rd_test HE-LPBK Read only mode. Randomize num_lines, addresses, req_len counter checking he_lpbk_reqlen1_test HE-LPBK Loopback mode. 128 CLs, req_len = 1CL, random addresses data checking, counter checking he_lpbk_reqlen2_test HE-LPBK Loopback mode. 128 CLs, req_len = 2CL, random addresses. data checking, counter checking he_lpbk_reqlen4_test HE-LPBK Loopback mode. 128 CLs, req_len = 4CL, random addresses data checking, counter checking he_lpbk_reqlen8_test HE-LPBK Loopback mode. 128 CLs, req_len = 8CL, random addresses data checking, counter checking he_lpbk_test HE-LPBK Loopback mode. Randomize num_lines, addresses, req_len data checking, counter checking he_lpbk_thruput_contmode_test HE-LPBK Continuous mode, Read/Write mode. 50/50. Randomize num_lines, addresses req_len data checking, counter checking he_lpbk_thruput_test HE-LPBK Read/Write mode. 50/50. Randomize num_lines, addresses, req_len counter checking he_lpbk_wr_cont_test HE-LPBK Write only mode/ Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_lpbk_wr_test HE-LPBK Write only mode. Randomize num_lines, addresses, req_len counter checking he_mem_cont_test HE-MEM Continuous mode/LPBK mode, random num_lines, addresses, req_len data checking he_mem_lpbk_long_rst_test HE-LPBK Multiple iterations of he_lpb_seq with soft reset HE-LB in middle data checking, counter checking he_mem_lpbk_long_test HE-LPBK Multiple iterations of he_lpb_seq with STOP HE-LB in middle data checking, counter checking he_mem_lpbk_reqlen1_test HE-MEM Loopback mode. 128 CLs, req_len = 1CL, random addresses. data checking, counter checking he_mem_lpbk_reqlen2_test HE-MEM Loopback mode. 128 CLs, req_len = 2CL, random addresses. data checking, counter checking he_mem_lpbk_reqlen4_test HE-MEM Loopback mode. 128 CLs, req_len = 4CL, random addresses data checking, counter checking he_mem_lpbk_test HE-MEM Loopback mode. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_rd_cont_test HE-MEM Read only mode/ Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_rd_test HE-MEM Read only mode. Randomize num_lines, addresses, req_len counter checking he_mem_thruput_contmode_test HE-MEM Continuous mode, Read/Write mode. 50/50. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_thruput_test HE-MEM Read/Write mode. 50/50. Randomize num_lines, addresses, req_len counter checking he_mem_wr_cont_test HE-MEM Write only mode/ Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_wr_test HE-MEM Write only mode. Randomize num_lines, addresses, req_len counter checking he_random_long_test All HE's Enable all HEs and randomize modes for multiple iterations data checking if in lpbk mode, counter checking he_random_test All HEs Enable all HEs and randomize modes data checking if in lpbk mode, counter checking hehssi_csr_test HE-HSSI CSR accesses for Traffic Control Mail box registers data checking helb_csr_test HE-LPBK CSR accesses data checking helb_rd_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Read only mode data checking, counter checking helb_rd_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Read only mode data checking, counter checking helb_rd_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Read only mode data checking, counter checking helb_thruput_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Thruput mode data checking, counter checking helb_thruput_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Thruput mode data checking, counter checking helb_thruput_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Thruput mode data checking, counter checking helb_wr_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Write only mode data checking, counter checking helb_wr_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Write only mode data checking, counter checking helb_wr_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Write only mode data checking, counter checking hemem_csr_test HE-MEM CSR accesses data checking hemem_intr_test Interrupt HE MEMN Interrupt Interrupts assertion, PBA bits check malformedtlp_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing. maxpayloaderror_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing. MaxTagError_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3.Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing. mini_smoke_test All HEs shorter simpler version of random test for turn-in sanity check data checking if in lpbk mode, counter checking mmio_64b_bar_test PCIe MMIO Path 64-bit bar addess for MMIO data checking mmio_stress_nonblocking_test PF/VF Mux/Demux Stressing MMIO on PF/VF Mux/Demux with non-blocking MMIO reads data checking mmio_stress_test PF/VF Mux/Demux Stressing MMIO on PF/VF Mux/Demux data checking mmio_test PCIe MMIO Path MMIO targeting PF0(ST2MM, FME, PMCI, HSSI SS), PF1, PF1.VF1, PF1.VF2 data checking mmio_unimp_test PCIe MMIO Path MMIO acccess to unimplemented addresses MMIO checking MMIODataPayloadOverrun_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing. MMIOInsufficientData_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing. MMIOTimedout_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing. msix_csr_test MSIX CSR CSR accesses data checking pmci_csr_test PMCI CSR CSR accesses data checking port_gasket_csr_test PORT GASKET Port Gasket CSR test port csr checking TxMWrDataPayloadOverrun_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing TxMWrInsufficientData_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing UnexpMMIORspErr_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors. 1. Apply the error 2. Wait 5us 1us 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be retuened on resds. Write a 0x5 to set and a 0x4 to clear) 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.) 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4 6. Read the AFU_INTF_ERROR register, Be sure only the expected error(s) are set 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector. After clearing the error register,check if normal transcation are completing <p>The next section describes how to compile and build the UVM environment prior to running each UVM test and analyzing the results in the log files</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#84-ip-compile","title":"8.4 IP Compile","text":""},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#synopsys-vcs","title":"Synopsys VCS","text":"<p>To compile all IPs for the Synopsys VCS simulater:</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_VCS.mk cmplib\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#questasim","title":"Questasim","text":"<p>To compile all IPs for the Questasim simulater:</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_MSIM.mk cmplib </code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#85-rtl-test-bench-compile","title":"8.5 RTL &amp; Test Bench Compile","text":"<p>The RTL file list for compilation is located here: verification/scripts/rtl_comb.f</p> <p>The TB file list for compilation is located here: verification/scripts/ver_list.f</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#synopsys-vcs_1","title":"Synopsys VCS","text":"<p>To compile RTL and Testbench for the Synopsys VCS simulater</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_VCS.mk build DUMP=1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#questasim_1","title":"Questasim","text":"<p>To compile RTL and Testbench for the Questasim simulater</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_MSIM.mk build DUMP=1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#86-ip-and-rtl-test-bench-compile","title":"8.6 IP and RTL &amp; Test Bench Compile","text":""},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#synopsys-vcs_2","title":"Synopsys VCS","text":"<p>If the user wants to compile all IPs and RTL Testbench in one command for Synopsys VCS then follow the procedure below</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_VCS.mk build_all DUMP=1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#questasim_2","title":"Questasim","text":"<p>If the user wants to compile all IPs and RTL Testbench in one command for Questasim then follow the procedure below</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_MSIM.mk build_all DUMP=1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#synopsys-vcs_3","title":"Synopsys VCS","text":"<p>To run a simulation for Synopsys VCS:</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_VCS.mk run TESTNAME=mmio_test DUMP=1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#questasim_3","title":"Questasim","text":"<p>To run a simulation for Questasim:</p> <pre><code>    cd $VERDIR/scripts\n\ngmake -f Makefile_MSIM.mk run TESTNAME=mmio_test DUMP=1 </code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#synopsys-vcs_4","title":"Synopsys VCS","text":"<p>To dump the waveform, \"DUMP=1\" must be added into the command line for Synopsys VCS build and simulation. </p> <p><pre><code>    ofs-d5005/verification/scripts  gmake -f Makefile_VCS.mk build DUMP=1\nofs-d5005/verification/scripts  gmake -f Makefile_VCS.mk run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> Or</p> <pre><code>    ofs-d5005/verification/scripts  gmake -f Makefile_VCS.mk build_run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#questasim_4","title":"Questasim","text":"<p>To dump the waveform, \"DUMP=1\" must be added into the command line for Questasim build and simulation. </p> <p><pre><code>    ofs-d5005/verification/scripts  gmake -f Makefile_MSIM.mk build DUMP=1\nofs-d5005/verification/scripts  gmake -f Makefile_MSIM.mk run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> Or</p> <pre><code>    ofs-d5005/verification/scripts  gmake -f Makefile_MSIM.mk build_run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> <p>There are some optimizations in the Table below for convenience if you want to bypass some commands for both Synopsys VCS and Questasim:</p> Command (Synopsys VCS) Command (Questasim) Details gmake -f Makefile_VCS.mk build_all DUMP=1 gmake -f Makefile_MSIM.mk build_all DUMP=1 compile IP + compile RTL gmake -f Makefile_VCS.mk build_run TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk build_run TESTNAME= DUMP=1 compile RTL + run test gmake -f Makefile_VCS.mk do_it_all TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk do_it_all TESTNAME= DUMP=1 compile IP, RTL and run test gmake -f Makefile_VCS.mk rundb TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk rundb TESTNAME= DUMP=1 run test in sim dir + over-writes content"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#87-uvm-regression-test","title":"8.7 UVM Regression Test","text":"<pre><code>cd $VERDIR/scripts\n\nFor Regression in VCS with top/test package, execute the following command python uvm_regress.py -l -n 8 -s vcs -c\n\nResults are created in a sim directory ($VERDIR/sim) with individual testcase log dir\n\nFor Regression in MSIM with top/test package, execute the following command python uvm_regress.py -l -n 8 -s msim -c\n</code></pre> <p>Results are created in a sim directory ($VERDIR/sim_msim) with individual testcase log dir</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#88-uvm-waveform-and-transcript-analysis","title":"8.8 UVM Waveform and Transcript Analysis","text":""},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#synopsys-vcs_5","title":"Synopsys VCS","text":"<p>Running Synopsys VCS UVM tests will generate a ofs-d5005/verification/sim directory</p> <ul> <li>All build time logs are at ofs-d5005/verification/sim</li> </ul> <ul> <li>Each testcase will have separate directory inside sim ofs-d5005/verification/sim/ <p>There are two tracker or log files that are available: runsim.log and trans.log. </p> <p>runsim.log is the simulation log file generated from Synopsys VCS. The test sequence prints useful information for debugging purpose, such as the base address for each function or block. For HE-LB and HE-MEM, key information such as SRC_ADDR, DST_ADDR, NUM_LINES, mode, req_len etc is printed out as shown in Figure 3</p> <p></p> <p>Figure 3 runsim.log</p> <p>trans.log is generated from PCIe host VIP. trans.log records all transaction information coming in or going out of the VIP. Users can find traffic direction(DIR), TLP type, Tag, Address or BDF, 3 or 4 dword header of the TLP as shown in Figure 4</p> <p></p> <p>Figure 4 trans.log</p> <p>The waveform generated is named as \"inter.vpd\". To open the waveform, go to simulation result directory and run </p> <pre><code>dve -full64 -vpd inter.vpd &amp;\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#questasim_5","title":"Questasim","text":"<p>Running Questasim UVM tests will generate a ofs-d5005/verification/sim_msim directory</p> <ul> <li>All build time logs are at ofs-d5005/verification/sim_msim</li> </ul> <ul> <li>Each testcase will have separate directory inside sim ofs-d5005/verification/sim_msim/ <p>There are two tracker or log files that are available: runsim.log and trans.log. </p> <p>runsim.log is the simulation log file generated from Questasim. The test sequence prints useful information for debugging purpose, such as the base address for each function or block. For HE-LB and HE-MEM, key information such as SRC_ADDR, DST_ADDR, NUM_LINES, mode, req_len etc is printed out as shown in Figure 4</p> <p></p> <p>Figure 4 runsim.log</p> <p>trans.log is generated from PCIe host VIP. trans.log records all transaction information coming in or going out of the VIP. Users can find traffic direction(DIR), TLP type, Tag, Address or BDF, 3 or 4 dword header of the TLP as shown in Figure 5</p> <p></p> <p>Figure 5 trans.log</p> <p>The waveform generated is named as \"vsim.wlf\". To open the waveform, go to simulation result directory and run </p> <pre><code>    vsim -view vsim.wlf &amp;    </code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#9-modifying-uvm-testbench","title":"9 Modifying UVM Testbench","text":"<p>The next section describe what needs to be considered when modifying the UVM, targeting a different device, adding a new interface to the testbench and creating a new UVM test for a customized OFS Accelerator platform.</p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#91-modifying-uvm-environment-when-targeting-different-device","title":"9.1 Modifying UVM environment when targeting different device","text":"<p>A new device may have different design feature or flow. The base address must be allocated for the new device. The MMIO targeting the new device must be based on the base address. If it is a new PF or VF, PCIe HIP must be regenerated and enumeration sequence must be updated accordingly. </p>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#92-modifying-uvm-environment-when-adding-a-new-interface","title":"9.2 Modifying UVM environment when adding a new interface","text":"<p>Adding a new interface requires signal connections in the testbench. An additional BFM or verification IP is needed to drive the new interface. The main testbench file tb_top.sv is found at the following location</p> <pre><code>    $OFS_ROOTDIR/verification/testbench\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#93-adding-a-new-uvm-test","title":"9.3 Adding a new UVM test","text":"<p>In the following example we will modify an existing test \"he_lpbk\" and name it \"he_lpbk_new\", and rebuild the test to check it. Please follow the steps below </p> <ol> <li> <p>Create a new test sequence file under ofs-d5005/verification/tests/sequences</p> <pre><code>he_lpbk_seq_new.svh\n</code></pre> </li> <li> <p>Modify ifndef, define and endif statements in new test sequence case i.e he_lpbk_seq_new.svh file</p> <pre><code>`ifndef HE_LPBK_SEQ_NEW_SVH `define HE_LPBK_SEQ_NEW_SVH\n`endif // HE_LPBK_SEQ_NEW_SVH\n</code></pre> <p>also replace all occurences of he_lpbk_seq with he_lpbk_seq_new in the he_lpbk_seq_new.svh file</p> </li> <li> <p>Append the new sequence name into ofs-d5005/verification/tests/sequences/seq_lib.svh file</p> <pre><code>`include \"he_lpbk_seq_new.svh\"\n</code></pre> </li> <li> <p>Create a new test under ofs-d5005/verification/tests</p> <pre><code>he_lpbk_test_new.svh\n</code></pre> </li> <li> <p>Modify ifndef, define and endif statements in new test case i.e he_lpbk_test_new.svh file</p> <pre><code>`ifndef HE_LPBK_TEST_NEW_SVH `define HE_LPBK_TEST_NEW_SVH\n`endif // HE_LPBK_TEST_NEW_SVH\n</code></pre> <p>also replace all occurences of he_lpbk_test with he_lpbk_test_new in the he_lpbk_test_new.svh file</p> </li> <li> <p>Append the new test name into ofs-d5005/verification/tests/test_pkg.svh file</p> <pre><code>`include \"he_lpbk_test_new.svh\"\n</code></pre> </li> <li> <p>Rebuild UVM test suite for either Synopsys VCS or Questasim simulater</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_VCS.mk build_all\n</code></pre> <p>or</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_MSIM.mk build_all\n</code></pre> </li> <li> <p>Execute new test for either Synopsys VCS or Questasim simulater</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_VCS.mk run TESTNAME=he_lpbk_test_new\n</code></pre> <p>or</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_MSIM.mk run TESTNAME=he_lpbk_test_new\n</code></pre> </li> </ol> <p>9) Check new test and log files         cd ofs-d5005/verification/sim/he_lpbk_test_new</p> <pre><code>```sh\nopen runsim.log\n```\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/doc_modules/Glossary/","title":"Glossary","text":"Term Abbreviation Description Advanced\u00a0Error\u00a0Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link) Accelerator\u00a0Functional\u00a0Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.\u00a0Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region. Basic Building Block BBB Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. Best\u00a0Known\u00a0Configuration BKC The software and hardware configuration Intel uses to verify the solution. Board\u00a0Management\u00a0Controller BMC Supports features such as board power managment, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate component, such as an Intel\u00ae Max\u00ae 10 or Intel Cyclone\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA. Configuration and\u00a0Status\u00a0Register CSR The generic name for a register space which is accessed in order to interface with the module it resides in (e.g. AFU, BMC, various sub-systems and modules). Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Device\u00a0Feature\u00a0List DFL The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\u00a0This concept is the foundation for the OFS software framework. (link) FPGA\u00a0Interface\u00a0Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FPGA\u00a0Management\u00a0Engine FME Performs reconfiguration and other FPGA management functions. Each FPGA device only has one FME which is accessed through PF0. Host\u00a0Exerciser\u00a0Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Intel\u00a0Virtualization\u00a0Technology for\u00a0Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Joint Test Action Group JTAG Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. Memory\u00a0Mapped\u00a0Input/Output MMIO The memory space users may map and access both control registers and system memory buffers with accelerators. oneAPI Accelerator Support Package oneAPI-asp A collection of hardware and software components that enable oneAPI kernel to communicate with oneAPI runtime and OFS shell components. oneAPI ASP hardware components and oneAPI kernel form the AFU region of a oneAPI system in OFS. Open\u00a0FPGA\u00a0Stack OFS OFS is a software and hardware infrastructure providing an efficient approach to develop a custom FPGA-based platform or workload using an Intel, 3rd party, or custom board. Open\u00a0Programmable\u00a0Acceleration\u00a0Engine Software Development Kit OPAE SDK The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Platform\u00a0Interface\u00a0Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Platform Management Controller Interface PMCI The portion of the BMC that resides in the Agilex FPGA and allows the FPGA to communicate with the primary BMC component on the board. Partial Reconfiguration PR The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. For OFS designs, the PR region is referred to as the pr_slot. Port N/A When used in the context of the fpgainfo port command it represents the interfaces between the static FPGA fabric and the PR region containing the AFU. Remote System Update RSU The process by which the host can remotely update images stored in flash through PCIe. This is done with the OPAE software command \"fpgasupdate\". Secure Device Manager SDM The SDM is the point of entry to the FPGA for JTAG commands and interfaces, as well as for device configuration data (from flash, SD card, or through PCI Express* hard IP). Static Region SR The portion of the FPGA design that cannot be dynamically reconfigured during run-time. Single-Root\u00a0Input-Output\u00a0Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. SYCL SYCL SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Test Bench TB Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. Universal Verification Methodology UVM A modular, reusable, and scalable testbench structure via an API framework.  In the context of OFS, the UVM enviroment provides a system level simulation environment for your design. Virtual\u00a0Function\u00a0Input/Output VFIO An Input-Output Memory Management Unit (IOMMU)/device agnostic framework for exposing direct device access to userspace.\u00a0(link)"},{"location":"hw/doc_modules/Notices_%26_Disclaimers/","title":"Notices & Disclaimers","text":""},{"location":"hw/doc_modules/Notices_%26_Disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"hw/doc_modules/links/","title":"AFU Dev","text":""},{"location":"hw/f2000x/","title":"Index","text":"<p>Location for SoC Attach Collateral for OFS.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/","title":"AFU Development Guide: OFS for Intel\u00ae Agilex\u00ae SoC Attach FPGAs","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#1-introduction","title":"1. Introduction","text":"<p>This document is a design guide for the creation of an Accelerator Functional Unit (AFU) using Open FPGA Stack (OFS) for Intel\u00ae Agilex\u00ae FPGAs SoC Attach. The AFU concept consists of separating out the FPGA design development process into two parts, the construction of the foundational FPGA Interface Manager (FIM), and the development of the Acceleration Function Unit (AFU), as shown in the diagram below.</p> <p></p> <p>This diagram shows the separation of FPGA board interface development from the internal FPGA workload creation.  This separation starts with the FPGA Interface Manager (FIM) which consists of the external interfaces and board management functions.  The FIM is the base system layer and is typically provided by board vendors. The FIM interface is specific to a particular physical platform.  The AFU makes use of the external interfaces with user defined logic to perform a specific application.  By separating out the lengthy and complicated process of developing and integrating external interfaces for an FPGA into a board allows the AFU developer to focus on the needs of their workload.  OFS for Intel\u00ae Agilex\u00ae FPGAs SoC Attach provides the following tools for rapid AFU development:</p> <ul> <li>Scripts for both compilation and simulation setup</li> <li>Optional Platform Interface Manager (PIM) which is a set of SystemVerilog shims and scripts for flexible FIM to AFU interfacing</li> <li>Acceleration Simulation Environment (ASE) which is a hardware/software co-simulation environment scripts for compilation and Acceleration</li> <li>Integration with Open Programmable Acceleration Engine (OPAE) SDK for rapid software development for your AFU application</li> </ul> <p>Please notice in the above block diagram that the AFU region consists of static and partial reconfiguration (PR) regions where the PR region can be dynamically reconfigured while the remaining FPGA design continues to function.  Creating AFU logic for the static region is described in FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae SoC Attach FPGAs. This guide covers logic in the AFU Main region.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#11-document-organization","title":"1.1. Document Organization","text":"<p>This document is organized as follows:</p> <ul> <li>Description of design flow</li> <li>Interfaces and functionality provided in the Intel IPU Platform F2000X-PL FIM</li> <li>Downloading and installing OFS and OPAE SDK</li> <li>Building the FIM to support the AFU example</li> <li>Synthesize the AFU example</li> <li>Hardware/Software co-simulation using ASE</li> <li>Testing the AFU example in the Intel IPU Platform F2000X-PL card</li> <li>Debugging an AFU with Remote Signal Tap</li> </ul> <p>This guide provides theory followed by tutorial steps to solidify your AFU development knowledge.</p> <p>This guide uses the Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL as the platform for all tutorial steps. Additionally, this guide and the tutorial steps can be used with other platforms.</p> <p>If you have worked with previous Intel Programmable Acceleration products, you will find out that OFS for Intel\u00ae Agilex\u00ae FPGAs SoC Attach is similar. However, there are differences and you are advised to carefully read and follow the tutorial steps to fully understand the design tools and flow.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#111-glossary","title":"1.1.1. Glossary","text":"Term Abbreviation Description Advanced\u00a0Error\u00a0Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link) Accelerator\u00a0Functional\u00a0Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.\u00a0Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region. Basic Building Block BBB Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. Best\u00a0Known\u00a0Configuration BKC The software and hardware configuration Intel uses to verify the solution. Board\u00a0Management\u00a0Controller BMC Supports features such as board power managment, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate component, such as an Intel\u00ae Max\u00ae 10 or Intel Cyclone\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA. Configuration and\u00a0Status\u00a0Register CSR The generic name for a register space which is accessed in order to interface with the module it resides in (e.g. AFU, BMC, various sub-systems and modules). Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Device\u00a0Feature\u00a0List DFL The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\u00a0This concept is the foundation for the OFS software framework. (link) FPGA\u00a0Interface\u00a0Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FPGA\u00a0Management\u00a0Engine FME Performs reconfiguration and other FPGA management functions. Each FPGA device only has one FME which is accessed through PF0. Host\u00a0Exerciser\u00a0Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Intel\u00a0Virtualization\u00a0Technology for\u00a0Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Joint Test Action Group JTAG Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. Memory\u00a0Mapped\u00a0Input/Output MMIO The memory space users may map and access both control registers and system memory buffers with accelerators. oneAPI Accelerator Support Package oneAPI-asp A collection of hardware and software components that enable oneAPI kernel to communicate with oneAPI runtime and OFS shell components. oneAPI ASP hardware components and oneAPI kernel form the AFU region of a oneAPI system in OFS. Open\u00a0FPGA\u00a0Stack OFS OFS is a software and hardware infrastructure providing an efficient approach to develop a custom FPGA-based platform or workload using an Intel, 3rd party, or custom board. Open\u00a0Programmable\u00a0Acceleration\u00a0Engine Software Development Kit OPAE SDK The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Platform\u00a0Interface\u00a0Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Platform Management Controller Interface PMCI The portion of the BMC that resides in the Agilex FPGA and allows the FPGA to communicate with the primary BMC component on the board. Partial Reconfiguration PR The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. For OFS designs, the PR region is referred to as the pr_slot. Port N/A When used in the context of the fpgainfo port command it represents the interfaces between the static FPGA fabric and the PR region containing the AFU. Remote System Update RSU The process by which the host can remotely update images stored in flash through PCIe. This is done with the OPAE software command \"fpgasupdate\". Secure Device Manager SDM The SDM is the point of entry to the FPGA for JTAG commands and interfaces, as well as for device configuration data (from flash, SD card, or through PCI Express* hard IP). Static Region SR The portion of the FPGA design that cannot be dynamically reconfigured during run-time. Single-Root\u00a0Input-Output\u00a0Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. SYCL SYCL SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Test Bench TB Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. Universal Verification Methodology UVM A modular, reusable, and scalable testbench structure via an API framework.  In the context of OFS, the UVM enviroment provides a system level simulation environment for your design. Virtual\u00a0Function\u00a0Input/Output VFIO An Input-Output Memory Management Unit (IOMMU)/device agnostic framework for exposing direct device access to userspace.\u00a0(link)"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#12-prerequisite","title":"1.2. Prerequisite","text":"<p>This guide assumes you have the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows including the Intel\u00ae Quartus\u00ae Prime Pro Edition design flow</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in Intel\u00ae Quartus\u00ae Prime Pro Edition software, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on timing critical paths.</li> <li>RTL and coding practices to create synthesizable logic.</li> <li>Understanding of AXI and Avalon memory mapped and streaming interfaces.</li> <li>Simulation of complex RTL using industry standard simulators (Synopsys\u00ae VCS\u00ae or Siemens\u00ae QuestaSim\u00ae).</li> <li>Signal Tap Logic Analyzer tool in the Intel\u00ae Quartus\u00ae Prime Pro Edition software.</li> </ul> <p>You are strongly encouraged to review the FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae SoC Attach FPGAs</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#13-acceleration-functional-unit-afu-development-flow","title":"1.3. Acceleration Functional Unit (AFU) Development Flow","text":"<p>The AFU development flow is shown below: </p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#131-understanding-platform-capabilities","title":"1.3.1. Understanding Platform Capabilities","text":"<p>The block diagram of the F2000x Board is shown below:</p> <p></p> <p>The FIM provided with this release is shown below:</p> <p></p> <p>This release FIM provides the following features:</p> <ul> <li>Host interface<ul> <li>PCIe Gen4 x 16</li> <li>2 - PFs </li> <li>MSI-X interrupts</li> <li>Logic to demonstrate simple PCIe loopback</li> </ul> </li> <li>Network interface<ul> <li>2 - QSFP28/56 cages</li> <li>8 X 25 GbE with exerciser logic demonstrating traffic generation/monitoring</li> </ul> </li> <li>External Memory - DDR4 - 2400<ul> <li>4 Banks - 4 GB organized as 1 Gb x 32 with 1 Gb x 8 ECC</li> <li>Memory exerciser logic demonstrating external memory operation</li> </ul> </li> <li>Board Management<ul> <li>SPI interface</li> <li>FPGA management and configuration</li> <li>Example logic showing DFH operation</li> </ul> </li> <li>Partial reconfiguration control logic</li> <li>SoC - Xeon Icelake-D subsystem with embedded Linux<ul> <li>PCIe Gen4 x 16 interface to FPGA</li> <li>1 - PF, 3 - VF, AXI-S TLP packets</li> <li>DDR Memory<ul> <li>2 Banks - 8 GB organized as 1 Gb x 64 with 1 Gb x 8 ECC</li> <li>NVMe SSD - 64 GB</li> </ul> </li> </ul> </li> </ul>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#132-high-level-data-flow","title":"1.3.2. High Level Data Flow","text":"<p>The OFS high level data flow is shown below:</p> <p></p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#133-considerations-for-pim-usage","title":"1.3.3. Considerations for PIM Usage","text":"<p>An early decision for your AFU development is determining if the PIM will be included in your design flow. The PIM is an abstraction layer consisting of a collection of SystemVerilog interfaces and shims to enable partial AFU portability across hardware despite variations in hardware topology and native interfaces. The PIM adds a level of logic between an accelerator (an AFU) and the platform (the FIM). The use of the PIM is optional for AFU development.  Please see Connecting an AFU to a Platform using PIM for details on using the PIM and its capabilities. Please see PIM Tutorial for a detailed tutorial on using the PIM. The learning steps in the tutorial can be run with the OFS for Agilex FIM package. The installation of the FIM package is described later in this guide.  </p> <p>If you choose not to use the PIM, please see Non-PIM AFU Development for instruction on using a traditional RTL design flow. Note, the example AFU provided in OFS does not include PIM.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#134-afu-interfaces-included-with-intel-ipu-platform-f2000x-pl","title":"1.3.4. AFU Interfaces Included with Intel IPU Platform F2000X-PL","text":"<p>The figure below shows the interfaces available to the AFU in this architecture. It also shows the design hierarchy with module names from the fim (top.sv) to the PR region AFU (afu_main.sv). One of the main differences from the Stratix 10 PAC OFS architecture to this one is the presence of the static port gasket region (port_gasket.sv) that has components to facilitate the AFU and also consists of the PR region (afu_main.sv) via the PR slot. The Port Gasket contains all the PR specific modules and logic, e.g., PR slot reset/freeze control, user clock, remote STP etc. Architecturally, a Port Gasket can have multiple PR slots where user workload can be programmed into. However, only one PR slot is supported for OFS Release for Intel Agilex. Everything in the Port Gasket until the PR slot should be provided by the FIM developer. The task of the AFU developer is to add their desired application in the afu_main.sv module by stripping out unwanted logic and instantiating the target accelerator. As shown in the figure below, here are the interfaces connected to the AFU (highlighted in green) via the SoC Attach FIM:</p> <ol> <li>AXI Streaming (AXI-S) interface to the Host via PCIe Gen4x16</li> <li>AXI Memory Mapped Channels (4) to the DDR4 EMIF interface</li> <li>AXI Streaming (AXI-S) interface to the HSSI 25 Gb Ethernet</li> </ol> <p></p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#2-set-up-afu-development-environment","title":"2. Set Up AFU Development Environment","text":"<p>This section covers:</p> <ul> <li>Setup of the development environment.</li> <li>Retrieving and installing OFS, OPAE SDK.</li> <li>Building the SoC Attach FIM</li> <li>Generating a relocatable AFU build-tree or build-template from the SoC Attach FIM.</li> <li>Compiling the host_chan_mmio example AFU for the SoC Attach FIM.</li> </ul> <p>Additionally, this section includes steps to demonstrate loading and running the host_chan_mmio example AFU in an Intel IPU Platform F2000X-PL equipped Linux server.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#21-prepare-afu-development-environment","title":"2.1. Prepare AFU development environment","text":"<p>A typical development and hardware test environment consists of a development server or workstation with FPGA development tools installed and a separate server with the target OFS compatible FPGA PCIe card installed.  The typical usage and flow of data between these two servers is shown below:</p> <p></p> <p>Note: both development and hardware testing can be performed on the same server if desired.</p> <p>This guide uses Intel IPU Platform F2000X-PL as the target OFS compatible FPGA PCIe card for demonstration steps.  The Intel IPU Platform F2000X-PL must be fully installed following the Getting Started User Guide: OFS for Intel\u00ae Agilex\u00ae SoC Attach FPGAs. If using a different OFS FPGA PCIe card, contact your supplier for instructions on how to install and operate user developed AFUs.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#22-installation-of-quartus-and-ofs","title":"2.2. Installation of Quartus and OFS","text":"<p>Building AFUs with OFS for Agilex requires the build machine to have at least 64 GB of RAM.  </p> <p>The following is a summary of the steps to set up for AFU development:</p> <ol> <li>Install Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1  for Linux with Agilex device support.</li> <li>Make sure support tools are installed and meet version requirements.</li> <li>Clone and install the <code>ofs-f2000x-pl</code> repository.</li> <li>Review the files provided in the repository.</li> <li>Install the required Quartus patches.</li> <li>Build a relocatable AFU PR-able build-tree. This will be the base FIM for your AFUs.</li> </ol> <p>Note: For the Intel IPU Platform F2000X-PL platforms a relocatable AFU build-tree is not provided, so you will build it from the SoC Attach FIM. The SoC Attach FIM will then be loaded in your Intel IPU Platform F2000X-PL card to support your AFUs. If you are using different OFS compatible PCIe card, skip step 6 and follow the instructions provided by your supplier.</p> <ol> <li>Install Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1 for Linux with Agilex device support. </li> </ol> <p>Intel Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1  is the currently verified version of Quartus used for building the FIM and AFU images. The recommended Best Known Configuration (BKC) for development with OFS is Ubuntu 22.04 , which is the assumed operating system for this developer guide.</p> <ul> <li>Make sure to install the following linux packages to satisfy Quartus and OFS dependencies.</li> </ul> <p><pre><code>$ sudo dnf install -y gcc gcc-c++ make cmake libuuid-devel rpm-build autoconf automake bison boost boost-devel libxml2 libxml2-devel make ncurses grub2 bc csh flex glibc-locale-source libnsl ncurses-compat-libs </code></pre> - Apply the following configurations.</p> <pre><code>$ sudo localedef -f UTF-8 -i en_US en_US.UTF-8 $ sudo ln -s /usr/lib64/libncurses.so.6 /usr/lib64/libncurses.so.5 $ sudo ln -s /usr/bin/python3 /usr/bin/python\n</code></pre> <ul> <li>Download Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1 from Quartus Pro Prime Download.</li> </ul> <ul> <li>After running the Quartus Prime Pro installer, set the PATH environment variable to make the utilities <code>quartus</code>, <code>jtagconfig</code>, and <code>quartus_pgm</code> discoverable. Edit your bashrc file <code>~/.bashrc</code> to add the following line:</li> </ul> <pre><code>$ export PATH=$PATH:&lt;Quartus install directory&gt;/quartus/bin\n</code></pre> <p>For example, if the Quartus install directory is /home/intelFPGA_pro/23.1, then:</p> <pre><code>$ export PATH=$PATH:/home/intelFPGA_pro/23.1/quartus/bin\n</code></pre> <ul> <li>Verify that Quartus is discoverable by opening a new shell:</li> </ul> <pre><code>$ which quartus\n\n/home/intelFPGA_pro/23.1/quartus/bin/quartus\n</code></pre> <ol> <li>Make sure support tools are installed and meet version requirements.</li> </ol> <p>The OFS provided Quartus build scripts require the following tools. Verify these are installed in your development environment.</p> Item Version Python 3.7.7 GCC 7.2.0 cmake 3.11.4 git and git-lfs 1.8.3.1 perl 5.8.8 <p>To install the <code>Git Large File Storage</code> extension execute the next commands</p> <pre><code>$ curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash\n$ sudo dnf install git-lfs\n$ git lfs install\n</code></pre> <ol> <li>Clone the <code>ofs-f2000x-pl</code> repository.</li> </ol> <p>The OFS FIM source code is included in the public GitHub OFS repository. Create a new directory to use as a clean starting point to store the retrieved files.  The following is a short description of each repository, followed by the git commands for cloning.  The instructions section uses the HTTPS git method for cloning repositories.</p> <ul> <li>Navigate to the location for storage of OFS source, create the top-level source directory and clone OFS repositories.</li> </ul> <pre><code>$ mkdir ofs_fim_build_root\n$ cd ofs_fim_build_root\n$ export OFS_BUILD_ROOT=$PWD\n$ git clone --branch ofs-2023.1-1 --recurse-submodules https://github.com/OFS/ofs-f2000x-pl\n\nCloning into 'ofs-f2000x-pl' ...\n    ...\n    ...\n    Resolving deltas  ..., done.\n\n$ cd $OFS_BUILD_ROOT/ofs-f2000x-pl\n</code></pre> <ol> <li>Review the files provided in the repository.</li> </ol> <p>Verify the following directories are present in <code>$OFS_BUILD_ROOT</code> directory.  </p> <pre><code>$ ls\neval_scripts  ipss  license  LICENSE.txt  ofs-common README.md  sim  src  syn  tools  verification\n</code></pre> <p>The directories are arranged as shown below:</p> <pre><code>.\n\u251c\u2500\u2500 eval_scripts           ** Support tools \n\u2502   \u251c\u2500\u2500 ofs_f2000x_eval.sh\n\u2502   \u2514\u2500\u2500 README_ofs_f2000x_eval.txt\n\u251c\u2500\u2500 ipss    **Directory ipss consists of Platform Designer subsystems used in FIM**\n\u2502   \u251c\u2500\u2500 hssi           **2 x 4 x 25 GbE HSSI subsystem** \n\u2502   \u251c\u2500\u2500 mem            **External Memory interface subsystem**\n\u2502   \u251c\u2500\u2500 pcie           **PCIe subsystem**\n\u2502   \u251c\u2500\u2500 pmci           **BMC PMCI subsystem**\n\u2502   \u251c\u2500\u2500 qsfp           **QSFP internal register access subsystem**\n\u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 ofs-common             **Common files**\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LICENSE.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 scripts\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 sim\n\u2502\u00a0\u00a0 \u2502   \u2502   \u2514\u2500\u2500 syn\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 fpga_family\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 afu_top\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 copy_engine\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 flr\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 fme\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 fme_id_rom\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 he_hssi\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 he_lb\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 he_null\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 includes\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 interrupt\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 mem_tg\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 port_gasket\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 protocol_checker\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 remote_stp\n\u2502\u00a0\u00a0 \u2502   \u2502   \u2514\u2500\u2500 st2mm\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 fpga_family\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 sim                    **Unit level simulation files**\n\u2502   \u251c\u2500\u2500 bfm\n\u2502   \u251c\u2500\u2500 common\n\u2502   \u251c\u2500\u2500 readme.txt\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u2514\u2500\u2500 unit_test\n\u251c\u2500\u2500 src                    **Source RTL files**\n\u2502   \u251c\u2500\u2500 afu_top\n\u2502   \u251c\u2500\u2500 includes\n\u2502   \u251c\u2500\u2500 pd_qsys\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u2514\u2500\u2500 top\n\u251c\u2500\u2500 syn                    **Quartus compilation settings**\n\u2502   \u251c\u2500\u2500 common\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 setup\n\u2502   \u2514\u2500\u2500 syn_top\n\u251c\u2500\u2500 tools                  \n\u2502   \u2514\u2500\u2500 pfvf_config_tool  **Tools to configure the PF/VF Mux**\n\u2514\u2500\u2500 verification          **Verification**\n    \u251c\u2500\u2500 coverage\n    \u251c\u2500\u2500 README\n    \u251c\u2500\u2500 scripts\n    \u251c\u2500\u2500 testbench\n    \u251c\u2500\u2500 tests\n    \u251c\u2500\u2500 unit_tb   \n    \u2514\u2500\u2500 verifplan\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#23-installation-of-opae-sdk","title":"2.3. Installation of OPAE SDK","text":"<p>Follow the instructions in the Getting Started Guide: Open FPGA Stack for Intel IPU Platform F2000X-PL, section 6.2 Installing the OPAE SDK On the Host to build and install the required OPAE SDK for the Intel IPU Platform F2000X-PL.</p> <p>Working with the Intel\u00ae Intel IPU Platform F2000X-PL card requires opae-2.5.0-3. Follow the instructions in the Getting Started Guide: Intel\u00ae Open FPGA Stack for Intel IPU Platform F2000X-PL section 6.2 Installing the OPAE SDK On the Host. However, just make sure to check out the cloned repository to tag 2.5.0-3 and branch release/2.5.0.</p> <pre><code>$ git checkout tags/2.5.0-3 -b release/2.5.0\n</code></pre> <p>Note: The tutorial steps provided in the next sections assume the OPAE SDK is installed in default system locations, under the directory, <code>/usr</code>. In most system configurations, this will allow the OS and tools to automatically locate the OPAE binaries, scripts, libraries and include files required for the compilation and simulation of the FIM and AFUs.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#24-download-the-basic-building-blocks-repositories","title":"2.4. Download the Basic Building Blocks repositories","text":"<p>The <code>ofs-platform-afu-bbb</code> repository contains the PIM files as well as example PIM-based AFUs that can be used for testing and demonstration purposes. Similarly, the platform-independent BBB repository, <code>intel-fpga-bbb</code>, contains infrastructure shims, PIM-based AFU sample designs, and tutorials for further testing OFS. This guide will use the <code>host_chan_mmio</code> AFU example in the ofs-platform-afu-bbb repository and the <code>hello_world</code> sample accompanying the intel-fpga-bbb repository to demonstrate how to synthesize, load, simulate, and test a PIM-based AFU using the Intel IPU Platform F2000X-PL card with the SoC Attach FIM.</p> <p>Execute the next commands to clone the BBB repositories.</p> <pre><code>  # Clone the ofs-platform-afu-bbb repository.\n$ cd $OFS_BUILD_ROOT\n$ git clone https://github.com/OFS/ofs-platform-afu-bbb.git\n\n# Verify retrieval\n$ cd $OFS_BUILD_ROOT/ofs-platform-afu-bbb\n$ ls\nLICENSE  plat_if_develop  plat_if_release  plat_if_tests  README.md\n\n# Clone the intel-fpga-bbb repository.\n$ cd $OFS_BUILD_ROOT $ git clone https://github.com/OPAE/intel-fpga-bbb.git # Verify retrieval\n$ cd $OFS_BUILD_ROOT/intel-fpga-bbb\n$ ls\nAUTHORS  BBB_cci_gemm  BBB_cci_mpf  BBB_ccip_async  BBB_ccip_mux  BBB_mpf_vtp  cmake  CMakeLists.txt  CONTRIBUTING.md  COPYING  drivers  platform-ifc-mgr-compat  README.md  samples\n</code></pre> <p>The documentation in the ofs-platform-afu-bbb and intel-fpga-bbb repositories further address   - The PIM concept.   - The structure of the PIM-based AFU examples.   - How to generate a release and configure the PIM.   - How to connect an AFU to an FIM.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#25-compiling-the-ofs-fim-for-the-intel-ipu-platform-f2000x-pl","title":"2.5. Compiling the OFS FIM for the Intel IPU Platform F2000X-PL","text":"<p>Before synthesizing an AFU, one must build the FIM that will support the AFU by facilitating the infrastructure to access the FPGA, board resources, and enabling communication with the host server. To synthesize an AFUs for this FIM a relocatable PR build-tree or build-template should be generated out of the FIM.</p> <p>OFS provides a build script with the following FPGA image creation options:</p> <ul> <li>Flat compile, which combines the FIM and AFU into one FPGA image that is loaded into the entire FPGA device as a static image.</li> <li>PR compile, which creates an FPGA image consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. Additional AFUs may be loaded into the dynamic region using partial reconfiguration.</li> </ul> <p>The build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested. Each build script step will take several hours to complete. Please note, building in Quartus GUI is not supported - you must build with the provided scripts.</p> <p>The following sections describe how to set up the environment and build the provided FIM with a relocatable build-tree supporting PR. You will use this relocatable PR build-tree for all example AFU simulation and compilation steps in this guide.</p> <p>Note: For instructions to compile FIMs available for the Intel IPU Platform F2000X-PL, refer to [FPGA Interface Manager Developer Guide: Open FPGA Stack for Intel\u00ae Agilex\u00ae FPGAs SoC Attach]. </p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#251-setting-up-the-required-environment-variables-to-build-the-fim","title":"2.5.1. Setting Up the Required Environment Variables to build the FIM","text":"<p>Set the required environment variables as shown below. These environment variables must be set prior to simulation or compilation tasks. Please, create a simple script to set these variables and save time going forward.</p> <pre><code>$ cd $OFS_BUILD_ROOT/ofs-f2000x-pl\n$ export OFS_ROOTDIR=$PWD\n# Note, OFS_ROOTDIR is the directory where you cloned the repo, e.g. /home/MyProject/ofs-f2000x-pl *\n# Quartus Tools\n# Note, QUARTUS_HOME is your Quartus installation directory, e.g. $QUARTUS_HOME/bin contains Quartus executable.\n$ export WORKDIR=$OFS_ROOTDIR   $ export QUARTUS_HOME=&lt;user_path&gt;/intelFPGA_pro/23.1/quartus\n$ export QUARTUS_ROOTDIR=$QUARTUS_HOME\n$ export QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\n$ export QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR\n$ export IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\n$ export IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\n$ export QSYS_ROOTDIR=$QUARTUS_ROOTDIR/../qsys/bin\n$ export PATH=$QUARTUS_HOME/bin:$QUARTUS_HOME/qsys/bin:$QUARTUS_HOME/sopc_builder/bin/:$PATH\n# Synopsys Verification Tools\n$ export DESIGNWARE_HOME=&lt;user_path&gt;/synopsys/vip_common/vip_Q-2020.03A\n$ export PATH=$DESIGNWARE_HOME/bin:$PATH\n$ export VCS_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel\n$ export PATH=$VCS_HOME/bin:$PATH\n# OPAE SDK release\n$ export OPAE_SDK_REPO_BRANCH=release/2.5.0\n\n# The following environment variables are required for compiling the AFU examples. \n# Location to clone the ofs-platform-afu-bbb repository which contains PIM files and AFU examples.\n$ export OFS_PLATFORM_AFU_BBB=$OFS_BUILD_ROOT/ofs-platform-afu-bbb\n\n# Location to clone the intel-fpga-bbb repository which contain infrastructure shims, AFU samples and tutorials.\n$ export FPGA_BBB_CCI_SRC=$OFS_BUILD_ROOT/intel-fpga-bbb  # OPAE_PLATFORM_ROOT points to a release tree configured with the Platform Interface Manager (PIM).  \n$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_pr/pr_build_template\n\n# OPAE and MPF libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.  \n$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n# Header files from OPAE and MPF must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.\n$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#252-compiling-the-soc-attach-fim","title":"2.5.2 Compiling the SoC Attach FIM","text":"<p>The usage of the compile build script is shown below:</p> <pre><code>Usage: ./build_top.sh [-k] [-p] [--stage=&lt;action&gt;] &lt;build target&gt; [&lt;work dir name&gt;]\nBuild a FIM instance specified by &lt;build target&gt;. The target names\n  an FPGA architecture, board and configuration.\n\nThe FIM is built in &lt;work dir name&gt;. If not specified, the target is\n  ${OFS_ROOTDIR}/work.\n\nThe -k option preserves and rebuilds within an existing work tree\n  instead of overwriting it.\n\nWhen -p is set and the FIM supports partial reconfiguration, a PR\n  template tree is generated at the end of the FIM build. The PR template\n  tree is located in the top of the work directory but is relocatable\n  and uses only relative paths. See syn/common/scripts/generate_pr_release.sh\n  for details.\n\nThe --stage option controls which portion of the OFS build is run:\n    all     - Run all build stages (default).\n    setup   - Initialize a project in the work directory.\n    compile - Run the Quartus compilation flow on a project that was already\n              initialized with \"setup\".\n    finish  - Complete OFS post-compilation tasks, such as generating flash\n              images and, if -p is set, generating a release.\n\nThe -e option runs only Quartus analysis and elaboration. It completes the\n  \"setup\" stage, passes \"-end synthesis\" to the Quartus compilation flow\n  and exits without running the \"finish\" stage.\n</code></pre> <p>The next example command, builds the SoC Attach FIM for the Intel IPU Platform F2000X-PL and generates the relocatable PR build-tree in <code>$OFS_ROOTDIR/work_pr/pr_build_template</code>.</p> <pre><code># Build the provided base example design:\n$ cd $OFS_ROOTDIR\n$ ofs-common/scripts/common/syn/build_top.sh -p f2000x work_pr\n\n... build takes ~5 hours to complete\nCompile work directory:     &lt;$OFS_ROOTDIR&gt;/work_pr/syn/syn_top\nCompile artifact directory: &lt;$OFS_ROOTDIR&gt;/work_pr/syn/syn_top/output_files\n\n***********************************\n***\n***        OFS_PROJECT: f2000x\n***        OFS_FIM: base\n***        OFS_BOARD: adp\n***        Q_PROJECT:  ofs_top\n***        Q_REVISION: ofs_top\n***        SEED: XXX\n***        Build Complete\n***        Timing Passed!\n***\n***********************************\n</code></pre> <p>The build script copies the <code>ipss</code>, <code>sim</code>, <code>src</code> and <code>syn</code> directories to the specified work directory and then these copied files are used in the Quartus compilation process. The build reports and FPGA programming files are stored under <code>&lt;work_dir&gt;/syn/syn_top/output_files</code>. The directory <code>.../output_files/timing_report</code> contains the clocks reports, failing paths, and passing margin reports.</p> <p>The build script will run PACSign (if installed) and create unsigned FPGA programming files for user1 and user2 locations of the Intel IPU Platform F2000X-PL, FPGA flash. Please note if the Intel IPU Platform F2000X-PL has the root entry hash key loaded, then PACsign must be run to add the proper key to the FPGA binary file.</p> <p>The following table provides a detailed description of the generated *.bin output files.</p> File Description ofs_top[_hps].bin This is an intermediate, raw binary file. This intermediate raw binary file is produced by taking the Quartus generated .sof file, convertint it to.pof using quartus_pfg, then converting the .pof to.hexout using quartus_cpf, and finally converting the .hexout to.bin using objcopy. Depending on whether the FPGA design contains an HPS block, a different file will be generated. ofs_top.bin - Raw binary image of the FPGA generated if there is no HPS present in the design. ofs_top_hps.bin - Raw binary image of the FPGA generated if there is an HPS present in the design. ofs_top_page1_unsigned_user1.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User1 Image. This file is used to load the FPGA flash User1 Image using the fpgasupdate tool. ofs_top_page1_user1.bin This is an input file to PACSign to generate ofs_top_page1_unsigned_user1.bin. This file is created by taking the ofs_top_[hps].bin file and assigning the User1 or appending factory block information. ofs_top_page2_unsigned_user2.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User2 Image. This file is used to load the FPGA flash User2 Image using the fpgasupdate tool. ofs_top_page2_user2.bin This is an input file to PACSign to generate ofs_top_page2_unsigned_user2.bin. This file is created by taking the ofs_top_[hps].bin file and assigning the User2 or appending factory block information."},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#253-compiling-the-fim-in-preparation-for-designing-your-afu","title":"2.5.3. Compiling the FIM in preparation for designing your AFU","text":"<p>To test the functionality and capabilities of OFS, the default FIMs integrate the following traffic generators: hssi, memory, memory-traffic-generator, and loopback.</p> <p>To save the FPGA area, the default host exercisers in the FIM can be replaced by a lightweight \"he_null\" block during compile time. Specify which host exercisers to replace in the target_configuration option provided to the build_top.sh script.</p> <p>The options supported are <code>null_he_lb</code>, <code>null_he_hssi</code>, <code>null_he_mem</code> and <code>null_he_mem_tg</code>. All options or any subset of these are supported by the build_top.sh script. To compile a FIM for minimal area consumption execute the following command.</p> <pre><code>$ cd $OFS_ROOTDIR\n$ ofs-common/scripts/common/syn/build_top.sh -p f2000x:null_he,null_he_hssi,null_he_mem,null_he_mem_tg work_null_he\n</code></pre> <p>A few important points to keep in mind.</p> <p>* he_null is a minimal block with registers that responds to PCIe MMIO request. MMIO responses are required to keep PCIe alive (the end-points enabled in PCIe-SS need to service downstream requests).</p> <p>* If an exerciser with other I/O connections such has he_mem or he_hssi is replaced, then those I/O ports are simply tied off.</p> <p>* Finer grain control is provided since the user may just turn off the exercisers in Static region to save area. </p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#254-load-the-fim-into-the-flash-of-the-intel-ipu-platform-f2000x-pl","title":"2.5.4. Load the FIM into the Flash of the Intel IPU Platform F2000X-PL","text":"<p>In this step, you will load the previously compiled SoC Attach FIM binary into the flash of the Intel IPU Platform F2000X-PL board. AFUs developed in this guide using the SoC Attach FIM and the generated build-tree will be compatible with the image loaded on the Intel IPU Platform F2000X-PL board.</p> <pre><code># On Development Host\n$ cd $OFS_ROOTDIR/work_pr/syn/syn_top/output_files\n# Copy FIM files to SoC\n$ scp ofs_top_page1_unsigned_user1.bin &lt;user&gt;@&lt;SoC IP address&gt;:&lt;/remote/directory&gt;\n$ scp ofs_top_page2_unsigned_user2.bin &lt;user&gt;@&lt;SoC IP address&gt;:&lt;/remote/directory&gt;\n</code></pre> <pre><code># On SoC\n$ cd &lt;/remote/directory&gt;\n$ fpgasupdate ofs_top_page1_unsigned_user1.bin &lt;F2000x SKU2 PCIe b:d.f&gt;\n$ fpgasupdate ofs_top_page2_unsigned_user2.bin &lt;F2000x SKU2 PCIe b:d.f&gt;\n$ rsu fpga --page=user1 &lt;F2000x SKU2 PCIe b:d.f&gt;\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#3-compiling-an-afu","title":"3. Compiling an AFU","text":"<p>In this section, you will use the relocatable PR build-tree created in the previous steps from the FIM to compile an example PIM-based AFU. This section will be developed around the <code>host_chan_mmio</code> AFU example to showcase the synthesis of a PIM-based AFU.</p> <p>The <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio</code> is a simple example demonstrating both hardware and software access to an AFU. The <code>host_chan_mmio</code> example AFU consists of the following files.</p> <pre><code>host_chan_mmio\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 avalon\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_avalon.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 axi\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_axi.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 host_chan_mmio.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon1.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon2_512rw.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi1.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 test_mmio_axi2_512rw.txt\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 main.c\n    \u251c\u2500\u2500 Makefile\n</code></pre> <p>This example AFU contains examples using both Avalon and AXI interfaces. The hw directory contains the RTL to implement the hardware functionality using Avalon and AXI interfaces. However, this guide will use the AXI version of the <code>host_chan_mmio</code> AFU to go through the compilation steps. The sw directory of the AFU contains the source code of the host application that communicates with the actual AFU hardware.</p> <p>The build steps presented below demonstrate the ease in building and running an actual AFU on the Intel IPU Platform F2000X-PL board. To successfully execute the instructions in this section, you must have set up your development environment and compiled the SoC Attach FIM as instructed in section 2 of this document.</p> <p>Additionally, you need to set the <code>OPAE_PLATFORM_ROOT</code> environment variable to the path where the PR build-tree was generated during the SoC Attach FIM compilation through the [-p] switch.</p> <pre><code>$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_pr/pr_build_template\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#31-create-the-afu-synthesis-environment","title":"3.1. Create the AFU Synthesis Environment","text":"<p>Here, you will create the synthesis environment to build the <code>host_chan_mmio</code> example. For this task, the PIM flow provides the script <code>afu_synth_setup</code>. See how to use it below.</p> <pre><code>usage: afu_synth_setup [-h] -s SOURCES [-p PLATFORM] [-l LIB] [-f] dst\n\nGenerate a Quartus build environment for an AFU. A build environment is\ninstantiated from a release and then configured for the specified AFU. AFU\nsource files are specified in a text file that is parsed by rtl_src_config,\nwhich is part of the OPAE base environment.\n\npositional arguments:\n  dst                   Target directory path (directory must not exist).\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA platform name.\n  -l LIB, --lib LIB     FPGA platform release hw/lib directory. If not\n                        specified, the environment variables OPAE_FPGA_HW_LIB\n                        and then BBS_LIB_PATH are checked.\n  -f, --force           Overwrite target directory if it exists.\n</code></pre> <p>Execute <code>afu_synth_setup</code> as follows to create the synthesis environment for a <code>host_chan_mmio</code> AFU that fits the SoC Attach FIM previously constructed.</p> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio\n\n$ mkdir -p $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x\n$ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt hardware\n\nNow, move into the synthesis environment ```hardware``` directory just created. From there, execute the ```afu_synth``` command. The successful completion of the command will produce the ```host_chan_mmio.gbs``` file under the synthesis environment directory, ```$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x/hardware```.\n\n$ cd hardware\n$ $OPAE_PLATFORM_ROOT/bin/afu_synth\nCompiling ofs_top ofs_pr_afu\nGenerating host_chan_mmio.gbs\n==================================\n...\n...\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\nDesign meets timing\n===========================================================================\n</code></pre> <p>The previous output indicates the successful compilation of the AFU and the compliance with the timing requirements. Analyze the reports generated in case the design does not meet timing. The timing reports are stored in the directory, <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x/hardware/build/syn/syn_top/output_files/timing_report</code>.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#32-loading-and-running-host_chan_mmio-example-afu","title":"3.2. Loading and Running host_chan_mmio example AFU","text":"<p>Once the compilation finishes successfully, load the new <code>host_chan_mmio.gbs</code> bitstream file into the partial reconfiguration region of the target Intel IPU Platform F2000X-PL board. Keep in mind, that the loaded image is dynamic - this image is not stored in flash and if the card is power cycled, then the PR region is re-loaded with the default AFU.</p> <p>To load the image, perform the following steps:</p> <pre><code># On Development Host\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x/base/hardware\n# Copy FIM files to SoC\n$ scp host_chan_mmio.gbs &lt;user&gt;@&lt;SoC IP address&gt;:&lt;/remote/directory&gt;\n</code></pre> <pre><code># On SoC\n$ cd &lt;/remote/directory&gt;\n$ fpgasupdate host_chan_mmio.gbs &lt;F2000x SKU2 PCIe b:d.f&gt; [2022-04-15 20:22:18.85] [WARNING ] Update starting. Please do not interrupt.\n[2022-04-15 20:22:19.75] [INFO    ] Partial Reconfiguration OK\n[2022-04-15 20:22:19.75] [INFO    ] Total time: 0:00:00.90\n</code></pre> <p>Set up your board to work with the newly loaded AFU.</p> <pre><code># For the following example, the F2000x SKU2 PCIe b:d.f is assumed to be 15:00.0,\n# however this may be different in your system\n# Create the Virtual Functions (VFs):\n$ pci_device 15:00.0 vf 3\n# Verify:\n$ lspci -s 15:00\n15:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n15:00.1 Processing accelerators: Intel Corporation Device bccf\n15:00.2 Processing accelerators: Intel Corporation Device bccf\n15:00.3 Processing accelerators: Intel Corporation Device bccf\n\n# Bind VFs to VFIO driver. \n$  opae.io init -d 0000:15:00.1 opae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:15:00.1 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:15:00.1 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:15:00.1 is 52\n$ opae.io init -d 0000:15:00.2\nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:15:00.2 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:15:00.2 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:15:00.2 is 53\n$  opae.io init -d 0000:15:00.3\nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:15:00.3 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:15:00.3 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:15:00.3 is 54\n# Verify the new AFU is loaded.  The host_chan_mmio AFU GUID is \"76d7ae9c-f66b-461f-816a-5428bcebdbc5\".\n$ fpgainfo port\n//****** PORT ******//\nObject Id                        : 0xF100000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x6015000000000000\nPCIe s:b:d.f                     : 0000:15:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nAccelerator GUID                 : d15ab1ed-0000-0000-0210-000000000000\n//****** PORT ******//\nObject Id                        : 0x4015000000000000\nPCIe s:b:d.f                     : 0000:15:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nAccelerator GUID                 : d15ab1ed-0000-0000-0110-000000000000\n//****** PORT ******//\nObject Id                        : 0x2015000000000000\nPCIe s:b:d.f                     : 0000:15:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nAccelerator GUID                 : 76d7ae9c-f66b-461f-816a-5428bcebdbc5\n</code></pre> <p>Now, navigate to the directory of the <code>host_chan_mmio</code> AFU containing the host application's source code, <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw</code>. Once there, compile the <code>host_chan_mmio</code> host application and execute it on the host server to excercise the functionality of the AFU.</p> <p>Note: If OPAE SDK libraries were not installed in the default systems directories under <code>/usr</code>, you need to set the <code>OPAE_LOC</code>, <code>LIBRARY_PATH</code>, and <code>LD_LIBRARY_PATH</code> environment variables to the custom locations where the OPAE SDK libraries were installed.</p> <pre><code># On Development Host, move to the sw directory of the the host_chan_mmio AFU. This directory holds the source for the host application.\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw\n$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n$ make\n# Copy application to SoC\n$ scp host_chan_mmio &lt;user&gt;@&lt;SoC IP address&gt;:&lt;/remote/directory&gt;\n</code></pre> <pre><code># On SoC, Run the application\n$ cd &lt;/remote/directory&gt;\n$  ./host_chan_mmio\nAFU ID:  76d7ae9cf66b461f 816a5428bcebdbc5\nAFU MMIO interface: AXI Lite\nAFU MMIO read bus width: 64 bits\n512 bit MMIO write supported: yes\nAFU pClk frequency: 470 MHz\n\nTesting 32 bit MMIO reads:\n  PASS - 4 tests\n\nTesting 32 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 64 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 512 bit MMIO writes:\n  PASS\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#33-loading-and-running-the-hello_world-example-afu","title":"3.3. Loading and running the hello_world example AFU","text":"<p>The platform-independent examples AFU repository also provides some interesting example AFUs. In this section, you will compile and execute the PIM based <code>hello_world</code> AFU. The RTL of the <code>hello_world</code> AFU receives from the host application an address via memory mapped I/O (MMIO) write and generates a DMA write to the memory line at that address. The content written to memory is the string \"Hello world!\". The host application spins, waiting for the memory line to be updated. Once available, the software prints out the string.</p> <p>The <code>hello_world</code> example AFU consists of the following files. </p> <p><pre><code>hello_world\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 avalon\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_world_avalon.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 sources.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 axi\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_world_axi.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 sources.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 ccip\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_world_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 sources.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 hello_world.json\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 hello_world\n    \u251c\u2500\u2500 hello_world.c\n    \u251c\u2500\u2500 Makefile\n    \u2514\u2500\u2500 obj\n        \u251c\u2500\u2500 afu_json_info.h\n        \u2514\u2500\u2500 hello_world.o\n</code></pre> The hw directory contains the RTL to implement the hardware functionality using CCIP, Avalon, and AXI interfaces. However, this guide will use the AXI version of the AFU to go through the compilation steps. The sw directory of the AFU contains the source code of the host application that communicates with the AFU hardware.</p> <p>The following instructions can be used to compile other AFU samples accompanying this repository.</p> <ol> <li>If not done already, download and clone the repository.</li> </ol> <pre><code>$ cd $OFS_BUILD_ROOT $ git clone https://github.com/OFS/examples-afu.git\n</code></pre> <ol> <li>Install the Basic Building Blocks include files and libraries. </li> </ol> <pre><code>$ cd $OFS_BUILD_ROOT/intel-fpga-bbb\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_INSTALL_PREFIX=/usr ..\n$ make\n$ sudo make install\n</code></pre> <p>By default, the Basic Building Blocks include and library files will be installed in <code>/usr/local</code>. You can change this installation prefix to another path by adding <code>-DCMAKE_INSTALL_PREFIX=&lt;&lt;custom_path&gt;&gt;</code> to the cmake command, as above. In most cases, you should choose the same prefix for both the OPAE SDK and the Basic Building Blocks.</p> <p>If OPAE and the Basic Building Blocks are installed to standard system directories, such as <code>/usr/</code> and <code>/usr/local</code>, they may already be found on C and C++ header and library search paths. Otherwise, their installation directories must be added explicitly.</p> <p>\u00a0\u00a0\u00a0\u00a0 * Header files from OPAE and BBB must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.</p> <p>\u00a0\u00a0\u00a0\u00a0 * OPAE and BBB libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.</p> <ol> <li>Make sure to set the next environment variables.</li> </ol> <pre><code># Set the FPGA_BBB_CCI_SRC variable to the full path of the intel-fpga-bbb directory created in the git clone step above.\n$ export FPGA_BBB_CCI_SRC=$OFS_BUILD_ROOT/intel-fpga-bbb  # Header files from OPAE and MPF must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.\n$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\n\n# OPAE and MPF libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.  \n$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n# OPAE_PLATFORM_ROOT points to a release tree that has been configured with the Platform Interface Manager (PIM).  \n$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_pr/pr_build_template\n</code></pre> <ol> <li> <p>Compile the <code>hello_word</code> sample AFU.  <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world\n$ afu_synth_setup --source hw/rtl/axi/sources.txt build\n$ cd build\n$ ${OPAE_PLATFORM_ROOT}/bin/afu_synth\nCompiling ofs_top ofs_pr_afu\nGenerating hello_world.gbs\n==================================\n.\n.\n.\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'hello_world.gbs'\nDesign meets timing\n===========================================================================\n</code></pre></p> </li> <li> <p>To test the AFU in actual hardware, load the <code>hello_world.gbs</code> to the Intel IPU Platform F2000X-PL card. For this step to be successful, the SoC Attach FIM must have already been loaded to the Intel IPU Platform F2000X-PL card following the steps described in Section 2 of this document.</p> </li> </ol> <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/build/\n# Copy FIM files to SoC\n$ scp hello_world.gbs &lt;user&gt;@&lt;SoC IP address&gt;:&lt;/remote/directory&gt;\n</code></pre> <pre><code># On SoC\n$ cd &lt;/remote/directory&gt;\n$ fpgasupdate hello_world.gbs &lt;F2000x SKU2 PCIe b:d.f&gt;\n[2022-04-15 20:22:18.85] [WARNING ] Update starting. Please do not interrupt.\n[2022-04-15 20:22:19.75] [INFO    ] Partial Reconfiguration OK\n[2022-04-15 20:22:19.75] [INFO    ] Total time: 0:00:00.90\n</code></pre> <p>Set up your Intel IPU Platform F2000X-PL board to work with the newly loaded <code>hello_world.gbs</code> file.</p> <pre><code># For the following example, the Intel IPU Platform F2000X-PL PCIe b:d.f is assumed to be 15:00.0,\n# however this may be different in your system\n# Create the Virtual Functions (VFs):\n$ pci_device 15:00.0 vf 3\n# Verify:\n$ lspci -s 15:00\n15:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n15:00.1 Processing accelerators: Intel Corporation Device bccf\n15:00.2 Processing accelerators: Intel Corporation Device bccf\n15:00.3 Processing accelerators: Intel Corporation Device bccf\n\n# Bind VFs to VFIO driver.  Enter &lt;&lt;Your username&gt;&gt;\n$ opae.io init -d 0000:15:00.1\nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:15:00.1 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:15:00.1 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:15:00.1 is 52\n$ opae.io init -d 0000:15:00.2\nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:15:00.2 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:15:00.2 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:15:00.2 is 53\n$ opae.io init -d 0000:15:00.3\nopae.io 0.2.5\nUnbinding (0x8086,0xbccf) at 0000:15:00.3 from dfl-pci\nBinding (0x8086,0xbccf) at 0000:15:00.3 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:15:00.3 is 54\n# &lt; Verify the new AFU is loaded.  The hello_world AFU GUID is \"c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\".\n$ fpgainfo port\n//****** PORT ******//\nObject Id                        : 0xF100000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x6015000000000000\nPCIe s:b:d.f                     : 0000:15:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nAccelerator GUID                 : d15ab1ed-0000-0000-0210-000000000000\n//****** PORT ******//\nObject Id                        : 0x4015000000000000\nPCIe s:b:d.f                     : 0000:15:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nAccelerator GUID                 : d15ab1ed-0000-0000-0110-000000000000\n//****** PORT ******//\nObject Id                        : 0x2015000000000000\nPCIe s:b:d.f                     : 0000:15:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nAccelerator GUID                 : c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\n</code></pre> <ol> <li>Compile and execute the host application of the <code>hello_world</code> AFU. You should see the application outputs the \"Hello world!\" message in the terminal.</li> </ol> <pre><code># On Development Host, move to the sw directory of the hello_world AFU and build application\n$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/sw\n$ make\n# Copy application to SoC\n$ scp hello_world &lt;user&gt;@&lt;SoC IP address&gt;:&lt;/remote/directory&gt;\n</code></pre> <pre><code># On SoC, Run the application\n$ cd &lt;/remote/directory&gt;\n$ ./hello_world\nHello world!\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#34-modify-the-afu-user-clocks-frequency","title":"3.4. Modify the AFU user clocks frequency","text":"<p>An OPAE compliant AFU specifies the frequency of the <code>uclk_usr</code> and <code>uclk_usr_div2</code> clocks through the JSON file for AFU configuration located under the <code>&lt;afu_example&gt;/hw/rtl</code> directory of an AFU design. For instance, the AFU configuration file of the <code>host_chan_mmio</code> example is <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/host_chan_mmio.json</code>.</p> <p>The AFU specifies the frequency for uClk_usr in its platform configuration file using the following key:value pairs:</p> <pre><code>  \"clock-frequency-high\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n  \"clock-frequency-low\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n</code></pre> <p>These <code>key:value</code> tuples are used to configure the PLL of the target platform that provides the user clocks through the AFU clocks interface. In addition, the specified frequency affects the timing closure process on the user clocks during AFU compilation. </p> <p>Setting the value field to a float number (e.g., 315.0 to specify 315 MHz) drives the AFU generation process to close timing within the bounds set by the low and high values and sets the AFU's JSON metadata to specify the user clock PLL  frequency values.</p> <p>The following example shows the JSON file of the <code>host_chan_mmio</code> to set the AFU uClk to 500 MHz and uClk_div2 to 250 MHz.</p> <pre><code>{\n   \"version\": 1,\n   \"afu-image\": {\n      \"power\": 0,\n      \"clock-frequency-high\": 500,\n      \"clock-frequency-low\": 250,\n      \"afu-top-interface\":\n         {\n            \"class\": \"ofs_plat_afu\"\n         },\n      \"accelerator-clusters\":\n         [\n            {\n               \"name\": \"host_chan_mmio\",\n               \"total-contexts\": 1,\n               \"accelerator-type-uuid\": \"76d7ae9c-f66b-461f-816a-5428bcebdbc5\"\n            }\n         ]\n   }\n}\n</code></pre> <p>Save the changes to <code>host_chan_mmio.json</code> file, then execute the <code>afu_synth_setup</code> script to create a new copy of the AFU files with the modified user clock settigns.</p> <p><pre><code>$ mkdir -p $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x\n$ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_f2000x_afu_clks\n\nCopying build from /home/&lt;user_area&gt;/ofs-f2000x-pl/work_pr/pr_build_template/hw/lib/build...\nConfiguring Quartus build directory: build_F2000x_afu_clks/build\nLoading platform database: /home/&lt;user_area&gt;/ofs-f2000x-pl/work_pr/pr_build_template/hw/lib/platform/platform_db/ofs_agilex_adp.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting platform/platform_afu_top_config.vh\nWriting platform/platform_if_addenda.qsf\nWriting ../hw/afu_json_info.vh\n</code></pre> Compile the <code>host_chan_mmio</code> AFU with the new frequency values.</p> <pre><code>$ cd build_f2000x_afu_clks\n$ $OPAE_PLATFORM_ROOT/bin/afu_synth\n</code></pre> <p>During the compilation phase, you will observe the Timing Analyzer uses the specified user clock frequency values as the target to close timing.</p> <p></p> <p></p> <p>AFU developers must ensure the AFU hardware design meets timing. The compilation of an AFU that fails timing shows a message similar to the following.</p> <pre><code>.\n.\n.\n\nWrote host_chan_mmio.gbs\n\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\n*** Design does not meet timing\n  *** See build/syn/syn_top/output_files/timing_report\n\n===========================================================================\n</code></pre> <p>The previous output indicates the location of the timing reports for the AFU designer to identify the failing paths and perform the necessary design changes. Next, is a listing of the timing report files from a <code>host_chan_mmio</code> AFU that fails to meet timing after modifying the user clock frequency values.</p> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x/build_f2000x_afu_clks\n$ ls build/syn/syn_top/output_files/timing_report\n\nclocks.rpt  clocks.sta.fail.summary  clocks.sta.pass.summary\n</code></pre> <p>Warning: AFU developers must inform software developers of the maximum operating frequency (Fmax) of the user clocks to avoid any unexpected behavior of the accelerator and potentially of the overall system.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#4-simulating-an-afu-using-ase","title":"4. Simulating an AFU using ASE","text":"<p>The Application Simulation Environment (ASE) is a hardware/software co-simulation environment for your AFU. See diagram below illustrating ASE operation:</p> <p></p> <p>ASE uses the simulator Direct Programming Interface (DPI) to provide HW/SW connectivity.  The PCIe connection to the AFU under testing is emulated with a transactional model.</p> <p>The following list describes ASE operation:</p> <ul> <li>Attempts to replicate the transactions that will be seen in real system.</li> <li>Provides a memory model to AFU, so illegal memory accesses can be identified early.</li> <li>Not a cache simulator.</li> <li>Does not guarantee synthesizability or timing closure.</li> <li>Does not model system latency.</li> <li>No administrator privileges are needed to run ASE.  All code is user level.</li> </ul> <p>The remainder of this section is a tutorial providing the steps on how to run ASE with either Synopsys\u00ae VCS\u00ae or Siemens\u00ae QuestaSim\u00ae using an example AFU and the AFU build tree previously created in this guide.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#41-set-up-steps-to-run-ase","title":"4.1. Set Up Steps to Run ASE","text":"<p>In this section you will set up your server to support ASE by independently downloading and installing OPAE SDK and ASE. Then, set up the required environment variables.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#411-install-opae-sdk","title":"4.1.1. Install OPAE SDK","text":"<p>Follow the instructions documented in the Getting Started Guide: Open FPGA Stack for Intel\u00ae Agilex\u00ae FPGAs Targeting the Intel\u00ae FPGA SmartNIC N6001-PL, section 6.2 Installing the OPAE SDK On the Host to build and install the required OPAE SDK for the Intel IPU Platform F2000X-PL card.</p> <p>The F2000x SKU2 card requires 2.5.0-3. Follow the instructions provided in the Getting Started Guide: Open FPGA Stack for Intel\u00ae Agilex\u00ae FPGAs Targeting the Intel\u00ae FPGA SmartNIC N6001-PL, section 6.2 Installing the OPAE SDK On the Host. However, just make sure to check out the cloned repository to tag 2.5.0-3 and branch release/2.5.0.</p> <pre><code>$ git checkout tags/2.5.0-3 -b release/2.5.0\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#412-install-ase-tools","title":"4.1.2 Install ASE Tools","text":"<p>ASE is an RTL simulator for OPAE-based AFUs. The simulator emulates both the OPAE SDK software user space API and the AFU RTL interface. The majority of the FIM as well as devices such as PCIe and local memory are emulated with simple functional models.</p> <p>ASE must be installed separatedly from the OPAE SDK. However, the recommendation is to install it in the same target directory as OPAE SDK.</p> <ol> <li> <p>If not done already, set the environment variables as described in section, Set Up AFU Development Environment.</p> </li> <li> <p>Clone the <code>opae-sim</code> repository.</p> </li> </ol> <p><pre><code>$ cd $OFS_BUILD_ROOT\n$ git clone https://github.com/OFS/opae-sim.git\n$ cd opae-sim\n$ git checkout tags/2.5.0-2 -b release/2.5.0 </code></pre> 2. Building ASE requires the include file <code>mock/opae_std.h</code>. If the OPAE SDK was installed under the default system directories, the C_INCLUDE_PATH variable must be set as follows. </p> <pre><code>$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\n</code></pre> <ol> <li>Create a build directory and build ASE to be installed under the default system directories along with OPAE SDK.</li> </ol> <pre><code>$ mkdir build\n$ cd build\n$ cmake  -DCMAKE_INSTALL_PREFIX=/usr ..\n$ make\n</code></pre> <p>Optionally, if the desire is to install ASE binaries in a different location to the system's default, provide the path to CMAKE through the CMAKE_INSTALL_PREFIX switch, as follows.</p> <pre><code>$ cmake -DCMAKE_INSTALL_PREFIX=&lt;&lt;/some/arbitrary/path&gt;&gt; ..  </code></pre> <ol> <li>Install ASE binaries and libraries under the system directory <code>/usr</code>.</li> </ol> <pre><code>$ sudo make install  </code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#413-setup-required-ase-environment-variables","title":"4.1.3. Setup Required ASE Environment Variables","text":"<p>The values set to the following environment variables assume the OPAE SDK and ASE were installed in the default system directories below <code>/usr</code>. Setup these variables in the shell where ASE will be executed. You may wish to add these variables to the script you created to facilitate configuring your environment.</p> <pre><code>$ cd /usr/bin\n$ export PATH=$PWD:$PATH\n$ cd /usr/lib/python*/site-packages\n$ export PYTHONPATH=$PWD\n$ cd /usr/lib\n$ export LIBRARY_PATH=$PWD\n$ cd /usr/lib64\n$ export LD_LIBRARY_PATH=$PWD\n$ cd $OFS_BUILD_ROOT/ofs-platform-afu-bbb\n$ export OFS_PLATFORM_AFU_BBB=$PWD\n$ cd $OFS_ROOTDIR/work_pr/pr_build_template\n$ export OPAE_PLATFORM_ROOT=$PWD\n## For VCS, set the following:\n$ export VCS_HOME=&lt;Set the path to VCS installation directory&gt;\n$ export PATH=$VCS_HOME/bin:$PATH\n## For QuestaSIM, set the following:\n$ export MTI_HOME=&lt;path to Modelsim installation directory&gt;\n$ export PATH=$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$PATH\n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#42-simulating-the-host_chan_mmio-afu","title":"4.2. Simulating the host_chan_mmio AFU","text":"<p>The <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio</code> is a simple example demonstrating both hardware and software access to an AFU. The <code>host_chan_mmio</code> example AFU consists of the following files:</p> <pre><code>host_chan_mmio\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 avalon\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_avalon.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 axi\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_axi.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 host_chan_mmio.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon1.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon2_512rw.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi1.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 test_mmio_axi2_512rw.txt\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 main.c\n    \u251c\u2500\u2500 Makefile\n</code></pre> <p>This example AFU contains examples using both Avalon and AXI interface buses. This guide will use the AXI version of the <code>host_chan_mmio</code> AFU.</p> <p>ASE uses client-server application architecture to deliver hardware/software co-simulation.  You require one shell for the hardware based simulation and another shell where the software application is running. The hardware is started first with a simulation compilation and simulator startup script, once the simulator has loaded the design, it will wait until the software process starts. Once the software process starts, the simulator proceeds.  Transaction logging and waveform capture is performed.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#421-set-up-and-run-the-hw-simulation-process","title":"4.2.1 Set Up and Run the HW Simulation Process","text":"<p>You will run the <code>afu_sim_setup</code> script to create the scripts for running the ASE environment.  The <code>afu_sim_setup</code> script has the following usage:</p> <pre><code>usage: afu_sim_setup [-h] -s SOURCES [-p PLATFORM] [-t {VCS,QUESTA,MODELSIM}]\n                     [-f] [--ase-mode ASE_MODE] [--ase-verbose]\n                     dst\n\nGenerate an ASE simulation environment for an AFU. An ASE environment is\ninstantiated from the OPAE installation and then configured for the specified\nAFU. AFU source files are specified in a text file that is parsed by\nrtl_src_config, which is also part of the OPAE base environment.\n\npositional arguments:\n  dst                   Target directory path (directory must not exist).\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA Platform to simulate.\n  -t {VCS,QUESTA,MODELSIM}, --tool {VCS,QUESTA,MODELSIM}\n                        Default simulator.\n  -f, --force           Overwrite target directory if it exists.\n  --ase-mode ASE_MODE   ASE execution mode (default, mode 3, exits on\n                        completion). See ase.cfg in the target directory.\n  --ase-verbose         When set, ASE prints each CCI-P transaction to the\n                        command line. Transactions are always logged to\n                        work/ccip_transactions.tsv, even when not set. This\n                        switch sets ENABLE_CL_VIEW in ase.cfg.\n</code></pre> <p>Run <code>afu_sim_setup</code> to create the ASE simulation environment for the <code>host_chan_mmio</code> example AFU. The <code>'-t VCS'</code> option indicates to prepare the ASE simulation environment for Synopsys\u00ae VCS\u00ae.</p> <pre><code>$ mkdir -p $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/f2000x\n\n$ afu_sim_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt -t VCS simulation\n\nCopying ASE from /opae-sdk/install-opae-sdk/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\n\nTool Brand: VCS\nLoading platform database: /ofs-f2000x-pl/work_pr/build_tree/hw/lib/platform/platform_db/ofs_agilex_adp.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> creates the ASE scripts in the directory <code>host_chan_mmio_sim</code> where the <code>afu_sim_setup</code> script was run.  Start the simulator as shown below:</p> <pre><code>$ cd simulation\n$ make\n$ make sim\n</code></pre> <p>This process launches the AFU hardware simulator. Before moving to the next section, pay attention to the simulator output highlighted in the image below.</p> <p></p> <p>The simulation artifacts are stored in host_chan_mmio/work and consist of:</p> <pre><code>log_ase_events.tsv\nlog_ofs_plat_host_chan.tsv \nlog_ofs_plat_local_mem.tsv \nlog_pf_vf_mux_A.tsv \nlog_pf_vf_mux_B.tsv \n</code></pre>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#422-set-up-and-run-the-sw-process","title":"4.2.2 Set Up and Run the SW Process","text":"<p>Open an additional shell to build and run the host application that communicates with the actual AFU hardware. Set up the same environment variable you have set up in the shell you have been working on until this point. </p> <p>Additionally, as indicated by the hardware simulator output that is currently executing in the \"simulator shell\", copy and paste the line <code>\"export ASE_WORKDIR=...\"</code>, into the new \"software shell\". See the last image of the previous section.</p> <p><pre><code>$ export ASE_WORKDIR= &lt;&lt;as directed in HW simulation shell&gt;&gt;\n</code></pre> Then, go to the sw directory of the <code>host_chan_mmio</code> AFU example to compile the host application.</p> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw  $ make\n\nafu_json_mgr json-info --afu-json=../hw/rtl/host_chan_mmio.json --c-hdr=obj/afu_json_info.h\nWriting obj/afu_json_info.h\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c main.c -o obj/main.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c test_host_chan_mmio.c -o obj/test_host_chan_mmio.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/connect.c -o obj/connect.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/csr_mgr.c -o obj/csr_mgr.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/hash32.c -o obj/hash32.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/test_data.c -o obj/test_data.o\ncc -o host_chan_mmio obj/main.o obj/test_host_chan_mmio.o obj/connect.o obj/csr_mgr.o obj/hash32.o obj/test_data.o  -z noexecstack -z relro -z now -pie -luuid -lopae-c-ase\n</code></pre> <p>Now, launch the host application to exercise the AFU hardware running on the simulator shell. The next image shows the AFU hardware simulation process on the left side shell. The right hand shell shows the host application's output of a successful simulation.</p> <pre><code>$ with_ase ./host_chan_mmio\n  [APP]  Initializing simulation session ...\nRunning in ASE mode\nAFU ID:  76d7ae9cf66b461f 816a5428bcebdbc5\nAFU MMIO interface: AXI Lite\nAFU MMIO read bus width: 64 bits\n512 bit MMIO write supported: yes\nAFU pClk frequency: 470 MHz\n\nTesting 32 bit MMIO reads:\n  PASS - 4 tests\n\nTesting 32 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 64 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 512 bit MMIO writes:\n  PASS\n  [APP]  Deinitializing simulation session\n  [APP]         Took 1,003,771,568 nsec\n  [APP]  Session ended\n</code></pre> <p> </p> <p>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</p> <pre><code>$ make wave\n</code></pre> <p>This brings up the Synopsys\u00ae VCS\u00ae simulator GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the afu instance located under, <code>ase_top | ase_top_plat | ase_afu_main_pcie_ss | ase_afu_main_emul | afu_main | port_afu_instances | ofs_plat_afu | afu</code> , as shown below.</p> <p></p> <p>Right click on the <code>afu (afu)</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p></p> <p></p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#43-simulating-the-hello_world-afu","title":"4.3 Simulating the hello_world AFU","text":"<p>In this section you will quickly simulate the PIM-based <code>hello_world</code> sample AFU accompanying the examples-afu repository.</p> <ol> <li> <p>Set the environment variables as described in section 4.1. Set Up Steps to Run ASE.</p> </li> <li> <p>Prepare an RTL simulation environment for the AXI version of the <code>hello_world</code> AFU.</p> <p>Simulation with ASE requires two software processes, one to simulate the AFU RTL and the other to run the host software that excercises the AFU. To construct an RTL simulation environment under the directory <code>simulation</code>, execute the following.</p> <pre><code>$ mkdir -p $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/f2000x\n$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/f2000x\n$ afu_sim_setup -s $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/hw/rtl/axi/sources.txt simulation\n\nCopying ASE from /usr/local/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\nTool Brand: VCS\nLoading platform database: /home/&lt;user_area&gt;/ofs-f2000x-pl/work_pr/pr_build_template/hw/lib/platform/platform_db/ofs_agilex_adp.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> script constructs an ASE environment in the <code>hello_world_sim</code> subdirectory. If the command fails, confirm that the path to the afu_sim_setup is on your PATH environment variable (in the OPAE SDK bin directory) and that your Python version is at least 2.7.</p> </li> <li> <p>Build and execute the AFU RTL simulator.</p> <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/f2000x/simulation\n$ make\n$ make sim  </code></pre> <p>The previous commands will build and run the Synopsys\u00ae VCS\u00ae RTL simulator, which prints a message saying it is ready for simulation. The simulation process also prints a message instructing you to set the ASE_WORKDIR environment variable in a second shell.</p> </li> <li> <p>Open a second shell where you will build and execute the host software. In this new \"software shell\", set up the environment variables you have set up so far in the \"hardware simulation\" shell.</p> </li> <li> <p>Also, set the ASE_WORKDIR environment variable following the instructions given in the \"hardware simulation\" shell.</p> <p><pre><code>$ export ASE_WORKDIR=$OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/f2000x/simulation/work\n</code></pre> 6. Then, move to the sw directory of the <code>hello_world</code> AFU sample to build the host software.</p> <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/sw\n$ make      </code></pre> </li> <li> <p>Run the <code>hello_world</code> host application to resume the work of the RTL simulation. The host software process and the RTL simulation execute in lockstep. If successful, you should see the Hello world! output.</p> <pre><code>$ with_ase ./hello_world\n\n[APP]  Initializing simulation session ...\nHello world!\n  [APP]  Deinitializing simulation session\n  [APP]         Took 43,978,424 nsec\n  [APP]  Session ended\n</code></pre> <p>The image below shows the simulation of the AFU hardware and the execution of the host application side-by-side.</p> <p></p> </li> </ol> <p></p> <p></p> <ol> <li> <p>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</p> <pre><code>make wave\n</code></pre> <p>This brings up the DVE GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the afu instance located under, <code>ase_top | ase_top_plat | ase_afu_main_pcie_ss | ase_afu_main_emul | afu_main | port_afu_instances | ofs_plat_afu | hello_afu</code>, as shown below.</p> </li> </ol> <p></p> <p>Right click on the <code>hello_afu</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p></p> <p></p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#5-adding-remote-signal-tap-logic-analyzer-to-debug-the-afu","title":"5. Adding Remote Signal Tap Logic Analyzer to debug the AFU","text":"<p>Remote Signal Tap is currently not supported in F2000x base FIM configuration.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#6-how-to-modify-the-pfvf-mux-configuration","title":"6. How to modify the PF/VF MUX configuration","text":"<p>For information on how to modify the PF/VF mapping for your own design, refer to the FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae SoC Attach FPGAs.</p>"},{"location":"hw/f2000x/dev_guides/afu_dev/ug_dev_afu_ofs_f2000x/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/","title":"Intel\u00ae FPGA Interface Manager Developer Guide: Intel Agilex SoC Attach: Open FPGA Stack","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#1-introduction","title":"1 Introduction","text":""},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#11-about-this-document","title":"1.1 About This Document","text":"<p>This document serves as a design guide for FPGA developers, system architects, and hardware developers using Open FPGA Stack (OFS) as a starting point for the creation of an FPGA Interface Manager (FIM) for a custom FPGA acceleration board.   </p> <p>OFS addresses the demand for FPGA acceleration boards and workloads by providing a powerful methodology for the rapid development of FPGA Acceleration systems.  This methodology addresses the challenges and responsibilities of the board, platform, and workload developers by providing a complete FPGA project consisting of RTL and simulation code, build scripts, and software.  This provided FPGA project can be rapidly customized to meet new market requirements.</p> <p>OFS separates the FPGA design into two areas: FPGA Interface Manager (FIM) and workload (or Acceleration Function Unit) as shown in the figure below:</p> <p></p> <p>As can be seen in this diagram, the OFS FPGA structure has a natural separation into two distinct areas: </p> <ul> <li>FPGA Interface Manager (FIM or sometimes called the \"the shell\") containing:<ul> <li>FPGA external interfaces and IP cores (e.g. Ethernet, DDR-4, PCIe, etc)</li> <li>PLLs/resets</li> <li>FPGA - Board management infrastructure</li> <li>Interface to Acceleration Function Unit (AFU)</li> </ul> </li> <li>Acceleration Function Unit (\"the workload\")<ul> <li>Uses the FIM interfaces to perform useful work inside the FPGA</li> <li>Contains logic supporting partial reconfiguration</li> <li>Remote Signal Tap core for remote debugging of workload</li> </ul> </li> </ul> <p>This guide is organized as follows: </p> <ul> <li>Introduction</li> <li>Top Level Block Diagram description<ul> <li>Control and data flow</li> </ul> </li> <li>Description of Sub-systems<ul> <li>Command/status registers (CSR) and software interface</li> <li>Clocking, resets, and interfaces</li> <li>High-Speed Serial Interface Sub-System (HSSI-SS) - also known as the Ethernet Sub-System</li> <li>External Memory Interface Sub-System (MEM-SS)</li> </ul> </li> <li>High-level development flow description<ul> <li>Installation of OFS RTL and development packages</li> <li>Compiling FIM</li> <li>Simulation  </li> </ul> </li> <li>Design customization walkthroughs</li> </ul> <p>This document uses the  Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL as the main example platform to illustrate key points and demonstrate how to extend the capabilities provided in OFS.  The demonstration steps serve as a tutorial for the development of your OFS knowledge.  </p> <p>This document covers OFS architecture lightly. For more details on the OFS architecture, please see Open FPGA Stack Technical Reference Manual.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#12-release-capabilities","title":"1.2 Release Capabilities","text":"<p>Agilex SoC Attach OFS supports the following features.</p> FIM BASE Intel IPU Platform F2000X-PL f2000x PCIe Configuration Host: PCIe Gen4x16SoC: PCIe Gen4x16 SR-IOV support Host: 2 PFs, No VFsSoC:  1 PFs, 3 VFs AXI ST datapath 512b @ 470MHz Transceiver Subsystem Configuration 2x4x25G <p>The FIM also integrates:</p> <ul> <li>SoC AFU and Host AFU</li> <li>Exercisers demonstrating PCIe, external memory, and Ethernet interfaces</li> <li>FME CSR</li> <li>Remote Signal Tap</li> <li>Partial Reconfiguration</li> </ul> <p>The Host exercisers are provided for the quick evaluation of the FIM and can be leveraged for the verification of the platform's functionality and capabilities.  The host exercisers can be removed by the designer to release FPGA real estate to accommodate new workload functions. To compile the FIM without host exercisers go to How to compile the FIM in preparation for designing your AFU.</p> <p>OFS is extensible to meet the needs of a broad set of customer applications.  The general use cases listed below are examples where the OFS base design is easily extended to build a custom FIM:</p> <ol> <li>Use OFS design example as-is<ul> <li>Porting the code to another platform that is identical to OFS reference platform changing targeted FPGA device and pinout</li> <li>Change I/O assignments without changing design</li> </ul> </li> <li>Update the configuration of peripheral IP in OFS design example, not affecting FIM architecture<ul> <li>External memory settings</li> <li>Ethernet Subsystem analog settings</li> </ul> </li> <li>Remove/update peripheral feature in OFS design example, not affecting FIM architecture<ul> <li>External memory speed/width change</li> <li>Change number of VFs supported</li> </ul> </li> <li>Add new features as an extension to OFS design example, not affecting the FIM architecture<ul> <li>Add/remove external memory interface to the design</li> <li>Add/remove user clocks for the AFU</li> <li>Add/remove IP to the design with connection to the AFU</li> </ul> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#13-knowledge-prerequisites","title":"1.3 Knowledge Prerequisites","text":"<p>OFS is an advanced application of FPGA technology. This guide assumes you have the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows using Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1.</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on timing critical paths.</li> <li>RTL (System Verilog) and coding practices to create synthesized logic.</li> <li>RTL simulation tools.</li> <li>Intel\u00ae Quartus\u00ae Prime Pro Edition Signal Tap Logic Analyzer tool software.</li> </ul>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#2-top-level-description","title":"2 Top Level Description","text":"<p>The FIM targets operation in the  Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL the block diagram is shown below.  </p> <p></p> <ul> <li>Host interface <ul> <li>PCIe Gen4 x 16</li> </ul> </li> <li>SoC Interface<ul> <li>PCIe Gen4 x 16</li> </ul> </li> <li>Network interface<ul> <li>2 - QSFP28/56 cages</li> <li>Eight Arm\u00ae AMBA\u00ae 4 AXI4-Stream channels of 25G Ethernet interfacing to an E-tile Ethernet Subsystem.</li> </ul> </li> <li>External Memory - DDR4<ul> <li>Four Fabric DDR4 banks, 1200 MHz, 4GB, x32 no ECC (optionally can be configured x40 with ECC or x8 no ECC)</li> </ul> </li> <li>Board Management<ul> <li>SPI interface</li> <li>FPGA configuration</li> </ul> </li> </ul>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#21-top-level-fpga","title":"2.1 Top Level FPGA","text":"<p>The internal FPGA architecture is shown below:</p> <p></p> <p>The following Platform Designer IP subsystems are used to implement the following:</p> <ul> <li>P-tile PCIe Subsystem</li> <li>E-Tile Ethernet Subsystem</li> <li>Memory Subsystem</li> </ul> <p>Documentation on the above Platform Designer IP subsystems is available by request to your Intel support team.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#22-fim-fpga-resource-usage","title":"2.2 FIM FPGA Resource Usage","text":"<p>The provided design includes both required board management and control functions as well as optional interface exerciser logic that both creates transactions and validates operations.  These exerciser modules include:</p> <ul> <li>HE_MEM - this module creates external memory transactions to the DDR4 memory and then verifies the responses.</li> <li>HE_MEM-TG -The memory traffic generator (TG) AFU provides a way for users to characterize local memory channel bandwidth with a variety of traffic configuration features including request burst size, read/write interleave count, address offset, address strobe, and data pattern.</li> <li>HE_HSSI - this module creates ethernet transactions to the HSSI Subsystem and then verifies the responses.</li> </ul> <p>The FIM uses a small portion of the available FPGA resources.  The table below shows resource usage for a base FIM built with 2 channels of external memory, a small AFU instantiated that has host CSR read/write, external memory test and Ethernet test functionality.</p> <p>Note: The host exerciser modules allow you to evaluate the FIM in hardware and are removed when you begin development. </p> <p>The AGFC023R25A2E2VR0  FPGA has the following resources available for base FIM design :</p> Resource needed / total on device (%) Logic utilization (ALMs) 229,622 / 782,400 ( 29 % ) M20K blocks 1,241 / 10,464 (12 %) Pins 518 / 742 ( 70 % ) IOPLLs 10 / 15 ( 67 % ) <p>The resource usage for the FIM base:</p> Entity Name ALMs needed ALM Utilization % M20Ks M20K Utilization % top 229,646.10 29.35 1241 11.86 soc_afu 87,364.80 11.17 273 2.61 soc_pcie_wrapper 37,160.80 4.75 195 1.86 pcie_wrapper 36,233.40 4.63 187 1.79 host_afu 26,462.20 3.38 140 1.34 hssi_wrapper 20,066.30 2.56 173 1.65 pmci_wrapper 8,449.90 1.08 186 1.78 mem_ss_top 7,907.10 1.01 60 0.57 auto_fab_0 2,708.90 0.35 13 0.12 soc_bpf 1,210.20 0.15 0 0.00 qsfp_1 635.50 0.08 4 0.04 qsfp_0 628.70 0.08 4 0.04 fme_top 628.60 0.08 6 0.06 host_soc_rst_bridge 151.40 0.02 0 0.00 rst_ctrl 16.80 0.00 0 0.00 soc_rst_ctrl 16.50 0.00 0 0.00 sys_pll 0.50 0.00 0 0.00 <p>The following example without the he_lb,he_hssi,he_mem,he_mem_tg:</p> Entity Name ALMs needed ALM Utilization % M20Ks M20K Utilization % top 162,010.20 20.71 992 9.48 pcie_wrapper 36,771.70 4.70 195 1.86 soc_afu_top 34,851.30 4.45 85 0.81 pcie_wrapper 33,358.90 4.26 175 1.67 hssi_wrapper 20,109.90 2.57 173 1.65 afu_top 14,084.20 1.80 91 0.87 pmci_wrapper 8,447.90 1.08 186 1.78 mem_ss_top 8,379.70 1.07 60 0.57 alt_sld_fab_0 2,725.10 0.35 13 0.12 bpf_top 1,213.00 0.16 0 0.00 fme_top 638.30 0.08 6 0.06 qsfp_top 626.70 0.08 4 0.04 qsfp_top 619.20 0.08 4 0.04 axi_lite_rst_bridge 147.40 0.02 0 0.00 rst_ctrl 17.40 0.00 0 0.00 rst_ctrl 15.90 0.00 0 0.00 sys_pll 0.50 0.00 0 0.00 <p>The following example without the Ethernet Subsystem (no_hssi):</p> Entity Name ALMs needed ALM Utilization % M20Ks M20K Utilization % top 189,827.00 24.26 980 9.37 soc_afu_top 67,751.40 8.66 197 1.88 pcie_wrapper 36,909.30 4.72 195 1.86 pcie_wrapper 36,077.70 4.61 187 1.79 afu_top 26,549.40 3.39 140 1.34 pmci_wrapper 8,688.10 1.11 186 1.78 mem_ss_top 8,079.00 1.03 60 0.57 alt_sld_fab_0 1,751.90 0.22 9 0.09 bpf_top 1,186.00 0.15 0 0.00 dummy_csr 664.70 0.08 0 0.00 dummy_csr 662.80 0.08 0 0.00 dummy_csr 661.20 0.08 0 0.00 fme_top 649.40 0.08 6 0.06 axi_lite_rst_bridge 161.70 0.02 0 0.00 rst_ctrl 16.30 0.00 0 0.00 rst_ctrl 16.00 0.00 0 0.00 sys_pll 0.50 0.00 0 0.00 <p>The following example without the Ethernet Subsystem (no_hssi) + no host exercisers (he_lb, he_hssi, he_mem, he_mem_tg):</p> Entity Name ALMs needed ALM Utilization % M20Ks M20K Utilization % top 139,105.70 17.78 807 7.71 pcie_wrapper 36,518.80 4.67 195 1.86 pcie_wrapper 33,234.50 4.25 175 1.67 soc_afu_top 32,700.00 4.18 85 0.81 afu_top 14,178.20 1.81 91 0.87 pmci_wrapper 8,693.20 1.11 186 1.78 mem_ss_top 7,999.00 1.02 60 0.57 alt_sld_fab_0 1,758.40 0.22 9 0.09 bpf_top 1,183.50 0.15 0 0.00 dummy_csr 667.20 0.09 0 0.00 dummy_csr 666.30 0.09 0 0.00 dummy_csr 663.10 0.08 0 0.00 fme_top 652.80 0.08 6 0.06 axi_lite_rst_bridge 153.80 0.02 0 0.00 rst_ctrl 18.20 0.00 0 0.00 rst_ctrl 16.50 0.00 0 0.00 sys_pll 0.50 0.00 0 0.00"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#3-description-of-sub-systems","title":"3 Description of Sub-Systems","text":""},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#31-host-control-and-data-flow","title":"3.1 Host Control and Data Flow","text":"<p>The host control and data flow is shown in the diagram below:</p> <p></p> <p>The control and data paths are composed of the following:</p> <ul> <li>Host Interface Adapter (PCIe)</li> <li>SoC Interface Adapter (PCIe)</li> <li>Low Performance Peripherals<ul> <li>Slow speed peripherals (JTAG, I2C, Smbus, etc)</li> <li>Management peripherals (FME)</li> </ul> </li> <li>High Performance Peripherals<ul> <li>Memory peripherals</li> <li>Acceleration Function peripherals (eg. AFUs)</li> <li>HPS Peripheral</li> </ul> </li> <li>Fabrics<ul> <li>Peripheral Fabric (multi drop)</li> <li>AFU Streaming fabric (point to point)</li> </ul> </li> </ul> <p>Peripherals are connected to one another using AXI, either:</p> <ul> <li>Via the peripheral fabric (AXI4-Lite, multi drop)</li> <li>Via the AFU streaming fabric (AXI-S, point to point)</li> </ul> <p>Peripherals are presented to software as:</p> <ul> <li>OFS managed peripherals that implement DFH CSR structure.  </li> <li>Native driver managed peripherals (i.e. Exposed via an independent PF, VF)</li> </ul> <p>The peripherals connected to the peripheral fabric are primarily Intel OPAE managed resources, whereas the peripherals connected to the AFU are \u201cprimarily\u201d managed by native OS drivers. The word \u201cprimarily\u201d is used since the AFU is not mandated to expose all its peripherals to Intel OPAE. </p> <p>OFS uses a defined set of CSRs to expose the functionality of the FPGA to the host software.  These registers are described in Open FPGA Stack Reference Manual - MMIO Regions section.</p> <p>If you make changes to the FIM that affect the software operation, then OFS provides a mechanism to communicate that information to the proper software driver that works with your new hardware.  The Device Feature Header (DFH) structure is followed to provide compatibility with OPAE software.  Please see FPGA Device Feature List (DFL) Framework Overview for a description of DFL operation from the driver perspective.</p> <p>In the default design, the SoC and Host AFUs are isolated from each other. You must develop mechanisms for Host - SoC communication if desired.</p> <p>Note: The default configuration of the Board Peripheral Fabric, there is a connection from the Host Interface to the PMCI-SS, however the PMCI-SS is not in the Host DFL, and is not discovered by Host SW by default. If you want to guarantee that the Host can not access the PMCI-SS, and by extension the Board BMC, you must implement a filtering mechanism, for example, in the Host ST2MM module to prevent access to the PMCI-SS address space.</p> <p>Refer to the following documents for more information on sub-systems:</p> <ul> <li>Intel FPGA PCI Express Subsystem IP User Guide</li> <li>Intel FPGA Memory Subsystem IP User Guide</li> <li>Intel FPGA Ethernet Subsystem IP User Guide</li> </ul>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#4-high-level-development-flow","title":"4 High Level Development Flow","text":"<p>OFS provides a framework of FPGA synthesizable code, simulation environment, and synthesis/simulation scripts.  FIM designers can use the provided code as-is, modify the provided code, or add new code to meet your specific product requirements. The instructions provided after this point are for you to either evaluate the existing design (the current section) or to modify and generate your own design (described in the Custom FIM Development Flow section). </p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#41-development-pre-requisites","title":"4.1 Development Pre-requisites","text":"<p>The following pre-requisites must be satisfied to go through the development flow.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#411-tutorial-pre-requisites","title":"4.1.1 Tutorial Pre-requisites","text":"<p>To run the FPGA compilation steps covered in this guide, requires the following:</p> <ol> <li>Workstation or server with a Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1 installed on a Intel Quartus Prime Pro-supported Linux distribution.  See Operating System Support.  The Linux distribution known to work with this version of Ubuntu 22.04 . Note, Windows is not supported.</li> <li>Compilation targeting Agilex devices requires a minimum of 64 GB of RAM.</li> <li>Simulation of lower level functionality (not chip level) is supported by Synopsys\u00ae VCS and Mentor Graphics\u00ae QuestaSim SystemVerilog simulators.</li> <li>Simulation of chip level requires Synopsys VCS and VIP</li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#412-development-environment","title":"4.1.2 Development Environment","text":"<p>To run the tutorial steps in this guide requires this development environment:</p> Item Version Intel Quartus Prime Pro 23.1 OPAE SDK Branch Tag: release/2.5.0 Simulator Synopsys VCS P-2019.06-SP2-5 or newer for UVM simulation of top level FIM Python 3.7.7 GCC 7.2.0 cmake 3.11.4 git with git-lfs 1.8.3.1 PERL 5.8.8 <p>Note: Steps to install Intel Quartus Prime Pro are provided in the Installation of OFS section.</p> <p>To install the <code>Git Large File Storage (LFS)</code> extension run the following commands:</p> <pre><code>curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash\nsudo dnf install git-lfs\ngit lfs install\n</code></pre> <p>To test FPGA image files on hardware, this version of OFS only targets  Intel IPU Platform F2000X-PL. You may modify the build scripts and pin files to target different boards with Agilex FPGA devices.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#42-installation-of-ofs","title":"4.2 Installation of OFS","text":"<p>In this section you set up a development machine for compiling the OFS FIM. These steps are separate from the setup for a deployment machine where the FPGA acceleration card is installed.  Typically, FPGA development and deployment work is performed on separate machines, however, both development and deployment can be performed on the same server if desired.  Please see the Getting Started Guide: Intel\u00ae Open FPGA Stack for Intel FPGA for instructions on installing software for deployment of your FPGA FIM, AFU and software application on a server.  </p> <p>Building the OFS FIM requires the build machine to have at least 64 GB of RAM.  </p> <p>The following is a summary of the steps to set up for FIM development:</p> <ol> <li>Install Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1 Linux with Agilex device support</li> <li>Make sure support tools are installed and meet version requirements</li> <li>Clone the  repository</li> <li>Install required Intel Quartus Prime Pro patches which are included in the cloned <code>ofs-f2000x</code> repository</li> <li>Review the files provided in the repo</li> <li>Test installation by building the FIM</li> </ol> <p>Intel\u00ae Quartus\u00ae Prime Pro Edition Version 23.1 is the currently verified version of Intel Quartus Prime Pro used for building the FIM and AFU images.  Porting to newer versions of Intel Quartus Prime Pro may be performed by developers, however, you will need to verify operation.</p> <p>The recommended Best Known Configuration (BKC) for development of the OFS FIM is Ubuntu 22.04, which is the assumed operating system for this developer guide. </p> <ol> <li> <p>Prior to installing Intel Quartus Prime Pro, perform the following steps to satisfy the required dependencies.</p> <pre><code>sudo dnf install -y gcc gcc-c++ make cmake libuuid-devel rpm-build autoconf automake bison boost boost-devel libxml2 libxml2-devel make ncurses grub2 bc csh flex glibc-locale-source libnsl ncurses-compat-libs </code></pre> </li> <li> <p>Apply the following configurations.</p> <pre><code>sudo localedef -f UTF-8 -i en_US en_US.UTF-8 sudo ln -s /usr/lib64/libncurses.so.6 /usr/lib64/libncurses.so.5 sudo ln -s /usr/bin/python3 /usr/bin/python\n</code></pre> </li> <li> <p>Download Intel\u00ae Quartus\u00ae Prime Pro Edition Linux.</p> </li> <li> <p>After running the Quartus Prime Pro installer, set the PATH environment variable to make utilities <code>quartus</code>, <code>jtagconfig</code>, and <code>quartus_pgm</code> discoverable. Edit your bashrc file <code>~/.bashrc</code> to add the following line:</p> <pre><code>export PATH=&lt;Quartus install directory&gt;/quartus/bin:$PATH\nexport PATH=&lt;Quartus install directory&gt;/qsys/bin:$PATH\n</code></pre> <p>For example, if the Intel Quartus Prime Pro install directory is /home/intelFPGA_pro/23.1 then the new line is:</p> <pre><code>export PATH=/home/intelFPGA_pro/23.1/quartus/bin:$PATH\nexport PATH=/home/intelFPGA_pro/23.1/qsys/bin:$PATH\n</code></pre> </li> <li> <p>Verify, Intel Quartus Prime Pro is discoverable by opening a new shell:</p> <pre><code>which quartus\n</code></pre> <p>Example output:   <pre><code>/home/intelFPGA_pro/23.1/quartus/bin/quartus\n</code></pre></p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#421-clone-the-ofs-git-repo","title":"4.2.1 Clone the OFS Git Repo","text":"<p>Retrieve the OFS FIM source code from the OFS f2000x FIM Github Branch repository. Create a new directory to use as a clean starting point to store the retrieved files.  The following is a short description of each repository, followed by the git commands for cloning.  The instructions section uses the HTTPS git method for cloning repositories.</p> <ol> <li> <p>Navigate to the location you want to clone the OFS source files, and create the top-level source directory.</p> <pre><code>mkdir IOFS_BUILD_ROOT\n</code></pre> </li> <li> <p>Clone OFS repositories.</p> <pre><code>cd IOFS_BUILD_ROOT\ngit clone --recurse-submodules https://github.com/OFS/ofs-f2000x-pl\n</code></pre> </li> <li> <p>Checkout the proper tag</p> <pre><code>cd ofs-f2000x-pl\ngit checkout --recurse-submodules tags/ofs-2023.1-1\n</code></pre> </li> <li> <p>Ensure that <code>ofs-common</code> has been cloned as well</p> <pre><code>git submodule status\n</code></pre> <p>Example output:</p> <pre><code>ea585a4f48d50faf3ae7ecfbec82525a8d22c730 ofs-common (ofs-2023.1-1)\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#43-directory-structure-of-ofs","title":"4.3 Directory Structure of OFS","text":"<p>List the directory contents of the cloned repo to verify that the following directories and files are present in <code>$IOFS_BUILD_ROOT/ofs-f2000x</code> directory.  </p> <p><pre><code>ls -1\n</code></pre> Expected output: <pre><code>external\nipss\nLICENSE.txt\nofs-common\nsim\nsrc\nsyn\ntools\nverification\n</code></pre></p> <p>Use the following command to show how the directories are arranged:</p> <p><pre><code>find . -mindepth 1 -maxdepth 2 -type d -not -path '*/\\.*' -print | sed -e 's/[^-][^\\/]*\\//--/g' -e 's/--/|  /g' -e 's/|-/|   /g'\n</code></pre> Expected output:</p> <pre><code>|  eval_scripts\n|  | |  ipss\n|  |  hssi\n|  |  mem\n|  |  pcie\n|  |  pmci\n|  |  qsfp\n|  ofs-common\n|  |  scripts\n|  |  src\n|  |  tools\n|  |  verification\n|  sim\n|  |  bfm\n|  |  common\n|  |  scripts\n|  |  unit_test\n|  src\n|  |  afu_top\n|  |  includes\n|  |  pd_qsys\n|  |  top\n|  syn\n|  |  scripts\n|  |  setup\n|  |  syn_top\n|  tools\n|  |  pfvf_config_tool\n|  verification\n|  |  scripts\n|  |  testbench\n|  |  tests\n|  |  unit_tb\n|  |  verifplan\n</code></pre>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#44-compiling-the-ofs-fim","title":"4.4 Compiling the OFS FIM","text":"<p>OFS provides a build script with the following FPGA image creation options:</p> <ul> <li>Flat compile which combines the FIM and AFU into one FPGA image that is loaded into the entire FPGA device</li> <li>A PR compile which creates a FPGA image consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. The AFU image may be loaded into the dynamic region using partial reconfiguration.  </li> </ul> <p>The build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested. The full build script typically takes around 3 hours to complete.</p> <p>The build script flow is the primary flow described in this user guide. For instructions on compiling using the Intel Quartus Prime Pro GUI, refer to the Compiling the OFS FIM Using Quartus GUI section.</p> <p>The following sections describe how to set up the environment and build the provided FIM and AFU. Follow these steps as a tutorial to learn the build flow.  You will use this environment and build scripts for the creation of your specialized FIM.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#441-setting-up-required-environment-variables","title":"4.4.1. Setting Up Required Environment Variables","text":"<p>Set required environment variables as shown below.  These environment variables must be set prior to simulation or compilation tasks so creating a simple script to set these variables saves time. </p> <p>Set the following environment variables based on your environment: <pre><code>export QUARTUS_MAINPATH=/&lt;YOUR_QUARTUS_DIRECTORY&gt;/23.1 export TOOLS_LOCATION=&lt;YOUR_TOOLS_DIRECTORY&gt; export LM_LICENSE_FILE=&lt;YOUR_LM_LICENSE_PATH&gt;\nexport DW_LICENSE_FILE=&lt;YOUR_DW_LICENSE_PATH&gt;\nexport SNPSLMD_LICENSE_FILE=&lt;YOUR_SNPSLMD_LICENSE_PATH&gt;\n</code></pre></p> <p>Note: The TOOLS_LOCATION directory is where the Synopsis tools reside. Refer to the <code>UVM_HOME</code> variable below for an example.</p> <p>Then set the remaining environment variables: <pre><code>export QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus export QUARTUS_HOME=$QUARTUS_ROOTDIR export QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR export QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR export IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip export IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip export INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld export QSYS_ROOTDIR=$QUARTUS_ROOTDIR/../qsys/bin export IOFS_BUILD_ROOT=$PWD\nexport OFS_ROOTDIR=$IOFS_BUILD_ROOT/ofs-f2000x\nexport WORKDIR=$OFS_ROOTDIR export VERDIR=$OFS_ROOTDIR/verification/ofs-f2000x/common:$OFS_ROOTDIR/verification export OFS_PLATFORM_AFU_BBB=$IOFS_BUILD_ROOT/ofs-platform-afu-bbb export OPAE_SDK_REPO_BRANCH=release/$OPAE_SDK_VERSION\nexport OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_dir/build_tree    export LIBRARY_PATH=$IOFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib export LD_LIBRARY_PATH=$IOFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib64 export OPAE_LOC=/install-opae-sdk export PYTHONPATH=/root/.local/lib/python3.7.7/site-packages/ export QUARTUS_NUM_PARALLEL_PROCESSORS=8 export DESIGNWARE_HOME=$TOOLS_LOCATION/synopsys/vip_common/vip_Q-2020.03A\nexport UVM_HOME=$TOOLS_LOCATION/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm export VCS_HOME=$TOOLS_LOCATION/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel export MTI_HOME=$TOOLS_LOCATION/intelFPGA_pro/questa_fse export PATH=$PATH:$QUARTUS_HOME/bin:$QUARTUS_HOME/qsys/bin:$QUARTUS_HOME/sopc_builder/bin/:$IOFS_BUILD_ROOT/opae-sdk/install-opae-sdk/bin:$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$DESIGNWARE_HOME/bin:$VCS_HOME/bin\n</code></pre></p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#442-compiling-the-fim","title":"4.4.2 Compiling the FIM","text":"<p>The f2000x  FIM build flow uses the bash script <code>$OFS_ROOTDIR/ofs-common/scripts/common/syn/build_top.sh</code>.  There are several setup files that must be put in place before compilation, which is handled by the build script. If you wish to compile the f2000x FIM using the Intel Quartus Prime Pro GUI, you must at least run the setup portion of the <code>build_top.sh</code> script before compiling with the GUI. For instructions on compiling the FIM using the Quartus GUI, refer to the Compiling the OFS FIM Using Quartus GUI section.</p> <p>The usage of the compile build script is shown below: <pre><code>ofs-common/scripts/common/syn/build_top.sh/build_top.sh [-p] f2000x[:OPTIONS]  work_dir </code></pre></p> <p>Note: Refer to the $OFS_ROOTDIR/ofs-common/scripts/common/syn/README for detailed information on using this script</p> <ul> <li>To build the provided design using a flat, non-PR build flow use the following commands:<pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh f2000x:flat  work_dir\n</code></pre> </li> </ul> <ul> <li>To build the provided design with in-tree PR enabled use the following commands:<pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh f2000x work_dir\n</code></pre> </li> </ul> <ul> <li>To build the provided design with a relocatable (out-of-tree) PR directory use the following commands:<pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh -p f2000x work_dir\n</code></pre> <p>Refer to the Create a Relocatable PR Directory Tree section for more information on out-of-tree PR builds.</p> </li> </ul> <p>The build takes ~3 hours to complete. A successful build will report the following:</p> <pre><code>Compile work directory:     &lt;$IOFS_BUILD_ROOT&gt;/ofs-f2000x/work_f2000x /syn/syn_top\nCompile artifact directory: &lt;$IOFS_BUILD_ROOT&gt;/ofs-f2000x/work_f2000x /syn/syn_top/output_files\n\n***********************************\n***\n***        OFS_PROJECT: f2000x ***        OFS_FIM: base\n***        OFS_BOARD: adp\n***        Q_PROJECT:  ofs_top\n***        Q_REVISION: ofs_top\n***        SEED: 0\n***        Build Complete\n***        Timing Passed!\n***\n***********************************\n</code></pre> <p>The build script copies the <code>ipss</code>, <code>ofs-common</code>, <code>sim</code>, <code>src</code>,<code>syn</code> and <code>tools</code> directories to the specified work directory and then these copied files are used in the Intel Quartus Prime Pro compilation process.</p> <p>Some key output directories are described in the following table:</p> Directory Description <code>$OFS_ROOTDIR/&lt;WORK_DIR&gt;/syn/syn_top</code> Intel Quartus Prime Pro project (ofs_top.qpf) and other Intel Quartus Prime Pro specific files <code>$OFS_ROOTDIR/&lt;WORK_DIR&gt;/syn/syn_top/output_files</code> Directory with build reports and FPGA programming files <p>The build script will run PACSign (if installed) and create an unsigned FPGA programming files for both user1 and user2 locations of the f2000x  FPGA flash.  Please note, if the f2000x  has the root entry hash key loaded, then PACsign must be run to add the proper key to the FPGA binary file.</p> <p>The following table provides a detailed description of the generated *.bin files.</p> File Description ofs_top.bin This is an intermediate, raw binary file. This intermediate raw binary file is produced by taking the Intel Quartus Prime Pro generated *.sof file, and converting it to *.pof using quartus_pfg, then converting the *.pof to *.hexout using quartus_cpf, and finally converting the *.hexout to *.bin using objcopy. <code>ofs_top.bin</code> - Raw binary image of the FPGA. ofs_top_page0_unsigned_factory.bin This is the unsigned PACSign output generated for the Factory Image. Unsigned means that the image has been signed with an empty header. ofs_top_page1_user1.bin This is an input file to PACSign to generate <code>ofs_top_page1_unsigned_user1.bin</code>. This file is created by taking the ofs_top.bin file and assigning the User1 or appending factory block information. Unsigned means that the image has been signed with an empty header. ofs_top_page1_unsigned_user1.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User1 Image. This file is used to load the FPGA flash User1 Image using the fpgasupdate tool. Unsigned means that the image has been signed with an empty header. ofs_top_page2_user2.bin This is an input file to PACSign to generate <code>ofs_top_page2_unsigned_user2.bin</code>. This file is created by taking the <code>ofs_top.bin</code> file and assigning the User2 or appending factory block information. ofs_top_page2_unsigned_user2.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User2 Image. This file is used to load the FPGA flash User2 Image using the fpgasupdate tool. Unsigned means that the image has been signed with an empty header. ofs_top.sof This image is used to generate <code>ofs_top.bin</code>, and can also be used to program the Agilex device directly through JTAG <p>Note: The <code>build/output_files/timing_report</code> directory contains clocks report, failing paths and passing margin reports. </p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#443-create-a-relocatable-pr-directory-tree-from-the-base_x16-fim","title":"4.4.3 Create a Relocatable PR Directory Tree from the base_x16 FIM","text":"<p>If you are developing a FIM to be used by another team developing AFU workload(s), scripts are provided that create a relocatable PR directory tree. ODM and board developers will make use of this capability to enable a broad set of AFUs to be loaded on a board using PR.</p> <p>You can create this relocatable PR directory tree by either:</p> <ul> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh followed by running /ofs-common/scripts/common/syn/generate_pr_release.sh</li> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh with optional -p switch included</li> </ul> <p>The generate_pr_release.sh has the following command structure:</p> <p><pre><code>ofs-common/scripts/common/syn/generate_pr_release.sh -t &lt;work_directory&gt;/build_tree &lt;target_board&gt; &lt;work_directory&gt;\n</code></pre> Where:</p> <ul> <li><code>&lt;work_directory&gt;/build_tree</code> is the location for your relocatable PR directory tree in the work directory</li> <li><code>&lt;target_board&gt;</code> is the name of the board target/FIM e.g. f2000x </li> <li><code>&lt;work_directory&gt;</code> is the work directory</li> </ul> <p>Here is an example of running the generate_pr_release.sh script:</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/generate_pr_release.sh -t work_f2000x/build_tree f2000x   work_f2000x </code></pre> <p>The resulting relocatable build tree has the following structure:</p> <p><pre><code>.\n\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_synth\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 build_env_config\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 run.sh -&gt; afu_synth\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 update_pim\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 blue_bits\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_top_page0_unsigned_factory.bin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_top_page1_unsigned_user1.bin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_top_page2_unsigned_user2.bin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_top.sof -&gt; ../lib/build/syn/syn_top/output_files/ofs_top.sof\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 lib\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 build\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 fme-ifc-id.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 fme-platform-class.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 platform\n\u2514\u2500\u2500 README\n</code></pre> This build tree can be moved to a different location and used for AFU development of PR-able AFU to be used with this board.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#444-compiling-the-ofs-fim-using-quartus-gui","title":"4.4.4 Compiling the OFS FIM Using Quartus GUI","text":"<p>Perform the following steps to compile the OFS FIM using the Quartus GUI:</p> <ol> <li> <p>Set the environment variables as described in the Setting Up Required Environment Variables section.</p> </li> <li> <p>Run the setup portion of the build script. This takes a few seconds to complete.</p> <pre><code>./ofs-common/scripts/common/syn/build_top.sh --stage setup f2000x work_dir\n</code></pre> </li> <li> <p>Open the OFS FIM project using the Intel Quartus Prime Pro GUI. The project is located at <code>$OFS_ROOTDIR/work_dir/syn/syn_top/ofs_top.qpf</code>.</p> </li> <li> <p>Ensure the checkbox next to Assembler (Generate programming files) is marked.</p> </li> <li> <p>Click the arrow next to Compile Design in the Compilation Flow window to start full compilation.</p> </li> <li> <p>After compilation is complete, check the <code>$OFS_ROOTDIR/work_dir/syn/syn_top/output_files</code> directory. This directory will contain the output SOF image generated by Quartus, named <code>ofs_top.sof</code>.</p> </li> <li> <p>Run the finish portion of the build script. This will generate the images that can be programmed to f2000x FPGA flash. Use the optional <code>-p</code> argument to create an out-of-tree PR build.</p> <pre><code>./ofs-common/scripts/common/syn/build_top.sh --stage finish f2000x work_dir\n</code></pre> </li> <li> <p>Check the <code>$OFS_ROOTDIR/work_dir/syn/syn_top/output_files</code> directory again to see that all output files have been generated.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#45-unit-level-simulation","title":"4.5 Unit Level Simulation","text":"<p>Unit level simulation of key components in the FIM is provided. These simulations provide verification of the following areas:</p> <ul> <li>Ethernet</li> <li>PCIe</li> <li>External Memory</li> <li>Core FIM</li> </ul> <p>The Unit Level simulations work with Synopsys VCS-MX or Mentor Graphics Questasim simulators. Readme files are provided explaining how to run the simulation of each component. </p> <p>The scripts to run the unit level simulations are located in <code>$OFS_ROOTDIR/sim/unit_test</code>, which contains subdirectories <code>soc_tests</code> and <code>host_tests</code>. The table below lists the tests that are provided.</p> Test Type Test Name SoC Tests csr_test dfh_walker flr he_lb_test he_mem_test hssi_kpi_test hssi_test mem_ss_csr_test mem_ss_rst_test mem_tg_test pf_vf_access_test qsfp_test regress_run.py Host Tests csr_test he_lb_test pcie_csr_test pf_vf_access_test pmci_csr_test pmci_mailbox_test pmci_rd_default_value_test pmci_ro_mailbox_test pmci_vdm_b2b_drop_err_scenario_test pmci_vdm_len_err_scenario_test pmci_vdm_mctp_mmio_b2b_test pmci_vdm_multipkt_error_scenario_test pmci_vdm_multipkt_tlp_err_test pmci_vdm_tlp_error_scenario_test pmci_vdm_tx_rx_all_random_lpbk_test pmci_vdm_tx_rx_all_toggle_test pmci_vdm_tx_rx_lpbk_test regress_run.py"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#451-run-comprehensive-unit-tests","title":"4.5.1 Run Comprehensive Unit Tests","text":"<p>The <code>regress_run.py</code> script is provided to automatically run all unit tests for either the SoC or the Host. Note that running all tests will take around three hours for the SoC tests and around 2.5 hours for the Host tests to complete.</p> <p>Perform the following steps to run comprehensive tests:</p> <ol> <li>Set the environment variables as described in the Setting Up Required Environment Variables section.</li> <li> <p>Navigate to the test directory you wish to run from.</p> <ul> <li>SoC Tests<pre><code>cd $OFS_ROOTDIR/sim/unit_test/soc_tests\n</code></pre> </li> </ul> <ul> <li>Host Tests<pre><code>cd $OFS_ROOTDIR/sim/unit_test/host_tests\n</code></pre> </li> </ul> </li> <li> <p>Run the tests with the <code>regress_run.py</code>. Use the <code>-h</code> argument to display the help menu.</p> <p>For example, to run all tests locally, using VCS, with 8 processors:</p> <pre><code>python regress_run.py -l -n 8 -k all -s vcs\n</code></pre> </li> <li> <p>Once all tests have completed, the comprehensive test summary will be shown. The following is an example test summary after running the SoC tests:</p> <pre><code>2023-05-14 19:10:55,404: Passing Unit Tests:12/12 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n2023-05-14 19:10:55,404:    csr_test:......... PASS -- Time Elapsed:0:03:57.713154\n2023-05-14 19:10:55,404:    dfh_walker:....... PASS -- Time Elapsed:0:02:46.025067\n2023-05-14 19:10:55,404:    flr:.............. PASS -- Time Elapsed:0:03:26.289900\n2023-05-14 19:10:55,404:    he_lb_test:....... PASS -- Time Elapsed:0:06:41.142643\n2023-05-14 19:10:55,404:    he_mem_test:...... PASS -- Time Elapsed:1:39:01.824096\n2023-05-14 19:10:55,404:    hssi_kpi_test:.... PASS -- Time Elapsed:2:21:33.007328\n2023-05-14 19:10:55,404:    hssi_test:........ PASS -- Time Elapsed:2:16:36.821034\n2023-05-14 19:10:55,404:    mem_ss_csr_test:.. PASS -- Time Elapsed:0:38:45.836540\n2023-05-14 19:10:55,404:    mem_ss_rst_test:.. PASS -- Time Elapsed:0:40:51.065354\n2023-05-14 19:10:55,404:    mem_tg_test:...... PASS -- Time Elapsed:0:54:00.210146\n2023-05-14 19:10:55,404:    pf_vf_access_test: PASS -- Time Elapsed:0:03:25.561919\n2023-05-14 19:10:55,404:    qsfp_test:........ PASS -- Time Elapsed:0:39:29.192304\n2023-05-14 19:10:55,404: Failing Unit Tests: 0/12 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n2023-05-14 19:10:55,404: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n2023-05-14 19:10:55,404:       Number of Unit test results captured: 12\n2023-05-14 19:10:55,404:       Number of Unit test results passing.: 12\n2023-05-14 19:10:55,404:       Number of Unit test results failing.:  0\n2023-05-14 19:10:55,404:     End Unit regression running at date/time................: 2023-05-14 19:10:55.404641\n2023-05-14 19:10:55,404:     Elapsed time for Unit regression run....................: 2:22:39.310455\n</code></pre> </li> <li> <p>Output logs for each individual test are saved in the respective test's directory</p> <pre><code>$OFS_ROOTDIR/sim/unit_test/&lt;TEST_TYPE&gt;/&lt;TEST_NAME&gt;/&lt;SIMULATOR&gt;/transcript\n</code></pre> <p>For example, the log for the SoC DFH Walker test using VCS can be found in:</p> <pre><code>$OFS_ROOTDIR/sim/unit_test/soc_tests/dfh_walker/sim_vcs/transcript\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#452-run-individual-unit-tests","title":"4.5.2 Run Individual Unit Tests","text":"<p>The <code>run_sim.sh</code> scripts are provided to run individual unit tests for either the SoC or the Host. Before you can run any unit tests, you must generate the IP simulation files. Note that the <code>regress_run.py</code> script used for comprehensive testing does this step automatically. Perform the following steps to generate the IP simulation files:</p> <ol> <li>Set the environment variables as described in the Setting Up Required Environment Variables section.</li> <li>Generate the IP simulation files for all unit tests:<pre><code>cd `$OFS_ROOTDIR/ofs-common/scripts/common/sim`\nsh gen_sim_files.sh f2000x </code></pre> </li> </ol> <p>Next, perform the following steps to run individual tests:</p> <ol> <li> <p>Navigate to the directory of the test you wish to run</p> <pre><code>cd $OFS_ROOTDIR/sim/unit_test/&lt;TEST_TYPE&gt;/&lt;TEST_NAME&gt;\n</code></pre> <p>For example, to run the DFH walker test for the SoC:</p> <pre><code>cd $OFS_ROOTDIR/sim/unit_test/soc_tests/dfh_walker\n</code></pre> </li> <li> <p>Run the test with your desired simulator:</p> <ul> <li> <p>Using VCS</p> <pre><code>sh run_sim.sh\n</code></pre> </li> </ul> <ul> <li> <p>Using Questasim</p> <pre><code>sh run_sim.sh MSIM=1\n</code></pre> </li> </ul> <ul> <li> <p>Using VCS-MX</p> <pre><code>sh run_sim.sh VCSMX=1\n</code></pre> </li> </ul> </li> <li> <p>Once the test has completed, the test summary will be shown. The following is an example test summary after running the SoC DFH Walker Test:</p> <pre><code>Test status: OK\n\n********************\nTest summary\n********************\n   test_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n$finish called from file \"/home/applications.fpga.ofs.fim-f2000x-pl/sim/unit\n_test/scripts/../../bfm/rp_bfm_simple/tester.sv\", line 210.\n$finish at simulation time            355393750\nV C S   S i m u l a t i o n   R e p o r t\nTime: 355393750 ps\nCPU Time:     59.870 seconds;       Data structure size:  91.2Mb\nSun May 14 16:54:20 2023\n</code></pre> </li> <li> <p>The log for the test is stored in a transcript file in the simulation directory of the test that was run.</p> <pre><code>$OFS_ROOTDIR/sim/unit_test/&lt;TEST_TYPE&gt;/&lt;TEST_NAME&gt;/&lt;SIMULATOR&gt;/transcript\n</code></pre> <p>For example, the log for the SoC DFH Walker test using VCS can be found in:</p> <pre><code>$OFS_ROOTDIR/sim/unit_test/soc_tests/dfh_walker/sim_vcs/transcript\n</code></pre> <p>The simulation waveform database is saved as vcdplus.vpd for post simulation review. You are encouraged to run the additional simulation examples to learn about each key area of the OFS shell.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5-custom-fim-development-flow","title":"5 Custom FIM Development Flow","text":"<p>FIM development for a new acceleration card consists of the following steps:</p> <ol> <li>Installation of OFS and familiarization with scripts and source code</li> <li>Development of high level block diagram with your specific functionality<ol> <li>Determination of requirements and key performance metrics</li> <li>Selection of IP cores</li> <li>Selection of FPGA device</li> <li>Software memory map</li> </ol> </li> <li>Selection and implementation of FIM Physical interfaces including:<ol> <li>External clock sources and creation of internal PLL clocks</li> <li>General I/O</li> <li>Ethernet modules</li> <li>External memories</li> <li>FPGA programming methodology</li> </ol> </li> <li>Device physical implementation<ol> <li>FPGA device pin assignment</li> <li>Inclusion of logic lock regions</li> <li>Creation of timing constraints</li> <li>Create Intel Quartus Prime Pro FIM test project and validate:<ol> <li>Placement</li> <li>Timing constraints</li> <li>Build script process</li> <li>Review test FIM FPGA resource usage</li> </ol> </li> </ol> </li> <li>Select FIM to AFU interfaces and development of PIM</li> <li>FIM design implementation<ol> <li>RTL coding</li> <li>IP instantiation</li> <li>Development of test AFU to validate FIM</li> <li>Unit and device level simulation</li> <li>Timing constraints and build scripts</li> <li>Timing closure and build validation</li> </ol> </li> <li>Creation of FIM documentation to support AFU development and synthesis</li> <li>Software Device Feature discovery</li> <li>Hardware/software integration, validation and debugging</li> <li>High volume production preparation</li> </ol> <p>The FIM developer works closely with the hardware design of the target board, software development and system validation.</p> <p>This section describes how to perform specific customizations of areas of the FIM. Each section can be done independently. The following walkthroughs are provided:</p> Section Walkthrough 5.1 How to add a new module to the FIM 5.2 How to debug the FIM with Signal Tap 5.3 How to compile the FIM in preparation for designing your AFU 5.4 How to resize the Partial Reconfiguration Region 5.5 How to modify the Memory Subsystem 5.6 How to compile the FIM with no HSSI 5.7 How to change the PCIe Device ID and Vendor ID 5.8 How to migrate to a different Agilex device number 5.9 How to change the Ethernet interface from 8x25 GbE to 8x10 GbE 5.10 How to change the Ethernet interface from 8x25 GbE to 2x100 GbE 5.11 How to add more transceiver channels to the FIM 5.12 How to modify the PF/VF MUX configuration 5.13 How to create a minimal FIM <p>In each section, it is assumed that:</p> <ol> <li>You have a clean, unmodified clone of the OFS repo.  See the Clone the OFS Git Repo section.</li> <li>After cloning, you must set various environment variables. See the Setting Up Required Environment Variables section.</li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#51-how-to-add-a-new-module-to-the-fim","title":"5.1 How to add a new module to the FIM","text":"<p>This section provides a walkthrough for adding a custom module to the FIM, simulating the new design, compiling the new design, implementing and testing the new design on hardware, and debugging the new design on hardware.</p> <p>If you intend to add a new module to the FIM area, then you will need to inform the host software of the new module. The FIM exposes its functionalities to host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO). This set of CSR registers and their operation is described in FIM MMIO Regions.</p> <p>See FPGA Device Feature List (DFL) Framework Overview for a description of the software process to read and process the linked list of Device Feature Header (DFH) CSRs within a FPGA.</p> <p>The Hello FIM example adds a simple DFH register and 64bit scratchpad register connected to the Board Peripheral Fabric (BPF) that can be accessed by the SoC. You can use this example as the basis for adding a new feature to your FIM. </p> <p>The Hello FIM design can be verified by Unit Level simulation, Universal Verification Methodology (UVM) simulation, and running in hardware on the f2000x  card. The process for these are described in this section. </p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#511-board-peripheral-fabric-bpf","title":"5.1.1 Board Peripheral Fabric (BPF)","text":"<p>The Hello FIM module will be connected to the Board Peripheral Fabric (BPF), and will be connected such that it can only be mastered by the SoC. The BPF is an interconnect generated by Platform Designer. The figure below shows the APF/BPF Master/Slave interactions, as well as the added Hello FIM module.</p> <p></p> <p>You can create, modify, and/or generate the BPF manually in Platform Designer or more conveniently by executing a provided script.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#512-soc-mmio-region","title":"5.1.2 SoC MMIO Region","text":"<p>We will add the Hello FIM module to an un-used address space in the SoC MMIO region. The table below shows the MMIO region for the SoC with the Hello FIM module added at base address <code>0x16000</code>.</p> Offset Feature CSR set 0x00000 FME AFU 0x01000 Thermal Management 0x03000 Global Performance 0x04000 Global Error 0x10000 PCIe Interface 0x12000 QSFP Controller 0 0x13000 QSFP Controller 1 0x14000 HSSI Interface 0x15000 EMIF Interface 0x16000 Hello FIM 0x80000 PMCI Controller 0x100000 ST2MM (Streaming to Memory-Mapped) 0x130000 PR Control &amp; Status (Port Gasket) 0x131000 Port CSRs (Port Gasket) 0x132000 User Clock (Port Gasket) 0x133000 Remote SignalTap (Port Gasket) 0x140000 AFU Errors (AFU Interface Handler) <p>Refer to the FIM Technical Reference Manual: Interconnect Fabric for more information on the default MMIO region.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#513-hello-fim-csr","title":"5.1.3 Hello FIM CSR","text":"<p>The Hello FIM CSR will consist of the three registers shown in the table below. The DFH and Hello FIM ID registers are read-only. The Scratchpad register supports read and write accesses.</p> Offset Attribute Description Default Value 0x016000 RO DFH(Device Feature Headers) register 0x30000006a0000100 0x016030 RW Scrachpad register 0x0 0x016038 RO Hello FIM ID register 0x6626070150000034"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#514-files-to-edit-to-support-hello-fim","title":"5.1.4 Files to Edit to Support Hello FIM","text":"<p>The table below shows all files in $OFS_ROOTDIR that will be modified or created in order to implement the Hello FIM module. The build_top.sh script copies files from $OFS_ROOTDIR into the target work directory and then the copied files are used in the Quartus build process. Details on editing these files is given in subsequent sections.</p> Category Status Path File Description Source Modify src/top top.sv Top RTL Modify src/pd_qsys bpf_top.sv BPF top RTL New src/hello_fim hello_fim_top.sv Hello FIM top RTL New src/hello_fim hello_fim_com.sv Hello FIM common RTL Design Files Modify syn/syn_top ofs_top.qsf Quartus setting file Modify syn/syn_top ofs_top_sources.tcl Define sources for top level design New syn/setup hello_fim_design_files.tcl Define RTLs of Hello FIM Modify syn/setup fabric_design_files.tcl Define IPs for fabric Platform Designer Modify src/pd_qsys/fabric bpf.txt Text definition of BPF interconnect Modify src/pd_qsys/fabric bpf.qsys BPF Qsys file Simulation Modify sim/unit_test/soc_tests/dfh_walker test_csr_defs.sv Define CSRs for simulation Verification Modify /ofs-common/verification/fpga_family/agilex/tests/sequences mmio_seq.svh MMIO testbench Modify /ofs-common/verification/fpga_family/agilex/tests/sequences dfh_walking_seq.svh DFH Walking testbench Modify ofs-common/verification/fpga_family/agilex/scripts Makefile_VCS.mk Makefile for VCS"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#515-pre-requisites-for-adding-hello-fim","title":"5.1.5 Pre-Requisites for Adding Hello FIM","text":"<p>The following pre-requisites must be satisfied before adding the Hello FIM module.</p> <ol> <li>Clone the design repositories. See the Clone the OFS Git Repo section.</li> <li>Set the environment variables. See the Setting Up Required Environment Variables section.</li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#516-file-modification","title":"5.1.6 File Modification","text":"<p>This section describes the steps to add the Hello FIM module to the FIM.  The steps in this simple example are the basis for modifying the FIM for more complex functions.</p> <ol> <li> <p>Modify <code>syn/syn_top/ofs_top.qsf</code></p> <ol> <li> <p>Define the <code>INCLUDE_HELLO_FIM</code> Verilog macro to the <code>Verilog Macros</code> section. This will enable instantiation of the Hello FIM module. If this is not set, a dummy register will be instantiated instead.</p> <pre><code>######################################################\n# Verilog Macros\n######################################################\n.....\nset_global_assignment -name VERILOG_MACRO \"INCLUDE_HELLO_FIM\"     # Includes Hello FIM\n</code></pre> </li> </ol> </li> <li> <p>Modify <code>syn/syn_top/ofs_top_sources.tcl</code></p> <ol> <li> <p>Add <code>hello_fim_design_files.tcl</code> to the list of subsystems in the Design Files section.</p> <pre><code>############################################\n# Design Files\n############################################\n...\n# Subsystems\n...\nset_global_assignment -name SOURCE_TCL_SCRIPT_FILE ../setup/hello_fim_design_files.tcl\n</code></pre> </li> </ol> </li> <li> <p>Create <code>syn/setup/hello_fim_design_files.tcl</code></p> <ol> <li> <p>Create <code>hello_fim_design_files.tcl</code> with the following contents:</p> <pre><code># Copyright 2023 Intel Corporation.\n#\n# THIS SOFTWARE MAY CONTAIN PREPRODUCTION CODE AND IS PROVIDED BY THE\n# COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE # LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# Hello FIM Files\n#--------------------\nset_global_assignment -name SYSTEMVERILOG_FILE $::env(BUILD_ROOT_REL)/src/hello_fim/hello_fim_com.sv\nset_global_assignment -name SYSTEMVERILOG_FILE $::env(BUILD_ROOT_REL)/src/hello_fim/hello_fim_top.sv\n</code></pre> </li> </ol> </li> <li> <p>Modify <code>/src/pd_qsys/fabric/fabric_design_files.tcl</code></p> <ol> <li> <p>Add <code>bpf_hello_fim_slv.ip</code> to the list of files in the BPF section.</p> <pre><code>#--------------------\n# BPF\n#--------------------\n...\nset_global_assignment -name IP_FILE ../ip_lib/src/pd_qsys/fabric/ip/bpf/bpf_hello_fim_slv.ip\n</code></pre> </li> </ol> </li> <li> <p>Modify <code>src/top/top.sv</code></p> <ol> <li> <p>Add <code>bpf_hello_fim_slv_if</code> to AXI4-Lite Interfaces:</p> <pre><code>// AXI4-lite interfaces\nofs_fim_axi_lite_if #(.AWADDR_WIDTH(12), .ARADDR_WIDTH(12)) bpf_hello_fim_slv_if();\n</code></pre> </li> <li> <p>Modify the value of <code>NEXT_DFH_OFFSET</code> of <code>mem_ss_top</code> from <code>24'h6B000</code> to <code>24'h1000</code></p> <pre><code>//*******************************\n// Memory Subsystem\n//*******************************\n`ifdef INCLUDE_DDR4\nmem_ss_top #(\n.FEAT_ID          (12'h009),\n.FEAT_VER         (4'h1),\n.NEXT_DFH_OFFSET  (24'h1000),\n.END_OF_LIST      (1'b0)\n) mem_ss_top (\n</code></pre> </li> <li> <p>Modify the value of <code>NEXT_DFH_OFFSET</code> of the Memory Subsystem <code>dummy_csr</code> from <code>24'h6B000</code> to <code>24'h1000</code></p> <pre><code>// Placeholder logic if no mem_ss\ndummy_csr #(\n.FEAT_ID          (12'h009),\n.FEAT_VER         (4'h1),\n.NEXT_DFH_OFFSET  (24'h1000),\n.END_OF_LIST      (1'b0)\n) emif_dummy_csr (\n</code></pre> </li> <li> <p>Add Hello FIM instance and dummy CSR after the Memory Subsystem. Set the <code>NEXT_DFH_OFFSET</code> to <code>24'h6A000</code> for both</p> <pre><code>//*******************************\n// Hello FIM Subsystem\n//*******************************\n`ifdef INCLUDE_HELLO_FIM\nhello_fim_top #(\n.ADDR_WIDTH       (12),\n.DATA_WIDTH       (64),\n.FEAT_ID          (12'h100),\n.FEAT_VER         (4'h0),\n.NEXT_DFH_OFFSET  (24'h6A000),\n.END_OF_LIST      (1'b0)\n) hello_fim_top_inst (\n.clk (clk_csr),\n.reset(~rst_n_csr),\n.csr_lite_if    (bpf_hello_fim_slv_if)         );\n`else\ndummy_csr #(   .FEAT_ID          (12'h100),\n.FEAT_VER         (4'h0),\n.NEXT_DFH_OFFSET  (24'h6A000),\n.END_OF_LIST      (1'b0)\n) hello_fim_dummy (\n.clk         (clk_csr),\n.rst_n       (rst_n_csr),\n.csr_lite_if (bpf_hello_fim_slv_if)\n);\n`endif </code></pre> </li> </ol> </li> <li> <p>Modify <code>/src/pd_qsys/bpf_top.sv</code></p> <ol> <li> <p>Add <code>bpf_hello_fim_slv_if</code> to the interface descriptions</p> <pre><code>...\nmodule bpf_top (\n...\n//BPF funtions\n...\nofs_fim_axi_lite_if.master bpf_hello_fim_slv_if\n</code></pre> </li> <li> <p>Add <code>bpf_hello_fim_slv_if</code> to the module</p> <pre><code>module bpf_top (\n...\n);\n...\n.bpf_hello_fim_slv_awaddr    (bpf_hello_fim_slv_if.awaddr     ),\n.bpf_hello_fim_slv_awprot    (bpf_hello_fim_slv_if.awprot     ),\n.bpf_hello_fim_slv_awvalid   (bpf_hello_fim_slv_if.awvalid    ),\n.bpf_hello_fim_slv_awready   (bpf_hello_fim_slv_if.awready    ),\n.bpf_hello_fim_slv_wdata     (bpf_hello_fim_slv_if.wdata      ),\n.bpf_hello_fim_slv_wstrb     (bpf_hello_fim_slv_if.wstrb      ),\n.bpf_hello_fim_slv_wvalid    (bpf_hello_fim_slv_if.wvalid     ),\n.bpf_hello_fim_slv_wready    (bpf_hello_fim_slv_if.wready     ),\n.bpf_hello_fim_slv_bresp     (bpf_hello_fim_slv_if.bresp      ),\n.bpf_hello_fim_slv_bvalid    (bpf_hello_fim_slv_if.bvalid     ),\n.bpf_hello_fim_slv_bready    (bpf_hello_fim_slv_if.bready     ),\n.bpf_hello_fim_slv_araddr    (bpf_hello_fim_slv_if.araddr     ),\n.bpf_hello_fim_slv_arprot    (bpf_hello_fim_slv_if.arprot     ),\n.bpf_hello_fim_slv_arvalid   (bpf_hello_fim_slv_if.arvalid    ),\n.bpf_hello_fim_slv_arready   (bpf_hello_fim_slv_if.arready    ),\n.bpf_hello_fim_slv_rdata     (bpf_hello_fim_slv_if.rdata      ),\n.bpf_hello_fim_slv_rresp     (bpf_hello_fim_slv_if.rresp      ),\n.bpf_hello_fim_slv_rvalid    (bpf_hello_fim_slv_if.rvalid     ),\n.bpf_hello_fim_slv_rready    (bpf_hello_fim_slv_if.rready     ),\n...\nendmodule\n</code></pre> </li> </ol> </li> <li> <p>Create <code>src/hello_fim</code></p> <ol> <li> <p>Create <code>src/hello_fim</code> directory</p> <pre><code>mkdir $OFS_ROOTDIR/src/hello_fim\n</code></pre> </li> </ol> </li> <li> <p>Create <code>src/hello_fim/hello_fim_top.sv</code></p> <ol> <li> <p>Create <code>hello_fim_top.sv</code> with the following contents:</p> <pre><code>// ***************************************************************************\n//                               INTEL CONFIDENTIAL\n//\n//        Copyright (C) 2023 Intel Corporation All Rights Reserved.\n//\n// The source code contained or described herein and all  documents related to\n// the  source  code  (\"Material\")  are  owned  by  Intel  Corporation  or its\n// suppliers  or  licensors.    Title  to  the  Material  remains  with  Intel\n// Corporation or  its suppliers  and licensors.  The Material  contains trade\n// secrets  and  proprietary  and  confidential  information  of  Intel or its\n// suppliers and licensors.  The Material is protected  by worldwide copyright\n// and trade secret laws and treaty provisions. No part of the Material may be\n// used,   copied,   reproduced,   modified,   published,   uploaded,  posted,\n// transmitted,  distributed,  or  disclosed  in any way without Intel's prior\n// express written permission.\n//\n// No license under any patent,  copyright, trade secret or other intellectual\n// property  right  is  granted  to  or  conferred  upon  you by disclosure or\n// delivery  of  the  Materials, either expressly, by implication, inducement,\n// estoppel or otherwise.  Any license under such intellectual property rights\n// must be express and approved by Intel in writing.\n//\n// You will not, and will not allow any third party to modify, adapt, enhance, \n// disassemble, decompile, reverse engineer, change or create derivative works \n// from the Software except and only to the extent as specifically required by \n// mandatory applicable laws or any applicable third party license terms \n// accompanying the Software.\n//\n// -----------------------------------------------------------------------------\n// Engineer     : \n// Create Date  : Nov 2021\n// Module Name  : hello_fim_top.sv\n// Project      : IOFS\n// -----------------------------------------------------------------------------\n//\n// Description: \n// This is a simple module that implements DFH registers and \n// AVMM address decoding logic.\nmodule hello_fim_top  #(\nparameter ADDR_WIDTH  = 12, parameter DATA_WIDTH = 64, parameter bit [11:0] FEAT_ID = 12'h001,\nparameter bit [3:0]  FEAT_VER = 4'h1,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h1000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput  logic    clk,\ninput  logic    reset,\n// -----------------------------------------------------------\n//  AXI4LITE Interface\n// -----------------------------------------------------------\nofs_fim_axi_lite_if.slave   csr_lite_if\n);\nimport ofs_fim_cfg_pkg::*;\nimport ofs_csr_pkg::*;\n//-------------------------------------\n// Signals\n//-------------------------------------\nlogic [ADDR_WIDTH-1:0]              csr_waddr;\nlogic [DATA_WIDTH-1:0]              csr_wdata;\nlogic [DATA_WIDTH/8-1:0]            csr_wstrb;\nlogic                               csr_write;\nlogic                               csr_slv_wready;\ncsr_access_type_t                   csr_write_type;\nlogic [ADDR_WIDTH-1:0]              csr_raddr;\nlogic                               csr_read;\nlogic                               csr_read_32b;\nlogic [DATA_WIDTH-1:0]              csr_readdata;\nlogic                               csr_readdata_valid;\nlogic [ADDR_WIDTH-1:0]              csr_addr;\nlogic [63:0]                        com_csr_writedata;\nlogic                               com_csr_read;\nlogic                               com_csr_write;\nlogic [63:0]                        com_csr_readdata;\nlogic                               com_csr_readdatavalid;\nlogic [5:0]                         com_csr_address;\n// AXI-M CSR interfaces\nofs_fim_axi_mmio_if #(\n.AWID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.AWADDR_WIDTH (ADDR_WIDTH),\n.WDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH),\n.ARID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.ARADDR_WIDTH (ADDR_WIDTH),\n.RDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH)\n) csr_if();\n// AXI4-lite to AXI-M adapter\naxi_lite2mmio axi_lite2mmio (\n.clk       (clk),\n.rst_n     (~reset),\n.lite_if   (csr_lite_if),\n.mmio_if   (csr_if)\n);\n//---------------------------------\n// Map AXI write/read request to CSR write/read,\n// and send the write/read response back\n//---------------------------------\nofs_fim_axi_csr_slave #(\n.ADDR_WIDTH (ADDR_WIDTH),\n.USE_SLV_READY (1'b1)\n) csr_slave (\n.csr_if             (csr_if),\n.csr_write          (csr_write),\n.csr_waddr          (csr_waddr),\n.csr_write_type     (csr_write_type),\n.csr_wdata          (csr_wdata),\n.csr_wstrb          (csr_wstrb),\n.csr_slv_wready     (csr_slv_wready),\n.csr_read           (csr_read),\n.csr_raddr          (csr_raddr),\n.csr_read_32b       (csr_read_32b),\n.csr_readdata       (csr_readdata),\n.csr_readdata_valid (csr_readdata_valid)\n);\n// Address mapping\nassign csr_addr             = csr_write ? csr_waddr : csr_raddr;\nassign com_csr_address      = csr_addr[5:0];  // byte address\nassign csr_slv_wready       = 1'b1 ;\n// Write data mapping\nassign com_csr_writedata    = csr_wdata;\n// Read-Write mapping\nalways_comb\nbegin\ncom_csr_read             = 1'b0;\ncom_csr_write            = 1'b0;\ncasez (csr_addr[11:6])\n6'h00 : begin // Common CSR\ncom_csr_read       = csr_read;\ncom_csr_write      = csr_write;\nend   default: begin\ncom_csr_read       = 1'b0;\ncom_csr_write      = 1'b0;\nend\nendcase\nend\n// Read data mapping\nalways_comb begin\nif (com_csr_readdatavalid) begin\ncsr_readdata       = com_csr_readdata;\ncsr_readdata_valid = 1'b1;\nend\nelse begin\ncsr_readdata       = '0;\ncsr_readdata_valid = 1'b0;\nend\nend\nhello_fim_com  #(\n.FEAT_ID          (FEAT_ID),\n.FEAT_VER         (FEAT_VER),\n.NEXT_DFH_OFFSET  (NEXT_DFH_OFFSET),\n.END_OF_LIST      (END_OF_LIST)\n) hello_fim_com_inst (\n.clk                   (clk                     ),\n.reset                 (reset                   ),\n.writedata             (com_csr_writedata       ),\n.read                  (com_csr_read            ),\n.write                 (com_csr_write           ),\n.byteenable            (4'hF                    ),\n.readdata              (com_csr_readdata        ),\n.readdatavalid         (com_csr_readdatavalid   ),\n.address               (com_csr_address         )\n);\nendmodule\n</code></pre> </li> </ol> </li> <li> <p>Create <code>src/hello_fim/hello_fim_com.sv</code></p> <ol> <li> <p>Create <code>hello_fim_com.sv</code> with the following contents:</p> <pre><code>module hello_fim_com #(\nparameter bit [11:0] FEAT_ID = 12'h001,\nparameter bit [3:0]  FEAT_VER = 4'h1,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h1000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput clk,\ninput reset,\ninput [63:0] writedata,\ninput read,\ninput write,\ninput [3:0] byteenable,\noutput reg [63:0] readdata,\noutput reg readdatavalid,\ninput [5:0] address\n);\nwire reset_n = !reset;  reg [63:0] rdata_comb;\nreg [63:0] scratch_reg;\nalways @(negedge reset_n ,posedge clk)  if (!reset_n) readdata[63:0] &lt;= 64'h0; else readdata[63:0] &lt;= rdata_comb[63:0];\nalways @(negedge reset_n , posedge clk)\nif (!reset_n) readdatavalid &lt;= 1'b0; else readdatavalid &lt;= read;\nwire wr = write;\nwire re = read;\nwire [5:0] addr = address[5:0];\nwire [63:0] din  = writedata [63:0];\nwire wr_scratch_reg = wr &amp; (addr[5:0]  == 6'h30)? byteenable[0]:1'b0;\n// 64 bit scratch register\nalways @( negedge  reset_n,  posedge clk)\nif (!reset_n)  begin\nscratch_reg &lt;= 64'h0;\nend\nelse begin\nif (wr_scratch_reg) begin scratch_reg &lt;=  din;  end\nend\nalways @ (*)\nbegin\nrdata_comb = 64'h0000000000000000;\nif(re) begin\ncase (addr)  6'h00 : begin\nrdata_comb [11:0]   = FEAT_ID ;  // dfh_feature_id  is reserved or a constant value, a read access gives the reset value\nrdata_comb [15:12]  = FEAT_VER ;  // dfh_feature_rev    is reserved or a constant value, a read access gives the reset value\nrdata_comb [39:16]  = NEXT_DFH_OFFSET ;  // dfh_dfh_ofst is reserved or a constant value, a read access gives the reset value\nrdata_comb [40]     = END_OF_LIST ;        //dfh_end_of_list\nrdata_comb [59:40]  = 20'h00000 ;  // dfh_rsvd1     is reserved or a constant value, a read access gives the reset value\nrdata_comb [63:60]  = 4'h3 ;  // dfh_feat_type  is reserved or a constant value, a read access gives the reset value\nend\n6'h30 : begin\nrdata_comb [63:0]   = scratch_reg; end\n6'h38 : begin\nrdata_comb [63:0]       = 64'h6626_0701_5000_0034;\nend\ndefault : begin\nrdata_comb = 64'h0000000000000000;\nend\nendcase\nend\nend\nendmodule\n</code></pre> </li> </ol> </li> <li> <p>Modify <code>src/pd_qsys/fabric/bpf.txt</code></p> <ol> <li> <p>Add <code>hello_fim</code> as a slave in the BPF, and enable the SoC as a master for it.</p> <pre><code>#### - '#' means comment\n# NAME   TYPE      BASEADDRESS    ADDRESS_WIDTH    SLAVES\napf         mst     n/a             21             fme,soc_pcie,hssi,qsfp0,qsfp1,emif,pmci,hello_fim\n...\nhello_fim   slv     0x16000         12             n/a\n</code></pre> </li> </ol> </li> <li> <p>Execute the helper script to re-generate the BPF design files</p> <pre><code>cd $OFS_ROOTDIR/src/pd_qsys/fabric/\nsh gen_fabrics.sh\n</code></pre> </li> <li> <p>After the shell script finishes, you can find the generated <code>bpf_hello_fim_slv.ip</code> file in <code>$OFS_ROOTDIR/src/pd_qsys/fabric/ip/bpf/</code>. This is the ip variant of the axi4lite shim that bridges the Hello FIM module with the BPF. The updated <code>bpf.qsys</code> file is located in <code>$OFS_ROOTDIR/src/pd_qsys/fabric</code>. You can view the updated bpf file in Platform designer as follows.</p> <pre><code>cd $OFS_ROOTDIR/src/pd_qsys/fabric\nqsys-edit bpf.qsys --quartus-project=$OFS_ROOTDIR/syn/syn_top/ofs_top.qpf\n</code></pre> <p>The image below shows the BPF that integrates the <code>bpf_hello_fim_slv</code> axi4lite shim at address 0x16000, generated through the helper script gen_fabrics.sh.</p> <p></p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#517-unit-level-simulation-of-hello-fim-design","title":"5.1.7 Unit Level Simulation of Hello FIM Design","text":"<p>The following section describes the file modifications that need to be made to perform unit level simulations of the Hello FIM design, followed by instructions for running the unit level simulations.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5171-unit-level-simulation-file-modification","title":"5.1.7.1 Unit Level Simulation File Modification","text":"<p>Perform the following steps to modify the Unit Level simulation files to support the Hello FIM design.</p> <ol> <li> <p>Modify <code>$OFS_ROOTDIR/sim/unit_test/soc_tests/dfh_walker/test_csr_defs.sv</code></p> <ol> <li> <p>Add a <code>HELLO_FIM_IDX</code> entry to the <code>t_dfh_idx</code> enumeration:</p> <pre><code>typedef enum {\nFME_DFH_IDX,\nTHERM_MNGM_DFH_IDX,\nGLBL_PERF_DFH_IDX,\nGLBL_ERROR_DFH_IDX,\nQSFP0_DFH_IDX,\nQSFP1_DFH_IDX,\nHSSI_DFH_IDX,\nEMIF_DFH_IDX,\nHELLO_FIM_DFH_IDX,\nPMCI_DFH_IDX,\nST2MM_DFH_IDX,\nPG_PR_DFH_IDX,\nPG_PORT_DFH_IDX,\nPG_USER_CLK_DFH_IDX,\nPG_REMOTE_STP_DFH_IDX,\nAFU_ERR_DFH_IDX,\nMAX_DFH_IDX\n} t_dfh_idx;\n</code></pre> </li> <li> <p>Add an entry for <code>HELLO_FIM_IDX</code> into the <code>get_dfh_names()</code> function:</p> <pre><code>function automatic dfh_name[MAX_DFH_IDX-1:0] get_dfh_names();\ndfh_name[MAX_DFH_IDX-1:0] dfh_names;\ndfh_names[FME_DFH_IDX]         = \"FME_DFH\";\ndfh_names[THERM_MNGM_DFH_IDX]  = \"THERM_MNGM_DFH\";\ndfh_names[GLBL_PERF_DFH_IDX]   = \"GLBL_PERF_DFH\";\ndfh_names[GLBL_ERROR_DFH_IDX]  = \"GLBL_ERROR_DFH\";\ndfh_names[QSFP0_DFH_IDX]       = \"QSFP0_DFH\";\ndfh_names[QSFP1_DFH_IDX]       = \"QSFP1_DFH\";\ndfh_names[HSSI_DFH_IDX]        = \"HSSI_DFH\";\ndfh_names[EMIF_DFH_IDX]        = \"EMIF_DFH\";\ndfh_names[HELLO_FIM_DFH_IDX]   = \"HELLO_FIM_DFH\";\ndfh_names[PMCI_DFH_IDX]        = \"PMCI_DFH\";\ndfh_names[ST2MM_DFH_IDX]       = \"ST2MM_DFH\";\ndfh_names[PG_PR_DFH_IDX]       = \"PG_PR_DFH\";\ndfh_names[PG_PORT_DFH_IDX]     = \"PG_PORT_DFH\";\ndfh_names[PG_USER_CLK_DFH_IDX] = \"PG_USER_CLK_DFH\";\ndfh_names[PG_REMOTE_STP_DFH_IDX] = \"PG_REMOTE_STP_DFH\";\ndfh_names[AFU_ERR_DFH_IDX] = \"AFU_ERR_DFH\";\nreturn dfh_names;\nendfunction\n</code></pre> </li> <li> <p>Modify the expected DFH value of the EMIF from <code>64'h3_00000_06B000_1009</code> to <code>64'h3_00000_001000_1009</code> and add the expected value for <code>HELLO_FIM</code> as <code>64'h3_00000_06A000_0100</code>:</p> <pre><code>function automatic [MAX_DFH_IDX-1:0][63:0] get_dfh_values();\nlogic[MAX_DFH_IDX-1:0][63:0] dfh_values;\ndfh_values[FME_DFH_IDX]        = 64'h4000_0000_1000_0000;\ndfh_values[THERM_MNGM_DFH_IDX] = 64'h3_00000_002000_0001;\ndfh_values[GLBL_PERF_DFH_IDX]  = 64'h3_00000_001000_0007;\ndfh_values[GLBL_ERROR_DFH_IDX] = 64'h3_00000_00e000_1004;\ndfh_values[QSFP0_DFH_IDX]      = 64'h3_00000_001000_0013;\ndfh_values[QSFP1_DFH_IDX]      = 64'h3_00000_001000_0013;\ndfh_values[HSSI_DFH_IDX]       = 64'h3_00000_001000_100f;\ndfh_values[EMIF_DFH_IDX]       = 64'h3_00000_001000_1009;\ndfh_values[HELLO_FIM_DFH_IDX]  = 64'h3_00000_06A000_0100;\ndfh_values[PMCI_DFH_IDX]       = 64'h3_00000_080000_1012;\ndfh_values[ST2MM_DFH_IDX]      = 64'h3_00000_030000_0014;\ndfh_values[PG_PR_DFH_IDX]      = 64'h3_00000_001000_1005;\ndfh_values[PG_PORT_DFH_IDX]     = 64'h4_00000_001000_1001;\ndfh_values[PG_USER_CLK_DFH_IDX] = 64'h3_00000_001000_1014;\ndfh_values[PG_REMOTE_STP_DFH_IDX] = 64'h3_00000_00d000_2013;\ndfh_values[AFU_ERR_DFH_IDX] = 64'h3_00001_000000_2010;\nreturn dfh_values;\nendfunction\n</code></pre> </li> </ol> </li> <li> <p>Regenerate the simulation files</p> <pre><code>cd $OFS_ROOTDIR/ofs-common/scripts/common/sim\nsh gen_sim_files.sh f2000x </code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5172-run-dfh-walker-simulation","title":"5.1.7.2 Run DFH Walker Simulation","text":"<p>After the simulation files have been re-generated, run the DFH Walker test to ensure the Hello FIM module can be accessed by the SoC through the BPF.</p> <ol> <li> <p>Run the DFH Walker test</p> <pre><code>cd $OFS_ROOTDIR/sim/unit_test/soc_tests/dfh_walker\nsh run_sim.sh\n</code></pre> </li> <li> <p>Check the output for the presence of the <code>HELLO_FiM</code> module at address <code>0x16000</code>:</p> <pre><code>********************************************\nRunning TEST(0) : test_dfh_walking\n********************************************\n\n...\n\nREAD64: address=0x00015000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000010001009\n\nEMIF_DFH\n   Address   (0x15000)\nDFH value (0x3000000010001009)\nREAD64: address=0x00016000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x30000006a0000100\n\nHELLO_FIM_DFH\n   Address   (0x16000)\nDFH value (0x30000006a0000100)\nREAD64: address=0x00080000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000800001012\n\nPMCI_DFH\n   Address   (0x80000)\nDFH value (0x3000000800001012)\n...\n\nTest status: OK\n\n********************\nTest summary\n********************\n   test_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#518-uvm-verfication-of-the-hellofim","title":"5.1.8 UVM Verfication of the HelloFIM","text":"<p>The following section describes the file modifications that need to be made to perform UVM verifaction of the Hello FIM design, followed by instructions for running the UVM simulations.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5181-uvm-simulation-file-modification","title":"5.1.8.1 UVM Simulation File Modification","text":"<p>Perform the following steps to modify the UVM simulation files to support the Hello FIM design.</p> <ol> <li> <p>Modify <code>$OFS_ROOTDIR/verification/tests/sequences/dfh_walking_seq.svh</code></p> <ol> <li> <p>Modify the <code>dfh_offset_array</code> to insert the Hello FIM.</p> <pre><code>dfh_offset_array = new[16];\ndfh_offset_array[ 0] = tb_cfg0.PF0_BAR0;                    // FME_DFH                0x8000_0000\ndfh_offset_array[ 1] = dfh_offset_array[ 0] + 64'h0_1000;   // THERM_MNGM_DFH         0x8000_1000\ndfh_offset_array[ 2] = dfh_offset_array[ 1] + 64'h0_2000;   // GLBL_PERF_DFH          0x8000_3000\ndfh_offset_array[ 3] = dfh_offset_array[ 2] + 64'h0_1000;   // GLBL_ERROR_DFH         0x8000_4000\ndfh_offset_array[ 4] = dfh_offset_array[ 3] + 64'h0_E000;   // QSFP0_DFH              0x8001_2000\ndfh_offset_array[ 5] = dfh_offset_array[ 4] + 64'h0_1000;   // QSFP1_DFH              0x8001_3000\ndfh_offset_array[ 6] = dfh_offset_array[ 5] + 64'h0_1000;   // HSSI_DFH               0x8001_4000\ndfh_offset_array[ 7] = dfh_offset_array[ 6] + 64'h0_1000;   // EMIF_DFH               0x8001_5000\ndfh_offset_array[ 8] = dfh_offset_array[ 7] + 64'h0_1000;   // HELLO_FIM_DFH          0x8001_6000\ndfh_offset_array[ 9] = dfh_offset_array[ 8] + 64'h6_a000;   // PMCI_DFH               0x8008_0000\ndfh_offset_array[ 10] = dfh_offset_array[ 9] + 64'h8_0000;  // ST2MM_DFH              0x8010_0000\ndfh_offset_array[ 11] = dfh_offset_array[10] + 64'h3_0000;  // PG_PR_DFH_IDX          0x8013_0000\ndfh_offset_array[ 12] = dfh_offset_array[11] + 64'h0_1000;  // PG_PORT_DFH_IDX        0x8013_1000\ndfh_offset_array[ 13] = dfh_offset_array[12] + 64'h0_1000;  // PG_USER_CLK_DFH_IDX    0x8013_2000\ndfh_offset_array[ 14] = dfh_offset_array[13] + 64'h0_1000;  // PG_REMOTE_STP_DFH_IDX  0x8013_3000\ndfh_offset_array[ 15] = dfh_offset_array[14] + 64'h0_D000;  // PG_AFU_ERR_DFH_IDX     0x8014_0000\n</code></pre> </li> </ol> </li> <li> <p>Modify <code>$OFS_ROOTDIR/verification/tests/sequences/mmio_seq.svh</code></p> <ol> <li> <p>Add test code related to the Hello FIM. This code will verify the scratchpad register at 0x16030 and read only the register at 0x16038.</p> <pre><code>// HELLO_FIM_Scratchpad 64 bit access\n`uvm_info(get_name(), $psprintf(\"////Accessing PF0 HELLO_FIM_Scratchpad Register %0h+'h16030////\", tb_cfg0.PF0_BAR0), UVM_LOW)\nassert(std::randomize(wdata));\naddr = tb_cfg0.PF0_BAR0+'h1_6000+'h30;\nmmio_write64(.addr_(addr), .data_(wdata));\nmmio_read64 (.addr_(addr), .data_(rdata));\nif(wdata !== rdata)\n`uvm_error(get_name(), $psprintf(\"Data mismatch 64! Addr = %0h, Exp = %0h, Act = %0h\", addr, wdata, rdata))\nelse\n`uvm_info(get_name(), $psprintf(\"Data match 64! addr = %0h, data = %0h\", addr, rdata), UVM_LOW)\naddr = tb_cfg0.PF0_BAR0+'h1_6000+'h38;\nwdata = 64'h6626_0701_5000_0034;\nmmio_read64 (.addr_(addr), .data_(rdata));\nif(wdata !== rdata)\n`uvm_error(get_name(), $psprintf(\"Data mismatch 64! Addr = %0h, Exp = %0h, Act = %0h\", addr, wdata, rdata))\nelse\n`uvm_info(get_name(), $psprintf(\"Data match 64! addr = %0h, data = %0h\", addr, rdata), UVM_LOW)\n</code></pre> <p>Note: uvm_info and uvm_error statements will put a message into log file.</p> </li> </ol> </li> <li> <p>Modify <code>$OFS_ROOTDIR/verification/scripts/Makefile_VCS.mk</code></p> <ol> <li> <p>Add <code>INCLUDE_HELLO_FIM</code> define option to enable Hello FIM on UVM</p> <pre><code>VLOG_OPT += +define+INCLUDE_HELLO_FIM\n</code></pre> </li> </ol> </li> <li> <p>Re-generate the UVM files</p> <ol> <li> <p>Navigate to the verification scripts directory</p> <pre><code>cd $VERDIR/scripts\n</code></pre> </li> <li> <p>Clean the output of previous builds</p> <pre><code>gmake -f Makefile_VCS.mk clean\n</code></pre> </li> <li> <p>Compile the IP files</p> <pre><code>gmake -f Makefile_VCS.mk cmplib_adp\n</code></pre> </li> <li> <p>Build the RTL and Test Benches</p> <pre><code>gmake -f Makefile_VCS.mk build_adp DUMP=1 DEBUG=1 </code></pre> <p>Note: Using the <code>DEBUG</code> option will provide more detail in the log file for the simulation.</p> </li> </ol> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5182-run-uvm-dfh-walker-simulation","title":"5.1.8.2 Run UVM DFH Walker Simulation","text":"<p>Perform the following steps to run the UVM DFH Walker Simulation.</p> <ol> <li> <p>Run the DFH Walker simulation</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_VCS.mk run TESTNAME=dfh_walking_test DUMP=1 DEBUG=1\n</code></pre> <p>Note: Using the <code>DEBUG</code> option will provide more detail in the log file for the simulation.</p> </li> <li> <p>The output logs are stored in the $VERDIR/sim/dfh_walking_test directory. The main files to note are described in the table below:</p> File Name Description runsim.log A log file of UVM trans.log A log file of transactions on PCIe bus inter.vpd A waveform for VCS </li> <li> <p>Run the following command to quickly verify- that the Hello FIM module was successfully accessed. In the example below, the message <code>DFH offset Match! Exp = 80016000 Act = 80016000</code> shows that the Hello FIM module was successfully accessed.</p> <pre><code>cd $VERDIR/sim/dfh_walking_test\ncat runsim.log | grep \"DFH offset\"\n</code></pre> <p>Expected output:</p> <pre><code>UVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 111950000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp = 80000000 Act = 80000000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 112586000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80001000 Act = 80001000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 113222000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80003000 Act = 80003000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 113858000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80004000 Act = 80004000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 114494000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80012000 Act = 80012000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 115147000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80013000 Act = 80013000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 115801000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80014000 Act = 80014000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 116628000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80015000 Act = 80015000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 117283000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80016000 Act = 80016000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 117928000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80080000 Act = 80080000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 118594000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80100000 Act = 80100000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 119248000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80130000 Act = 80130000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 119854000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80131000 Act = 80131000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 120460000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80132000 Act = 80132000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 121065000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80133000 Act = 80133000\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/dfh_walking_seq.svh(73) @ 121672000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80140000 Act = 80140000\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5183-run-uvm-mmio-simulation","title":"5.1.8.3 Run UVM MMIO Simulation","text":"<p>Perform the following steps to run the UVM MMIO Simulation.</p> <ol> <li> <p>Run the MMIO test</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_VCS.mk run TESTNAME=mmio_test DUMP=1\n</code></pre> </li> <li> <p>Run the following commands to show the result of the scratchpad register and Hello FIM ID register. You can see the \"Data match\" message indicating that the registers are successfuly verified.</p> <pre><code>cd $VERDIR/sim/mmio_test\ncat runsim.log | grep \"Data\" | grep 1603\n</code></pre> <p>Expected output:</p> <pre><code>UVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/mmio_seq.svh(68) @ 115466000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] Data match 64! addr = 80016030, data = 880312f9558c00e1\nUVM_INFO /home/applications.fpga.ofs.fim-f2000x-pl/verification/tests/sequences/mmio_seq.svh(76) @ 116112000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] Data match 64! addr = 80016038, data = 6626070150000034\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#519-compile-the-f2000x-design-with-hello-fim","title":"5.1.9 Compile the f2000x Design with Hello FIM","text":"<p>Perform the following to compile the Hello FIM design.</p> <ol> <li>Ensure the pre-requesites described in the Pre-Requisites for Adding Hello FIM section are satisfied.</li> <li>Ensure that Intel Quartus Prime Pro is in your $PATH</li> <li> <p>Compile the design</p> <pre><code>$OFS_ROOTDIR/ofs-common/scripts/common/syn/build_top.sh -p f2000x work_hello_fim\n</code></pre> </li> <li> <p>Once compilation is complete, the output files can be found in the <code>$OFS_ROOTDIR/work_hello_fim/syn/syn_top/output_files</code> directory.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5110-program-the-f2000x-with-the-hellofim-design","title":"5.1.10 Program the f2000x with the HelloFIM Design","text":"<p>Perform the following steps to program the f2000x with the HelloFIM design generated in the previous section. This flow uses the RSU feature, which requires that an OPAE enabled design is already loaded on the FPGA. All OPAE commands are run from the SoC, and the new image will be updated from the SoC.</p> <ol> <li> <p>Use the <code>fpgainfo fme</code> command to obtain the PCIe <code>s:b:d.f</code> associated with your board. In this example, the PCIe <code>s:b:d.f</code> is <code>0000:15:00.0</code>.</p> <pre><code>fpgainfo fme\n</code></pre> <p>Example output:</p> <pre><code>Intel IPU Platform f2000x\nBoard Management Controller NIOS FW version: 1.1.9 Board Management Controller Build version: 1.1.9 //****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x5010302A97C08A3\nBitstream Version                : 5.0.1\nPr Interface Id                  : fb25ff1d-c31a-55d8-81d8-cbcedcfcea17\nBoot Page                        : user1\nUser1 Image Info                 : a566ceacaed810d43c60b0b8a7145591\nUser2 Image Info                 : a566ceacaed810d43c60b0b8a7145591\nFactory Image Info               : None\n</code></pre> </li> <li> <p>Navigate to the output directory in the Hello FIM work directory that contains the output files from compilation. </p> <pre><code>cd $OFS_ROOTDIR/work_hello_fim/syn/syn_top/output_files\n</code></pre> </li> <li> <p>Initiate the User Image 1 update by running <code>fpgasupdate</code> from a shell in the SoC. This will update User Image 1 stored in FPGA Flash. Remember to use the PCIe BDF associated with your board.</p> <pre><code>sudo fpgasupdate ofs_top_page1_unsigned_user1.bin 0000:15:00.0\n</code></pre> </li> <li> <p>Run the <code>rsu</code> command to re-configure the FPGA with User Image 1 from FPGA Flash.</p> <pre><code>sudo rsu fpga --page=user1 0000:15:00.0\n</code></pre> </li> <li> <p>Run the <code>fpgainfo fme</code> command again to verify the User1 Image Info has been updated.</p> <p>Example Output:</p> <pre><code>Intel IPU Platform f2000x\nBoard Management Controller NIOS FW version: 1.1.9 Board Management Controller Build version: 1.1.9 //****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x5010302A97C08A3\nBitstream Version                : 5.0.1\nPr Interface Id                  : fb25ff1d-c31a-55d8-81d8-cbcedcfcea17\nBoot Page                        : user1\nUser1 Image Info                 : 81d8cbcedcfcea17fb25ff1dc31a55d8\nUser2 Image Info                 : a566ceacaed810d43c60b0b8a7145591\nFactory Image Info               : None\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5111-verify-the-hello-fim-design-on-the-f2000x-using-opae","title":"5.1.11 Verify the Hello FIM Design on the f2000x Using OPAE","text":"<p>This section will describe how to access the Hello FIM registers using the opae.io tool.</p> <ol> <li> <p>Confirm the driver software on 0000:15:00.0</p> <pre><code>opae.io ls\n</code></pre> <p>Example output:</p> <pre><code>[0000:15:00.0] (0x8086:0xbcce 0x8086:0x17d4) Intel IPU Platform f2000x (Driver: dfl-pci)\n</code></pre> </li> <li> <p>Initialize the opae.io tool</p> <pre><code>opae.io init -d 15:00.0\n</code></pre> </li> <li> <p>Confirm the driver software on 0000:15:00.0 has been updated</p> <pre><code>opae.io ls\n</code></pre> <p>Example Output:</p> <pre><code>[0000:15:00.0] (0x8086:0xbcce 0x8086:0x17d4) Intel IPU Platform f2000x (Driver: vfio-pci)\n</code></pre> </li> <li> <p>Run the DFH Walker test to verify there is a module at offset <code>0x16000</code></p> <pre><code>opae.io walk -d 15:00.0\n</code></pre> <p>Example output:</p> <pre><code>offset: 0x0000, value: 0x4000000010000000\n   dfh: id = 0x0, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4\noffset: 0x1000, value: 0x3000000020000001\n    dfh: id = 0x1, rev = 0x0, next = 0x2000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x3000, value: 0x3000000010000007\n    dfh: id = 0x7, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x4000, value: 0x30000000e0001004\n    dfh: id = 0x4, rev = 0x1, next = 0xe000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x12000, value: 0x3000000010000013\n    dfh: id = 0x13, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x13000, value: 0x3000000010000013\n    dfh: id = 0x13, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x14000, value: 0x3000000010002015\n    dfh: id = 0x15, rev = 0x2, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x15000, value: 0x3000000010001009\n    dfh: id = 0x9, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x16000, value: 0x30000006a0000100\n    dfh: id = 0x100, rev = 0x0, next = 0x6a000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x80000, value: 0x3000000800002012\n    dfh: id = 0x12, rev = 0x2, next = 0x80000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x100000, value: 0x3000000300000014\n    dfh: id = 0x14, rev = 0x0, next = 0x30000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x130000, value: 0x3000000010001005\n    dfh: id = 0x5, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x131000, value: 0x4000000010001001\n    dfh: id = 0x1, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4\noffset: 0x132000, value: 0x3000000010001014\n    dfh: id = 0x14, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x133000, value: 0x30000000d0002013\n    dfh: id = 0x13, rev = 0x2, next = 0xd000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x140000, value: 0x3000010000002010\n    dfh: id = 0x10, rev = 0x2, next = 0x0, eol = 0x1, reserved = 0x0, feature_type = 0x3\n</code></pre> </li> <li> <p>Read all of the registers in the Hello FIM module</p> <ol> <li> <p>Read the DFH Register</p> <pre><code>opae.io -d 15:00.0 -r 0 peek 0x16000\n</code></pre> <p>Example Output:</p> <pre><code>0x30000006a0000100\n</code></pre> </li> <li> <p>Read the Scratchpad Register</p> <pre><code>opae.io -d 15:00.0 -r 0 peek 0x16030\n</code></pre> <p>Example Output:</p> <pre><code>0x0\n</code></pre> </li> <li> <p>Read the ID Register</p> <pre><code>opae.io -d 15:00.0 -r 0 peek 0x16038\n</code></pre> <p>Example Output:</p> <pre><code>0x6626070150000034\n</code></pre> </li> </ol> </li> <li> <p>Verify the scratchpad register at 0x16030 by writing and reading back from it.</p> <ol> <li> <p>Write to Scratchpad register</p> <pre><code>opae.io -d 0000:15:00.0 -r 0 poke 0x16030 0x123456789abcdef\n</code></pre> </li> <li> <p>Read from Scratchpad register</p> <pre><code>opae.io -d 15:00.0 -r 0 peek 0x16030\n</code></pre> <p>Expected output:</p> <pre><code>0x123456789abcdef\n</code></pre> </li> <li> <p>Write to Scratchpad register</p> <pre><code>opae.io -d 15:00.0 -r 0 poke 0x16030 0xfedcba9876543210\n</code></pre> </li> <li> <p>Read from Scratchpad register</p> <pre><code>opae.io -d 15:00.0 -r 0 peek 0x16030\n</code></pre> <p>Expected output:</p> <pre><code>0xfedcba9876543210\n</code></pre> </li> </ol> </li> <li> <p>Release the opae.io tool</p> <pre><code>opae.io release -d 15:00.0\n</code></pre> </li> <li> <p>Confirm the driver has been set back to <code>dfl-pci</code></p> <pre><code>opae.io ls\n</code></pre> <p>Example output:</p> <pre><code>[0000:15:00.0] (0x8086:0xbcce 0x8086:0x17d4) Intel IPU Platform f2000x (Driver: dfl-pci)\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#52-how-to-debug-the-fim-with-signal-tap","title":"5.2 How to Debug the FIM with Signal Tap","text":"<p>For debugging issues within the FIM, Signal Tap can be used to gain internal visibility into your design. This section describes the process of adding a Signal Tap instance to the Hello FIM design example described in the How to add a new module to the FIM section, however the process can be used for any design.</p> <p>For more detailed information on Signal Tap please see refer to Quartus Prime Pro Edition User Guide: Debug Tools (RDC Document ID 683819).</p> <p>Signal Tap uses the Intel FPGA Download Cable II USB device to provide access.  Please see Intel FPGA Download Cable II for more information. This device is widely available via distributors for purchase.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#521-adding-signal-tap-to-the-hello-fim-example","title":"5.2.1 Adding Signal Tap to the Hello FIM example","text":"<p>The following steps guide you through the process of adding a Signal Tap instance to your design. The added Signal Tap instance provides hardware to capture the desired internal signals and connect the stored trace information via JTAG. Please be aware that the added Signal Tap hardware will consume FPGA resources and may require additional floorplanning steps to accommodate these resources. Some areas of the FIM use logic lock regions and these regions may need to be re-sized. These steps assume the use of the  Intel IPU Platform F2000X-PL.  </p> <p>The steps below use the hello_fim example to add Signal Tap, however the general process can be used for any design.</p> <ol> <li> <p>The design must be synthesized before adding Signal Tap.</p> <ul> <li> <p>If you are using the previously built Hello FIM design, copy the work directory and rename it so that we have a work directory dedicated to the Hello FIM Signal Tap design.</p> <pre><code>cp -r $OFS_ROOTDIR/work_hello_fim $OFS_ROOTDIR/work_hello_fim_with_stp\n</code></pre> </li> </ul> <ul> <li> <p>If you are adding signal tap to a new design that has not yet been synthesized, perform the following steps to synthesize the design.</p> <ol> <li>Set the environment variables as described in the Setting Up Required Environment Variables section.</li> <li> <p>Run the setup portion of the build script to create a working directory based on the original source files.</p> <pre><code>./ofs-common/scripts/common/syn/build_top.sh --stage setup f2000x &lt;YOUR_STP_WORK_DIR&gt;\n</code></pre> </li> <li> <p>Open the project in the Intel Quartus Prime Pro GUI. The Intel Quartus Prime Pro project is named ofs_top.qpf and is located in the work directory <code>$OFS_ROOTDIR/&lt;YOUR_STP_WORK_DIR&gt;/syn/syn_top/ofs_top.qpf</code>.</p> </li> <li>In the Compilation Flow window, run Analysis &amp; Synthesis.</li> <li>Once Synthesis has completed, you may skip to Step 3.</li> </ol> </li> </ul> </li> <li> <p>Open the Hello FIM Signal Tap project in the Intel Quartus Prime Pro GUI. The Intel Quartus Prime Pro project is named ofs_top.qpf and is located in the work directory <code>$OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top/ofs_top.qpf</code>.</p> </li> <li> <p>Select Tools &gt; Signal Tap Logic Analyzer to open the Signal Tap GUI.</p> <p></p> </li> <li> <p>Accept the \"Default\" selection and click \"Create\".</p> <p></p> </li> <li> <p>This opens the Signal Tap Logic Analyzer window.</p> <p></p> </li> <li> <p>Set up the clock for the STP instance. This example instruments the hello_fim_top module previously intetegrated into the FIM. If unfamiliar with code, it is helpful to use the Intel Quartus Prime Pro Project Navigator to find the block of interest and open the design instance for review. For example, see the image below using Project Navigator to open the top module where hello_fim_top_inst is instantiated.</p> <p></p> </li> <li> <p>Assign the clock for sampling the Signal Tap instrumented signals of interest. Note, that the clock selected should be associated with the signals you want to view for best trace fidelity. Different clocks can be used, however, there maybe issues with trace inaccuracy due to sampling time differences. Ensure that all signals that are to be sampled are on the same clock domain as the clock you select here. In the middle right of the Signal Tap window, under Signal Configuration, Clock:, select \"\u2026\" as shown below:</p> <p></p> </li> <li> <p>In the Node Finder tool that popped up, input \"hello_fim_top_inst|clk\" into the \"Named:\" textbox and click \"Search\". Select \"clk\" in the Matching Nodes list and click the \"&gt;\" button to select this clock as shown below. Click \"OK\" to close the Node Finder dialog.</p> <p></p> </li> <li> <p>Update the sample depth and other Signal Tap settings as needed for your debugging criteria.</p> <p></p> </li> <li> <p>In the Signal Tap GUI add the nodes to be instrumented by double-clicking on the \"Double-click to add nodes\" legend.</p> <p></p> </li> <li> <p>This brings up the Node Finder to add the signals to be traced. In this example we will monitor the memory mapped interface to the Hello FIM. Select the signals that appear from the  search patterns hello_fim_top_inst|reset and hello_fim_top_inst|csr_lite_if*. Click Insert and close the Node Finder dialog.</p> <p></p> </li> <li> <p>To provide a unique name for your Signal Tap instance, select \"auto signaltap_0\", right-click, and select Rename Instance (F2). Provide a descriptive name for your instance, for example, \"STP_For_Hello_FIM\".</p> <p></p> </li> <li> <p>Save the newly created Signal Tap file, and give it the same name as the instance. Ensure that the Add file to current project checkbox is ticked.</p> <p></p> </li> <li> <p>In the dialog that pops up, click \"Yes\" to add the newly created Signal Tap file to the project settings files.</p> <p></p> <p>This will aurtomatically add the following lines to <code>$OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top/ofs_top.qsf</code>:</p> <pre><code>set_global_assignment -name ENABLE_SIGNALTAP ON\nset_global_assignment -name USE_SIGNALTAP_FILE STP_For_Hello_FIM.stp\nset_global_assignment -name SIGNALTAP_FILE STP_For_Hello_FIM.stp\n</code></pre> </li> <li> <p>Close all Quartus GUIs.</p> </li> <li> <p>Compile the project with the Signal Tap file added to the project. Use the -k switch to perform the compilation using the files in a specified working directory and not the original ones from the cloned repository. </p> <pre><code>ofs-common/scripts/common/syn/build_top.sh -p -k f2000x work_hello_fim_with_stp\n</code></pre> <p>Alternatively, you can copy the ofs_top.qsf and STP_For_Hello_FIM.stp files from the Hello FIM with STP work directory to replace the original files in the cloned OFS repository. In this scenario, all further FIM compilation projects will include the Signal Tap instance integrated into the design. Execute the following commands for this alternative flow:</p> <p>Copy the modified file \"work_hello_fim_with_stp/syn/syn_top/ofs_top.qsf\" over to the source OFS repository, into \"syn/syn_top/\".</p> <pre><code>cd $OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top\ncp ofs_top.qsf $OFS_ROOTDIR/syn/syn_top\ncp STP_For_Hello_FIM.stp $OFS_ROOTDIR/syn/syn_top\n</code></pre> <p>Compile the FIM using the files from the OFS repository to create a new work directory.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x work_hello_fim_with_stp_from_src_repo\n</code></pre> </li> <li> <p>Ensure that the compile completes successfully and meets timing:</p> <pre><code>***********************************\n***\n***        OFS_PROJECT: f2000x\n***        OFS_FIM: base\n***        OFS_BOARD: adp\n***        Q_PROJECT:  ofs_top\n***        Q_REVISION: ofs_top\n***        SEED: 0\n***        Build Complete\n***        Timing Passed!\n***\n***********************************\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#522-configuring-the-fpga-with-a-sof-image-via-jtag","title":"5.2.2 Configuring the FPGA with a SOF Image via JTAG","text":"<p>Every successful run of <code>build_top.sh</code> script creates the file <code>$OFS_ROOTDIR/&lt;WORK_DIRECTORY&gt;/syn/syn_top/output_files/ofs_top_hps.sof</code> which can be used with the Intel FPGA Download Cable II to load the image into the FPGA using the f2000x  JTAG access connector. </p> <p>Perform the steps described in the following sections to load the <code>ofs_fim.sof</code> image created in the previous section into the Agilex FPGA using the Intel FPGA Download Cable II. You will also use the Intel FPGA Download Cable II to access the Signal Tap instance via JTAG.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5221-connecting-to-intel-fpga-download-cable","title":"5.2.2.1 Connecting to Intel FPGA Download Cable","text":"<p>The f2000x  has a 10 pin JTAG header on the top side of the board.  This JTAG header provides access to either the Agilex FPGA or Cyclone\u00ae 10 BMC device.  Perform the followign steps to connect the Itel FPGA Download Cable II and target the Agilex device:</p> <ol> <li> <p>Locate SW2 and SW3 on the f2000x board as shown in the following figure.</p> <p></p> </li> <li> <p>Set the switches described in the following table:</p> Switch Position SW2 ON SW3.3 ON </li> <li> <p>Connect the Intel FPGA Download Cable to the JTAG header of the f2000x as shown in the figure below.</p> <p></p> </li> <li> <p>Depending on your server, install the card in a slot that allows room for the JTAG cable. The figure below shows the f2000x installed in a Supermicro server slot.</p> <p></p> </li> <li> <p>There are two JTAG modes that exist. Short-chain mode is when only the Cyclone 10 device is on the JTAG chain. Long-chain mode is when both the Cyclone 10 and the Agilex FPGA are on the JTAG chain. Check which JTAG mode the f2000x board is in by running the following command.</p> <pre><code>$QUARTUS_ROOTDIR/bin/jtagconfig\n</code></pre> <ul> <li> <p>Example output when in short-chain mode (only Cyclone 10 detected):</p> <pre><code>1) USB-BlasterII [3-4]\n020F60DD    10CL080(Y|Z)/EP3C80/EP4CE75\n</code></pre> </li> </ul> <ul> <li> <p>Example output when in long-chain mode (both Cyclone 10 and Agilex detected):</p> <p><pre><code>1) USB-BlasterII [3-4]\n020F60DD   10CL080(Y|Z)/EP3C80/EP4CE75\n234150DD   AGFC023R25A(.|AE|R0)\n</code></pre>   If the Agilex device does not appear on the chain, ensure that the switches described in Step 1 have been set correctly and power cycle the board.</p> </li> </ul> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#5222-programming-the-agilex-fpga-via-jtag","title":"5.2.2.2 Programming the Agilex FPGA via JTAG","text":"<p>Perform the following steps to program the Agilex FPGA via JTAG.</p> <ol> <li> <p>Set the JTAG Enable bit in BMC register 0x378. The BMC registers are accessed through SPI control registers at addresses 0x8040C and 0x80400. in the PMCI.</p> <p>Note: These commands must be executed as root user from the SoC.</p> <p>Note: You may find the PCIe BDF of your card by running <code>fpgainfo fme</code>.</p> <p>These commands must be executed every time a new FPGA SOF image is to be loaded prior to running the Intel Quartus Prime Pro programmer.</p> <p><pre><code>opae.io init -d &lt;BDF&gt;\nopae.io -d &lt;BDF&gt; -r 0 poke 0x8040c 0x100000000\nopae.io -d &lt;BDF&gt; -r 0 poke 0x80400 0x37800000002\nopae.io release -d &lt;BDF&gt;\n</code></pre> For example, for a board with PCIe BDF <code>15:00.0</code>: <pre><code>opae.io init -d 15:00.0\nopae.io -d 15:00.0 -r 0 poke 0x8040c 0x100000000\nopae.io -d 15:00.0 -r 0 poke 0x80400 0x37800000002\nopae.io release -d 15:00.0\n</code></pre></p> </li> <li> <p>The SOF file is located in the work directory $OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top/output_files/ofs_top_hps.sof. If the target FPGA is on a different server, then transfer ofs_top_hps.sof and STP_For_Hello_FIM.stp files to the server with the target FPGA.</p> </li> <li> <p>You can use a Full Intel Quartus Prime Pro Installation or Standalone Quartus Prime Programmer &amp; Tools running on the machine where the f2000x  is installed or on a separte machine such as a laptop.</p> <p>Note: You can download the Quartus Prime Programmer and Tools by clicking on the \"Additional Software\" tab on the FPGA download page. The Quartus Prime Programmer and Tools come with Quartus programmer as well as System Console which are needed to program the flash devices.</p> <p>Note: If using the Intel FGPA download Cable on Linux, add the udev rule as described in Intel FPGA Download Cable (formerly USB-Blaster) Driver for Linux.</p> </li> <li> <p>Temporarily disable the PCIe AER feature. This is required because when you program the FPGA using JTAG, the f2000x PCIe link goes down for a moment causing a server surprise link down event. To prevent this server event, temporarily disable PCIe AER and remove the root port connected to the f2000x  PCIe slot using the following steps:</p> <ol> <li> <p>Find the root port connected to the f2000x .  In this example, the f2000x  is assigned PCIe BDF 15:00, so you will use Linux lspci tree command to determine the root port.  </p> <p><pre><code>lspci -t\n</code></pre> Sample Output; <pre><code>...\n    +-[0000:14]-+-00.0\n   |           +-00.1\n   |           +-00.2\n   |           +-00.3\n   |           +-00.4\n   |           \\-02.0-[15]----00.0   # The root port for 15:00.0 is 14:02.0\n...\n</code></pre> In this example, we see that the root port PCIe BDF of 15:00.0 is 14:02.0.</p> </li> <li> <p>Disable AER on the f2000x  PCIe root port and remove the root port using the commands entered as root.</p> <p><pre><code>sudo su   </code></pre> <pre><code>setpci -s 0000:14:02.0 ECAP_AER+0x08.L=0xFFFFFFFF\nsetpci -s 0000:14:02.0 ECAP_AER+0x14.L=0xFFFFFFFF\n</code></pre></p> </li> </ol> </li> <li> <p>Launch \"Quartus Prime Programmer\" software from the device which the Intel FPGA Programmer is connected.</p> <pre><code>$QUARTUS_ROOTDIR/bin/quartus_pgmw\n</code></pre> <p>Click on Hardware Setup, select USB-BlasterII in the Current Selected Hardware list, and ensure the JTAG Hardware Frequency is set to 16Mhz (The default is 24MHz).</p> <p></p> <p>Alternatively, use the following command from the command line to change the clock frequency:</p> <pre><code>jtagconfig \u2013setparam \u201cUSB-BlasterII\u201d JtagClock 16M\n</code></pre> </li> <li> <p>Click Auto Detect and make sure the Agilex Device is shown in the JTAG chain. Select the Cyclone 10 and Agilex devices if prompted.</p> <p></p> </li> <li> <p>Right-click on the cell in the File column for the Agilex device and click on Change file</p> <p></p> </li> <li> <p>Select the generated ofs_top.sof file for the Agilex FPGA with the Signal Tap instrumented Hello FIM example. Remember that the output files are located under work_hello_fim_with_stp/syn/syn_top/output_files/.</p> </li> <li> <p>Tick the checkbox below \"Program/Configure\" column and click on Start to program this .sof file.</p> <p></p> </li> <li> <p>After successful programming, you can close the \"Quartus Prime Programmer\" software. You can answer 'No' if a dialog pops up asking to save the 'Chain.cdf' file. This completes the Agilex .sof programming.</p> </li> <li> <p>Remove the PCIe root port found earlier and re-scan the PCIe Bus.</p> <p>Note: enter the command as root.</p> <pre><code>sudo su\necho 1 &gt; /sys/bus/pci/devices/0000\\:14\\:02.0/remove\necho 1 &gt; /sys/bus/pci/rescan\nexit\n</code></pre> </li> <li> <p>Verify the f2000x is present by checking expected bitstream ID using <code>fpaginfo fme</code>:</p> <pre><code>fpgainfo fme\n</code></pre> <p>Example output: <pre><code>Intel IPU Platform f2000x-PL\nBoard Management Controller NIOS FW version: 1.1.9\nBoard Management Controller Build version: 1.1.9\n//****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x5010302A97C08A3\nBitstream Version                : 5.0.1\nPr Interface Id                  : cf00eed4-a82b-5f07-be25-0528baec3711\nBoot Page                        : user1\nUser1 Image Info                 : 9e3db8b6a4d25a4e3e46f2088b495899\nUser2 Image Info                 : 9e3db8b6a4d25a4e3e46f2088b495899\nFactory Image Info               : None\n</code></pre></p> <p>Note: The Image Info fields will not change, because these represent the images stored in flash. In this example, we are programming the Agilex FPGA directly, thus only the Bitstream ID should change.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#523-signal-tap-trace-acquisition-of-hello-fim-signals","title":"5.2.3 Signal Tap trace acquisition of Hello FIM signals","text":"<ol> <li> <p>Once the instrumented HelloFIM SOF file is downloaded into the Agilex FPGA, start the Quartus Signal Tap GUI.</p> <pre><code>$QUARTUS_ROOTDIR/bin/quartus_stpw\n</code></pre> </li> <li> <p>In the Signal Tap GUI, open your STP file. Your STP file settings will load. In this example we used <code>STP_For_Hello_FIM.stp</code>.</p> <p></p> </li> <li> <p>In the right pane of the Signal Tap GUI, in the Hardware: selection box select the cable <code>USB-BlasterII</code>. In the Device: selection box select the Agilex device.</p> <p></p> </li> <li> <p>If the Agilex Device is not displayed in the Device: list, click the 'Scan Chain' button to re-scan the JTAG device chain.</p> </li> <li> <p>If not already set, you can create the trigger conditions. In this example, we will capture data on a rising edge of the Read Address Valid signal.</p> <p></p> </li> <li> <p>Start analysis by selecting the 'STP_For_Hello_FIM' instance and pressing 'F5' or clicking the Run Analysis icon in the toolbar. You should see a green message indicating the Acquisition is in progress. Then, move to the Data Tab to observe the signals captured.</p> <p></p> </li> <li> <p>To generate traffic in the csr_lite_if signals of the Hello FIM module, go back to the terminal and walk the DFH list or peek/poke the Hello FIM registers as was done during the creation of the Hello FIM design example.</p> <pre><code>opae.io init -d 0000:15:00.0\nopae.io walk -d 0000:15:00.0\nopae.io release -d 0000:15:00.0\n</code></pre> <p>The signals should be captured on the rising edge of <code>arvalid</code> in this example. Zoom in to get a better view of the signals.</p> <p></p> </li> <li> <p>The PCIe AER feature is automatically re-enabled by rebooting the server. </p> </li> </ol> <p>This concludes the example on how to instrument an OFS FIM with the Quartus Prime Signal Tap Logic Analyzer.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#53-how-to-compile-the-fim-in-preparation-for-designing-your-afu","title":"5.3 How to compile the FIM in preparation for designing your AFU","text":"<p>To save area, the default Host Excercisers in the FIM can be replaced by a \"he_null\" block during compile-time. There are a few things to note:</p> <ul> <li>\"he_null\" is a minimal block with registers that responds to PCIe MMIO request. MMIO responses are required to keep PCIe alive (end points enabled in PCIe-SS needs service downstream requests).</li> <li>If an exerciser with other I/O connections such as \"he_mem\" or \"he_hssi\" is replaced, then then those I/O ports are simply tied off.</li> <li>The options supported are <code>null_he_lb</code>, <code>null_he_hssi</code>, <code>null_he_mem</code> and <code>null_he_mem_tg</code>. Any combination, order or all can be enabled at the same time. </li> <li>Finer grain control is provided for you to, for example, turn off only the exercisers in the Static Region in order to save area.</li> </ul> <p>To compile a FIM for where the exercisers are removed and replaced with a he_null module and keeping the PF/VF multiplexor connections, execute the following command.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x:null_he,null_he_hssi,null_he_mem,null_he_mem_tg work_null_he\n</code></pre>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#54-how-to-resize-the-partial-reconfiguration-region","title":"5.4 How to Resize the Partial Reconfiguration Region","text":"<p>To take advantage of the available resources in the Agilex FPGA for an AFU design, you can adjust the size of the AFU PR partition. An example reason for the changing the size of PR region is if you add more logic to the FIM region, then you may need to reduce the size of the PR region to fit the additional logic into the static region.  Similiarly, if you reduce logic in the FIM region, then you can increase the size of the PR region to provide more logic resources for the AFU.</p> <p>After the compilation of the FIM, the resources usage broken down by partitions is reported in the <code>Logic Lock Region Usage Summary</code> sections of following two files:</p> <ul> <li><code>$OFS_ROOTDIR/&lt;YOUR_WORK_DIRECTORY&gt;/syn/syn_top/output_files/ofs_top.fit.place.rpt</code></li> <li> <p><code>$OFS_ROOTDIR/&lt;YOUR_WORK_DIRECTORY&gt;/syn/syn_top/output_files/ofs_top.fit.rpt</code></p> <p></p> </li> </ul> <p>In this case, the default size for the <code>afu_top|port_gasket|pr_slot|afu_main</code> PR partition is large enough to comfortably hold the logic of the default AFU, which is mainly occupied by the Host Exercisers. However, larger designs might require additional resources.</p> <p>Perform the following steps to customize the resources allocated to the AFU in the PR regions:</p> <ol> <li> <p>The <code>$OFS_ROOTDIR/syn/setup/pr_assignments.tcl</code> TCL file defines the Logic Lock Regions in the design, including the PR partition where the AFU is allocated.</p> <p>The default design uses the the following Logic Lock Regions:</p> <pre><code>set TOP_MEM_REGION    \"X115 Y310 X219 Y344\"\nset BOTTOM_MEM_REGION \"X0 Y0 X294 Y20\"\nset SUBSYSTEM_REGION  \"X0 Y0 X60 Y279; X0 Y0 X300 Y39; X261 Y0 X300 Y129;\"\nset AFU_PLACE_REGION  \"X61 Y40 X260 Y309; X220 Y130 X294 Y329; X12 Y280 X114 Y329;\"\nset AFU_ROUTE_REGION  \"X0 Y0 X294 Y329\"\n</code></pre> <p>Each region is made up of rectangles defined by the origin (X0,Y0) and the top right corner (X1,Y1).</p> </li> <li> <p>Use Quartus Chip Planner to identify the locations of the resources available within the Agilex device for placement and routing your AFU. The image below shows the default floorplan for the f2000x Agilex device.</p> <p></p> </li> <li> <p>Make changes to the <code>$OFS_ROOTDIR/syn/setup/pr_assignments.tcl</code> file based on your findings in Quartus Chip Planner. You can modify the size and location of existing Logic Lock Regions or add new ones and assign them to the AFU PR partition. You will need to modify the coordinates of other regions assigned to the FIM accordingly to prevent overlap.</p> </li> <li> <p>Recompile your FIM and create the PR relocatable build tree using the following commands:</p> <pre><code>cd $OFS_ROOTDIR    ofs-common/scripts/common/syn/build_top.sh -p f2000x  &lt;YOUR_WORK_DIRECTORY&gt;\n</code></pre> </li> <li> <p>Analyze the resource utilization report per partition produced after recompiling the design.</p> </li> <li> <p>Make further modifications to the PR regions until the results are satisfactory. Make sure timing constraints are met.</p> </li> </ol> <p>Refer to the following documentation for more information on how to optimize the floor plan of your Partial Reconfiguration design:</p> <ul> <li>Analyzing and Optimizing the Design Floorplan</li> <li>Partial Reconfiguration Design Flow - Step 3: Floorplan the Design</li> </ul>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#55-how-to-modify-the-memory-subsystem","title":"5.5 How to modify the Memory Subsystem","text":"<p>In this example we will modify the Memory Subsystem to enable ECC on all of the existing memory interfaces. You may make different modifications to meet your own design requirements. Perform the following steps to make this change.</p> <ol> <li> <p>Clone the design repositories or use an existing design. See the Clone the OFS Git Repo section.</p> </li> <li> <p>Set the environment variables as described in the Setting Up Required Environment Variables section.</p> </li> <li> <p>Navigate to the directory containing the Memory Subsystem IP file <code>mem_ss_fm.ip</code>.</p> <pre><code>cd $OFS_ROOTDIR/ipss/mem/qip/mem_ss/ </code></pre> </li> <li> <p>Open the Memory Subsystem IP file in Platform Designer to perform the required edits. </p> <pre><code>qsys-edit mem_ss_fm.ip\n</code></pre> <p>The IP Parameter Editor GUI opens as shown below.</p> <p></p> </li> <li> <p>Select the \"Memory Interfaces\" tab to view the current configuration of the Memory Interfaces. You may make edits to the configuration of any of the interfaces as needed. The figure below shows the default configuration of Interface 3.</p> <p></p> </li> <li> <p>In this example we will enable ECC for all four interfaces. In Interface tabs 0 through 3, change the drop-down selection for Memory DQ width from <code>32 (no ECC)</code> to <code>40 (with ECC)</code>. The figure below shows this change for Interface 3.</p> <p></p> </li> <li> <p>Generate the HDL code by clicking the Generate HDL... button at the bottom right corner of the Platform Designer window. In the dialog box that appears next, review the HDL generation options and click the Generate button at the bottom right corner of the dialog box. Save the system if prompted to do so. Once the generation process is finished, close the Platform designer windows. </p> </li> <li> <p>Edit the <code>$OFS_ROOTDIR/ipss/mem/rtl/mem_ss_pkg.sv</code> file to change the <code>DDR4_DQ_WIDTH</code> from <code>32</code> to <code>40</code>.</p> <pre><code>// DDR PARAMS\n...\nlocalparam DDR4_DQ_WIDTH      = 40;\n</code></pre> </li> <li> <p>Edit the <code>$OFS_ROOTDIR/syn/setup/emif_loc.tcl</code> file to assign the pins required for ECC enabled interfaces.</p> <ol> <li> <p>Uncomment the <code>DQS4</code> pin assignments for all memory interfaces</p> <pre><code>#---------------------------------------------------------\n# EMIF CH0\n#---------------------------------------------------------\n...\n# # CH0 DQS4 (ECC)\nset_location_assignment PIN_A39 -to ddr4_mem[0].dq[32]\nset_location_assignment PIN_J35 -to ddr4_mem[0].dq[33]\nset_location_assignment PIN_C38 -to ddr4_mem[0].dq[34]\nset_location_assignment PIN_G34 -to ddr4_mem[0].dq[35]\nset_location_assignment PIN_G38 -to ddr4_mem[0].dq[36]\nset_location_assignment PIN_C34 -to ddr4_mem[0].dq[37]\nset_location_assignment PIN_J39 -to ddr4_mem[0].dq[38]\nset_location_assignment PIN_A35 -to ddr4_mem[0].dq[39]\nset_location_assignment PIN_C36 -to ddr4_mem[0].dqs[4]\nset_location_assignment PIN_A37 -to ddr4_mem[0].dqs_n[4]\nset_location_assignment PIN_G36 -to ddr4_mem[0].dbi_n[4]\n#---------------------------------------------------------\n# EMIF CH1\n#---------------------------------------------------------\n...\n# # CH1 DQS4 (ECC)\nset_location_assignment PIN_N7  -to ddr4_mem[1].dq[32]\nset_location_assignment PIN_L12 -to ddr4_mem[1].dq[33]\nset_location_assignment PIN_L6  -to ddr4_mem[1].dq[34]\nset_location_assignment PIN_U14 -to ddr4_mem[1].dq[35]\nset_location_assignment PIN_U7  -to ddr4_mem[1].dq[36]\nset_location_assignment PIN_W12 -to ddr4_mem[1].dq[37]\nset_location_assignment PIN_W6  -to ddr4_mem[1].dq[38]\nset_location_assignment PIN_N14 -to ddr4_mem[1].dq[39]\nset_location_assignment PIN_L9  -to ddr4_mem[1].dqs[4]\nset_location_assignment PIN_N10 -to ddr4_mem[1].dqs_n[4]\nset_location_assignment PIN_W9  -to ddr4_mem[1].dbi_n[4]\n#---------------------------------------------------------\n# EMIF CH2\n#---------------------------------------------------------\n...\n# CH2 DQS4 (ECC)\nset_location_assignment PIN_GC37 -to ddr4_mem[2].dq[32]\nset_location_assignment PIN_GC41 -to ddr4_mem[2].dq[33]\nset_location_assignment PIN_FY37 -to ddr4_mem[2].dq[34]\nset_location_assignment PIN_GE40 -to ddr4_mem[2].dq[35]\nset_location_assignment PIN_FV36 -to ddr4_mem[2].dq[36]\nset_location_assignment PIN_FY41 -to ddr4_mem[2].dq[37]\nset_location_assignment PIN_GE36 -to ddr4_mem[2].dq[38]\nset_location_assignment PIN_FV40 -to ddr4_mem[2].dq[39]\nset_location_assignment PIN_GE38 -to ddr4_mem[2].dqs[4]\nset_location_assignment PIN_GC39 -to ddr4_mem[2].dqs_n[4]\nset_location_assignment PIN_FV38 -to ddr4_mem[2].dbi_n[4]\n#---------------------------------------------------------\n# EMIF CH3\n#---------------------------------------------------------\n...\n# # CH3 DQS4 (ECC)\nset_location_assignment PIN_FP46 -to ddr4_mem[3].dq[32]\nset_location_assignment PIN_FT43 -to ddr4_mem[3].dq[33]\nset_location_assignment PIN_FH47 -to ddr4_mem[3].dq[34]\nset_location_assignment PIN_FP42 -to ddr4_mem[3].dq[35]\nset_location_assignment PIN_FT47 -to ddr4_mem[3].dq[36]\nset_location_assignment PIN_FH43 -to ddr4_mem[3].dq[37]\nset_location_assignment PIN_FK46 -to ddr4_mem[3].dq[38]\nset_location_assignment PIN_FK42 -to ddr4_mem[3].dq[39]\nset_location_assignment PIN_FP44 -to ddr4_mem[3].dqs[4]\nset_location_assignment PIN_FT45 -to ddr4_mem[3].dqs_n[4]\nset_location_assignment PIN_FK44 -to ddr4_mem[3].dbi_n[4]\n</code></pre> </li> <li> <p>Change the pin assignment for <code>ddr4_mem[1].dbi_n[4]</code> from <code>PIN_G12</code> to <code>PIN_W9</code></p> <pre><code>set_location_assignment PIN_W9  -to ddr4_mem[1].dbi_n[4]\n</code></pre> </li> </ol> </li> <li> <p>Compile the design.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x &lt;YOUR_WORK_DIRECTORY&gt;\n</code></pre> </li> <li> <p>You may need to adjust the floorplan of the design in order to meet timing after a design change such as this. Refer to the How to Resize the Partial Reconfiguration Region section for information regarding modifications to the floorplan.</p> </li> </ol> <p>The configuration edits described here were made to the original source files of the cloned OFS repository. Therefore, these modifications will present in subsequent FIM compilations. This is because the FIM compilation process links and copies source files from the cloned OFS repository to the FIM compilation work directory.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#56-how-to-compile-the-fim-with-no-hssi","title":"5.6 How to compile the FIM with No HSSI","text":"<p>In this example we will compile f2000x with the Ethernet subsystem removed. To perform the flat compile of the FIM with no Ethernet subsystem, pass the <code>no_hssi</code> and <code>flat</code> options to the build_top.sh script:</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh f2000x :flat,no_hssi &lt;YOUR_WORK_DIRECTORY&gt;\n</code></pre> <p>If you wish to build a PR enabled design, you may adjust the Logic Lock regions to allocate more resources to the PR region since the Ethernet subsystem has been removed from the FIM. Refer to the How to Resize the Partial Reconfiguration Region section for information regarding modifications to the floorplan.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#57-how-to-change-the-pcie-device-id-and-vendor-id","title":"5.7 How to change the PCIe device ID and Vendor ID","text":"<p>The PCIe configuration registers contains the Vendor, Device and Subsystem Vendor ID registers which are used in PCIe add-in cards to uniquely identify the card for assignment to software drivers.  OFS has these registers set with Intel values for out of the box usage.  If you are using OFS for a PCIe add in card that your company manufactures, then update the PCIe Subsytem Subsystem ID and Vendor ID registers as described below and change OPAE provided software code to properly operate with your company's register values.</p> <p>The Vendor ID is assigned to your company by the PCI-SIG (Special Interest Group). The PCI-SIG is the only body officially licensed to give out IDs. You must be a member of PCI-SIG to request your own ID. Information about joining PCI-SIG is available here: PCI-SIG. You select the Subsystem Device ID for your PCIe add in card.</p> <p>Follow the instructions below to customize the PCIe device ID and Vendor ID of the f2000x  PLPlatform.</p> <p>You can display the current settings using the command <code>lspci -nvmms &lt;PCIe B.D.f&gt;</code> as shown below:</p> <p><pre><code>lspci -nvmms 98:00\n</code></pre> Example Output:</p> <pre><code>Slot:   98:00.0\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nRev:    01\nNUMANode:       1\nSlot:   98:00.1\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\nSlot:   98:00.2\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\nSlot:   98:00.3\nClass:  1200\nVendor: 1af4\nDevice: 1000\nSVendor:        1af4\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\nSlot:   98:00.4\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\n</code></pre>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#571-changing-the-pcie-subsystem-device-id-and-vendor-id","title":"5.7.1 Changing the PCIe Subsystem Device ID and Vendor ID","text":"<p>You will use IP Parameter Editor to modify the PCIe configuration registers.</p> <ol> <li> <p>Navigate to the PCIe Subsystem IP file and bring up IP Parameter Editor to change values.</p> <p>Note: Both the Host and SoC PCIe subsystems use the same IP module, so the following changes to Device ID and Vendor ID will be reflected in both the Host and SoC PCIe Subsystems.</p> <p><pre><code>cd $OFS_ROOTDIR/ipss/pcie/qip/ss\nqsys-edit pcie_ss.ip\n</code></pre> The IP Parameter Editor GUI will open.  Close any tool pop-ups.</p> <p></p> </li> <li> <p>Scroll down through the PCIe subsystem settings tabs to the PCIe Interfaces 0 Ports Settings tab as shown below:</p> <p></p> <p>Select the PCIe0 Device Identification Registers tab. You can edit the values of Vendor ID, Device ID, Subsystem Vendor ID and Subsystem Device ID for each PF/VF in use.</p> </li> <li> <p>Once you have made changes, click Generate HDL and save. </p> </li> <li>Make sure the environment variables are set as described in the Setting Up Required Environment Variables section.</li> <li> <p>Build your new FPGA image with build_top.sh script</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x work_pcie_vid\n</code></pre> </li> </ol> <p>Be aware that OPAE FPGA management commands require recognition of the FPGA PCIe Device ID for control.  If there is a problem between OPAE management recognition of FPGA PCIe values, then control of the card will be lost.  For this reason, you are strongly encouraged to initially confiugre the FPGA via JTAG to load the test FPGA image. Instructions for thes process are given in the Configuring the FPGA with a SOF Image via JTAG section. If there is a problem with the SOF image working with your host software that is updated for the new PCIe settings, then you can load a known good SOF file to recover.  Once you sure that both the software and FPGA work properly, you can load the FPGA into FPGA flash using the OPAE command <code>fpgasupdate</code>.</p> <p>The changes to software required to work with new PCIe settings are described in Software Reference Manual: Intel Open FPGA Stack </p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#58-how-to-migrate-to-a-different-agilex-device-number","title":"5.8 How to migrate to a different Agilex device number","text":"<p>The following instructions enable you to change the Agilex FPGA device part number of the f2000x, for example, to migrate to a device with a larger density. Be aware that this release works with Agilex devices that have P-tile for PCIe and E-tile for Ethernet.</p> <p>The default device for the Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL is AGFC023R25A2E2VR0</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#581-migrating-to-a-larger-device-with-the-same-package","title":"5.8.1 Migrating To a Larger Device With the Same Package","text":"<p>Perform the following steps to change the device to a larger density with the same package.</p> <ol> <li> <p>Clone the design repository. See the Clone the OFS Git Repo section.</p> </li> <li> <p>Set the environment variables as described in the Setting Up Required Environment Variables section.</p> </li> <li> <p>Navigate to the OFS Root Directory</p> <pre><code>cd $OFS_ROOTDIR\n</code></pre> </li> <li> <p>Use the following command to change the device part number throughout the OFS Root directory heirarchy, replacing <code>&lt;DEFAULT_OPN&gt;</code> and <code>&lt;NEW_OPN&gt;</code> with the part numbers specific to your update:</p> <pre><code>grep -rli '&lt;DEFAULT_OPN&gt;' * | xargs -i@ sed -i 's/&lt;DEFAULT_OPN&gt;/&lt;NEW_OPN&gt;/g' @\n</code></pre> <p>For example, use the following command to change from part AGFC023R25A2E2VR0 to part AGFA027R25A2E2VR0:</p> <pre><code>grep -rli 'AGFC023R25A2E2VR0'* | xargs -i@ sed -i 's/AGFC023R25A2E2VR0/AGFA027R25A2E2VR0/g' @\n</code></pre> <p>This changes all occurrences of the default device (AGFC023R25A2E2VR0) in the $OFS_ROOTDIR directory to the new device number (AGFA027R25A2E2VR0).</p> </li> <li> <p>Compile the flat (non-PR) design to verify the compilation is successful with the new part. The flat design is compiled without any Logic Lock constraints.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh f2000x:flat  &lt;YOUR_WORK_DIRECTORY&gt;\n</code></pre> </li> <li> <p>To enable the PR region, use Quartus Chip Planner to analyze the compiled flat design and adjust the Logic Lock constraints defined in <code>$OFS_ROOTDIR/syn/setup/pr_assignments.tcl</code> for the new device layout. Refer to the How to Resize the Partial Reconfiguration Region section for instructions. Re-compile the design with the out-of-tree PR region enabled.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x  &lt;YOUR_WORK_DIRECTORY&gt;\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#59-how-to-change-ethernet-interface-from-8x25-gbe-to-8x10-gbe","title":"5.9 How to change Ethernet interface from 8x25 GbE to 8x10 GbE","text":"<p>This section describes steps to change the Ethernet interface from 8x25 GbE to 8x10 GbE. </p> <ol> <li> <p>Edit the HSSI IP Subsystem $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss_8x25g.ip to be 8x10 GbE using IP Platform Editor.</p> <pre><code>cd $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss\nqsys-edit hssi_ss_8x25g.ip\n</code></pre> </li> <li> <p>The IP Prameter Editer comes up - expect 2-5 minutes for this process to complete.  When the pop-up indicates Open System Completed, click Close.  When the General Configuration window comes up, scroll down and switch ports 0 through 7 from 25GbE to 10GbE as shown below:</p> <p></p> </li> <li> <p>Click the IP Configuration tab and note the default settings of OFF for AN/LT and SYNCE.  You may optionally change these settings based on your application needs. The settings for P0 IP cover ports 0 to 3.  The settings for P4 cover ports 4 to 7.</p> <p></p> </li> <li> <p>Click \"P0 Configuration\" tab and note the default settings for maximum frame size.  You may optionally change these settings based on your application needs.  Set \"P4 Configuration\" as needed. </p> <p></p> </li> <li> <p>Leave other settings at default values.</p> </li> <li>Click <code>File</code> and <code>Save As</code> hssi_ss_8x10g.ip  Click <code>Generate HDL</code> in the bottom right hand corner of IP Editor and enable simulation support.</li> <li> <p>Edit $OFS_ROOTDIR/ipss/hssi/eth_design_files.tcl to comment out 8x25g and add in 8x10g.ip</p> <pre><code>#-----------------\n# HSSI SS IP\n#-----------------\n#set_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_8x10g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/ptp_iopll/ptp_sample_clk_pll.ip\n</code></pre> </li> <li> <p>Edit $OFS_ROOTDIR/syn/syn_top/ofs_top.qsf and $OFS_ROOTDIR/syn/syn_top/ofs_pr_afu.qsf to add new macro definition:</p> <pre><code>set_global_assignment -name VERILOG_MACRO \"ETH_10G\"    # Change Ethernet from 8x25 to 8x10 GbE\n</code></pre> </li> <li> <p>Build new 8x10G FIM</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x work_8x10gbe\n</code></pre> </li> <li> <p>You may need to adjust the floorplan of the design in order to meet timing after a design change such as this. Refer to the How to Resize the Partial Reconfiguration Region section for information regarding modifications to the floorplan.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#510-how-to-change-ethernet-interface-from-8-x-25-gbe-to-2-x-100-gbe","title":"5.10 How to change Ethernet interface from 8 X 25 GbE to 2 X 100 GbE","text":"<p>This section describes steps to change the Ethernet interface from 8 X 25 GbE to 2 x 100 GbE. </p> <ol> <li> <p>Edit HSSI IP Subsystem $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip to be 2 X 100 GbE using IP Platform Editor.</p> <pre><code>cd $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss\nqsys-edit hssi_ss_8x25g.ip\n</code></pre> </li> <li> <p>The IP Prameter Editer comes up - expect 2-5 minutes for this process to complete.  When pop-up indicates Open System Completed, click 'Close'.  The General Configuration window comes up, change ports to 2 and set \"PORT0_PROFILE\" and \"PORT4_PROFILE\" to \"100GCAUI-4\" as shown below:</p> <p></p> </li> <li> <p>Click the IP Configuration tab and note the default settings of OFF for AN/LT and SYNCE.  You may optionally change these settings based on your application needs.</p> <p></p> </li> <li> <p>Click \"P0 Configuration\" tab and note the default settings for maximum frame size.  You may optionally change these settings based on your application needs.  Set \"P4 Configuration\" as needed. </p> <p></p> </li> <li> <p>Leave other settings at default values.</p> </li> <li> <p>Click <code>File</code> and <code>Save As</code> hssi_ss_2x100g.  Click <code>Generate HDL</code> in the bottom right hand corner of IP Editor and enable simulation support.</p> </li> <li> <p>Edit $OFS_ROOTDIR/ipss/hssi/eth_design_files.tcl to comment out 8x25g and add in 2x100g.ip</p> <pre><code>#-----------------\n# HSSI SS IP\n#-----------------\n#set_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_2x100g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/ptp_iopll/ptp_sample_clk_pll.ip\n</code></pre> </li> <li> <p>Edit $OFS_ROOTDIR/syn/syn_top/ofs_top.qsf and $OFS_ROOTDIR/syn/syn_top/ofs_pr_afu.qsf to add new macro definition:</p> <pre><code>set_global_assignment -name VERILOG_MACRO \"ETH_100G\"      # Change Ethernet from 8x25 to 2x100 GbE\n</code></pre> </li> <li> <p>Update $OFS_ROOTDIR/syn/setup/eth_top.sdc:</p> <pre><code>#Timing for 100G\nset_false_path -from [get_clocks {sys_pll|iopll_0_clk_100m}] -to [get_clocks {hssi_wrapper|hssi_ss|hssi_ss_0|U_hssi_ss_ip_wrapper|U_hssi_ss_ip_top_p*|alt_ehipc3_fm_0|alt_ehipc3_fm_top_p*|alt_ehipc3_fm_hard_inst|E100GX4_FEC.altera_xcvr_native_inst|xcvr_native_s10_etile_0_example_design_4ln_ptp|tx_clkout|ch0}]; \n\nset_false_path -from [get_clocks {hssi_wrapper|hssi_ss|hssi_ss_0|U_hssi_ss_ip_wrapper|U_hssi_ss_ip_top_p*|alt_ehipc3_fm_0|alt_ehipc3_fm_top_p*|alt_ehipc3_fm_hard_inst|E100GX4_FEC.altera_xcvr_native_inst|xcvr_native_s10_etile_0_example_design_4ln_ptp|tx_clkout|ch0}] -to [get_clocks {sys_pll|iopll_0_clk_100m}];   \n</code></pre> </li> <li> <p>Build new 2x100G FIM.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x work_2x100gbe\n</code></pre> </li> <li> <p>You may need to adjust the floorplan of the design in order to meet timing after a design change such as this. Refer to  for information regarding modifications to the floorplan.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#511-how-to-add-more-transceiver-channels-the-ethernet-subsystem","title":"5.11 How to add more Transceiver channels the Ethernet Subsystem","text":"<p>This section describes how to add 4 extra Ethernet channels to the existing f2000x FIM design which uses the 8x25G (2x4x25G) as the default ethernet configuration.</p> <p>In this exercise we will add 4 extra channels to make a total of 12 channels. This configuration will be called 12x25G.</p> <ol> <li>Clone the design repository or use an existing design. See the Clone the OFS Git Repo section.</li> <li>Set the environment variables. See the Setting Up Required Environment Variables section.</li> <li> <p>Navigate to the directory containing the existing Ethernet Subsystem IP <code>hssi_ss_8x25g.ip</code>.</p> <pre><code>cd $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss\n</code></pre> </li> <li> <p>Create a copy of the existing 8x25G IP and name it <code>hssi_ss_12x25g.ip</code>.</p> <pre><code>cp hssi_ss_8x25g.ip hssi_ss_12x25g.ip\n</code></pre> </li> <li> <p>Open the newly created <code>hssi_ss_12x25g.ip</code> file in Platform Designer.</p> <pre><code>qsys-edit hssi_ss_12x25g.ip\n</code></pre> </li> <li> <p>In the HSSI Subsystem &gt; Device 0 Configuration &gt; Main Configuration tab, change the NUM_ENABLED_PORTS value from <code>8</code> to <code>12</code>. </p> <p></p> </li> <li> <p>In the HSSI Subsystem &gt; Device 0 Configuration &gt; Main Configuration tab, enable Ports 8 through 11, using the same configuration as the original 8 transceiver ports.</p> <p></p> <p></p> </li> <li> <p>Click Generate HDL. Close Platform Designer once generation is complete with no errors.</p> </li> <li> <p>Edit <code>$OFS_ROOTDIR/ipss/hssi/eth_design_files.tcl</code></p> <ol> <li> <p>Comment out the old 8x25G IP and and the new 12x25G IP in the HSSI SS IP section</p> <pre><code>#set_global_assignment -name IP_FILE ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip\nset_global_assignment -name IP_FILE ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_12x25g.ip\n</code></pre> </li> </ol> </li> <li> <p>Edit <code>$OFS_ROOTDIR/ipss/hssi/rtl/hssi_wrapper.sv</code></p> <ol> <li> <p>In the HSSI SS Instantiation section, replace the existing 8x25G IP instantiation with the new 12x25G IP instantiation.</p> <pre><code>//hssi_ss_8x25g\nhssi_ss_12x25g\n</code></pre> </li> <li> <p>In the Serial signal mapping to QSFP section, after the <code>else</code> statement, add the 4 new Ethernet ports:</p> <pre><code>`ifdef INCLUDE_HSSI_PORT_8\nassign serial_rx_p[PORT_8] = qsfp_serial[2].rx_p[0];\nassign serial_rx_n[PORT_8] = 1'b0;\nassign qsfp_serial[2].tx_p[0] = serial_tx_p[PORT_8];\n`endif\n`ifdef INCLUDE_HSSI_PORT_9\nassign serial_rx_p[PORT_9] = qsfp_serial[2].rx_p[1];\nassign serial_rx_n[PORT_9] = 1'b0;\nassign qsfp_serial[2].tx_p[1] = serial_tx_p[PORT_9];\n`endif\n`ifdef INCLUDE_HSSI_PORT_10\nassign serial_rx_p[PORT_10] = qsfp_serial[2].rx_p[2];\nassign serial_rx_n[PORT_10] = 1'b0;\nassign qsfp_serial[2].tx_p[2] = serial_tx_p[PORT_10];\n`endif\n`ifdef INCLUDE_HSSI_PORT_11\nassign serial_rx_p[PORT_11] = qsfp_serial[2].rx_p[3];\nassign serial_rx_n[PORT_11] = 1'b0;\nassign qsfp_serial[2].tx_p[3] = serial_tx_p[PORT_11];\n`endif\n</code></pre> </li> </ol> </li> <li> <p>Edit <code>$OFS_ROOTDIR/ipss/hssi/rtl/inc/ofs_fim_eth_plat_defines.svh</code></p> <ol> <li> <p>Define the new port macros in the section configuring 25G with no CVL</p> <pre><code>`define INCLUDE_HSSI_PORT_8\n`define INCLUDE_HSSI_PORT_9\n`define INCLUDE_HSSI_PORT_10\n`define INCLUDE_HSSI_PORT_11\n</code></pre> </li> </ol> </li> <li> <p>Edit <code>$OFS_ROOTDIR/ipss/hssi/rtl/inc/ofs_fim_eth_plat_if_pkg.sv</code></p> <ol> <li> <p>Change the parameter defining the number of QSFP ports from <code>2</code> to <code>3</code></p> <pre><code>localparam NUM_QSFP_PORTS = 3; // QSFP cage on board\n</code></pre> </li> <li> <p>Change the number of ethernet channels parameter for the 25G with no CVL configuration from <code>8</code> to <code>12</code></p> <p>```verilog localparam NUM_ETH_CHANNELS = 12; // Ethernet Ports ````</p> </li> </ol> </li> <li> <p>Edit <code>$OFS_ROOTDIR/syn/setup/eth_loc.tcl</code></p> <ol> <li> <p>Edit the pinout file to assign pins for the new QSFP. In this example we are using Channels 8-11 in the E-tile.</p> <pre><code>set_location_assignment PIN_DL1  -to qsfp_serial[2].tx_p[0]\nset_location_assignment PIN_DN4  -to qsfp_serial[2].tx_p[1]\nset_location_assignment PIN_DY1  -to qsfp_serial[2].tx_p[2]\nset_location_assignment PIN_EB4  -to qsfp_serial[2].tx_p[3]\nset_location_assignment PIN_DL8  -to qsfp_serial[2].rx_p[0]\nset_location_assignment PIN_DN13 -to qsfp_serial[2].rx_p[1]\nset_location_assignment PIN_DY8  -to qsfp_serial[2].rx_p[2]\nset_location_assignment PIN_EB13 -to qsfp_serial[2].rx_p[3]\n</code></pre> </li> </ol> </li> <li> <p>Compile the design</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p f2000x &lt;YOUR_WORK_DIRECTORY&gt;\n</code></pre> </li> <li> <p>You may need to adjust the floorplan of the design in order to meet timing after a design change such as this. Refer to the How to Resize the Partial Reconfiguration Region section for information regarding modifications to the floorplan.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#512-how-to-modify-the-pfvf-mux-configuration","title":"5.12 How to modify the PF/VF MUX configuration","text":"<p>The PF/VF Configuration Tool allows you to easily reconfigure the default number of PFs and VFs on both the SoC and Host side of your design. To modify the PF/VF configuration, you must:</p> <ol> <li> <p>Decide which PCIe PF/VFs require modification.  If you are modifying host side PF/VF configuration, you must edit file <code>pcie_host.ofss</code> file found in <code>$OFS_ROOTDIR/tools/pfvf_config_tool</code>.  If you want to modify SoC-side PF/VF configuration, edit the <code>pcie_soc.ofss</code> file found in the same location.  </p> <p>The code given below show the default Host *.ofss file:</p> <pre><code>[ProjectSettings]\nplatform = f2000x family = Agilex\nfim = base_x16\nPart = AGFC023R25A2E2VR0\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = True\n\n[pf0]\n[pf1]\n</code></pre> <p>This default configuration is made up of two physical functions (PF), and neither of them has any virtual functions (VF). </p> </li> <li> <p>Modify the OFSS file with the new PF/VF configuration.</p> <p>An example modification to the OFSS file is shown below.  In this example we have changed the configuration to: 6 PFs in total, 4 VFs in PF0, 1 VF in PF2, and 2 VFs on PF3.  You can add up to 8 PFs and could conceivably add up to the number of VFs supported by the PCIe IP. Note that more PFs/VFs will use more FPGA resources, which may cause fitter challenges.</p> <pre><code>[ProjectSettings]\nplatform = f2000x family = Agilex\nfim = base_x16\nPart = AGFC023R25A2E2VR0\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = True\n\n[pf0]\nnum_vfs = 4\n[pf1]\n[pf2]\nnum_vfs = 1\n[pf3]\nnum_vfs = 2\n[pf4]\n[pf5]\n</code></pre> </li> <li> <p>Run the <code>gen_ofs_settings.py</code> script found in <code>$OFS_ROOTDIR/ofs-fim-common/tools/pfvf_config_tool</code>.</p> <pre><code>./gen_ofs_settings.py\u00a0 --ini $OFS_ROOTDIR/tools/pfvf_config_tool/&lt;PCIE_SOURCE&gt;.ofss --platform &lt;PLATFORM&gt;\n</code></pre> <p>For example, execute the following command to generate Host settings in an f2000x design:</p> <pre><code>./gen_ofs_settings.py\u00a0 --ini $OFS_ROOTDIR/tools/pfvf_config_tool/pcie_host.ofss --platform f2000x\n</code></pre> <p>This script reconfigures the FIM by:</p> <ol> <li>Updating the PF/VF Mux Package APIs:<ul> <li>$OFS_ROOTDIR/src/afu_top/mux/top_cfg_pkg.sv</li> </ul> </li> <li>Adding/removing AFU endpoints<ul> <li>PF0 VFs - afu_main.port_afu_instances</li> <li>All other functions: afu_top.fim_afu_instances</li> <li>New AFUs will be instantiated as HE-NULL (he_null.sv) AFUs</li> </ul> </li> <li>Updating the pcie_ss.sh \"ip-deploy\" file<ul> <li>Generating the new pcie_ss.ip file ($OFS_ROOTDOR/ipss/pcie/ss/pcie_ss.ip)</li> <li>Adding scratch register reads/writes to sim/csr_test for added functions</li> <li>Updating the simulation filelists ($OFS_ROOTDIR/sim/common/pfvf_sim_pkg.sv)</li> </ul> </li> </ol> <p>If the port gasket is enabled in the OFSS file, all functions in the PR region must be a virtual function (VF) on physical function 0 (PF0) and are routed to Port AFU Instances (port_afu_instances.sv) in the port gasket.  You can enable the port gasket in the ini (*.ofss file) by adding <code>pg_enable = True</code> under the <code>num_vfs</code> in PF0. In the 2023.1 OFS SoC Attach Release for Intel IPU Platform F2000X-PL the PR region is in the SoC AFU, so the SoC OFSS file has the port gasket enabled by default:</p> <pre><code>[ProjectSettings]\nplatform = f2000x family = Agilex\nfim = base_x16\nPart = AGFC023R25A2E2VR0\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = False\n\n[pf0]\npg_enable = True\nnum_vfs = 3\n</code></pre> <p>If the port gasket is disabled, the virtual functions on PF0 are routed to FIM AFU Instances (fim_afu_instances.sv) in the static region.  All physical functions and virtual functions not on PF0 are routed to the FIM AFU Instances module (fim_afu_instances.sv) in afu_top.</p> <p>After you run the <code>gen_ofs_settings.py</code> script you should see a final success report:</p> <pre><code>2022.07.28.21:46:38 Info: Regenerate these scripts whenever you make any change to any Quartus-generated IP in your project.\n2022.07.28.21:46:38 Info: Finished: Create simulation script\nsh: /home/applications.fpga.ofs.rtl/env_not_shipped/f2000x/update_sim.sh: No such file or directory\nSuccess!  Thank you for using the IP-Deploy Tool\n</code></pre> </li> <li> <p>Recompile the FIM using the <code>build_top.sh</code> script described in the Compiling the FIM section of this guide. </p> </li> <li> <p>Verify the correct functionality of new the PF/VF Mux configuration.</p> <p>New PF/VF are seamlessly connected to their own CSR stub, which can be read at DFH Offset 0x0. You can bind to the function and perform <code>opae.io peek</code> commands to read from the stub CSR. Similarly, perform <code>opae.io poke</code> commands to write into the stub CSRs. Use this mechanism to verify that the new PF/VF Mux configuration allows to write and read back values from the stub CSRs. </p> <p>The GUID for every new PF/VF CSR stub is the same.   </p> <ul> <li>NULL_GUID_L           = 64'haa31f54a3e403501</li> <li>NULL_GUID_H           = 64'h3e7b60a0df2d4850</li> </ul> <p>Limitations: Setting 0 virtual functions on SoC PF0 is not supported. This is because the PR region cannot be left unconnected. A loopback may need to be instantiated in this special case. </p> <p>Load the newly compiled FIM to the card to test the functionality of the new PF/VF functions. Use the following commands to verify the number of PFs/VFs created:</p> <p><pre><code>sudo lspci -vvv -s b1:00.0 | grep VF\n</code></pre> Example output: <pre><code>Initial VFs: 4, Total VFs: 4, Number of VFs: 0, Function Dependency Link: 00\nVF offset: 6, stride: 1, Device ID: bccf               </code></pre></p> <p>Note: The PCIe B:D.F associated with your board may be different. Use the <code>fpgainfo fme</code> command to see the PCIe B:D:F for your board.</p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#513-how-to-create-a-minimal-fim","title":"5.13 How to Create a Minimal FIM","text":"<p>In this example, the exercisers and Ethernet subsystem are removed and a new AFU PR area is used to make use of the added area from the removed components.  This minimal FIM is useful for HDL applications.</p> <p>To create this minimal FIM, perform the following steps:</p> <ol> <li> <p>Change the PF/VF configuration to support only 1 PF with 1 VF. Edit the following files in the <code>$OFS_ROOTDIR/tools/pfvf_config_tool/</code> directory as shown below:</p> <ol> <li> <p><code>$OFS_ROOTDIR/tools/pfvf_config_tool/pcie_host.ofss</code></p> <pre><code>[ProjectSettings]\nplatform = f2000x family = Agilex\nfim = base_x16\nPart = AGFC023R25A2E2VR0\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = True\n\n[pf0]\n</code></pre> </li> <li> <p><code>$OFS_ROOTDIR/tools/pfvf_config_tool/pcie_soc.ofss</code> </p> <pre><code>[ProjectSettings]\nplatform = f2000x family = Agilex\nfim = base_x16\nPart = AGFC023R25A2E2VR0\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = soc_pcie_ss\nComponentName = pcie_ss\nis_host = False\n\n[pf0]\nnum_vfs = 1\npg_enable = True\n</code></pre> </li> </ol> </li> <li> <p>Save the modified ofs_dev.ofss file and build a new configuration.</p> <pre><code>python3 gen_ofs_settings.py --ini $OFS_ROOTDIR/tools/pfvf_config_tool/pcie_host.ofss --platform f2000x\n\npython3 gen_ofs_settings.py --ini $OFS_ROOTDIR/tools/pfvf_config_tool/pcie_soc.ofss --platform f2000x\n</code></pre> </li> <li> <p>Compile the new FIM with exercisers removed.</p> <pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh -p f2000x:null_he,null_he_lp,null_he_hssi,null_he_mem,null_he_mem_tg,no_hssi work_null_he_no_hssi\n</code></pre> </li> <li> <p>The build will complete with reduced resources as compared to the base version. You may review the floorplan in Quartus Chip Planner and modify the Logic Lock regions to allocate more resources to the PR region if desired. Refer to the How to Resize the Partial Reconfiguration Region section for information regarding modifications to the floorplan. </p> </li> </ol>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#6-single-event-upset-reporting","title":"6 Single Event Upset Reporting","text":"<p>A Single Event Upset (SEU) is the change in state of a storage element inside a device or system. They are caused by ionizing radiation strikes that discharge the charge in storage elements, such as configuration memory cells, user memory and registers.</p> <p>Error Detection CRC (EDCRC) circuitry in the Card BMC is used to detect SEU errors. The CRC function is enabled in Intel Quartus Prime Pro to enable CRC status to be reported to the FM61 via the dedicated CRC_ERROR pin.</p> <p>With the EDCRC there is no method to determine the severity of an SEU error i.e. there is not way to distinguish between non-critical and catastrophic errors. Hence once the SEU error is detected, the Host system must initiate the Card BMC reset procedure.</p> <p>SEU errors can be read from either the Card BMC SEU Status Register or the PMCI Subsystem SEU Error Indication Register. The processes to read these registers are described in greater detail in the BMC User Guide. Contact your Intel representative for access to the BMC User Guide.</p> <p>Additionally, refer to the Intel Agilex SEU Mitigation User Guide for more information on SEU detection and mitigation.</p>"},{"location":"hw/f2000x/dev_guides/fim_dev/ug_dev_fim_ofs_f2000x/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/f2000x/doc_modules/Glossary/","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to user space."},{"location":"hw/f2000x/doc_modules/Notices_%26_Disclaimers/","title":"Notices & Disclaimers","text":""},{"location":"hw/f2000x/doc_modules/Notices_%26_Disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for the safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/","title":"FPGA Interface Manager Technical Reference Manual for Intel Agilex SoC Attach: Open FPGA Stack","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1-overview","title":"1 Overview","text":""},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document describes the hardware architecture for the SoC Attach reference FIM of the Open FPGA Stack (OFS) targeting the Intel\u00ae Agilex FPGA.  After reviewing this document you should understand the features and functions of the components that comprise the FPGA Interface Manager (FIM), also known as the \"shell.\"</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#12-glossary","title":"1.2 Glossary","text":"Term Abbreviation Description Advanced\u00a0Error\u00a0Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link) Accelerator\u00a0Functional\u00a0Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.\u00a0Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region. Basic Building Block BBB Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. Best\u00a0Known\u00a0Configuration BKC The software and hardware configuration Intel uses to verify the solution. Board\u00a0Management\u00a0Controller BMC Supports features such as board power managment, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate component, such as an Intel\u00ae Max\u00ae 10 or Intel Cyclone\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA. Configuration and\u00a0Status\u00a0Register CSR The generic name for a register space which is accessed in order to interface with the module it resides in (e.g. AFU, BMC, various sub-systems and modules). Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Device\u00a0Feature\u00a0List DFL The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\u00a0This concept is the foundation for the OFS software framework. (link) FPGA\u00a0Interface\u00a0Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FPGA\u00a0Management\u00a0Engine FME Performs reconfiguration and other FPGA management functions. Each FPGA device only has one FME which is accessed through PF0. Host\u00a0Exerciser\u00a0Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Intel\u00a0Virtualization\u00a0Technology for\u00a0Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Joint Test Action Group JTAG Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. Memory\u00a0Mapped\u00a0Input/Output MMIO The memory space users may map and access both control registers and system memory buffers with accelerators. oneAPI Accelerator Support Package oneAPI-asp A collection of hardware and software components that enable oneAPI kernel to communicate with oneAPI runtime and OFS shell components. oneAPI ASP hardware components and oneAPI kernel form the AFU region of a oneAPI system in OFS. Open\u00a0FPGA\u00a0Stack OFS OFS is a software and hardware infrastructure providing an efficient approach to develop a custom FPGA-based platform or workload using an Intel, 3rd party, or custom board. Open\u00a0Programmable\u00a0Acceleration\u00a0Engine Software Development Kit OPAE SDK The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Platform\u00a0Interface\u00a0Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Platform Management Controller Interface PMCI The portion of the BMC that resides in the Agilex FPGA and allows the FPGA to communicate with the primary BMC component on the board. Partial Reconfiguration PR The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. For OFS designs, the PR region is referred to as the pr_slot. Port N/A When used in the context of the fpgainfo port command it represents the interfaces between the static FPGA fabric and the PR region containing the AFU. Remote System Update RSU The process by which the host can remotely update images stored in flash through PCIe. This is done with the OPAE software command \"fpgasupdate\". Secure Device Manager SDM The SDM is the point of entry to the FPGA for JTAG commands and interfaces, as well as for device configuration data (from flash, SD card, or through PCI Express* hard IP). Static Region SR The portion of the FPGA design that cannot be dynamically reconfigured during run-time. Single-Root\u00a0Input-Output\u00a0Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. SYCL SYCL SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Test Bench TB Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. Universal Verification Methodology UVM A modular, reusable, and scalable testbench structure via an API framework.  In the context of OFS, the UVM enviroment provides a system level simulation environment for your design. Virtual\u00a0Function\u00a0Input/Output VFIO An Input-Output Memory Management Unit (IOMMU)/device agnostic framework for exposing direct device access to userspace.\u00a0(link)"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#13-introduction-to-open-fpga-stack","title":"1.3 Introduction to Open FPGA Stack","text":"<p>The Open FPGA Stack (OFS) is a modular infrastructure of hardware platform components, open source unstreamed software, and broad ecosystem support that enables an efficient path to develop a custom FPGA platform.  OFS Provides a framework of FPGA synthesizable code, simulation environment and synthesis/simulation scripts. </p> <p>The key components of OFS include:</p> <ul> <li>Target development platforms such as Intel-branded  Acceleration Development Platforms (ADPs) and third-party platforms.</li> </ul> <ul> <li>Board Management Controller RTL and firmware that supports telemetry monitoring and capability for remote configuration updates.</li> </ul> <ul> <li>Source accessible, modular FPGA Interface  manager (FIM) RTL with a UVM infrastructure unit tests that can be leveraged for your own custom FIM design. The FIM can be thought of as the FPGA shell that provides the I/O ring and timing closed management components for the FPGA.</li> </ul> <ul> <li>Basic building blocks for interconnect and PF/VF translation and arbitration; Platform Interface Manager (PIM) which provides Avalon\u00ae and Arm\u00ae AMBA\u00ae 4 AXI4 bus compliant interfaces.</li> </ul> <ul> <li>AFU examples both in the git repository and workload examples provided by 3rd party vendors.</li> </ul> <ul> <li>Unit level simulation test suite</li> </ul> <ul> <li>System level simulation through a unified verification methodology (UVM)</li> </ul> <ul> <li>OPAE software development kit (APIs, up-streamed Linux drivers and software tools)</li> </ul> <ul> <li>Support for other frameworks to be built on top of the OPAE such as DPDK </li> </ul> <p>Figure 1-1 OFS Ingredients</p> <p></p> <p>These components are available in a two GitHub locations:</p> <ul> <li>OFS hardware GitHub site</li> <li>OPAE software GitHub site</li> </ul> <p>The OFS hardware repository supports hardware development and simulation.  Repositories for OFS high-level design support and board management controller RTL and firmware source code are also provided.  These repositories can be found in the Intel Opensource Technology GitHub location, which requires entitlement access.  To request access, please contact your local Intel sales representative.</p> <p>Table 1-2 OFS Hardware Repositories</p> Repository Contains OFS f2000x FIM Github Branch Contains FIM or shell RTL, automated compilation scripts, and unit tests and UVM framework. <p>The OPAE software GitHub site is fully opensource and contains resources for both software and workload developers.</p> <p>Table 1-3  OFS Software Repositories</p> OPAE Git Repository Folder Contains OPAE SDK Repo Contains the files for building and installing OPAE SDK from source. Linux DFL Contains OFS Linux drivers that are being upstreamed to the Linux kernel. ofs-platform-afu-bbb Contains the files and scripts to build the platform interface manager. opae-sim Contains the files for an AFU developer to build the Accelerator Functional Unit Simulation Environment (ASE) for workload development. <p>Providing the hardware and software source code and supporting test frameworks in a GitHub repository allows you to customize your designs with the latest versions easily.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#14-ofs-features","title":"1.4 OFS Features","text":"<p>The OFS architecture within the FPGA comprises two partitions:</p> <ul> <li>FPGA Interface Manager (FIM)</li> </ul> <ul> <li>Accelerator Functional Unit (AFU)     -   AFU SoC Dynamic Region and Static Region      -   AFU Host Static Region </li> </ul> <p>The FIM or shell provides platform management functionality, clocks, resets, and interface access to the host and peripheral features of the acceleration platform. </p> <p>The FIM architecture along with the supporting OPAE software supports features such as partial reconfiguration and virtualization.</p> <p>The FIM provides a standard Arm\u00ae AMBA\u00ae 4 AXI4 datapath interface. The FIM resides in the static region of the FPGA.</p> <p>The AFU partition is provided for custom acceleration workloads and may contain both static and partial reconfiguration regions.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#141-fpga-interface-manager-fim","title":"1.4.1 FPGA Interface Manager (FIM)","text":"<p>The updated OFS architecture for Intel\u00ae Agilex\u00ae FPGA devices improves upon the modularity, configurability and scalability of the first release of the OFS architecture while maintaining compatibility with the original design.  The primary components of the FPGA Interface Manager or shell of this reference design are: </p> <ul> <li>P-tile PCIe Subsystem</li> <li>E-Tile Ethernet Subsystem</li> <li>Memory Subsystem</li> <li>Reset Controller</li> <li>FPGA Management Engine (FME)</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from Host or AFU</li> <li>Platform Management Controller Interface (PMCI) to the board management controller</li> </ul> <p>The AFU Region provides design space for custom workloads and contains both static and partial reconfiguration regions.  Partial reconfiguration allows you to update your specific logic blocks or entire workload while the rest of your static design is still in operation.</p> <p>Note that as discussed previously, the BMC RTL and firmware, the OFS OPAE software stack and support for building your own customer board support package are also provided in separate OFS repositories.</p> <p>Figure 1-2 OFS for OFS FIM Platform Block Diagram</p> <p></p> <p>The table provides an overview of the OFS features targeting the Intel\u00ae Agilex\u00ae FPGA.  This reference FIM (shell) is a starting point for your custom FPGA design.  With this initial starting point, you can add or subtract interfaces or ports to different Agilex devices.</p> <p>Table 1-4 OFS FIM for Intel\u00ae Agilex\u00ae FPGA Features</p> Key Feature Description PCIe P-tile PCIe* Gen4x16 to the HostP-tile PCIe* Gen4x16 to the SoC (IceLake-D) Virtualization Host: 2 physical functions SoC:   1 physical function and 3 Virtual functions Memory Four Fabric DDR4 banks, x40 (optional ECC, be configured as x32 and ECC x8 ), 1200 MHz, 4GB Ethernet Eight Arm\u00ae AMBA\u00ae 4 AXI4-Stream channels of 25G Ethernet interfacing to an E-tile Ethernet Subsystem. Configuration and Board Manageability * FPGA Management Engine that provides general control of common FPGA tasks (ex. error reporting, partial reconfiguration) * Platform Controller Management Interface (PMCI) Module contained within the Agilex FPGA that interfaces through Avalon-Streaming x8 QuadSPI and SPI to a Board Management Controller Partial Reconfiguration Partial Reconfiguration region supported in hardware and software Software Support * Linux DFL drivers targeting OFS FIMs * OPAE Software Development Kit * OPAE Tools"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#subsystem-interfaces","title":"Subsystem Interfaces","text":"<p>The PCIe, Memory and Ethernet interfaces in this design use a new flexible subsystem design that provides a standard Arm\u00ae AMBA\u00ae 4 AXI4 interface.  To access these Intel FPGA IP Subsystem documents. Please go here and search for the following ID numbers: * 690604: PCIe Subsystem IP User Guide (Note: you must login to myIntel and request entitled access) * 686148: Memory Subsystem IP User Guide (Note: you must login to myIntel and request entitled access) * 773413: [Ethernet Subsystem Intel FPGA IP] (public document)</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#fpga-management-engine-fme","title":"FPGA Management Engine (FME)","text":"<p>The FIM contains only one FME, regardless of the number of host interfaces to the FIM. The FME provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA.</p> <p>Any feature, such as a memory interface or global error control that you want to control through FME, must expose its capability to host software drivers.  New features are exposed to the FME by adding a device feature header (DFH) register at the beginning of the feature's control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link.  For more information about DFHs, refer to the FPGA Device Feature List Framework Overview</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#streaming-datapath","title":"Streaming Datapath","text":"<p>The FIM implements an Arm\u00ae AMBA\u00ae 4 AXI4-Stream bus protocol for data transfer in the FIM. Arm\u00ae AMBA\u00ae 4 AXI4-Stream channels send data packets to and from the host channel IP without data abstraction. Memory-mapped I/O (MMIO) CSR accesses are routed to the ST2MM module, which converts the Arm\u00ae AMBA\u00ae 4 AXI4-Stream to an Arm\u00ae AMBA\u00ae 4 AXI4 memory-mapped protocol.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#virtualization","title":"Virtualization","text":"<p>This design supports virtualization by making use of the virtualization functionality in the PCIe Hard IP and mapping packets to the appropriate physical or virtual function through a PF/VF multiplexer.  </p> <p>This reference FIM example supports 2 PFs for the host and 1PF, 3VFs for the SoC; however, you may extend your configuration to whatever the PCIe Hard IP can support or your application requires.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#142-afu","title":"1.4.2 AFU","text":"<p>An AFU is an acceleration workload that interfaces with the FIM. The AFU boundary in this design comprises both static and partial reconfiguration (PR) regions.  You can decide how you want to partition these two areas or if you want your AFU region to only be a partial reconfiguration region.  A port gasket within the design provides all the PR-specific modules and logic required for partial reconfiguration. Only one partial reconfiguration region is supported in this design for SoC AFU.</p> <p>Similar to the FME, the port gasket exposes its capability to the host software driver through a DFH register placed at the beginning of the port gasket CSR space. In addition, only one PCIe link can access the port register space.  </p> <p>You can compile your design in one of the following ways:  * Your AFU (workload) for Host (Static Area) and SoC resides in the partial reconfiguration area.  * Your AFU is part of the static region and is compiled from a flat design. </p> <p>In this design, the AFU region is comprised of: * AFU Interface handler to verify transactions coming from AFU region. * PF/VF Mux to route transactions to and from corresponding AFU components:    * Host:     * ST2MM module.     * PCIe loopback host exerciser (HE-LPBK) .</p> <p>* SoC:     * ST2MM module.     * Ethernet Subsystem (previous HSSSI) host exerciser (HE-HSSI).     * Memory Host Exerciser (HE-MEM).     * Traffic Generator to memory (HE-MEM-TG).     * Port Gasket (PRG).</p> <ul> <li>Arm\u00ae AMBA\u00ae 4 AXI4 Streaming to Memory Map (ST2MM) Module that routes MMIO CSR accesses to FME and board peripherals.</li> <li>Host exercisers to test PCIe, memory and Ethernet Interfaces (these can be removed from the AFU region after your FIM design is complete to provide more resource area for workloads)</li> <li>Port gasket and partial reconfiguration support.</li> <li>Component for handling PLDM over MCTP over PCIe Vendor Defined Messages (VDM)</li> </ul> <p>For this design the PF/VF Mux provides the following mappings (found in /src/afu_top/mux/top_cfg_pkg.sv and /src/afu_top/mux/soc_top_cfg_pkg.sv):</p> <p>Table 1-5 PF/VF Mapping</p> <p>SoC (IceLake-D)</p> PF VF Feature BAR Bar Size PF0 OFS managed peripherals BAR 0 2MB AFU peripherals  Board peripherals BAR 0 256KB  768KB PF0 VF0 HE-MEM BAR 0 2MB VF1 HE-HSSI BAR 0 2MB VF2 HE-MEM TG BAR 0 2MB <p>Xeon Host</p> PF VF Feature BAR Bar Size PF0 OFS managed peripherals BAR 0 1MB AFU peripherals  Board peripherals 256KB  768KB PF1 HE-LPBK BAR 0 16KB <p>Figure 1-3 AFU Diagram </p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#143-platform-interface-manager","title":"1.4.3 Platform Interface Manager","text":"<p>The PIM provides a way to abstract the Arm\u00ae AMBA\u00ae 4 AXI4-Stream interface to the AFU by providing a library of shims that convert the host channel native packet into other protocols such as Arm\u00ae AMBA\u00ae 4 AXI4 memory-mapped, Avalon\u00ae streaming (Avalon-ST) or Avalon\u00ae memory-mapped (Avalon-MM). </p> <p>The FPGA or AFU developer implements these interface abstractions in the AFU regions (afu_top and soc_afu_top) of the design.  </p> <p>For more information, refer to the AFU Developer's Guide.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#144-platform-feature-discovery","title":"1.4.4 Platform Feature Discovery","text":"<p>This reference design comes with specific Intel FPGA drivers that are upstreamed to linux-dfl.  These drivers abstract the hardware and operating system specific details of the platform to the host. </p> <p>The FIM implements a device feature header (DFH) at the beginning of each host-discoverable feature in a linked list format that allows an FPGA platform driver running on the host to discover FME, port, and AFU features. </p> <p>You must implement a 64-bit DFH Device Feature Header register at the beginning (first 8B aligned address) of the feature CSR space for a new feature to be discovered or enumerated by a driver.  </p> <p>During host discovery, the driver traverses the DFH of the first feature from the first address on PF0 BAR0. Based on the information in the DFH, a driver can determine the CSR address range of the feature and other associated details. The end of the DFH contains a \"next DFH offset\" field that points the driver to the DFH of the next feature. </p> <p>The software must continue traversing the linked list until it sees the EOL (End-Of-List) bit set to 1 in the \"next DFH offset\" field it inspects.  A 1 indicates this is the last feature in the feature set. The figure below gives a simple illustration of the feature discovery by traversing the DFH registers. This model is similar to how PCIe enumeration occurs.</p> <p>Figure 1-4 Device Feature Header Linked List Traversal</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#145-ofs-reference-design","title":"1.4.5 OFS Reference Design","text":"<p>OFS provides FIM designs you can use as a starting point for your own custom design. These designs target a specific programmable acceleration card or development kit and exercise key FPGA device interfaces. </p> <p>The Intel Agilex\u00ae code line for OFS targets the Intel IPU Platform F2000X-PL.  FIM designs are released to for evaluation and use. </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#146-fim-simulation","title":"1.4.6 FIM Simulation","text":"<p>OFS provides unit tests and a UVM environment for the FIM and a framework for new feature verification. UVM provides a modular, reusable, and scalable testbench structure by providing an API framework that can be deployed across multiple projects. </p> <p>The FIM testbench is UVM compliant and integrates third-party verification IPs from Synopsys that require a license. </p> <p>Verification components include:</p> <ul> <li>FIM monitor to detect correct design behavior</li> </ul> <ul> <li>FIM assertions for signal level integrity testing</li> </ul> <ul> <li>Arm\u00ae AMBA\u00ae 4 AXI4 scoreboards to check data integrity</li> </ul> <ul> <li>FIM coverage to collect functional data</li> </ul> <p>The verification infrastructure can be found here for evaluation and use. Please refer to the Simulation User Guide for more information.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#2-ofs-high-level-architecture","title":"2 OFS High Level Architecture","text":"<p>OFS provides distinct data paths that simplify the design and integration process for adding or removing interface modules:</p> <ul> <li>High Bandwidth data path for AFU-attached high-performance peripherals (Ethernet Subsystem, Memory,  workload).</li> <li>Low Bandwidth data path for OFS management and slow peripheral components (JTAG, I2C, SMBus).</li> <li>AFU Peripheral Fabric (APF) to Board Peripheral Fabric (BPF) path to communicate with interface control and status registers (CSRs) and board components.</li> <li>Peer-to-peer datapath between AFU components.</li> <li>Peer-to-peer datapath between BPF components.</li> </ul> <p>Depending on your design goals, you can present peripherals to software as:</p> <ul> <li>OFS managed peripherals with a device feature header that is part of a device feature list.</li> <li>Native driver managed peripherals that are exposed through an independent physical function or virtual function.</li> </ul> <p>Figure 2-1 OFS Datapath Structure </p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#3-pcie-subsystem","title":"3 PCIe Subsystem","text":"<p>The FIM's PCIe Subsystem is a hierarchical design that targets the P-tile PCIe* hard IP and is configured to support Gen4 speeds and Arm\u00ae AMBA\u00ae 4 AXI4-Stream Data Mover functional mode.  The IP supports SR-IOV and is configured to provide  2 PFs for the host and 1PF, 3VFs for the SoC.  Native PCIe TLP packets are sent through the PCIe usingArm\u00ae AMBA\u00ae 4 AXI4 Stream Protocol.  Before they reach the AFU, the packets go through an adapter in the subsystem that converts any headers to a data mover format.  Tag allocation and management for packets sent from the application to the host are done by the PF/VF Mux which is part of the AFU region.</p> <p>Figure 3-1 OFS FIM RX-TX Datapath</p> <p></p> <p>Some key features of the PCIe interface are:</p> Feature OFS for Intel Agilex FPGA SoC Attach Subsystem Configuration Mode Host: PCIe Gen4x16SoC: PCIe Gen4x16 Tile P-Tile Port Mode Native Endpoint SR-IOV Host: 2 PFs, No VFsSoC:  1 PFs, 3 VFs MSI-X Support Yes Functional Mode Data Mover Profile Basic TLP Bypass No Header Packing Scheme Simple Data Width 512-bit (64-byte) Arm\u00ae AMBA\u00ae 4 AXI4-ST Clock Frequency 500 MHz Tags Supported 128 Reordering Enabled with buffer 64 KB Maximum Payload Size 512 Bytes Memory Requests Supported 1CL, 2CL, 4CL MMIO transaction Size 4B, 8B Control Shadow Interface Enabled Completion Timeout Interface Enabled <p>The PCIe PF, VF and Base Address Register (BAR) configuration can be modified in the PCIe Subsystem Platform Designer GUI interface.  The current implementation for the OFS FIM for Intel IPU Platform F2000X-PL is as follows:</p> <p>Table 3-1 Function and BAR Table for OFS for Intel IPU Platform F2000X-PL</p> <p>SoC (IceLake-D)</p> PF VF Feature BAR Bar Size PF0 OFS managed peripherals BAR 0 2MB AFU peripherals  Board peripherals BAR 0 256KB  768KB PF0 VF0 HE-MEM BAR 0 2MB VF1 HE-HSSI BAR 0 2MB VF2 HE-MEM TG BAR 0 2MB <p>Xeon Host</p> PF VF Feature BAR Bar Size PF0 OFS managed peripherals BAR 0 1MB AFU peripherals  Board peripherals 256KB  768KB PF1 HE-LPBK BAR 0 16KB"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#31-pcie-subsystem-header-format","title":"3.1 PCIe Subsystem Header Format","text":"<p>The first 32 bytes of the TLP from the PCIe subsystem denotes the PCIe header. There are two types of header format supported \u2013 Power User Mode header and Data Mover mode header. The tuser_vendor[0] bit on the Arm\u00ae AMBA\u00ae 4 AXI4-Stream channel indicates the header format of the TLP; tuser_vendor[0] =0 indicates Power User Mode header and tuser_vendor[0] =1 indicates Data Mover Mode header.</p> <p>The OFS FIM for Intel Agilex FPGA implements the Data Mover Functional Mode.  With this implementation, the application has the flexibility to use either mode for PCIe transaction, as shown in the following table. For more detailed information about the PCIe Subsystem, see the PCIe Subsystem Intel FPGA User Guide. </p> <p>Table 3-2 PCIe Subsystem Header Format Support for OFS for Agilex FPGA</p> Direction Type Power User Data Mover Host to Endpoint  MWr, MRd Yes No CPL/CPLd Yes Yes Msg Yes No Endpoint to Host MWr, MRd Yes Yes Intr Yes (MWr)  Yes CPL/CPLd Yes Yes Msg Yes Yes"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#311-power-user-header-format","title":"3.1.1 Power User Header Format","text":"<p>The Power User Format provides user complete control over PCIe Hard IP. The user can implement functionality of interest with finer control over PCIe Transaction Layer Packet (TLP), credit handling and various mode provided by HIP. </p> <p>The lower 16 bytes of the Power User Format are standard PCIe header as defined by PCIe specification, and the upper 16 bytes are specific to the PCIe Subsystem Intel FPGA IP. </p> <p>Table 3-3 Power User Header Format</p> <p></p> <p>The mapping of the PCIe defined header to the lower 16 bytes of the Arm\u00ae AMBA\u00ae 4 AXI4-Stream data channel is shown in the figure below. Each double word (DW) or 4 bytes in the PCIe header is mapped from big-endian to little-endian on Arm\u00ae AMBA\u00ae 4 AXI4-S data channel.  </p> <p>Figure 3-2 Power User Header Mapping to Arm\u00ae AMBA\u00ae 4 AXI4 Channel</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#312-data-mover-header-format","title":"3.1.2 Data Mover Header Format","text":"<p>The data mover mode allows high bandwidth data transfers to and from Host memory. It hides the complexity of handling PCIe TLPs. This format provides a simple interface for reading and writing to Host Memory. The data mover checks link partner credits before transmitting packets. It also provides MSI-X interrupt generation capability. </p> <p>In Data Mover Mode, the lower 16 bytes are data mover specific and do not follow a PCIe standard header.  </p> <p>Table 3-4 Data Mover Header Format</p> <p> </p> <p>The mapping of the data mover header to the lower 16 bytes of the Arm\u00ae AMBA\u00ae 4 AXI4-S data channel is shown below. Each byte in the data mover header is mapped directly to the Arm\u00ae AMBA\u00ae 4 AXI4-S data channel.  </p> <p>Figure 3-3 Data Mover Header Mapping to Arm\u00ae AMBA\u00ae 4 AXI4 Channel</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#32-pcie-subsystem-interface-module","title":"3.2 PCIe Subsystem Interface Module","text":"<p>The PCIe Subsystem Interface module (/ipss/pcie/rtl/pcie_ss_if.sv), provides the supporting interface between software and the PCIe subsystem.  </p> <p>The interface module provides the following:</p> <ul> <li>Device Feature Header Registers</li> <li>Control and Status Registers</li> <li>Indirect access to PCIe subsystem CSR registers through a CSR mailbox in the PCIe Subsystem Interface.</li> </ul>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#33-data-mover-request-cycles","title":"3.3 Data Mover Request Cycles","text":"<p>For Host read request cycles using the OFS FIM for Intel Agilex FPGA: * All requests in the RX direction will be MMIO.  * Requester ID from the request does get sent to the AFU. It is the AFU's responsibility to send back a completion to the host with the correct completer ID.  * Prefix is not supported.  * Memory Mapped (MM) Mode is not supported. * Slot Number is 0. * Base address is not sent to the AFU. * Local Address field is not used.</p> <p>For AFU/application request cycles using the OFS FIM for Intel Agilex FPGA: * All requests in the TX direction will be Memory Read/Write.  * The tag must be generated by the AFU/application. * Prefix is not supported.  * MM Mode is not supported. * Slot Number is 0 (non-0 only for switch) * VF Active, VF number and PF number are obtained from Data Mover Header Packet.</p> <p>Figure 3-4 Data Mover Request Cycles</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#34-data-mover-completion-cycles","title":"3.4 Data Mover Completion Cycles","text":"<p>For Host completion cycles using the OFS FIM for Intel Agilex FPGA: * All completions in the RX direction will be Data Completions.  * Prefix is not supported. * MM Mode is not supported. * Slot Number is 0. * Data packet responses (for Memory Read requests from AFU) from the PCIe SS may come out of order when the size is &gt;64B.</p> <p>For AFU/application completion cycles using the OFS FIM for Intel Agilex FPGA: * All requests in the TX direction will be Memory Read/Write.  * Requester ID is generated within the FIM. * That tag must be generated by the AFU/application. * Prefix is not supported.  * MM Mode is not supported. * Slot Number is 0. * VF Active, VF Number and PF number are obtained from the Data Mover Header Packet. </p> <p>Figure 3-5 Data Mover Completion Cycles</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#4-platform-interface-manager","title":"4 Platform Interface Manager","text":"<p>The FIM interfaces to an application in the AFU region through Arm\u00ae AMBA\u00ae 4 AXI4-Stream channels.  This format allows the AFU to access the host channel's raw interface without any translation. </p> <p>As a FIM developer, you have the option to provide the raw data format associated with the host interface channel to the workload or AFU developer or you can provide an intermediate protocol using Platform Interface Manager Components or your own custom interface.</p> <p>If you expose the raw Arm\u00ae AMBA\u00ae 4 AXI4-Stream interface of the FIM, workload developers also have the option to convert to a desired protocol using the PIM resources as well.  </p> <p>Refer to the AFU Developer Guide and the FPGA Interface Manager Developer Guide for more information on using the PIM in your design.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#5-interconnect-fabric","title":"5 Interconnect Fabric","text":"<p>There are three types of interconnect fabric in the OFS FIM design:  * Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF mux/demux fabric  * AFU Peripheral Fabric (APF)  * Board Peripheral Fabric (BPF)</p> <p>Figure 5-1 Interconnect Fabric Diagram</p> <p></p> <p>TLP packets sent from upstream PCIe Subsystem on Arm\u00ae AMBA\u00ae 4 AXI4-Stream channel are demultiplexed in the Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF mux/demux fabric and routed to the respective PF/VF function based on the PF/VF information in the TLP header, such as vf_active or the PF/VF number. In the opposite direction, TLP packets from downstream PF/VF function are muxed in the fabric and sent to PCIe subsystem over Arm\u00ae AMBA\u00ae 4 AXI4-Stream channel.</p> <p>All host MMIO requests targeting PF0 BAR0 are routed to the ST2MM module. The ST2MM converts MMIO TLP packets into Arm\u00ae AMBA\u00ae 4 AXI4-Lite memory requests and places the requests onto AFU Peripheral Fabric (APF). AFU peripherals, such as OFS managed AFU features and ST2MM, and Board Peripheral Fabric (BPF) are interconnected by APF. The BPF is the interconnect fabric one hierarchy below APF which connects all the board peripherals. Both APF and BPF allow multiple Arm\u00ae AMBA\u00ae 4 AXI4-Lite master and slave interconnect topology.</p> <p>If you are modifying the APF or BPF connections, you must use Platform Designer to generate the fabrics directly.  Please refer to the FPGA Interface Manager Developer Guide for directions on what files must be modified and how to generate the interconnect.</p> <p>For modifying the PF/VF mux you must update parameters in these files: * src/includes/top_cfg_pkg.sv * src/common/pf_vf_mux.sv Then make the corresponding update to AFU top level instantiation and connections: * src/afu_top/soc_afu_top.sv(SoC_AFU) and src/afu_top/afu_top.sv (HOST_AFU)</p> <p>For details on these modifications, please refer to the FIM Interface Manager Developer Guide.  </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#51-afu-peripheral-fabric-apf","title":"5.1 AFU Peripheral Fabric (APF)","text":"<p>The AFU Peripheral Fabric (APF) is a 64-bit Arm\u00ae AMBA\u00ae 4 AXI4-lite compliant interconnect fabric that connects AFU peripheral modules to board peripheral modules through the Board Peripheral Fabric (BPF). </p> <p>The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time. </p> <p>The address mapping for components interconnected by the APF is listed below. All components are mapped to PF0 BAR0 and implement Arm\u00ae AMBA\u00ae 4 AXI4-lite slave interface. Note that none of the features in the APF mapping are designed to act as a master.</p> <p>Table 5-1 APF Address Mapping</p> <p>SoC PF0 BAR 0</p> Address Size (Byte) Feature 0x00000\u20130xFFFFF 1024K Board Peripherals (See BPF address mapping) AFU Peripherals 0x100000 \u2013 0x10FFFF 64K ST2MM 0x130000 \u2013 0x13FFFF 64K PR Gasket: 4K= PR Gasket DFH, control and status 4K= Port DFH 4K=User Clock 52K=Remote STP 0x140000 \u2013 0x14FFFF 64K AFU Error Reporting (Protocol checker) <p>Host PF0 BAR 0</p> Address Size (Byte) Feature 0x00000\u20130xFFFFF 1024K Board Peripherals (See BPF address mapping) AFU Peripherals 0x100000 \u2013 0x10FFFF 64K ST2MM 0x140000 \u2013 0x14FFFF 64K AFU Error Reporting (Protocol checker)"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#52-board-peripheral-fabric-bpf","title":"5.2 Board Peripheral Fabric (BPF)","text":"<p>The Board Peripheral Fabric is the 64-bit Arm\u00ae AMBA\u00ae 4 AXI4-Lite compliant interconnect fabric that connects board peripheral modules to APF. The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time.</p> <p>The address mapping for components interconnected by BPF is listed below. All components are mapped to PF0 BAR0 and implement Arm\u00ae AMBA\u00ae 4 AXI4-lite slave interface. The Master column indicates if a component also implements Arm\u00ae AMBA\u00ae 4 AXI4-lite master interface which can send requests to the BPF.</p> <p>Table 5-2 BPF Address Mapping</p> <p>SoC PF0 BAR 0</p> Address Size (Byte) Feature Master 0x00000 \u2013 0x0FFFF 64K FME (FME, Error, etc) No 0x10000 \u2013 0x10FFF 4K SoC PCIe Interface No 0x11000 \u2013 0x11FFF 4K Reserved - 0x12000 \u2013 0x12FFF 4K QSFP Controller 0 No 0x13000 \u2013 0x13FFF 4K QSFP Controller 1 No 0x14000 \u2013 0x14FFF 4K Ethernet Subsystem - 0x15000 \u2013 0x15FFF 4K Memory Subsystem 0x80000 \u2013 0xFFFFF 512K PMCI Controller Yes <p>Host PF0 BAR 0</p> Address Size (Byte) Feature Master 0x00000 \u2013 0x00FFF 4K Host PCIe Interface No 0x80000 \u2013 0xFFFFF 512K PMCI Controller Yes"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#53-arm-amba-4-axi4-stream-pfvf-muxdemux","title":"5.3 Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF Mux/Demux","text":"<p>The Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF Mux/Demux routes the PCIe TLP packets from the PCIe subsystem Arm\u00ae AMBA\u00ae 4 AXI4-Stream RX channel to downstream PF/VF based on the pf_num and vf_num information in the PCIe TLP header.</p> <p>The Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF mux arbitrates PCIe TLP packets from downstream PF/VF to the PCIe SS Arm\u00ae AMBA\u00ae 4 AXI4-S TX channel. The PF/VF Mux/Demux is an M X N switch that allows any M port to target any N port, and any N port to target any M port, where M is the number of host/upstream ports, and N is the numbers functions/downstream ports.   </p> <p>The fpga top package file, <code>/src/afu_top/mux/top_cfg_pkg.sv and soc_top_cfg_pkg.sv</code> and, contains the PF/VF parameters and mappings.</p> <p>Figure 5-2 PF/VF Mux</p> <p></p> <p>The PF/VF mux integration is part of afu_top (<code>src/afu_top/afu_top.sv and /soc_afu_top</code>).  There are two independent TX PF/VF MUX trees, labeled \"A\" and \"B\".</p> <p>Both an A and a B port are passed to each AFU component with a unique PF/VF. You can design your AFU components to send all requests to the primary A port or partition requests across both A and B ports. A typical high-performance AFU sends read requests to the B port and everything else to the A port, giving the arbiter freedom to keep both the host TX and RX channels busy.</p> <p>In the reference FIM provided for Intel Agilex OFS, the A and B TX trees have been multiplexed down to a single channel for A and another for B. The A/B multiplexer merges them into a single TX stream that will be passed to the tag remapper.</p> <p>The tag remapper provides unique tags as required by the PCIe specification.  Tags are not provided by the PCIe Subsystem FPGA IP.  When creating your own AFU you can leverage this module to generate unique tags.</p> <p>Note that the primary PF/VF Mux A supports RX and TX ports.  For the secondary PF/VF Mux B only TX ports are supported and the RX input to the Mux is tied off.  </p> <p>The default mapping is shown below:</p> <p>Table 5-3 PF/VF Mapping</p> <p>SoC (IceLake-D)</p> PF VF Feature BAR Bar Size PF0 OFS managed peripherals BAR 0 2MB AFU peripherals  Board peripherals BAR 0 256KB  768KB PF0 VF0 HE-MEM BAR 0 2MB VF1 HE-HSSI BAR 0 2MB VF2 HE-MEM TG BAR 0 2MB <p>Xeon Host</p> PF VF Feature BAR Bar Size PF0 OFS managed peripherals BAR 0 1MB AFU peripherals  Board peripherals 256KB  768KB PF1 HE-LPBK BAR 0 16KB <p>For information on how to modify the PF/VF mapping for your own design, refer to the OFS FIM Developer User Guide.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#54-afu-interface-handler","title":"5.4 AFU Interface Handler","text":"<p>The AFU Interface Handler resides inline between the PCIe Arm\u00ae AMBA\u00ae 4 AXI4-Stream Adapter and the Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF Demux/Mux logic. Its main function is to provide: * Unique PCIe tags \u2013 Each PCIe transaction shares the 512 tags across all VFs in the AFU region * AFU error logging for all VFs in the AFU region</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#541-unified-tag-remapping","title":"5.4.1 Unified Tag Remapping","text":"<p>When a FPGA function sends out a read cycle, it allocates a unique tag which is subsequently used to identify the read completion.  The tag is considered busy; it cannot be assigned to another read cycle until read completion.  While a tag may be unique within a unit, two different units could unknowingly send out two read cycles of the same tag.  The PCIe subsystem requires unique tags for all read cycles irrespective of their origins.  Therefore, a mechanism is needed to uniquify tag globally across different units.</p> <p>OFS contains a tag remapper (<code>tag_remap.sv</code>) that intercepts the read cycle, finds a globally unique tag, and replaces the original tag value.  It also restores the original tag value when returning completion to the read requester.  tag_remap is placed between the Arm\u00ae AMBA\u00ae 4 AXI4-Stream interface of the PCIE subsystem and the PF/VF Mux/Demux.</p> <p>The logic is described as follows:</p> <ol> <li>A sub-module (<code>ofs_fim_tag_pool</code>) maintains a pool of available tags.</li> <li>TX read requests are held until a tag is available from the pool by setting tvalid=0 to the host, and tready=0 to the PF/VF Mux/Demux.</li> <li>When a TX read is dispatched, the tag is marked busy in the pool.</li> <li>The original tag is stored in tag_reg, so it can be recovered when returning a completion to the unit/function.</li> <li>Because completion to a read request can split into multiple smaller transfer sizes, responses are monitored and the final completion is detected using PCIe TLP rules.</li> <li>Tags are released in the pool only when all requested data are transferred.</li> <li>When the completion returns, the original tag is restored from <code>tag_reg</code>.</li> </ol>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#542-afu-error-handling","title":"5.4.2 AFU Error Handling","text":"<p>In this OFS design, the AFU Interface Handler handles error logging for all VFs in the AFU. Errors handled are as follows</p> <p>Table 5-4 AFU Error Descriptions</p> Checker Field Description AFU protocol checker (PCIe TLP) Malformed TLP AFU PCIe TLP contains unsupported format type MaxPayloadError AFU memory write payload size exceeds max_payload_length limit MaxReadReqSizeError AFU memory read payload size exceeds max_read_request_size limit MaxTagError AFU memory read request tag value exceeds the maximum supported tag count UnalignedAddrErr The address field in AFU memory write/read request TLP is not DW-aligned. UnexpMMIOResp AFU is sending a MMIO read response with no matching MMIO read request. MMIOTimedOutAFU is not responding to a MMIO read request within the pre-defined response timeout period.  MMIODataPayloadOverrunThe number of data payload sent by AFU for a MMIO response (cplD) is more than the data length specified in the response. MMIOInsufficientDataThe number of data payload sent by AFU for a MMIO response (cplD) is less than the data length specified in the response. TxMWrDataPayloadOverrun    The number of data payload sent by AFU for a memory write request is more than the data length specified in the request. TxMWrInsufficientData  The number of data payload sent by AFU for a memory write request is less than the data length specified in the request. AFU Protocol Checker (Arm\u00ae AMBA\u00ae 4 AXI4-Stream)TxValidViolationThree checkers are implemented in the FIM to catch errors and protocol violations."},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#55-tlp-to-arm-amba-4-axi4-lite-memory-mapped-bridge-st2mm","title":"5.5 TLP to Arm\u00ae AMBA\u00ae 4 AXI4-Lite Memory Mapped Bridge (ST2MM)","text":"<p>ST2MM implements the following key features: * Host MMIO bridge     * Maps MMIO TLP packets received from the PCIe Subsystem over streaming interface to Arm\u00ae AMBA\u00ae 4 AXI4-Lite memory-mapped request. The memory-mapped request is sent to AFU or Board peripherals over APF and BPF.     * Maps Arm\u00ae AMBA\u00ae 4 AXI4-lite MM response received from AFU or Board peripherals to TLP packets and send the packets over ST streaming channel to host HIA subsystem. * Sends MMIO response of all 0\u2019s for MMIO read to unused BAR region. * Interrupt     * Sends interrupt packets to the PCIe subsystem when interrupt requests are received from the peripherals. Interrupts can be requested by a peripheral through a memory write to interrupt CSR registers in the ST2MM.</p> <p>Figure 5-3 ST2MM Module</p> <p></p> <p>ST2MM implements both Arm\u00ae AMBA\u00ae 4 AXI4-lite master and slave interfaces that are connected to the designated slave and master port on APF. Host memory requests are sent on the ST2MM master interface to AFP where the requests are routed to the targeted peripherals. </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#6-mmio-regions","title":"6 MMIO Regions","text":"<p>The FIM and AFU expose their functionalities to the host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO). An MMIO region is an address space within a base address register (BAR) region to which features are memory mapped.  </p> <p>For example, when a feature is mapped to an MMIO region, the CSR registers of that feature are located within the address range of that region. There can be multiple MMIO regions within a BAR region. </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#61-feature-region","title":"6.1 Feature Region","text":"<p>A group of related CSRs can be categorized as a feature region. For example, a DMA engine has queue management function and quality of service (QoS) function; these are two different features of the DMA engine. A feature region is contained within a single PCIe BAR and cannot span across two BAR region boundaries. </p> <p>A Device Feature Header (DFH) register marks the start of the feature region and sub-feature region, and you must place it at the first address of the region. Each DFH starts at 4KB boundary. A DFH register contains information that OPAE software requires to enumerate the feature. It also has an offset field that points to the next DFH in a feature list. OPAE software traverses the linked list of DFHs in each BAR region to discover all the features implemented on the platform. </p> <p>The <code>EOL</code> field in a DFH marks the end of a DFH list and is only set in the DFH of the last feature in the feature list. The feature type field in the DFH is used to differentiate between the different types of feature region. Basic building blocks (BBB) and private features are always a child of an AFU or FPGA Interface Unit (FIU) and must be contained within an AFU or FIU, respectively.  </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#611-device-feature-header-dfh-structure","title":"6.1.1 Device Feature Header (DFH) Structure","text":"<p>All DFHs must follow the following structure to be compatible with OPAE software.  Note that only features you want to be exposed to the OPAE software must have a DFH.</p> <p>Table 6-1: DFH Register Structure</p> Bitfield Name Range Access Description FeatureType 63:60 RO 4\u2019b0000 \u2013 Reserved 4\u2019b0001 \u2013 AFU4\u2019b0010 \u2013 BBB4\u2019b0011 \u2013 Private Feature4'b0100 \u2013 FIM Reserved 59:41 Rsvd Reserved EOL 40 RO End of DFH List1'b0=No other feature header beyond this one1'b1=This is the last feature header NextDFHByteOffset 39:16 RO Next DFH byte offsetNext DFH Address= Current DFH address + Next DFH byte offset.  You can also use this value as an indication of the maximum size of the MMIO region occupied by this feature. FeatureRev 15:12 RO For AFU Feature type= AFU major version number that is user defined.All other feature types= Feature revision number FeatureID 11:0 RO For AFU feature type= CoreFIM version numberFor BBB feature type= Intel defined ID for BBBFor private feature type= User-defined ID to identify within an AFU For FIU type=ID for FIU unit (ex. 0 for FME, 1 for Port) <p>You must increment a feature revision number if a feature changes.  This change requires a corresponding change in the software to detect the new version and report mismatches between the hardware and software revision number. </p> <p>When indicating \"FeatureType\" in your DFH Structure, use the following guidance: * FIM= Any static region feature you want discovered through software.  FIM features must implement mandatory FIM registers, including a FIM feature ID. * AFU= User Application region; may be PR region.  AFU feature must implement mandatory AFU register including an AFU ID. * Private Feature = Linked list of features within the FIM or AFU which are enumerated and managed by separate software and do not require an ID. * Basic Building Blocks (BBB) = Special features within the AFU or FIM that are meant to be reusable basic building blocks.  They are enumerated and called by separate software services.  </p> <p>Table 6-2: Mandatory FIM and AFU Registers</p> <p>The following table details the registers required for a FIM feature or AFU to be discovered by OPAE software.  The ID_H and ID_L fields allow you to create a unique feature or AFU identifier that remains unchanged while the FeatureRev in the DFH register increments.</p> Byte Address offset with respect to DFH Register Name 0x0000 DFH with corresponding FeatureType field implemented 0x0008 ID_L: Lower 64 bits of unique ID number (GUID) 0x0010 ID_H: Upper 64 bits of unique ID number (GUID) 0x0018 Next AFU <p>Table 6-3: Next AFU Register Definition</p> <p>The following table details the \"Next AFU Register Definition.\"  This register is used if you have multiple AFUs that can be used with your FIM.  </p> Bit Attribute Description 63:24 Reserved Reserved 23:0 RO Next AFU DFH Byte Offset Next AFU DFH address =current address + offset; where a value of 0 implies this is the last AFU in the list. Example: AFU0 at address 0x0: Next AFU offset= 0x100  AFU1@ address 0x100: Next AFU offset = 0x100 AFU2 at address 0x200: Next AFU offset = 0x0 (End of AFU List) <p>6.2 Control and Status Registers</p> <p>All the Control and Status Registers (CSRs) in the FIM are 64-bit registers with the following MMIO write, and MMIO read support.</p> <p>Table 6-4: CSR MMIO Read and Write Support</p> Request Memory Attribute Payload size Memory Ordering MMIO Write UC 4B or 8B Strongly ordered MMIO Read UC 4B or 8B Strongly ordered <p>The FIM does not reorder the MMIO requests or responses. For MMIO writes, there is no reordering of requests in FIM, and UC ordering rules are followed. Similarly, for MMIO reads, there is no re-ordering of requests or responses in the FIM. An AFU may opt to re-order the MMIO read responses but the FIM does not enforce read response ordering. </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#621-software-access-to-registers","title":"6.2.1 Software Access to Registers","text":"<ul> <li>Software accesses 64-bit registers as aligned quadwords. For example, to modify a field (bit or byte) in a 64-bit register, the entire quadword is read, the appropriate field(s) are modified, and the entire quadword is written back.</li> <li>When updating registers through multiple accesses (whether in software or due to hardware disassembly), certain registers may have specific requirements on how the accesses must be ordered for proper behavior. These are documented as part of the respective register descriptions.</li> <li>For compatibility with future extensions or enhancements, software must assign the last read value to all \u201cReserved and Preserved\u201d (RsvdP) fields when written. In other words, any updates to a register must be read so that the appropriate merge between the RsvdP and updated fields occurs. Also, software must assign a value of zero for \u201cReserved and Zero\u201d (RsvdZ) fields when written.</li> <li>PCIe locked operations to FPGA hardware registers are not supported. Software must not issue locked operations to access FPGA hardware registers.</li> </ul> <p>In the following two cases, the FIM terminates MMIO Read requests by sending a completion with the data (CplD) specified below: * MMIO Timeout:  This occurs when the AFU does not respond within a set timeout. The timeout value is currently configured to 512 pclks (clk_2x). In this case, the FIM returns all 1s.</p> <ul> <li>Illegal MMIO Accesses: This occurs when the read is accessing undefined registers in the FIM or if an AFU access violation.  An example of an access violation is when a PF attempts to access the AFU when it is set to VF mode, or when a VF attempts to access the AFU when it is set to PF mode. In this case, the FME will returns all 0s.</li> </ul>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#62-register-attribute-definition","title":"6.2 Register Attribute Definition","text":"<p>Table 6-5: OFS Register Attribute Definitions</p> Attribute Expansion Description RW Read/Write This bit can be read or written by software. RO Read Only The bit is set by hardware only. Software can only read this bit. Writes do not have any effect. RW1C Read/ Write 1 to Clear Software can read or clear this bit. The software must write 1 to clear this bit. Writing zero to RW1C bit has no effect. Note that a multi-bit RW1C field may exist. In this case, all bits in the field are cleared if a 1 is written to any of the bits. RW1S Read/ Write 1 to Set Software can read this bit. Writing a 1 to the bit sets it to 1. Writing a 0 has no effect. It is not possible for software to set this bit to 0. The 1 to 0 transition can only be performed by HW. RW1CS Read/Write 1 to Clear Sticky Software can read and clear this bit. Writing a 1 to a bit clears it, while writing a 0 to a bit has no effect. This bit is only reinitialized to its default value by a power-on reset. RWD Read/Write Sticky across Hard Reset The bit can be read or written by SW. This bit is sticky or unchanged by any reset type, including Hard Reset. The bit gets cleared only with power on. *S Sticky across Soft Reset The bit will be sticky or unchanged by soft reset. These bits are only re-initialized to their default value by a power-on reset. *D Sticky across Hard Reset The bit is sticky or unchanged by or unchanged by any reset type, including hard reset. The bit gets cleared only with power on. Rsvd Reserved Reserved for future definitions. Currently don\u2019t care bits. RsvdP Reserved and Protected Reserved for future RW implementations. The software must preserve the value of this bit by read modify write. RsvdZ Reserved and Zero Reserved for future RW1C implementations. The software must write zero to this bit."},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#623-csr-offset-in-bars","title":"6.2.3 CSR Offset in BARs","text":"<p>The table below captures the FIM and AFU features in the supported BAR regions. The highlighted offset indicates the first DFH in the DFH list of a BAR region where device driver starts the DFH traversal.</p> <p>Table 6-6: PF0 BAR0 Features SoC AFU</p> Offset Feature CSR set 0x0000 FME AFU 0x10000 PCIe Interface 0x12000 QSFP Controller 0 0x13000 QSFP Controller 1 0x14000 Ethernet Interface 0x15000 Memory Interface 0x80000 PMCI 0x100000 St2MM 0x130000 PR Control &amp;  Status (Port Gasket) 0x131000 Port CSRs (Port Gasket) 0x132000 User Clock (Port  Gasket) 0x133000 Remote SignalTap (Port Gasket) 0x140000 AFU Errors (Protocol Checker) <p>Table 6-7: PF0 BAR0 Features Host AFU</p> Offset Feature CSR  set 0x0000 PCIe Interface"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#7-clocks","title":"7 Clocks","text":"<p>The following table provides external clock sources which correspond to pins on the FPGA that drive blocks of internal logic or are used as a reference clock for internal PLLs.  The names in the table are used in the top.sv or are the logical clock names used by their respective functional blocks.  </p> <p>Table 7-1: External Clock Source </p> Clock Frequency Description SYS_REFCLK 100MHz Reference clock to system IOPLL (sys_pll) which provides FIM system clocks. PCIE_REFCLK0 100MHz PCIe  Refclk 0 PCIE_REFCLK1 100MHz PCIe Refclk 1 SOC_PCIE_REFCLK0 100MHz PCIe Refclk 0 on the SOC side SOC_PCIE_REFCLK1 100MHz PCIe Refclk 1 on the SOC side qsfp_ref_clk 156.25MHz Ethernet  Refclk ddr4[0].ref_clk 150MHz Refclk  for EMIF channel 0 ddr4[1].ref_clk 150MHz Refclk for EMIF channel 1 ddr4[2].ref_clk 150MHz Refclk  for EMIF channel 2 ddr4[3].ref_clk 150MHz Refclk for EMIF channel 3 sdm_config_clk 125MHz SDM  Config Clock altera_reserved_tck 10MHz Default  JTAG Clock <p>Table 7-2: Internal Clocks</p> Clock Frequency Description clk_sys 400MHz System clock. Primary clock for PCIe datapath. clk_100m 100MHz 100MHz clock. For RemoteSTP and user  clock, or any logic that requires a 100MHz clock. clk_csr 100MHz Arm\u00ae AMBA\u00ae 4 AXI4-lite  interconnect fabric and CSR clock. Driven by clk_100m. clk_2x 400MHz 2x clock to AFU in PR slot. Driven by clk_sys. clk_1x 171.43MHz 1x clock to AFU in PR slot. uclk_usr 312.50  MHz Configurable  \u201cH\u201d clk for AFU. Default 312.50 MHz uclk_usr_div2 156.25 MHz Configurable  \u201cL\u201d clk for AFU. Default 156.25 MHz"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#8-reset","title":"8 Reset","text":""},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#81-reset-signals","title":"8.1 Reset Signals","text":"<p>The FIM system reset signals are driven according to a their respective requirements derived from their use cases.  The behavioral code defining the reset operation is located in the file <code>rst_ctrl.sv</code>. The FIM System Reset Drivers table below provides a list of the input and feedback signals that compose the various resets.</p> <p>Table 8-1: FIM System Reset Drivers</p> Reset Description <code>nPERST</code> pin Active low PCIe reset pin from the PCIe card edge that may be set by the host machine for cold or warm resets. <code>nCONFIG</code> pin Active low input to the FPGA that causes the FPGA to lose its configuration data, enter a reset state, and tri-state all I/O pins. Host software must reload the FPGA FIM after nCONFIG is activated. <code>ninit_done</code> Active low signal indicating FPGA core configuration is complete and FPGA has entered usermode.  This signal is provided by the configuration monitor block in rst_ctrl.sv. <code>pcie_reset_status</code> Active high reset status from PCIe hard IP. When driven high, this signal indicates that the PCIe IP core is not ready for usermode. <code>locked</code> Active high SYS IOPLL locked signal <code>pcie_cold_rst_ack_n</code> Reset Acknowledge signal from the PCIe subsystem that lets the Reset Controller know that the Cold Reset sequence has been completed. <code>pcie_warm_rst_ack_n</code> Reset Acknowledge signal from the PCIe subsystem that lets the Reset Controller know that the Warm Reset sequence has been completed. <p>Upon power-on, the reset module in the FIM holds the FIM in reset until all the reset conditions are de-activated:</p> <ul> <li><code>nPERST</code> signal is asserted.</li> <li>The <code>INIT_DONE</code> pin is driven high to indicate core configuration is complete.</li> <li>The SYS IOPLL is locked.</li> <li>The reset status from PCIe hard IP is de-asserted indicating the IP is ready for transfer. </li> </ul> <p>The reset module places the FIM back into reset if any of these conditions becomes active again. The only way to invoke a system reset to the FIM after power-up is to deassert the <code>nPERST</code> pin either by performing a warm reboot or through PCIe driver intervention. There are soft reset signals set aside to allow software to reset the Port, AFU and partial reconfiguration IP. </p> <p>The following table lists the reset outputs from the <code>rst_ctrl.sv</code> block.</p> <p>\u200b                                                      Table 8-2: FIM System Reset Outputs</p> Reset Description <code>rst_n_sys</code> pin System general reset synchronous to <code>clk_sys</code>.  This is a warm reset of the FPGA logic.  Sticky bits in the FME and other CSR registers will not be reset by this signal. <code>rst_n_100m</code> pin System general reset synchronous to clk_100m. <code>ninit_done</code> Active low signal indicating FPGA core configuration is complete and FPGA has entered usermode.  This signal is provided by the configuration monitor block in rst_ctrl.sv. <code>pwr_good_n</code> Hardware reset conditioned by <code>ninit_done</code> and the <code>pll_locked</code> signal.  The signal is generally set when power has been cycled or a physical hardware fault has occurred, requiring a reset of the FPGA logic.   This signal is synchronous to <code>clk_sys</code>. <code>pcie_cold_rst_ack_n</code> Hardware reset conditioned by the <code>pcie_reset_status</code> which is a summary reset driven by the PCIe Hard IP logic tile on the FPGA die.  This signal is synchronous to <code>clk_sy</code>s. <code>pcie_warm_rst_ack_n</code> Soft reset conditioned by <code>nPERST</code> when the pcie_reset_status is not asserted, meaning a warm reset is desired.  Cold reset sticky bits in the PCIe subsystem will not be reset by this signal."},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#9-interrupts","title":"9 Interrupts","text":"<p>The OFS platform supports interrupts through MSI-X feature implemented in the PCIe SS. The MSI-X Interrupt feature handles FME and AFU interrupts. </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#91-msi-x","title":"9.1 MSI-X","text":"<p>FME interrupts are primarily used to notify the host of error events happened in the FIM. When any of the bits in the FME error status registers is set, an interrupt request is sent to the MSI-X module. There are FME error status registers for various FPGA features such as RAS Error, Temperature monitoring etc.\u202fIf any of those error registers log an error, we trigger an FME interrupt.</p> <p>An AFU sends an interrupt to the MSI-X module in the PCIE SS on the AXI interrupt request channel. </p> <p>The MSI-X table entries and PBA vectors are implemented in the PCIE SS. The PCIE SS supports upto 4096 vectors in Static MSI-X mode</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#92-msi-x-entry-table","title":"9.2 MSI-X Entry Table","text":"<p>Each entry in the MSI-X table stores the message address, message data, and vector control for one interrupt vector. The address, data, and vector control information are populated by software (usually done by the PCIe SRIOV driver) after reading the PCIe endpoint configuration space.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#93-msi-x-pba-table","title":"9.3 MSI-X PBA Table","text":"<p>The PBA table contains a corresponding bit for each MSI-X interrupt vector. This PBA bit is set if that interrupt is triggered but is masked. When the interrupt is unmasked, the PBA bit is unset, and an interrupt is sent to the Host. When the Application generates an interrupt from an IRQ source, it sets the corresponding PBA bit. </p> <p>When the interrupt is triggered by an IRQ Source, the IRQ Processor checks the masking of that interrupt to determine if the PBA bit should be set. If unmasked, the IRQ Processor looks up MSI-X address and data for the interrupt vector and generates the interrupt request over the PCIe EP.</p> <p>The FIM implements the pending bit array as per the MSI-X specification.  When interrupts are enabled the FIM immediately generates an interrupt in response to a suitable event.  When interrupt vectors are masked, the pending bit array entry for the corresponding interrupt vector is set without issuing an interrupt.  When interrupt vectors are re-enabled, any pending interrupt entries are issued to the PCIe EP</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#94-interrupts-supported","title":"9.4 Interrupts Supported","text":"<p>Table 9-1: OFS for Agilex FPGA Interrupts Supported</p> PF/VF Vector Assignment PF0 0-5 Reserved 6 FME Error Interrupt PF0.VF00-3User AFU Interrupt"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#95-msi-x-table-locations","title":"9.5 MSI-X Table Locations","text":"<p>The MSI-X vector tables are at BAR4, address 0x2000. The MSI-X PBA tables are at BAR4, address 0x3000.</p> <p>Table 9-2: PF0 BAR4 Features</p> Offset Feature CSR set 0x02000 MSI-X Vector Tables 0x03000 MSI-X PBA Tables"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#10-external-memory-interface-emif","title":"10 External Memory Interface (EMIF)","text":"<p>There are 4 EMIF channels (4 DDR4 banks) on the f2000x platform which is targeted OFS FIM  for Intel Agilex FPGA. The HE-MEM exerciser module in AFU. ECC is not implemented in this design. Both memory subsystem and HE-MEM implement Arm\u00ae AMBA\u00ae 4 AXI4-MM interface.</p> <p>**Table 10-1 Memory Subsystem Configuration on the Intel IPU Platform F2000X-PL platform **</p> EMIF  Channel # Width ECC Size (GB) Speed  (MT/s) DDR4 Device FPGA Bank 0 x32 x8 4 2400 Three 1Gx16 3D 1 x32 x8 4 2400 Three 1Gx16 3A 2 x32 x8 4 2400 Three 1Gx16 2F 3 x32 x8 4 2400 Three 1Gx16 2E <p>Figure 10-1: EMIF Interfaces</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#101-emif-csr","title":"10.1 EMIF CSR","text":"<p>TheMIF is implemented as an external FME feature in OFS EA and the CSR for the EMIF feature is memory mapped to the FME BAR region. The following table captures the EMIF CSR registers.</p> <p>Table 10-2: EMIF CSR Registers</p> EMIF_DFH 0x000 0x300000001000100F EMIF Management DFH FIELD NAME RANGE ACCESS DEFAULT DESCRIPTION FeatureType [63:60] RO 0x3 Feature Type = Private Feature Reserved40 [59:40] RsvdZ 0x0 Reserved NextDfhByteOffset [39:16] RO 0x1000 Next DFH Byte  offset FeatureRev [15:12] RO 0x1 Feature Revision FeatureID [11:0] RO 0x00F Feature Id <p>\u200b               </p> EMIF_STAT 0x008 0x0000000000000000 EMIF Calibration Status Register FIELD NAME RANGE ACCESS DEFAULT DESCRIPTION Reserved [63:8] RsvdZ 0x0 Reserved CalFaliure [7:4] RO 0x0 EMIF PHY Calibration Failure (1 bit per interface) CalSuccess [3:0] RO 0x0 EMIF PHY  Calibration Successful (1 bit per  interface) EMIF_CAPABILI TY 0x010 0x000000000000000F EMIF Capabliity Register FIELD NAME RANGE ACCESS DEFAULT DESCRIPTION Reserved [63:4] RsvdZ 0x0 Reserved EMIFCap [3:0] RO 0xF Attached Memory  Capability (1 bit per  interface)"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#11-ethernet-interface-subsystem","title":"11 Ethernet Interface Subsystem","text":""},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#111-ethernet-interface-overview","title":"11.1 Ethernet Interface Overview","text":"<p>The Ethernet Subsystem provides portability to different Ethernet configurations across platforms and generations and reusability of the hardware framework and software stack. This reference FIM implements an E-tile Ethernet Subsystem IP in a 2x4x25GbE configuration and provides a Linux driver that can be leveraged for customization. Each group of 4x25GbE routes to a QSFP.</p> <p>For more information about how to reconfigure the Ethernet Subsystem please refer to the [Ethernet Subsystem Intel FPGA IP].</p> <p>Table 11-1: Ethernet Configurations for example OFS FIMs for Agilex FPGAs</p> Configuration/Mode Base Fim IP file name hssi_ss_8x25g Number of ports enabled 8 Enabled ports Port 0-7 Port{x} profile 25GbE Port{x} subprofile MAC+PCS Port{x} RSFEC True Port{x} PTP False Enable AN/LT False (for simulation efficiency) Enable NPDME True Enable JTAG to Avalon master bridge False Enable Tx packet classifier NA PTP accuracy mode NA Enable iCAL and pCAL recipe at power True TX/RX maximum frame size 1518 Enforce maximum frame size False Link fault generation mode Bidirectional Stop TX traffic when link partner sends PAUSE Yes Bytes to remove from RX frames Remove CRC bytes Forward RX PAUSE requests False Use source address insertion False Enable TX/RX VLAN detection True Enable asynchronous adapter clocks False Enable preamble Passthrough False Enable asynchronous adapter clocks False Enable strict preamble check False Enable strict SFD check False Average IPG 12 Enable adaptation load soft IP True Additional IPG removed as per AM period 0 PMA adaptation select NRZ_28Gbps_VSR <p>To determine which Transceiver Subsystem port maps to the QSFP A and B lanes, please refer to the following table:</p> <p>Table 11-2: Transceiver Subsystem Port Mapping</p> Port Number base 2x4x25G 0 QSFP-A Lane-0 1 QSFP-A Lane-1 2 QSFP-A Lane-2 3 QSFP-A Lane-3 4 QSFP-B Lane-0 5 QSFP-B Lane-1 6 QSFP-B Lane-2 7 QSFP-B Lane-3 8 NA 9 NA 10 NA 11 NA 12 NA 13 NA 14 NA 15 NA <p>Figure 11-1: Transceiver Subsystem Block Diagram</p> <p></p> <p>A host exerciser, named he-hssi, is provided in the pr_slot of the AFU partition. The Transceiver susbystem interface to the AFU has an Arm\u00ae AMBA\u00ae 4 AXI4-Stream data and sideband interface.  </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#112-ofs-ethernet-subsystem-interface-module","title":"11.2 OFS  Ethernet Subsystem Interface Module","text":"<p>A wrapper around the  Ethernet Subsystem integrates the following features:</p> <ul> <li>DFH registers </li> <li>Control &amp; status registers </li> <li>Indirect access to Transceiver SS CSR registers via CSR mailbox in the Ethernet Subsystem interface </li> </ul>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1121-ethernet-subsystem-control-and-status-register-csr-map","title":"11.2.1 Ethernet Subsystem Control and Status Register (CSR) Map","text":"<p>The Ethernet Subsystem connects to the APF which is memory mapped to PF0 BAR0. The Ethernet Subsystem CSR space in the FIM consists of two parts:</p> <ul> <li>Ethernet Subsystem CSRs assigned from offset 0x000 to 0x7FF</li> <li>Additional CSRs are added to FIM at offset 0x800 to 0xFFF</li> </ul> <p>The PCIe subsystem uses Arm\u00ae AMBA\u00ae 4 AXI4 Memory Mapped accesses to read and write Ethernet Subsystem Control and Status Registers in the FIM. The Ethernet Subsystem CSR Map structure is designed to scale according to IP capabilities.</p> <p>The Ethernet Subsystem CSR Map can be found <code>ipss/hssi/HSSI_SS_CSR.xls</code>.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#114-ethernet-subsytem-software","title":"11.4 Ethernet Subsytem Software","text":"<p>There are two pieces of software related to running the Ethernet Subsystem: The Linux* dfl network driver and the user space OPAE Tools.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1141-ethernet-subsystem-linux-driver","title":"11.4.1 Ethernet Subsystem Linux Driver","text":"<p>The Ethernet subystem is exposed as a feature in the PCIe PF BAR0 region. It has a Device Feature Header (DFH) specifying the interface.</p> <p>The primary functionality of the driver is to interact with the ethernet MAC and PHY through an indirect register access mailbox implemented by the HSSI_RCFG_CMD0, HSSI_RCFG_DATA0 registers described above. To aid in RTL bringup, the driver provides a debugfs interface directly to the indirect register access mailbox. For each HSSI interface in the system there would be a directory with the following form containing two files, regaddr and regval: /sys/kernel/debug/dfl-fme.X.Y</p> <p>To read a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then read the value as string out of regval file. To write a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then write the value as a C hex string to regval file.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1142-ethernet-subsystem-opae-user-space-tool","title":"11.4.2 Ethernet Subsystem OPAE User Space Tool","text":"<p>User space OPAE Tools that are part of OPAE SDK provide support for the Ethernet Subsystem. You can use the --help option to print more information about each of these commands:</p> <ul> <li>hssi: Provides a means of interacting with the 10G and 100G HSSI AFUs through the host exerciser.</li> <li>hssiloopback: Enables and disables Ethernet loopback.</li> <li>hssistats: Provides MAC statistics.</li> </ul>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#12-partial-reconfiguration","title":"12 Partial Reconfiguration","text":"<p>Partial Reconfiguration (PR) is an Intel FPGA technology that allows users to reconfigure parts of the FPGA device dynamically, while the remainder of the device continues to operate. In a non-partial reconfiguration flow, any change to the design requires full reprogramming of the entire configuration RAM (CRAM) arrays in the device. With partial reconfiguration, you can dynamically reprogram one or more CRAM frames. A partial reconfiguration design has a static region, and a PR regions, which can be modified to implement new logic. The portion of the CRAM on the chip to be reconfigured is contained within a PR region. For the PR flow, your design must be partitioned into static region and reconfigurable region. The static region is the area of your FPGA that is not reconfigured without reprogramming the entire FPGA. An area of the chip that you plan to partially reconfigure is a PR region.</p> <p>The Port Gasket contains all the PR specific modules and logic, such as PR slot reset/freeze control, user clock, remote STP etc. For this reference example only one PR slot is supported.</p> <p>The Figure below shows the fundamental concepts required to support PR in OFS platform. There are 4 OFS management DFH \u2013 PR, Port, User Clock and Remote STP in Port Gasket that is exposed to OFS software. These platform capabilities are generally used in conjunction to Partial Reconfiguration. The Figure below also demonstrates the concepts of adding a new interface to the PR region.</p> <p>Figure 12-1 Partial Reconfiguration Gasket</p> <p></p> <p>The isolation logic is provided on the output signals of the PR region to ensure they don\u2019t glitch and affect the interfacing logic in the Static Region (SR). The isolation logic is controlled by the PR Freeze logic during PR operation.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#121-user-clock-support","title":"12.1 User Clock Support","text":"<p>The reference platform provides two user configurable clock (uclk_usr, uclk_usr_div2) for use by the AFU. These clocks are generated by a reconfigurable IOPLL. The control and status of these clocks is expose through two pairs of command and status registers (USR_CLK_FREQ_CMD0 / USR_CLK_FREQ_STS0 &amp; USR_CLK_FREQ_CMD1 / USR_CLK_FREQ_STS1). The first pair controls the fPLL reconfiguration functionality. The second pair controls a clock frequency measurement block.</p> <p>The following are the default values of the userclk.</p> <p>uclk_usr: 312.5 MHz</p> <p>uclk_usr_div2: 156.2 MHz</p> <p>Table 12-1 usr_clk_* Acceptable Programming Range</p> Fabric Frequency Range uclk_usr (H) uclk_usr_div2 (L) Details 0-400 MHz 0-800 MHz 0-400 MHz Clocks set on 2x relationship for L&lt;400 MHz 400-800 MHz 400-800 MHz 400-800 MHz Clks are equal for L&gt;400 MHz <p>PLL Reconfiguration</p> <p>The blue bit stream hardware exposes the low level IOPLL reconfiguration interfaces directly to software control. Through the USR_CLK_FREQ_CMD0 register software can select the reference clock, assert the PLL power down pin and issue reads and writes on the IOPLL Avalon-mm reconfiguration bus. Through the USR_CLK_FREQ_STS0 register software can query the IOPLL active reference clock, locked status and readdata returned from the IOPLL AVMM interface for read requests.</p> <p>Clock Frequency Counter</p> <p>The user clocks, generated by the reconfigurable IOPLL, are connected to a frequency measurement circuit. Software selects which of the two clocks to measure by setting the clock select bit in the USER_CLK_FREQ_CMD1 register. After 10ms software can read the frequency, in 10 KHz units, from the USER_CLK_FREQ_STS1 register. Reading this register before 10ms has passed will return undefined data but otherwise has no effect.</p> <p>Configuring User Clocks</p> <p>To program the user clock to the desired frequency, user will set the clock-frequency-low and clock-frequency-high fields in the PR AFU GBS .json file to the desired frequency value. During PR, SW will try to provide the closest possible frequency to the value specified in the .json file.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#13-host-exercisers","title":"13 Host Exercisers","text":"<p>The Host Exerciser (HE) modules are responsible for generating traffic with the intent of exercising the specific interface they are designed to connect to. They are intended to test the interface in simulation and hardware, enable measurement of bandwidth and other performance KPIs and, in some cases, provide an example of data movement between interfaces (PCIe to DDR for e.g.) for adoption into a customer application.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#131-he-lb-and-he-mem-host-exerciser","title":"13.1 HE-LB and HE-MEM Host Exerciser","text":"<p>The Host Exerciser Loopback module is a traffic generator that can be attached both to host memory, over PCIe (HE-LB), and to local memory, such as board-attached DDR (HE-MEM). The Host Exerciser (HE) is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth as well as demonstrating data path correctness. The FIM picks up the HE-LB module behind the PIM (Platform Interface Manager). The PIM converts the Arm\u00ae AMBA\u00ae 4 AXI4 with TLP out of the PCIe SS to standard Arm\u00ae AMBA\u00ae 4 AXI4 (MM for completions and Lite for CSR) interfaces. The figure below shows how the HE-LB is instantiated in the FIM.</p> <p>Figure 13-1 HE-LB Dataflow Diagram </p> <p></p> <p>The exerciser has two primary modes: loopback, in which read data is fed back as writes, and read/write mode, in which reads and writes are generated independently. Furthermore, the host_exerciser software provided with OPAE that drives the RTL has two major modes: \"lpbk\" and \"mem\". These modes only select the UUID of the HE AFU, with lpbk selecting a version configured with no local memory (56e203e9-864f-49a7-b94b-12284c31e02b) and mem seeking a version with local memory (8568ab4e-6ba5-4616-bb65-2a578330a8eb). The behavior of each engine with and without local memory is described below.</p> <p>Figure 13-2 HE Engine Heirarchy </p> <pre><code>flowchart TB\n    classDef gr fill:green,color:white;\n    classDef ol fill:olive,color:white;\n    classDef rd fill:maroon,color:white;\n\n    he_lb(\"he_lb_top\"):::gr --- he_lb_main\n    he_mem(\"he_mem_top\"):::gr --- he_lb_main\n    he_lb_main:::gr ---- he_lb_engines\n    he_lb_engines:::gr ---- mode_rdwr:::rd\n    he_lb_engines:::gr ---- mode_lpbk:::rd\n    he_lb_engines:::gr ---- mode_atomic:::rd\n    he_lb_main --- he_lb_csr:::ol</code></pre> <p>For more details of HE-LB and HE-MEM IP, please refer to ofs-fim-common/src/common/he_lb/README.md</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#132-memory-traffic-generator-he-mem-tg","title":"13.2 Memory Traffic Generator  (HE-MEM-TG)","text":"<p>The memory traffic generator (TG) AFU provides a way for users to characterize local memory channel bandwidth with a variety of traffic configuration features including request burst size, read/write interleave count, address offset, address strobe, and data pattern.</p> <p>The AFU consists of a series of configurable Arm\u00ae AMBA\u00ae 4 AXI4-MM traffic generators connected to the available local memory channels not attached to HE-MEM. It has a separate CSR block for AFU feature information and high-level status, including a TG_CAPABILITY register that describes the available traffic generators with a 1 bit active high mask and a TG_STAT register that provides the 4-bit, one-hot status of each TG in adjacent fields. The status is decoded left to right as follows: pass, fail, timeout, active. For additional detail, refer to the MEM_TG CSR table ofs-fim-common/src/common/mem_tg/MEM_TG_CSR.xls</p> <p>Each traffic generator is configured through a separate Avalon-MM interface at incremental offsets of 0x1000 from the AFU DFH. For details on the TG2 configuration space, refer to the MEM_TG_CSR.xls. The default configuration for each TG performs a single-word write followed by a read at address 0. Triggering the start of the test on a TG will initiate a counter to measure the duration of the test which is recorded in the AFU CSR block and used to report memory channel bandwidth.</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#132-hssi-host-exerciser-he-hssi","title":"13.2 HSSI Host Exerciser (HE-HSSI)","text":"<p>HE-HSSI is an Ethernet AFU that handles client side ethernet traffic. The reference HE-HSSI has following features:</p> <ul> <li>HE-HSSI provides an E-tile compatible interface with the Transceiver Subsystem.</li> <li>Includes a traffic generator and checker or monitor</li> <li>Provides pause signals to the Transceiver Subsystem for XON and XOFF generation</li> <li>Generates traffic or incoming traffic that can be looped back into transmit path by enabling loopback mode, which will bypass traffic generator</li> <li>At the HE-HSSI interface boundary the Ethernet data interface is Arm\u00ae AMBA\u00ae 4 AXI4-Stream with 64-bit data at eth_clk clock</li> <li>The Traffic generator and checker modules have a 64-bit data interface at eth_clk clock.</li> <li>The traffic generator supports the following modes:<ul> <li>Fixed length or Random Length</li> <li>Incremental pattern or Random pattern</li> </ul> </li> <li>Traffic checker does a 32-bit crc check in 10/25G. In the 100G configuration, there is no data integrity check, only a packet counter.</li> <li>The CSR of this AFU is accessible through Arm\u00ae AMBA\u00ae 4 AXI4-Stream PCIe TLP interface</li> <li>The PCIe TLP to CSR Interface Conversion module converts PCIe TLPs into simple CSR interface</li> <li>The CSR space of the traffic generator and checker modules are accessed in an indirect way using mailbox registers</li> <li>If used for more than one channel, each channel has a separate traffic generator and traffic checker with separate CSR space.</li> <li>Reads and Writes to individual traffic controller CSR spaces can be done by selecting that particular channel using channel select register.</li> </ul> <p>The HE-HSSI Ethernet block diagram is below.</p> <p>Figure 13-3: HE-HSSI Block Diagram Block Diagram</p> <p></p> <p>The diagram below shows the path followed depending on if you enable loopback mode in HE-HSSI or not. In loopback mode, traffic is looped back into the transmit path which will bypass traffic. Alternatively, the traffic generates traffic.</p> <p>Figure 13-4: HE-HSSI Operation Mode Traffic Patterns </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1322-he-hssi-csr-map","title":"13.2.2 HE-HSSI CSR Map","text":"<p>The reference HSSI AFU contains the following registers and a similar arrangement of register space can be implemented for other use case-specific HSSI AFUs.</p> <ul> <li>AFU DFH Register: Device feature header for the AFU (AFU_DFH)</li> <li>AFU ID Registers: 128-bit UUID for the AFU which occupies two 64-bit registers (AFU_ID_L, AFU_ID_H)</li> <li>Mailbox Registers: Command and Data register for traffic controller register access. It follows the standard access method defined for OFS. Access method and implementation is same as Reconfiguration Interface defined for the HSSI FIM. (TRAFFIC_CTRL_CMD, TRAFFIC_CTRL_DATA)</li> <li>Channel Select Register: Channel select register for traffic controller mailbox access. It is used in cases where more than one channel is in the AFU, else it defaults to zero, meaning channel-0 is selected. (TRAFFIC_CTRL_PORT_SEL)</li> <li>Scratchpad Register: Scratchpad register for CSR access checking. (AFU_SCRATCHPAD)</li> </ul> <p>The CSR excel for HE-HSSI module can be found at ofs-fim-common/src/common/he_hssi/HE_HSSI_CSR.xls.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#133-he-null-overview","title":"13.3 HE-Null Overview","text":"<p>This module is a simple stub that is used to replace various HE and other blocks in the FIM whenever they are bypassed using the qsf compiler directive such as null_he_lb, null_he_hssi, null_he_mem and null_he_mem_tg. To find out more about these compiler directives, refer to the [Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs].</p> <p>Table 13-1 HE-Null DFH</p> REGISTER NAME ADDRESS ACCESS DEFAULT DESCRIPTION DFH 0x0000 RO 0x0000_0000_1000_0000 DFH register GUID_L 0x0008 RO 0xaa31f54a3e403501 Lower 64b of GUID GUID_H 0x0010 RO 0x3e7b60a0df2d4850 Upper 64b of GUID SCRATCHPAD 0x0018 RW 0x0 Scratchpad <p>Figure 13-5: HE-Null Block Diagram</p> <p></p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#14-reliability-accessibility-serviceability-ras-and-error-handling","title":"14 Reliability, Accessibility, Serviceability (RAS) and Error Handling","text":"<ol> <li>Downstream AFU checker: Identifies AFU violations.  For example, these checker flags violations of the interface specification. </li> <li>Upstream software or PCIe link checker: Identifies invalid traffic from PCIe that violates FIM or PCIe specifications. For example, this checker flags an application sending traffic if it violates the FIM specification or creates a PCIe link issue by causing completion timeout or malformed TLP. </li> <li>FIM - Checks for bugs in the FIM fabric.</li> </ol> <p>Errors reported by the checker are logged in either the FME error registers port error registers, or both, as shown in the table below.  For more details on each of the registers, please refer to FME_CSR.xls</p> <p>Table 14-1: Error Registers</p> MMIO Region Area Register Description FME CoreFIM FME_ERROR FME Error Status Register 0.  Registers parity errors, underflow or overflow errors and access mismatches. FME CoreFIM FME_ERROR0_MASK FME Error Mask Register 0.  Write a 0 to mask errors in the FME Error Status Register 0. FME External PCIE0_ERROR PCIe0 Error Status Register. FME External PCIE0_ERROR_MASK PCIe0 Error Mask Register 0.  Write a 0 to mask errors in the PCIe0 Error Status Register 0. FME CoreFIM FME_FIRST_ERROR First FME Error Register. FME CoreFIM FME_NEXT_ERROR FME Next Error Register. FME CoreFIM RAS_NOFAT_ERR_STAT Reliability/Accessibility/Serviceability (RAS) Non-Fatal Error Status Register. FME CoreFIM RAS_NOFAT_ERR_MASK RAS Non-Fatal Error Mask Register. Write 0 to mask error fields in RAS_NOFAT_ERR_STAT Register. FME CoreFIM RAS_CATFAT_ERR_STAT RAS Catastrophic and Fatal Errors Status Register. FME CoreFIM RAS_CATFAT_ERR_MASK RAS Catastrophic and Fatal Errors Mask Register. Write 0 to mask error fields in the RAS_CATFAT_ERR_STAT Register. FME CoreFIM RAS_ERROR_INJ RAS error Injection Register. PORT CoreFIM PORT_ERROR Port Error Status Register. PORT CoreFIM PORT_FIRST_ERROR Port First Error Register . PORT CoreFIM PORT_MALFORMED_REQ0 Port Malformed Request Register 0.  Provides malformed request header LSBs. PORT CoreFIM PORT_MALFORMED_REQ1 Port Malformed Request Register 1.  Provides malformed request header MSBs."},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#141-fme-errors","title":"14.1 FME Errors","text":""},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1411-fme_error0","title":"14.1.1 FME_ERROR0","text":"<p>The FME_ERROR0 register flags CoreFIM FME errors in the Global Error (GLBL_ERROR) private feature. The error bits in this register are sticky bits. You can only clear these bits through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in FME_ERROR0_MASK register masks the error.</p> <p>Table 14-2: FME Error Types</p> Error Type Description Fabric errors FIFO underflow/overflow condition in CoreFIM. These errors only occur if you have introduced bugs into the FIM or during very rare single event upset (SEU) or SEU-like events. Invalid port access A port can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the Port. If it finds a PF is trying to access a port that is mapped to a VF or vice-versa, an error will be reported. Invalid AFU access An AFU can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the AFU associated with the Port. If it finds a PF is trying to access an AFU that is mapped to a VF or vice-versa, an error is reported and a fake response is sent back to the requester to avoid a completion timeout on the host."},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1412-pcie0_error","title":"14.1.2 PCIE0_ERROR","text":"<p>The PCIe Avalon-ST to Arm\u00ae AMBA\u00ae 4 AXI4-Stream bridge monitors the PCIe link for errors and logs any such errors in the PCIE0_ERROR register (in PCIE0 feature region) and PCIE0_ERROR register in the GLBL_ERR private feature.    The error bits in the PCIE0_ERROR register are sticky bits that you can only clear through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in PCIE0_ERROR0_MASK masks the error.  </p> <p>If you have other external FME features, you can add similar _ERROR registers to this space. Please refer to the following spreadsheet: https://github.com/OFS/ofs-f2000x-pl/ipss/pcie/rtl/PCIE_CSR.xls or the SystemVerilog file: https://github.com/OFS/ofs-f2000x-pl/ipss/pcie/rtl/pcie_csr.sv for more details on this register.  <p>NOTE</p> <p>The PCIE0_ERROR register is located in both the Global Error external feature memory space and a separate PCIe external feature memory space.  OPAE software supports the PCIe external feature memory space beginning at offset 0x40000 for OFS EA and going forward.  PCIe registers beginning at 0x4000 in the Global Error external feature memory space are there for backward compatibility to the Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1413-fme_first_error-fme_next_error","title":"14.1.3 FME_FIRST_ERROR, FME_NEXT_ERROR","text":"<p>The FME_FIRST_ERROR register flags which of the FME error reporting registers, such as FME_ERROR0, PCIE0_ERROR0, has reported the first error occurrence. The error fields of the first error register are then continuously logged into the FME_FIRST_ERROR register until a system reset or software clears all the errors in that first error register. Likewise, the FME_NEXT_ERROR indicates which of the FME error reporting registers (except the first error register) has reported the next occurrence of error after the first error register. The error fields of the next error register are continuously logged into the FME_NEXT_ERROR register until a system reset or software clears all the errors in the second error register.</p> <p>Please refer to fme_csr.sv for individual register field descriptions or the SystemVerilog file: fme_csr.sv</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1414-reliability-accessibility-serviceability-ras-error-status","title":"14.1.4 Reliability, Accessibility, Serviceability (RAS) Error Status","text":"<p>The RAS feature in CoreFIM labels errors as non-fatal, fatal or catastrophic based on their impact to the system.  * A non-fatal error usually originates from software or an AFU.  With a non-fatal error, the user application may still be able to recover from the error by performing a soft reset on the AFU, fixing the user application software if necessary, and clearing the error. On the other hand, a fatal or catastrophic error is non-recoverable and requires the platform to be reset. * Non-fatal errors are logged in the RAS_NOFAT_ERR_STAT register and fatal or catastrophic errors are logged in the RAS_CATFAT_ERR_STAT register.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#14141-non-fatal-errors","title":"14.1.4.1 Non-Fatal Errors","text":"<p>The RAS_NOFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It logs the high-level status of non-fatal errors in the hardware.  Unlike the error bits in the PCIE0_ERROR and FME_ERROR0 registers which are RW1C (software can write a 1 to clear the error), the error bits in this register are read-only and can only be cleared by system reset. Software has an option to mask the error using RAS_NOFAT_ERR_MASK.</p> <p>Please refer to FME_CSR.xls for individual register field descriptions or the SystemVerilog file: fme_csr.sv</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#14142-catastrophic-fatal-errors","title":"14.1.4.2 Catastrophic &amp; Fatal Errors","text":"<p>The RAS_CATFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It captures the high-level status of errors that can only be recovered with a system reset. Therefore, the error bits in the RAS_CATFAT_ERR_STAT register are read-only and can only be cleared by system reset or masked through RAS_CATFAT_ERR_MASK. Please refer to FME_CSR.xls for individual register field descriptions or the SystemVerilog file: fme_csr.sv</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1415-ras-error-injection","title":"14.1.5 RAS Error Injection","text":"<p>For software testing purposes, you can inject non-fatal, fatal, and catastrophic errors into the platform through the RAS_ERROR_INJ register.  These errors are reported in the RAS_CATFAT_ERR_STAT and RAS_NOFAT_ERR_STAT registers. Please refer to FME_CSR.xls for individual register field descriptions or the SystemVerilog file: fme_csr.sv</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1416-fme-error-interrupts","title":"14.1.6 FME Error Interrupts","text":"<p>In an event of an FME error, the MSI-X module in the FIM generates an interrupt so the host can decide on the next course of action. The FIM does not stall upstream and downstream traffic after the FME error. However, a port error triggered by invalid request from a user AFU stalls all the traffic going from AFU to PCIe. The interrupt capability is discoverable by querying the <code>NumbSuppInterrupt</code> field of the PORT_CAPABILITY register in the Port private feature.  The MSI-X vector number is recorded in the <code>InterruptVectorNumber</code> field of the GLBL_ERROR_CAPABILITY register of the Global Error external feature.</p> <p>An FME error interrupt is generated in response to the FME_ERROR0, PCIE0_ERROR0, RAS_NOFAT_ERR_STAT, or RAS_CATFAT_ERR_STAT registers recording a new, unmasked, error per the rules defined by CoreFIM interrupt feature.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#14161-msi-x-masking-pending-bit-array-pba-clearing","title":"14.1.6.1 MSI-X Masking &amp; Pending Bit Array (PBA) Clearing","text":"<p>If the MSI-X vector corresponding to the FME error interrupt is masked, events are recorded in the PBA array.  Clearing the FME error status registers clears the corresponding MSI-X PBA entries.  If only some events are cleared, the normal interrupt triggering rules apply and a new pending interrupt is registered.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1417-fme-error-handling","title":"14.1.7 FME Error Handling","text":"<p>When the host receives an FME error interrupt, it must take the recommended actions described below to bring the system back to its normal operation.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#14171-catastrophicfatal-error","title":"14.1.7.1 Catastrophic/Fatal Error","text":"<p>A system reset is mandatory for any catastrophic or fatal error.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#14172-non-fatal-error","title":"14.1.7.2 Non-Fatal Error","text":"<p>When software receives a non-fatal error interrupt which does not require a system reset, it can take the following steps to clear the error after software handles the error: 1.  Set the *_ERROR_MASK register to all 1\u2019s to mask all errors 2. Clear the *_FIRST_ERROR register 3. Clear the *_ERROR register 4. Set *_ERROR_MASK register to all 0\u2019s to enable all errors</p> <ul> <li>Result: The *_ERROR &amp; *_FIRST_ERROR registers begin capturing new errors.</li> </ul> <p>NOTE</p> <p>A system reset can only clear RAS Error status registers.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#143-mmio-requests","title":"14.3 MMIO Requests","text":"<p>The FIM is designed to gracefully handle MMIO request scenarios.  </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1431-unsupported-functions-and-bar","title":"14.3.1 Unsupported Functions and BAR","text":"<p>The PCIe hard IP in the FIM guarantees that only TLP packets for the functions and BARs supported by the FIM (as configured in PCIe HIP IP instantiation) are sent to the FIM.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1432-mmio-request-decoding","title":"14.3.2 MMIO Request Decoding","text":"<p>The packet router and memory decoder in the FIM ensure that only legal MMIO requests are forwarded to the targeted MMIO region. Full address and BAR decoding is done both in the packet router and the memory decoder to ensure the requests are forwarded to the designated CSR region as defined in the MMIO Regions chapter.  Any unsolicited/illegal MMIO request is dropped, and an error is reported back to host through the FME error register.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1433-unused-fmeport-csr-regions","title":"14.3.3 Unused FME/Port CSR Regions","text":"<p>All the CSR slaves in FIM which are mapped to the FME or Port CSR regions must always respond to MMIO read requests targeting its associated CSR region. A CSR slave must return all 0s for MMIO reads to its unused CSR region such as a reserved space or a region where no CSR register is implemented for the address.</p> <p>The FIM ensures MMIO reads to FME or Port CSR regions that are not mapped to any CSR slave always gets a response of all 0s. The memory decoder module and fake responder module in the FIM provide this guaranteed response.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1434-unsupported-mmio-request","title":"14.3.4 Unsupported MMIO Request","text":"<p>Any MMIO request targeting FME or Port CSR regions with a length or address alignment that are not  supported by the FIM is dropped, and an error is logged in PCIE0_ERROR register. The MMIO checker module in the FIM guarantees this response. When an unsupported MMIO read request to the FIM CSR region is detected, the FIM sends back a CPL (completion without data) with error status (UR) back to host.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1435-afu-access-violation","title":"14.3.5 AFU Access Violation","text":"<p>AFU access violations refer to the scenarios where a PF is attempting to access the MMIO region of an AFU bound to a VF (virtualization enabled), or when a VF is trying to access the MMIO region of an AFU bound to a PF (virtualization disabled). When such a violation is detected, the FIM drops the request and logs the error in the FME_ERROR0 register. If the request is an MMIO read request, the FIM returns a fake response to the host.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#1436-afu-mmio-response-timeout","title":"14.3.6 AFU MMIO Response Timeout","text":"<p>An AFU MMIO Response timeout functions in the same manner described in the MMIO Response Timeout section.</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#15-ofs-design-hierarchy","title":"15 OFS Design Hierarchy","text":"<p>Files for design, build and unit test simulation are found at https://github.com/OFS/ofs-f2000x-pl, release branch release/ofs-2023.1.  </p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#151-design-guidance","title":"15.1 Design Guidance","text":"<p>The OFS FIM is designed with configurability and scalability in mind.  At a high level, these are the necessary steps for a user to customize the design.  Please refer to the FPGA Interface Manager Developer's Guide</p> <p>Table 15-2 Features</p> Step Description Comments 1 Re-configure PCIe HIP for additional VFs (if necessary) * PF0 is mandatory for running OPAE software* Only modification of the VFs (added or subtracted) by the user is recommended. * Default configuration supports 1 PF and 3 VFs. 2 Update Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF MUX-DEMUX configuration (if necessary) * The PF/VF MUX-DEMUX is parameterized for flexibility. You can change, add or delete PF or VF functions by updating the top_cfg_pkg.sv file. * You also have the option of keeping the default configuration and tying off the unused VFs if needed. 3 Update top level and AFU level as necessary * If you integrating additional external interfaces, make the edits at the top level (ofs_top.sv) and propagate the interface down to the AFU level (afu_top.sv and soc_afu_top.sv) 4 Add user implemented function(s) in AFU * All of your implemented functions must have the required Arm\u00ae AMBA\u00ae 4 AXI4-Stream interface for both the data path and the MMIO control path to CSRs. * All CSRs in the user-implemented function must have the required DFH layout. * See host exerciser CSRs for reference. 5 Update UVM testbench * The OFS full chip UVM environment is coded specifically for verifying the default configuration containing the host exercisers for the PCIe, memory, and Ethernet. * User must update the UVM testbench to reflect new RTL behavior for any customization changes. See The Simulation User Guide <p>For more information on modifying the FIM, refer to the FPGA Interface Manager Developer's Guide</p>"},{"location":"hw/f2000x/reference_manuals/ofs_fim/mnl_fim_ofs/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/","title":"Platform Evaluation Script: Open FPGA Stack for Intel Agilex SoC Attach FPGAs","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to user space."},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#1-overview","title":"1 Overview","text":""},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a set-up and user guide for the checkout and evaluation of an Intel IPU Platform F2000X-PL development platform using Open FPGA Stack (OFS). After reviewing the document, you will be able to:</p> <ul> <li>Set-up and modify the script to the your environment</li> </ul> <ul> <li>Compile and simulate an OFS reference design</li> </ul> <ul> <li>Run hardware and software tests to evaluate the complete OFS flow</li> </ul>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#table-1-2-software-version-summary","title":"Table 1-2: Software Version Summary","text":"Component Version Description FPGA Platform Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL Intel platform you can use for your custom board development OFS FIM Source Code Branch: https://github.com/OFS/ofs-f2000x-pl, Tag: ofs-2023.1-1 OFS Shell RTL for Intel Agilex FPGA (targeting https://github.com/OFS/ofs-f2000x-pl) OFS FIM Common Branch: https://github.com/OFS/ofs-fim-common/2023.1, Tag: https://github.com/OFS/ofs-fim-common/2023.1 Common RTL across all OFS-based platforms AFU Examples Branch: examples-afu , Tag:ofs-examples-https://github.com/OFS/examples-afu/releases/tag/ofs-2023.1-1 Tutorials and simple examples for the Accelerator Functional Unit region (workload region) OPAE SDK Branch: 2.5.0-3, Tag: 2.5.0-3 Open Programmable Acceleration Engine Software Development Kit Kernel Drivers Branch: ofs-2023.1-5.15-1, Tag: ofs-2023.1-5.15-1 OFS specific kernel drivers OPAE Simulation Branch: opae-sim, Tag: 2.5.0-3 Accelerator Simulation Environment for hardware/software co-simulation of your AFU (workload) Intel Quartus Prime Pro Edition Design Software 23.1 Intel\u00ae Quartus\u00ae Prime Pro Edition Linux Software tool for Intel FPGA Development Operating System Ubuntu 22.04 Operating system on which this script has been tested <p>A download page containing the release and already-compiled FIM binary artifacts that you can use for immediate evaluation on the Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL can be found on the OFS ofs-2023.1-1 official release drop on GitHub.</p> <p></p> Term Abbreviation Description Advanced\u00a0Error\u00a0Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link) Accelerator\u00a0Functional\u00a0Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.\u00a0Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region. Basic Building Block BBB Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. Best\u00a0Known\u00a0Configuration BKC The software and hardware configuration Intel uses to verify the solution. Board\u00a0Management\u00a0Controller BMC Supports features such as board power managment, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate component, such as an Intel\u00ae Max\u00ae 10 or Intel Cyclone\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA. Configuration and\u00a0Status\u00a0Register CSR The generic name for a register space which is accessed in order to interface with the module it resides in (e.g. AFU, BMC, various sub-systems and modules). Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Device\u00a0Feature\u00a0List DFL The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\u00a0This concept is the foundation for the OFS software framework. (link) FPGA\u00a0Interface\u00a0Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FPGA\u00a0Management\u00a0Engine FME Performs reconfiguration and other FPGA management functions. Each FPGA device only has one FME which is accessed through PF0. Host\u00a0Exerciser\u00a0Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Intel\u00a0Virtualization\u00a0Technology for\u00a0Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Joint Test Action Group JTAG Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. Memory\u00a0Mapped\u00a0Input/Output MMIO The memory space users may map and access both control registers and system memory buffers with accelerators. oneAPI Accelerator Support Package oneAPI-asp A collection of hardware and software components that enable oneAPI kernel to communicate with oneAPI runtime and OFS shell components. oneAPI ASP hardware components and oneAPI kernel form the AFU region of a oneAPI system in OFS. Open\u00a0FPGA\u00a0Stack OFS OFS is a software and hardware infrastructure providing an efficient approach to develop a custom FPGA-based platform or workload using an Intel, 3rd party, or custom board. Open\u00a0Programmable\u00a0Acceleration\u00a0Engine Software Development Kit OPAE SDK The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Platform\u00a0Interface\u00a0Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Platform Management Controller Interface PMCI The portion of the BMC that resides in the Agilex FPGA and allows the FPGA to communicate with the primary BMC component on the board. Partial Reconfiguration PR The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. For OFS designs, the PR region is referred to as the pr_slot. Port N/A When used in the context of the fpgainfo port command it represents the interfaces between the static FPGA fabric and the PR region containing the AFU. Remote System Update RSU The process by which the host can remotely update images stored in flash through PCIe. This is done with the OPAE software command \"fpgasupdate\". Secure Device Manager SDM The SDM is the point of entry to the FPGA for JTAG commands and interfaces, as well as for device configuration data (from flash, SD card, or through PCI Express* hard IP). Static Region SR The portion of the FPGA design that cannot be dynamically reconfigured during run-time. Single-Root\u00a0Input-Output\u00a0Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. SYCL SYCL SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Test Bench TB Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. Universal Verification Methodology UVM A modular, reusable, and scalable testbench structure via an API framework.  In the context of OFS, the UVM enviroment provides a system level simulation environment for your design. Virtual\u00a0Function\u00a0Input/Output VFIO An Input-Output Memory Management Unit (IOMMU)/device agnostic framework for exposing direct device access to userspace.\u00a0(link)"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#2-introduction-to-ofs-evaluation-script","title":"2 Introduction to OFS Evaluation Script","text":"<p>By following the setup steps and using the OFS evaluation script you can quickly evaluate many features that the OFS framework provides and also leverage this script for your own development.  </p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#21-pre-requisites","title":"2.1 Pre-Requisites","text":"<p>This script uses the following set of software tools which should be installed using the directory structure below. Tool versions can vary.</p> <ul> <li>Intel Quartus\u00ae Prime Pro Software</li> <li>Synopsys\u00ae VCS Simulator</li> <li>Siemens\u00ae Questa\u00ae Simulator</li> </ul> <p>Figure 2-1 Folder Hierarchy for Software Tools</p> <p></p> <ol> <li> <p>You must create a directory named \"ofs-X.X.X\" where the X represents the current release number, for example ofs-2023.1-1. </p> </li> <li> <p>You must clone the required OFS repositories as per Figure 2-2.  Please refer to the BKC table for locations. Please go [OFS Getting Started User Guide] for the instructions for the BKC installation.</p> </li> <li> <p>Once the repositories are cloned, copy the evaluation script (ofs_f2000x_eval.sh) which is located at [eval_scripts] beneath the $IOFS_BUILD_ROOT directory location as shown in the example below:</p> </li> </ol> <p>Figure 2-2 Directory Structure for OFS Project</p> <pre><code>## ofs-2023.1-1\n##  -&gt; examples-afu\n##  -&gt; linux-dfl\n##  -&gt; ofs-f2000x-pl\n##  -&gt; opae-sdk\n##  -&gt; opae-sim\n##  -&gt; ofs_f2000x_eval.sh\n</code></pre> <ol> <li>Open the README file named (README_ofs_f2000x_eval.txt) which is located at [eval_scripts] which informs the user which sections to modify in the script prior to building the FIM and running hardware, software and simulation tests.</li> </ol>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#22-f2000x-evaluation-script-modification","title":"2.2 f2000x Evaluation Script modification","text":"<p>To adapt this script to the user environment please follow the instructions below which explains which line numbers to change in the ofs_f2000x_eval.sh script </p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#user-directory-creation","title":"User Directory Creation","text":"<p>The user must create the top-level source directory and then clone the OFS repositories</p> <pre><code>mkdir ofs-2023.1-1\n</code></pre> <p>In the example above we have used ofs-2023.1-1 as the directory name</p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#set-up-proxy-server-lines-65-67","title":"Set-Up Proxy Server (lines 65-67)","text":"<p>Please enter the location of your proxy server to allow access to external internet to build software packages.</p> <p>Note: Failing to add proxy server will prevent cloning of repositories and the user will be unable to build the OFS framework.</p> <pre><code>export http_proxy=&lt;user_proxy&gt;\nexport https_proxy=&lt;user_proxy&gt;\nexport no_proxy=&lt;user_proxy&gt;\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#license-files-lines-70-72","title":"License Files (lines 70-72)","text":"<p>Please enter the the license file locations for the following tool variables</p> <pre><code>export LM_LICENSE_FILE=&lt;user_license&gt;\nexport DW_LICENSE_FILE=&lt;user_license&gt;\nexport SNPSLMD_LICENSE_FILE=&lt;user_license&gt;\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#tools-location-line-85-86-87-88","title":"Tools Location (line 85, 86, 87, 88)","text":"<p>Set Location of Quartus, Synopsys and Questasim</p> <pre><code>export QUARTUS_TOOLS_LOCATION=/home\nexport SYNOPSYS_TOOLS_LOCATION=/home\nexport QUESTASIM_TOOLS_LOCATION=/home\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#quartus-tools-version-line-93","title":"Quartus Tools Version (line 93)","text":"<p>Set version of Quartus</p> <pre><code>export QUARTUS_VERSION=23.1\n</code></pre> <p>In the example above \"23.1\" is used as the Quartus tools version</p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#opae-tools-line-106","title":"OPAE Tools (line 106)","text":"<p>change OPAE SDK VERSION</p> <pre><code>export OPAE_SDK_VERSION=2.5.0-3\n</code></pre> <p>In the example above \"2.5.0-3\" is used as the OPAE SDK tools version</p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#pcie-bus-number-lines-230-and-237","title":"PCIe (Bus Number) (lines 230 and 237)","text":"<p>The Bus number must be entered by the user after installing the hardware in the chosen server, in the example below \"b1\" is the Bus Number for a single card as defined in the evaluation script.</p> <pre><code>export ADP_CARD0_BUS_NUMBER=b1\n</code></pre> <p>The evaluation script uses the bus number as an identifier to interrogate the card. The command below will identify the accelerater card plugged into a server. </p> <pre><code>lspci | grep acc\n\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <p>The result identifies the card as being assigned \"b1\" as the bus number so the entry in the script changes to</p> <pre><code>export ADP_CARD0_BUS_NUMBER=b1\n</code></pre> <p>The user can also run the following command on the ofs_f2000x_eval.sh script to automatically change the bus number to b1 in the ofs_f2000x_eval.sh script.</p> <p>grep -rli 'b1' * | xargs -i@ sed -i 'b1' @</p> <p>if the bus number is 85 for example </p> <pre><code>85:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <p>the command to change to 85 in the evaluation script would be</p> <p>grep -rli 'b1' * | xargs -i@ sed -i '85' @</p> <p>The ofs_f2000x_eval.sh script has now been modified to the server set-up and the user can proceed to build, compile and simulate the OFS stack</p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#3-f2000x-evaluation-script","title":"3 f2000x Evaluation Script","text":""},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#31-overview","title":"3.1 Overview","text":"<p>The figure below shows a snapshot of the full evaluation script menu showing all 62 options and each one one of 11 sub-menus which focus on different areas of evaluation. Each of these menu options are described in the next section.</p> <p>Figure 3-1 ofs_f2000x_eval.sh Evaluation Menu</p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#311-adp-tools-menu","title":"3.1.1 ADP TOOLS MENU","text":"<p>By selecting \"List of Documentation for ADP f2000x Project,\" a list of links to the latest OFS documentation appears. Note that these links will take you to documentation for the most recent release which may not correspond to the release version you are evaluating. To find the documentation specific to your release, ensure you clone the intel-ofs-docs tag that corresponds to your OFS version.</p> <p>By selecting \"Check Versions of Operating System and Quartus Premier Design Suite\", the tool verifies correct Operating System, Quartus version, kernel parameters, license files and paths to installed software tools.</p> <p></p> Menu Option Example Output 1 - List of Documentation for ADP f2000x Project  Open FPGA Stack Overview                  Guides you through the setup and build steps to evaluate the OFS solution                 https://ofs.github.io 2 - Check versions of Operating System and Quartus Premier Design Suite (QPDS) Checking Linux release                 Linux version 5.15.92-dfl-66b0076c2c-lts (oe-user@oe-host) (x86_64-ese-linux-gcc (GCC) 11.3.0, GNU ld (GNU Binutils) 2.38.20220708) #1 SMP PREEMPT Wed Feb 8 21:21:27 UTC 2023                  Checking RedHat release                 cat: /etc/redhat-release: No such file or directory                  Checking Ubuntu release                 cat: /etc/lsb-release: No such file or directory                  Checking Kernel parameters                 initrd=\\microcode.cpio LABEL=Boot root=PARTUUID=2beb0add-07bf-4736-bc31-9b60e7b78375  rootfstype=ext4  console=ttyS5,115200 iomem=relaxed intel_iommu=on pci=realloc default_hugepagesz=1G hugepagesz=1G hugepages=4 rootwait console=ttyS0,115200 console=tty0                  Checking Licenses                 LM_LICENSE_FILE is set to port@socket number:port@socket number                 DW_LICENSE_FILE is set to port@socket number:port@socket number                 SNPSLMD_LICENSE_FILE is set to port@socket number:port@socket number                  Checking Tool versions                 QUARTUS_HOME is set to /home/intelFPGA_pro/23.1/quartus                 QUARTUS_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus                 IMPORT_IP_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus/../ip                 QSYS_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus/../qsys/bin                  Checking QPDS Patches                 Quartus Prime Shell                 Version 23.1 Build XXX XX/XX/XXXX Patches X.XX SC Pro Edition                 Copyright (C) XXXX  Intel Corporation. All rights reserved."},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#312-adp-hardware-menu","title":"3.1.2 ADP HARDWARE MENU","text":"<p>Identifies card by PCIe number, checks power, temperature and current firmware configuration. </p> <p></p> Menu Option Example Output 3 - Identify Acceleration Development Platform (ADP) f2000x Hardware via PCIe PCIe card detected as                 15:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)                 Host Server is connected to SINGLE card configuration 4 - Identify the Board Management Controller (BMC) Version and check BMC sensors Intel IPU Platform F2000X-PL                 Board Management Controller NIOS FW version: 1.1.9                 Board Management Controller Build version: 1.1.9                 //****** BMC SENSORS ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:15:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x17D4                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x5010302EB5E4B14                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 3e46f208-8b49-5899-9e3d-b8b6a4d25a4e 5 - Identify the FPGA Management Engine (FME) Version Intel IPU Platform F2000X-PL                 Board Management Controller NIOS FW version: 1.1.9                 Board Management Controller Build version: 1.1.9                 //****** FME ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:15:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x17D4                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x5010302EB5E4B14                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 3e46f208-8b49-5899-9e3d-b8b6a4d25a4e                 Boot Page                        : user1                 User1 Image Info                 : 9e3db8b6a4d25a4e3e46f2088b495899                 User2 Image Info                 : 9e3db8b6a4d25a4e3e46f2088b495899                 Factory Image Info               : None 6 - Check Board Power and Temperature Intel IPU Platform F2000X-PL                 Board Management Controller NIOS FW version: 1.1.9                 Board Management Controller Build version: 1.1.9                 //****** POWER ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:15:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x17D4                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x5010302EB5E4B14                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 3e46f208-8b49-5899-9e3d-b8b6a4d25a4e                 ( 1) QSFP (Primary) Supply Rail Voltage                 : N/A                 etc ......................                  Intel IPU Platform F2000X-PL                 Board Management Controller NIOS FW version: 1.1.9                 Board Management Controller Build version: 1.1.9                 //****** TEMP ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:15:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x17D4                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x5010302EB5E4B14                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 3e46f208-8b49-5899-9e3d-b8b6a4d25a4e                 ( 1) FPGA FABRIC Remote Digital Temperature#3           : 33.00 Celsius                 etc ...................... 7 - Check Accelerator Port status //****** PORT ******//                 Object Id                        : 0xEF00000                 PCIe s:b:d.f                     : 0000:15:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x17D4                 Socket Id                        : 0x00 8 - Check MAC and PHY status Intel IPU Platform F2000X-PL                 Board Management Controller NIOS FW version: 1.1.9                 Board Management Controller Build version: 1.1.9                 //****** MAC ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:15:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x17D4                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x5010302EB5E4B14                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 3e46f208-8b49-5899-9e3d-b8b6a4d25a4e                 Number of MACs                   : 255                 mac info is not supported                  Intel IPU Platform F2000X-PL                 Board Management Controller NIOS FW version: 1.1.9                 Board Management Controller Build version: 1.1.9                 //****** PHY ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:15:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x17D4                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x5010302EB5E4B14                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 3e46f208-8b49-5899-9e3d-b8b6a4d25a4e                 QSFP0                            : Connected                 QSFP1                            : Connected                  //****** HSSI information ******//                 HSSI version                     : 1.0                 Number of ports                  : 8                 Port0                            :25GbE        DOWN                 Port1                            :25GbE        DOWN                 Port2                            :25GbE        DOWN                 Port3                            :25GbE        DOWN                 Port4                            :25GbE        DOWN                 Port5                            :25GbE        DOWN                 Port6                            :25GbE        DOWN                 Port7                            :25GbE        DOWN"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#313-adp-pfvf-mux-menu","title":"3.1.3 ADP PF/VF MUX MENU","text":"<p>This menu reports the number of PF/VF functions in the reference example and also allows you to reduce the number to 1PF and 1VF to reduce resource utilisation and create larger area for your workload development. This selection is optional and if the user wants to implement the default number of PF's and VF's then option 9, 10 and 11 should not be used.  Additionally the code used to make the PF/VF modification can be leveraged to increase or modify the number of PF/VFs in the existing design within the limits that the PCIe Subsystem supports (8PF/2K VFs)</p> <p></p> Menu Option Description 9 - Check PF/VF Mux Configuration  This menu selection displays the current configuration of the pcie_host.ofss and pcie_soc.ofss file which is located at the following directory $OFS_ROOTDIR/tools/pfvf_config_tool                  [ProjectSettings]                 platform = f2000x                 fim = base_x16                 family = Agilex                 Part = AGFC023R25A2E2VR0                 IpDeployFile = pcie_ss.sh                 IpFile = pcie_ss.ip                 OutputName = pcie_ss                 ComponentName = pcie_ss                 is_host = True                  [pf0]                  [pf1]                  [ProjectSettings]                 platform = f2000x                 fim = base_x16                 family = Agilex                 Part = AGFC023R25A2E2VR0                 IpDeployFile = pcie_ss.sh                 IpFile = pcie_ss.ip                 OutputName = soc_pcie_ss                 ComponentName = pcie_ss                 is_host = False                  [pf0]                 pg_enable = True                 num_vfs = 3 10 - Modify PF/VF Mux Configuration As an example this menu selection modifies the pcie_host.ofss and pcie_soc.ofss file to 1 PF located in the following directory $OFS_ROOTDIR/tools/pfvf_config_tool             This option also displays the the modified pcie_host.ofss and pcie_soc.ofss files 11 - Build PF/VF Mux Configuration If option 10 is not used then then the default number of PF's and VF's is used to build the FIM, if option 10 is selected then only 1 VF is built to reduce logic utilisation"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#314-adp-fimpr-build-menu","title":"3.1.4 ADP FIM/PR BUILD MENU","text":"<p>Builds FIM, Partial Reconfiguration Region and Remote Signal Tap</p> <p></p> Menu Option Description 12 - Check ADP software versions for ADP f2000x Project OFS_ROOTDIR is set to /home/user_area/ofs-X.X.X/ofs-f2000x-pl                 OPAE_SDK_REPO_BRANCH is set to release/X.X.X                 OPAE_SDK_ROOT is set to /home/user_area/ofs-X.X.X/ofs-f2000x-pl/../opae-sdk                 LD_LIBRARY_PATH is set to /home/user_area/ofs-X.X.X/ofs-f2000x-pl/../opae-sdk/lib64: 13 - Build FIM for f2000x Hardware This option builds the FIM based on the setting for the $ADP_PLATFORM, $FIM_SHELL environment variable. Check this variable in the following file ofs_f2000x_eval.sh 14 - Check FIM Identification of FIM for f2000x Hardware The FIM is identified by the following file fme-ifc-id.txt located at $OFS_ROOTDIR/$FIM_WORKDIR/syn/syn_top/ 15 - Build Partial Reconfiguration Tree for f2000x Hardware This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development 16 - Build Base FIM Identification(ID) into PR Build Tree template This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU workloads 17 - Build Partial Reconfiguration Tree for f2000x Hardware with Remote Signal Tap This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development for the Remote Signal Tap flow 18 - Build Base FIM Identification(ID) into PR Build Tree template with Remote Signal Tap This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree for Remote Signal Tap to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU workloads"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#315-adp-hardware-programmingdiagnostic-menu","title":"3.1.5 ADP HARDWARE PROGRAMMING/DIAGNOSTIC MENU","text":"<p>The following submenu allows you to: * Program and check flash  * Perform a remote system update (RSU) of the FPGA image into the FPGA * Bind virtual functions to VFIO PCIe driver  * Run host exerciser (HE) commands such as loopback to test interfaces VFIO PCI driver binding * Read the control and status registers (CSRs) for bound modules that are part of the OFS reference design.</p> <p></p> Menu Option Description 19 - Program BMC Image into f2000x Hardware The user must place a new BMC flash file in the following directory $OFS_ROOTDIR/bmc_flash_files. Once the user executes this option a new BMC image will be programmed. A remote system upgrade command is initiated to store the new BMC image 20 - Check Boot Area Flash Image from f2000x Hardware This option checks which location area in FLASH the image will boot from, the default is user1              Boot Page : user1 21 - Program FIM Image into user1 area for f2000x Hardware This option programs the FIM image \"ofs_top_page1_unsigned_user1.bin\" into user1 area in flash 22 - Initiate Remote System Upgrade (RSU) from user1 Flash Image into f2000x Hardware This option initiates a Remote System Upgrade and soft reboots the server and re-scans the PCIe bus for the new image to be loaded              2022-11-10 11:26:24,307 - [[pci_address(0000:b1:00.0), pci_id(0x8086, 0xbcce)]] performing RSU operation             2022-11-10 11:26:24,310 - [[pci_address(0000:b0:02.0), pci_id(0x8086, 0x347a)]] removing device from PCIe bus             2022-11-10 11:26:24,357 - waiting 10 seconds for boot             2022-11-10 11:26:34,368 - rescanning PCIe bus: /sys/devices/pci0000:b0/pci_bus/0000:b0             2022-11-10 11:26:35,965 - RSU operation complete 23 - Check PF/VF Mapping Table, vfio-pci driver binding and accelerator port status This option checks the current vfio-pci driver binding for the PF's and VF's 24 - Unbind vfio-pci driver This option unbinds the vfio-pci driver for the PF's and VF's 25 - Create Virtual Functions (VF) and bind driver to vfio-pci f2000x Hardware This option creates vfio-pci driver binding for the PF's and VF's             Once the VF's have been bound to the driver the user can select menu option 23 to check that the new drivers are bound 26 - Verify FME Interrupts with hello_events The hello_events utility is used to verify FME interrupts. This tool injects FME errors and waits for error interrupts, then clears the errors 27 - Run HE-LB Test This option runs 5 tests              1) checks and generates traffic with the intention of exercising the path from the AFU to the Host at full bandwidth             2) run a loopback throughput test using one cacheline per request             3) run a loopback read test using four cachelines per request             4) run a loopback write test using four cachelines per request             5) run a loopback throughput test using four cachelines per request 28 - Run HE-MEM Test This option runs 2 tests              1) Checking and generating traffic with the intention of exercising the path from FPGA connected DDR; data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host             2) run a loopback throughput test using one cacheline per request 29 - Run HE-HSSI Test This option runs 1 test              HE-HSSI is responsible for handling client-side ethernet traffic. It wraps the 10G and 100G HSSI AFUs, and includes a traffic generator and checker. The user-space tool hssi exports a control interface to the HE-HSSI's AFU's packet generator logic              1) Send traffic through the 10G AFU              30 - Run Traffic Generator AFU Test This option runs 3 tests              TG AFU has an OPAE application to access &amp; exercise traffic, targeting a specific bank              1) Run the preconfigured write/read traffic test on channel 0             2) Target channel 1 with a 1MB single-word write only test for 1000 iterations             3) Target channel 2 with 4MB write/read test of max burst length for 10 iterations 31 - Read from CSR (Command and Status Registers) for f2000x Hardware This option reads from the following CSR's             HE-LB Command and Status Register Default Definitions             HE-MEM Command and Status Register Default Definitions             HE-HSSI Command and Status Register Default Definitions"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#316-adp-hardware-afu-testing-menu","title":"3.1.6  ADP HARDWARE AFU TESTING MENU","text":"<p>This submenu tests partial reconfiguration by building and loading an memory-mapped I/O example AFU/workload, executes software from host, and tests remote signal tap.</p> <p></p> Menu Option Description 32 - Build and Compile host_chan_mmio example This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS (Green Bit Stream) ready for hardware programming 33 - Execute host_chan_mmio example This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test 34 - Modify host_chan_mmio example to insert Remote Signal Tap This option inserts a pre-defined host_chan_mmio.stp Signal Tap file into the OFS code to allow a user to debug the host_chan_mmio AFU example 35 - Build and Compile host_chan_mmio example with Remote Signal Tap This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS(Green Bit Stream) ready for hardware programming with Remote Signal tap enabled 36 - Execute host_chan_mmio example with Remote Signal Tap This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test. The user must open the Signal Tap window when running the host code to see the transactions in the Signal tap window"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#317-adp-hardware-afu-bbb-testing-menu","title":"3.1.7 ADP HARDWARE AFU BBB TESTING MENU","text":"<p>This submenu tests partial reconfiguration using a hello_world example AFU/workload, executes sw from host</p> <p></p> Menu Option Description 37 - Build and Compile hello_world example This option builds the hello_ world example from the following repo $FPGA_BBB_CCI_SRC/samples/tutorial/afu_types/01_pim_ifc/$AFU_BBB_TEST_NAME, where AFU_BBB_NAME=hello_world. This produces a GBS(Green Bit Stream) ready for hardware programming 38 - Execute hello_world example This option builds the host code for hello_world example and programs the GBS file and then executes the test"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#319-adp-unit-test-project-menu","title":"3.1.9 ADP UNIT TEST PROJECT MENU","text":"<p>Builds, compiles and runs standalone simulation block tests. More unit test examples are found at the following location ofs-f2000x-pl/sim/unit_test </p> <p></p> Menu Option Result 39 - Generate Simulation files for Unit Test This option builds the simulation file set for running a unit test simulation 40 - Simulate Unit Test dfh_walker and log waveform This option runs the dfh_walker based on the environment variable \"UNIT_TEST_NAME=dfh_walker\" in the evaluation script. A user can change the test being run by modifying this variable"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#3110-adp-uvm-project-menu","title":"3.1.10 ADP UVM PROJECT MENU","text":"<p>Builds, compiles and runs full chip simulation tests. The user should execute the options sequentially ie 41,42, 43 and 44</p> <p></p> Menu Option Description 41 - Check UVM software versions for f2000x Project DESIGNWARE_HOME is set to /home/synopsys/vip_common/vip_Q-2020.03A                 UVM_HOME  is set to /home/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm                 VCS_HOME is set to /home/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel                 VERDIR is set to /home/user_area/ofs-X.X.X/fim-f2000x-pl/verification                 VIPDIR is set to /home/user_area/ofs-X.X.X/fim-f2000x-pl/verification 42 - Compile UVM IP This option cmpiles the UVM IP  43 - Compile UVM RTL and Testbench This option compiles the UVM RTL and Testbench 44 - Simulate UVM dfh_walking_test and log waveform This option runs the dfh_walking test based on the environment variable \"UVM_TEST_NAME=dfh_walking_test\" in the evaluation script. A user can change the test being run by modifying this variable 45 - Simulate all UVM test cases (Regression Mode) This option runs the f2000x regression mode, cycling through all UVM tests defined in verification/tests/test_pkg.svh file"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#3111-adp-build-all-project-menu","title":"3.1.11 ADP BUILD ALL PROJECT MENU","text":"<p>Builds the complete OFS flow, good for regression testing and overnight builds</p> <p>For this menu a user can run a sequence of tests (compilation, build and simulation) and executes them sequentially. After the script is successfully executed, a set of binary files is produced which a you can use to evaluate your hardware. Log files are also produced which checks whether the tests passed.</p> <p>A user can run a sequence of tests and execute them sequentially. In the example below when the user selects option 46 from the main menu the script will execute 24 tests ie (main menu options 2, 9, 12, 13, 14, 15, 16, 17, 18, 32, 34, 35, 37, 39, 40, 41, 42, 43 and 44. These 19 menu options are chosen to build the complete OFS flow covering build, compile and simulation.</p> <p></p> Menu Option Result 46 - Build and Simulate Complete f2000x Project Generating Log File with date and timestamp                 Log file written to /home/guest/ofs-2.3.1/log_files/f2000x_log_2022_11_10-093649/ofs_f2000x_eval.log"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#definition-of-multi-test-set-up","title":"Definition of Multi-Test Set-up","text":"<p>Menu Option 46 above in the evaluation script can be refined to tailor it to the users need and is principally defined by the variable below</p> <p>MULTI_TEST[A,B]=C</p> <p>where</p> <p>A= Total Number of menu options in script B= Can be changed to a number to select the test order C= Menu Option in Script</p> <p>Example 1 MULTI_TEST[46,0]=2</p> <p>A= 46 is the total number of options in the script B= 0 indicates that this is the first test to be run in the script C= Menu option in Script ie 2- List of Documentation for ADP f2000x Project</p> <p>Example 2 MULTI_TEST[46,0]=2 MULTI_TEST[46,1]=9</p> <p>In the example above two tests are run in order ie 0, and 1 and the following menu options are executed ie 2- List of Documentation for ADP f2000x Project and 9 - Check ADP software versions for ADP f2000x Project</p> <p>The user can also modify the build time by de-selecting options they do not wish to use, see below for a couple of use-case scenarios.</p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#default-user-case","title":"Default User Case","text":"<p>A user can run a sequence of tests and execute them sequentially. In the example below when the user selects option 46 from the main menu the script will execute 24 tests ie (main menu options 2, 9, 12, 13, 14, 15, 16, 17, 18, 32, 34, 35, 37, 39, 40, 41, 42, 43 and 44. All other tests with an \"X\" indicates do not run that test</p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#user-case-for-adp-fimpr-build-menu","title":"User Case for ADP FIM/PR BUILD MENU","text":"<p>In the example below when the user selects option 46 from the main menu the script will only run options from the ADP FIM/PR BUILD MENU (7 options, main menu options 12, 13, 14, 15, 16, 17 and 18). All other tests with an \"X\" indicates do not run that test.</p> <p></p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#4-f2000x-common-test-scenarios","title":"4 f2000x Common Test Scenarios","text":"<p>This section will describe the most common compile build scenarios if a user wanted to evaluate an acceleration card on their server. The Pre-requisite column indcates the menu comamnds that must be run befere executing the test eg To run Test 5 then a user needs to have run option 13, 15 and 16 before running options 23, 24, 25, 32 and 33.</p> Test Test Scenario Pre-Requisite Menu Option Menu Option Test 1 FIM Build - 13 Test 2 Partial Reconfiguration Build 13 15, 16 Test 3 Program FIM and perform Remote System Upgrade 13 21, 22 Test 4 Bind PF and VF to vfio-pci drivers - 23, 24, 25 Test 5 Build, compile and test AFU on hardware 13, 15, 16 23, 24, 25, 32, 33 Test 6 Build, compile and test AFU Basic Building Blocks on hardware 13, 15, 16 23, 24, 25, 37, 38 Test 7 Build and Simulate Unit Tests - 39, 40 Test 8 Build and Simulate UVM Tests - 42, 43, 44, 45"},{"location":"hw/f2000x/user_guides/ug_eval_ofs/ug_eval_script_ofs_f2000x/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/","title":"OFS Getting Started Guide for Intel Agilex SoC Attach FPGAs","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#10-about-this-document","title":"1.0 About this Document","text":"<p>The purpose of this document is to help users get started in evaluating the 2023.1 version of the SoC Attach release targeting the Intel\u00ae Infrastructure Processing Unit (Intel\u00ae IPU) Platform F2000X-PL. After reviewing this document, a user shall be able to:</p> <ul> <li>Set up their server environment according to the Best Known Configuration (BKC)</li> <li>Build a Yocto image with the OPAE SDK and Linux DFL Drivers included</li> <li>Load and verify firmware targeting the SR and PR regions of the board, the BMC, and the ICX-D SoC NVMe and BIOS</li> <li>Verify full stack functionality offered by the SoC Attach OFS solution</li> <li>Know where to find additional information on other SoC Attach ingredients</li> </ul>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#11-audience","title":"1.1 Audience","text":"<p>The information in this document is intended for customers evaluating the Intel IPU Platform F2000X-PL. The card is an acceleration development platform (ADP) intended to be used as a starting point for evaluation and development. This document will cover key topics related to initial bring up and development of the Intel IPU Platform F2000X-PL, with links for deeper dives on the topics discussed therein.</p> <p>Note: Code command blocks are used throughout the document. Commands that are intended for you to run are preceded with the symbol '$', and comments with '#'. Full command output may not be shown.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-1-terminology","title":"Table 1: Terminology","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to user space."},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-2-related-documentation","title":"Table 2: Related Documentation","text":"Name Location Platform Evaluation Script: Open FPGA Stack for Intel Agilex FPGA link FPGA Interface Manager Technical Reference Manual for Intel Agilex SoC Attach: Open FPGA Stack link Software Reference Manual: Open FPGA Stack link Intel\u00ae FPGA Interface Manager Developer Guide: Intel Agilex SoC Attach: Open FPGA Stack link Intel\u00ae Accelerator Functional Unit Developer Guide: Open FPGA Stack for Intel\u00ae Agilex\u00ae FPGAs SoC Attach link Security User Guide: Intel Open FPGA Stack link Virtual machine User Guide: Open FPGA Stack + KVM link Docker User Guide: Intel\u00ae Open FPGA Stack link Release Notes link - under \"Important Notes\" Board Management Controller User Guide v1.1.9 (Pre-Release): Intel IPU Platform F2000X-PL Work with your Intel sales representative for access"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-3-related-repositories","title":"Table 3: Related Repositories","text":"Name Location Intel-FPGA-BBB https://github.com/OPAE/intel-fpga-bbb.git OFS-PLATFORM-AFU-BBB https://github.com/OFS/ofs-platform-afu-bbb.git, tag: ofs-2023.1-1 AFU-EXAMPLES https://github.com/OFS/examples-afu.git, tag: ofs-2023.1-1 OPAE-SDK https://github.com/OFS/opae-sdk.git, tag: 2.5.0-3 LINUX-DFL https://github.com/OFS/linux-dfl.git, tag: ofs-2023.1-6.1-1 META-OFS https://github.com/OFS/meta-ofs, tag: ofs-2023.1-4"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-4-software-and-firmware-component-version-summary-for-soc-attach","title":"Table 4: Software and Firmware Component Version Summary for SoC Attach","text":"Component Version Download link (where applicable) Available FIM Version(s) PR Interface ID: bf2a9e1a-b05d-5130-b47c-776055c0d67e 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell Host Operating System Ubuntu 22.04 Official Release Page Host OPAE SDK 2.5.0-3 https://github.com/OFS/opae-sdk/releases/tag/2.5.0-3 Host Linux DFL ofs-2023.1-6.1-1 https://github.com/OFS/linux-dfl/releases/tag/ofs-2023.1-6.1-1 SoC OS meta-intel-ese Reference Distro 1.0-ESE (kirkstone) 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell SoC Kernel Version 5.15.92-dfl-66b0076c2c-lts 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell SoC OPAE SDK 2.5.0-3 https://github.com/OFS/opae-sdk/releases/tag/2.5.0-3 SoC Linux DFL ofs-2023.1-6.1-1 https://github.com/OFS/linux-dfl/releases/tag/ofs-2023.1-6.1-1 SoC BMC and RTL 1.1.9 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell SoC BIOS 0ACRH608_REL 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell <p>Not all components shown in Table 4 will have an update available upon release. The OPAE SDK and Linux DFL software stacks are incorporated into a Yocto image and do not need to be downloaded separately. Updates required for the 2023.1 OFS SoC Attach Release for Intel IPU Platform F2000X-PL are shown under Table 9 in section 2.0 Updating the Intel IPU Platform F2000X-PL.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#12-server-requirements","title":"1.2 Server Requirements","text":"<p>The following requirements must be met when purchasing a server to support the Intel IPU Platform F2000X-PL.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#121-host-server-specifications","title":"1.2.1 Host Server Specifications","text":"<p>The host server must meet the following minimal specifications:</p> <ul> <li>The server platform must contain at least 64GiB of RAM to to compile the Yocto or FIM images</li> <li>If using the server platform to build a Yocto image, it is recommended to have at least 200 GB of free storage space</li> </ul>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#122-host-bios","title":"1.2.2 Host BIOS","text":"<p>Te Host BIOS settings known to work with the Intel IPU Platform F2000X-PL:</p> <ul> <li>PCIe slot width must be x16</li> <li>PCIe slot speed must be 4</li> <li>PCIe slot must have iommu enabled</li> <li>Intel VT for Directed I/O (VT-d) must be enabled</li> <li>PCIe Volume Management for the riser and PCIe slot in which the F2000x-PL card is installed must be disabled</li> </ul> <p>Specific BIOS paths are not listed here, as they can differ between BIOS vendors and versions.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#123-host-server-kernel-and-grub-configuration","title":"1.2.3 Host Server Kernel and GRUB Configuration","text":"<p>While many host Linux kernel and OS distributions may work with this design, only the following configuration(s) have been tested:</p> <ul> <li>Ubuntu 22.04, 5.15-lts</li> </ul>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#13-server-forced-air-cooling","title":"1.3 Server Forced Air Cooling","text":"<p>The Intel IPU Platform F2000X-PL is a high-performance processing card with a passive heat sink to dissipate device heat and must be installed in a server with sufficient forced airflow cooling to keep all devices operating below maximum temperature. The table below lists the thermal terms and descriptions used in thermal analysis.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-5-thermal-terms-and-descriptions","title":"Table 5: Thermal Terms and Descriptions","text":"Term Description Cubic Feet per Minute (CFM) Volumetric airflow rate, in cubic feet per minute, of air passing through faceplate. Tj FPGA Junction Temperature TLA Local Ambient temperature. Temperature of forced air as it enters the Intel IPU Platform F2000X-PL. \u00a0 Note: In many systems, this is higher than the room ambient due to  heating effects of chassis components. <p>Note: The FPGA junction temperature must not exceed 100\u00b0C. The case temperature of the QSFP modules must meet the module vendor's specification.</p> <p>Note: The table below provides the thermal targets for which the Intel IPU Platform F2000X-PL was designed. As a card manufacturer, you must qualify your own production cards.</p> <p>The maximum card inlet air temperatures must support continuous operation under the worst-case power scenario of 150W TDP.</p> <p>The airflow requirements for optimal heat sink performance at minimum is characteristic of CAT 3 servers or PCIe SIG Level 7 thermal profiles, in both, forward &amp; reverse flow, see figure below:</p> <p> </p> <p>As the Intel IPU Platform F2000X-PL is a development platform, it is not integrated into the server baseband management controller closed loop cooling control. It is strongly recommended that you set your server's fan settings to run constantly at 100% with the server chassis lid closed to prevent unwanted Intel IPU Platform F2000X-PL thermal shutdown.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#14-external-connections","title":"1.4 External Connections","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-1-external-connections","title":"Figure 1: External Connections","text":"<p>The items listed Table 6 in are known to work for external connectivity. Specific links are given for convenience, other products may be used but have not been tested.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-6-external-connection-cables","title":"Table 6: External Connection Cables","text":"Item Part Number Link to source RS-232 to USB Adapter DTECH FTDI USB to TTL Serial Adapter, 3 m USB to TTL Serial USB to Ethernet Adapter, Aluminum 3 Port USB 3.0 Teknet USB Hub with Ethernet adapter Flash Drive, 64 GB or larger SanDisk QSFP DAC Cable \u00a0FS.com Generic 2m 100G QSP28 Passive Direct Attach Copper QSFP28 DAC (optional) Intel FPGA Download Cable II PL-USB2-BLASTER USB-Blaster II"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#15-preparing-the-intel-ipu-platform-f2000x-pl-for-installation","title":"1.5 Preparing the Intel IPU Platform F2000X-PL for Installation","text":"<p>Turn the board over to back side and remove the Kapton tape covering switches SW2 and SW3 and make sure the switches are set as shown in Figure 1.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-7-switch-settings","title":"Table 7: Switch Settings","text":"Name Value SW3.1 off SW3.2 off SW3.2 on SW3.2 off SW2 off"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-2-board-switch-settings","title":"Figure 2: Board Switch Settings","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#151-usb-to-serial-adapter","title":"1.5.1 USB to Serial Adapter","text":"<p>The Intel IPU Platform F2000X-PL has a serial UART for access located on back edge of the board. This connection is useful for making BIOS and boot settings and for monitoring the SoC. In most servers, you will need to remove a riser card and route the USB to serial cable and (optional) Intel FPGA USB Blaster through an unused PCIe slot above or below where the IPU is installed. See Figure 3 for an example of cable routing.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-3-cable-routing","title":"Figure 3: Cable Routing","text":"<p>The USB to serial connection is shown in Figure 4 where the White wire is TXD, Black wire is ground and Green wire is RXD.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-4-usb-to-serial-adapter-connection","title":"Figure 4: USB to Serial Adapter connection","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#152-ipu-jtag","title":"1.5.2 IPU JTAG","text":"<p>The Intel IPU Platform F2000X-PL provides a 10 pin JTAG header for FPGA and Cyclone 10 Board Management Controller development work using a Intel FPGA Download Cable II. This JTAG connection is optional for initial bring-up but is useful for manual image reprogramming and debug. See Figure 5 noting the orientation of the connection. The orientation of the USB Blaster II requires careful installation in a PCIe bay that has additional room in the adjacent bay. This may require you to either install the board over the PSU of the server, or to temporarily remove an adjacent riser while programming.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-5-usb-blaster-ii-connection","title":"Figure 5: USB Blaster II Connection","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-6-usb-blaster-ii-installation","title":"Figure 6: USB Blaster II Installation","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#153-power","title":"1.5.3 Power","text":"<p>The Intel IPU Platform F2000X-PL must receive power from both the 12 V and 3.3V PCIe slot and the 12 V Auxiliary 2\u00d74 power connector. The board does not power up if any of the 12 V and 3.3 V PCIe slot, or 12 V Auxiliary power sources are disconnected.</p> <p>PCIe specifications define 12 V Auxiliary power connector pin assignment. The Intel IPU Platform F2000X-PL implements an 8-position right angle (R/A) through-hole PCB header assembly on the top right side of the board as depicted in the picture below.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-7-12v-pcie-aux-connector-location","title":"Figure 7: 12V PCIe AUX Connector Location","text":"<p>Refer the table below for pinout details.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-8-12v-2x3-aux-connector-pin-out","title":"Table 8: 12V (2x3) AUX Connector Pin Out","text":"Pin Description 1 +12V 2 +12V 3 +12V 4 Sense 1 5 Ground 6 Sense 0 7 Ground 8 Ground <p>See Auxiliary power connection in Figure 8.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-8-auxiliary-power-connection","title":"Figure 8: Auxiliary Power Connection","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#154-usb-hub-connection","title":"1.5.4 USB Hub Connection","text":"<p>The USB Hub is connected to the USB type A connector on the front panel. Additionally, attach a network connected Ethernet connection to the USB hub. See Figure 9.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#figure-9-usb-hub-connection","title":"Figure 9: USB Hub Connection","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#155-creating-a-bootable-usb-flash-drive-for-the-soc","title":"1.5.5 Creating a Bootable USB Flash Drive for the SoC","text":"<p>Connect your flash drive to an available Linux host. In this section the USB will set up to be used as a secondary boot source for the SoC and will also be used to update the NVMe from which the ICX-D SoC boots in section 2.1 Updating the F2000X-PL ICX-D SoC NVMe.</p> <p>You will load the latest pre-compiled Yocto <code>core-image-minimal</code> WIC image into USB flash. This image can be downloaded from 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell, under assets, or compiled from meta-ofs. Compilation is discussed in section 4.0 Compiling a Custom Yocto SoC Image.</p> <ol> <li> <p>Insert a 64 GB or larger USB Flash Drive into the USB slot of a computer/server you can use to format the drive. The following instructions assume you are using some flavor of GNU+Linux. You need sudo access privileges on this machine.</p> </li> <li> <p>In a terminal window, find the device name of the USB flash drive and unmount the device:</p> <pre><code>$ lsblk\n\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT\nsda 8:0 0 1.8T 0 disk\n\u251c\u2500sda1 8:1 0 600M 0 part /boot/efi\n\u251c\u2500sda2 8:2 0 1G 0 part /boot\n\u2514\u2500sda3 8:3 0 1.8T 0 part\n\u251c\u2500rhel-root 253:0 0 50G 0 lvm /\n\u251c\u2500rhel-swap 253:1 0 4G 0 lvm \\[SWAP\\]\n\u2514\u2500rhel-home 253:6 0 1.7T 0 lvm /home\nsdb 8:16 0 447.1G 0 disk\n\u251c\u2500sdb1 8:17 0 600M 0 part\n\u251c\u2500sdb2 8:18 0 1G 0 part\n\u2514\u2500sdb3 8:19 0 445.5G 0 part\n\u251c\u2500fedora_localhost\\--live-swap 253:2 0 4G 0 lvm\n\u251c\u2500fedora_localhost\\--live-home 253:3 0 301G 0 lvm\n\u251c\u2500fedora_localhost\\--live-root 253:4 0 70G 0 lvm\n\u2514\u2500fedora_localhost\\--live-centos_root 253:5 0 70.5G 0 lvm\nsdd 8:48 1 57.3G 0 disk\n\u2514\u2500sdd1 8:49 1 57.3G 0 part\n</code></pre> <p>In the above example, the 64 GB USB Flash device is designated <code>sdd</code>. Note, your device file name may be different. You are looking for an entry that matches the size of   your USB Flash. You can also check the output of <code>dmesg</code> after manually plugging in your USB Flash device to view the name the kernel has given it in an auto-generated event.</p> </li> <li> <p>Unmount the USB flash (if not already unmounted).</p> <pre><code>$ sudo umount /dev/sdd1\numount: /dev/sdd1: not mounted.\n</code></pre> </li> <li> <p>Download the Yocto WIC image to the Linux computer. To prevent boot errors that may arise when using the same boot image loaded in both USB flash and on-board NVMe, you must choose an older version of the Yocto WIC to load onto the USB. Browse the tagged Yocto release images on GitHub and choose the second newest release image as the temporary USB boot target. In this example we will use the OFS 2023.1 RC3 release. You will also need to download the newest Yocto release image (core-image-full-cmdline-intel-corei7-64-20230428022313.rootfs.wic.gz).</p> <pre><code># Download an older version of the Yocto release image to use as the USB boot target, version 2023.1 RC3 shown here\n$ wget https://github.com/OFS/meta-ofs/releases/download/ofs-2023.1-3/core-image-full-cmdline-intel-corei7-64-20230505161810.rootfs.wic.gz\n$ wget https://github.com/OFS/meta-ofs/releases/download/ofs-2023.1-3/core-image-full-cmdline-intel-corei7-64-20230505161810.rootfs.wic.gz.sha256\n# Verify the checksum of the downloaded image\n$ sha256sum -c https://github.com/OFS/meta-ofs/releases/download/ofs-2023.1-3/core-image-full-cmdline-intel-corei7-64-20230505161810.rootfs.wic.gz.sha256\n# Uncompress the package\n$ gzip -d core-image-full-cmdline-intel-corei7-64-20230505161810.rootfs.wic.gz\n\n# Download the most recent Yocto release image, which will overwrite on-board NVMe\n$ wget https://github.com/OFS/meta-ofs/releases/download/ofs-2023.1-4/core-image-full-cmdline-intel-corei7-64-20230512215350.rootfs.wic\n$ wget https://github.com/OFS/meta-ofs/releases/download/ofs-2023.1-4/core-image-full-cmdline-intel-corei7-64-20230512215350.rootfs.wic.sha256\n# Verify the checksum of the downloaded image\nsha256sum -c core-image-full-cmdline-intel-corei7-64-20230512215350.rootfs.wic.sha256\n# Uncompress the package\n$ gzip -d core-image-full-cmdline-intel-corei7-64-20230512215350.rootfs.wic\n</code></pre> </li> <li> <p>Copy core-image-full-cmdline-intel-corei7-64-20230505161810.rootfs.wic to the USB flash. This process may take several minutes.</p> <pre><code>$ sudo dd if=core-image-full-cmdline-intel-corei7-64-20230505161810.rootfs.wic of=/dev/sdd1 bs=512k status=progress conv=sync\n$ sgdisk -e /dev/sdd\n</code></pre> </li> <li> <p>Create a partition to store the Yocto image, which will be used to overwrite on-board NVMe as the default boot target.</p> <pre><code>    $ sudo fdisk /dev/sdd\n    Command (m for help): p\n    Command (m for help): n\n    Partition number (4-128, default 4): &lt;&lt;press enter&gt;&gt;\n    First sector (14617908-125045390, default 14618624): &lt;&lt;press enter&gt;&gt;\n    Last sector, +/-sectors or +/-size{K,M,G,T,P} (14618624-125045390, default\n    125045390): &lt;&lt;press enter&gt;&gt;\n    Created a new partition 4 of type 'Linux filesystem' and of size 92 GiB.\n    Command (m for help): p\nCommand (m for help): w\n</code></pre> </li> <li> <p>Verify USB flash is partitioned.</p> <pre><code>$ lsblk\n    NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\n    sdd           8:0    1 114.6G  0 disk\n    |-sdd1        8:1    1   300M  0 part\n    |-sdd2        8:2    1  22.1G  0 part\n    |-sdd3        8:3    1    44M  0 part\n    `-sdd4        8:4    1  92.2G  0 part\n</code></pre> </li> <li> <p>Format the new partition.</p> <pre><code>$ mkfs -t ext4 /dev/sdd4\n$ mount /dev/sda4 /mnt\n</code></pre> </li> <li> <p>Copy compressed <code>core-image-minimal</code> WIC into /mnt.</p> <pre><code>$ cp core-image-full-cmdline-intel-corei7-64-20230428022313.rootfs.wic.gz /mnt\n</code></pre> </li> </ol> <p>Remove the USB flash from the Linux computer and install the flash drive in the USB hub attached to the Intel IPU Platform F2000X-PL.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#20-updating-the-intel-ipu-platform-f2000x-pl","title":"2.0 Updating the Intel IPU Platform F2000X-PL","text":"<p>Every Intel IPU Platform F2000X-PL ships with pre-programmed firmware for the FPGA user1, user2, and factory images, the Cyclone 10 BMC RTL and FW, the SoC NVMe, and the SoC BIOS. The combination of FW images in Table 4 compose the official 2023.1 OFS SoC Attach Release for Intel IPU Platform F2000X-PL. Upon initial receipt of the board from manufacturing you will need to update two of these regions of flash to conform with the best known configuration for SoC Attach.  As shown in Table 9, not all devices require firmware updates. To instruct users in the process of updating on-board Intel IPU Platform F2000X-PL firmware, examples are provided in this guide illustrating the firmware update process for all devices.  </p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-9-intel-ipu-platform-f2000x-pl-fw-components","title":"Table 9: Intel IPU Platform F2000X-PL FW Components","text":"HW Component File Name Version Update Required (Yes/No) Download Location FPGA SR Image1 user1: ofs_top_page1_unsigned_user1.binuser2: ofs_top_page2_unsigned_user2.binfactory: ofs_top_page0_unsigned_factory.bin PR Interface ID: bf2a9e1a-b05d-5130-b47c-776055c0d67e Yes 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell FPGA PR IMAGE2 ofs_pr_afu.green_region_unsigned.gbs N/A Yes Compiled with FIM ICX-D NVMe core-image-full-cmdline-intel-corei7-64-20230512215350.rootfs.wic N/A Yes 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell BMC RTL and FW AC_BMC_RSU_user_retail_1.1.9_unsigned.rsu 1.1.9 No 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell BIOS Version 0ACRH608_REL.BIN 0ACRH608_REL Yes 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell <p>If a component does not have a required update, it will not have an entry on 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell.</p> <p>1To check the PR Interface ID of the currently programmed FIM and the BMC RTL and FW version, use <code>fpgainfo fme</code> from the SoC. 2Must be programmed if using AFU-enabled exercisers, not required otherwise.</p> <pre><code>$ fpgainfo fme\nIntel IPU Platform F2000X-PL\n**Board Management Controller NIOS FW version: 1.1.9**\n**Board Management Controller Build version: 1.1.9**\n//****** FME ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nPorts Num                        : 01\n**Bitstream Id                     : 360572756236924878**\nBitstream Version                : 5.0.1\n**Pr Interface Id                  : bf2a9e1a-b05d-5130-b47c-776055c0d67e**\nBoot Page                        : user1\nUser1 Image Info                 : 9e3db8b6a4d25a4e3e46f2088b495899\nUser2 Image Info                 : None\nFactory Image Info               : None\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#21-updating-the-f2000x-pl-icx-d-soc-nvme","title":"2.1 Updating the F2000X-PL ICX-D SoC NVMe","text":"<p>The Intel IPU Platform F2000X-PL ships with a Yocto image pre-programmed in NVMe, which is not the same as the SoC Attach OFS image that we will be using. The latter provides only the OPAE SDK and Linux DFL drivers and is fully open source. This section will show how you can use an attached USB drive to load a new image into flash. You will use a serial terminal to install the new image - Minicom and PuTTy terminal emulators have both been tested. <code>minicom</code> is used for demonstration purposes as the serial terminal to access the ICX-D SoC UART connection in this section. Information on compiling your own Yocto image for use with the Intel IPU Platform F2000X-PL is discussed in section 4.0 Compiling a Custom Yocto SoC Image.</p> <p>Note: Username and password for the default SoC NVMe boot image are \"root\" and \"root@123\".</p> <ol> <li> <p>First, make sure to complete the steps in section 1.5.5 Creating a Bootable USB Flash Drive for the SoC, and attach the USB drive either directly into the rear of the Intel IPU Platform F2000X-PL, or into a USB Hub that itself is connected to the board.</p> </li> <li> <p>Ensure your Minicom terminal settings match those shown below. You must direct Minicom to the USB device created in <code>/dev</code> associated with your RS-232 to USB Adapter cable. This cable must be attached to a server that is separate from the one housing your Intel IPU Platform F2000X-PL. Check the server logs in <code>dmesg</code> to figure out which device is associated with your cable: <code>[    7.637291] usb 1-4: FTDI USB Serial Device converter now attached to ttyUSB0</code>. In this example the special character file <code>/dev/ttyUSB0</code> is associated with our cable, and can be connected to using the following command: <code>sudo minicom --color=on -D /dev/ttyUSB0</code>.</p> <p></p> </li> <li> <p>Change the SoC boot order to boot from USB first. Reboot the server. From your     serial Minicom terminal, watch your screen and     press 'ESC' key to go into BIOS setup mode. Once BIOS setup comes     up as shown below, click the right arrow key six times to move from     'Main' set up menu to 'Boot' setup:</p> <p>Main setup menu:</p> <p></p> <p></p> <p>Your order of boot devices may differ. You need to move the USB flash    up to Boot Option #1 by first using the down arrow key to highlight    the USB device then use '+' key to move the USB device to #1 as    shown below:</p> <p></p> <p>Press 'F4' to save and exit.</p> </li> <li> <p>You will boot into Yocto automatically. Log in with username <code>root</code> and an empty password using Minicom. Take note of the IP address of the board, you can use this to log in without needing the serial cable.</p> <p></p> <p>Verify that you have booted from the USB and not the on-board NVMe <code>lsblk -no pkname $(findmnt -n / | awk '{ print $2 }')</code>. You should see a device matching <code>/dev/sd*</code>, and not <code>nvme*n*p*</code>. If you see <code>nvme*n*p*</code>, then review the previous steps.</p> <p>Record the IP address of the SoC at this time <code>ip -4 addr</code>. This will be used to log in remotely using SSH.</p> </li> <li> <p>Check that 4 partitions created in 1.5.5 Creating a Bootable USB Flash Drive for the SoC are visible to the SoC in <code>/dev/sd*</code>:</p> <pre><code>$ lsblk -l\nroot@intel-corei7-64:/mnt# lsblk -l\nNAME      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsda         8:0    1 117.2G  0 disk\nsda1        8:1    1  38.5M  0 part /boot\nsda2        8:2    1    20G  0 part /\nsda3        8:3    1    44M  0 part [SWAP]\nsda4        8:4    1  97.1G  0 part /mnt\nnvme0n1   259:0    0  59.6G  0 disk\nnvme0n1p1 259:1    0   300M  0 part\nnvme0n1p2 259:2    0  22.1G  0 part\nnvme0n1p3 259:3    0    44M  0 part\n</code></pre> <p>Mount partition 4, and <code>cd</code> into it.</p> <pre><code>$ mount /dev/sda4 /mnt`\n$ cd /mnt\n</code></pre> </li> <li> <p>Uncompress and install the Yocto release image in the SoC NVMe.</p> <pre><code>$ zcat core-image-full-cmdline-intel-corei7-64-20230512215350.rootfs.wic\n$ dd if=core-image-full-cmdline-intel-corei7-64-20230512215350.rootfs.wic of=/dev/nvme0n1 bs=1M status=progress conv=sync\n$ sync\n$ sgdisk -e /dev/nvme0n1\n</code></pre> <p>The transfer from USB to NVMe will take several minutes.</p> </li> <li> <p>Reboot the SoC and update the SoC BIOS to boot from NVMe. Follow steps 2 and 3 from this section again, and this time move the NVME back to the front of the boot order. The NVMe is named <code>UEFI OS (PCIe SSD)</code> by the BIOS. Press F4 to save and exit.</p> <p>You can use <code>wget</code> to retrieve a new version of the Yocto release image from meta-ofs once the SoC's network connection is up. Use <code>wget</code> to copy the image to the SoC over the network under <code>/mnt</code>. You may need to delete previous Yocto images to save on space: <code>$ wget --no-check-certificate --user &lt;Git username&gt; --ask-password https://github.com/OFS/meta-ofs/releases/download/ofs-2023.1-2/core-image-full-cmdline-intel-corei7-64-20230428022313.rootfs.wic.gz</code>. Uncompress the newly retrieved file: <code>gzip -d core-image-full-cmdline-intel-corei7-64-20230428022313.rootfs.wic.gz</code>. This may take several minutes.</p> </li> </ol>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#211-setting-the-time","title":"2.1.1 Setting the Time","text":"<ol> <li> <p>Use Linux command to set system time using format: <code>date --set=\"STRING\"</code>.</p> <pre><code>date -s \"26 APRIL 2023 18:00:00\"\n</code></pre> </li> <li> <p>Set HWCLOCK to current system time:</p> <pre><code>hwclock --systohc\n</code></pre> <p>Verify time is set properly</p> <pre><code>date\n...\nhwclock --show\n...\n</code></pre> </li> </ol>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#30-updating-the-intel-ipu-platform-f2000x-pl","title":"3.0 Updating the Intel IPU Platform F2000X-PL","text":""},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#31-preparing-the-intel-ipu-platform-f2000x-pl-soc-for-updates","title":"3.1 Preparing the Intel IPU Platform F2000X-PL SoC for Updates","text":"<p>Updating the Intel IPU Platform F2000X-PL firmware often requires reboots of the SoC or reconfiguration of the FPGA region. If there are processes connected from the host to the SoC that do not expect the downtime to occur, or if the host is not tolerant to a surprise PCie link down, the following instructions can be used to properly orchestrate updates with the host when reboots occur.</p> <p>Note: The following instructions assume you know the PCIe Bus/Device/Function (BDF) address of your Intel IPU Platform F2000X-PL. Run the command <code>lspci | grep bcce</code> to print all boards with a DID that matches <code>bcce</code>.</p> <pre><code>$ lspci | grep bcce\n31:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n31:00.1 Processing accelerators: Intel Corporation Device bcce (rev 01)\n# In this example, 31:00.0 is the proper PCIe BDF of our device\n</code></pre> <ol> <li>Shut down all VMs and software applications attached to any PFs/VFs on the host</li> <li>Issue the command <code>sudo pci_device &lt;&lt;PCIe BDF&gt;&gt; unplug</code> on the host to remove the PCIe device from the PCIe bus</li> <li>Shut down all software applications on the SoC accessing non-management PFs/VFs</li> <li>Issue your update command on the SoC, which will cause an SoC reboot and surprise PCIe link down on the host (ex. <code>reboot</code>, <code>rsu bmc/bmcimg/fpga</code>)</li> <li>Once you have completed all firmware updates, you may restart application software on the SoC</li> <li>Issue command <code>sudo pci_device &lt;&lt;PCIe BDF&gt;&gt; plug</code> on the host to rescan the PCIe bus and rebind the device to its native driver</li> <li>Restart software applications on the host</li> </ol>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#32-updating-fim-bmc-and-afu-with-fpgasupdate","title":"3.2 Updating FIM, BMC and AFU with <code>fpgasupdate</code>","text":"<p>The <code>fpgasupdate</code> tool updates the Intel\u00ae C10 10 BMC image and firmware, root entry hash, FPGA Static Region (SR) and user image (PR). The <code>fpgasupdate</code> will only accept images that have been formatted using PACSign. If a root entry hash has been programmed onto the board, then the image will also need to be signed using the correct keys. Please refer to the Security User Guide: Intel Open FPGA Stack for information on creating signed images and on programming and managing the root entry hash. The <code>fpgasupdate</code> tool is used to program images into flash memory. The <code>rsu</code> tool is used to configure the FPGA/BMC with an image that is already stored in flash memory, or to switch between user1 and user2 images. All images received from an official Intel release will be \"unsigned\", as described in the Security User Guide: Intel Open FPGA Stack.</p> <p>Note: 'Unsigned' in this context means the image has passed through <code>PACsign</code> and has had the proper security blocks prepended using a set of 'dummy' keys. FIMs with image signing enabled will require all programmable images to pass through <code>PACsign</code> even if the currently programmed FIM/BMC do not require specific keys to authenticate.</p> <p>There are two regions of flash you may store FIM images for general usage, and one backup region. These locations are referred to as user1, user2, and factory. The factory region is not programmed by default and can only be updated once keys have been provisioned. The BMC FW and RTL will come pre-programmed with version 1.1.9.</p> <p>Updating the FIM from the SoC requires the SoC be running a Yocto image that includes the OPAE SDK and Linux DFL drivers. Updating the FIM using <code>fpgasupdate</code> also requires an OFS enabled FIM to be configured on the F2000X-PL, which it will ship with from manufacturing. You need to transfer any update files to the SoC over SSH. The OPAE SDK utility <code>fpgasupdate</code> will be used to update all ofthe board's programmable firmware . This utility will accept files of the form *.rsu, *.bin, and *.gbs, provided the proper security data blocks have been prepended by PACSign. The default configuration the IPU platform ships with will match the below:</p> <pre><code>$ fpgainfo fme\nIntel IPU Platform F2000X-PL\n**Board Management Controller NIOS FW version: 1.1.9**\n**Board Management Controller Build version: 1.1.9**\n//****** FME ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nPorts Num                        : 01\n**Bitstream Id                     : 360572756236924878**\nBitstream Version                : 5.0.1\n**Pr Interface Id                  : bf2a9e1a-b05d-5130-b47c-776055c0d67e**\nBoot Page                        : user1\nUser1 Image Info                 : 9e3db8b6a4d25a4e3e46f2088b495899\nUser2 Image Info                 : None\nFactory Image Info               : None\n</code></pre> <p>To load a new update image, you need to pass the IPU's PCIe BDF and the file name to <code>fpgasupdate</code> on the SoC. The below example will update the user1 image in flash:</p> <pre><code>$ fpgasupdate ofs_top_page1_unsigned_user1.bin 15:00.0\n</code></pre> <p>After loading an update image, <code>rsu fpga/bmc/bmcimg</code> can be used to reload the firmware and apply the change, as discussed below. An RSU of the BMC will always cause a reload of both the BMC and FPGA images.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#33-loading-images-with-rsu","title":"3.3 Loading images with <code>rsu</code>","text":"<p>RSU performs a Remote System Update operation on an Intel IPU Platform F2000X-PL, given its PCIe address. An <code>rsu</code> operation sends an instruction to the device to trigger a power cycle of the card only if run with <code>bmcimg</code>. <code>rsu</code> will force reconfiguration from flash for either the BMC or FPGA. PCIe Advanced Error Reporting (AER) is temporarily disabled for the card when RSU is in progress</p> <p>The Intel IPU Platform F2000X-PL contains two regions of flash you may store FIM images. These locations are referred to as user1 and user2. After an image has been programmed to either of these regions in flash using fpgasupdate, you may perform an <code>rsu</code> to reconfigure the Agilex FPGA with the new image stored in flash. This operation will indicate to the BMC which region to configure the FPGA device from after power-on.</p> <p>If the factory image has been updated, Intel strongly recommends you immediately RSU to the factory image to ensure the image is functional.</p> <p>You can determine which region of flash was used to configure their FPGA device using the command <code>fpgainfo fme</code> and looking at the row labelled Boot Page.</p> <p>When loading a new FPGA SR image, use the command <code>rsu fpga</code>. When loading a new BMC image, use the command <code>rsu bmc</code>. When using the RSU command, you may select which image will be configured to the selected device. For example, when performing an RSU for the Agilex FPGA, you may select to configure the user1, user2, or factory image. When performing an RSU for the C10 BMC, you may select to configure the user or factory image. You may also use RSU to reconfigure the SDM on devices that support it. The RSU command sends an instruction to the BMC to reconfigure the selected device from an image stored in flash.</p> <pre><code>$ rsu fpga --page=user1 15:00.0\n</code></pre> <p>Useage:</p> <pre><code>rsu bmc --page=(user|factory) [PCIE_ADDR]\nrsu fpga --page=(user1|user2|factory) [PCIE_ADDR]\nrsu sdm [PCIE_ADDR]\n</code></pre> <p>You can use RSU to change which page in memory the FPGA will boot from by default.</p> <p>Synopsis:</p> <pre><code>rsu fpgadefault --page=(user1|user2|factory) --fallback=&lt;csv&gt; 15:00.0\n</code></pre> <p>Use to set the default FPGA boot sequence. The <code>--page</code> option determines the primary FPGA boot image. The <code>--fallback</code> option allows a comma-separated list of values to specify fallback images.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#34-updating-the-icx-d-soc-bios","title":"3.4 Updating the ICX-D SoC BIOS","text":"<p>The ICX-D SoC NVMe comes pre-programmed with BIOS v7 (0ACRH007). This version will need to be replaced with 0ACRH608_REL. BIOS update files come in the form 0ACRH\\&lt;\\&lt;version&gt;&gt;.bin, and can be downloaded on 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell. This update process is in-band, and requires you to download and install a BIOS UEFI utility from AMI called \"APTIO V AMI Firmware Update Utility\", available here. This package will install a utility in the UEFI shell called AfuEfix64.efi which will be used to overwrite the ICX-D BIOS.</p> <ol> <li> <p>Check your BIOS Version. Reboot the SoC and wait for the BIOS version to be shown. In this example, the BIOS will need to be updated.</p> <p></p> </li> <li> <p>Download both the ICX-D SoC Update image and APTIO V AMI Firmware Update Utility. Unzip the BIOS update image and locate your BIOS update binary. Unzip Aptio_V_AMI_Firmware_Update_Utility.zip, and then navigate to Aptio_V_AMI_Firmware_Update_Utility\\afu\\afuefi\\64 and unzip AfuEfi64.zip. The file we need from this package is called AfuEfix64.efi.</p> <p></p> </li> <li> <p>Copy both files over to the SoC into /boot/EFI using the SoC's IP.</p> <pre><code>$ scp 0ACRH608_REL.BIN root@XX.XX.XX.XX:/boot/EFI\n$ scp AfuEfix64.efi root@XX.XX.XX.XX:/boot/EFI\n</code></pre> </li> <li> <p>Reboot the SoC from a TTY Serial terminal. Watch your screen and press 'ESC' key to go into BIOS setup mode. Select 'Built-in EFI Shell'.</p> <p></p> </li> <li> <p>At EFI prompt enter the following:</p> <pre><code>Shell&gt; FS0:\nFS0:&gt; cd EFI\nFS0:\\EFI\\&gt; AfuEfix64.efi 0ACRH608_REL.BIN /p /n /b\n</code></pre> <p>Press 'E'. When the update has completed type 'reset -w' to reboot.</p> <p></p> </li> <li> <p>Watch your screen and press 'ESC' key to go into BIOS setup mode. Verify BIOS version matches expectation.</p> <p></p> </li> <li> <p>Click the right arrow key six times to move from 'Main' set up menu to 'Boot' setup. Select NVMe as the primary boot source.</p> <p></p> </li> </ol>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#40-compiling-a-custom-yocto-soc-image","title":"4.0 Compiling a Custom Yocto SoC Image","text":"<p>Current Yocto image architecture for SoC Attach is based off of the IOTG Yoct-based ESE BSP and substitutes the Linux DFL kernel including the latest DFL drivers for FPGA devices along with the OPAE SDK user space. The image targets x86_64 SoC FPGA devices but should boot on most UEFI-based machines. The source code and documentation for this image is hosted on the meta-ofs repository.</p> <p>Build requirements exceed 100 GiB of disk space, depending on which image is built. As a reference point, on a system with two Intel(R) Xeon(R) E5-2699 v4 for a total of 44 CPU cores, the initial, non-incremental build takes less than an hour of wall time.</p> <p>The <code>repo</code> tool is needed to clone the various Yocto layer repositories used in this example.</p> <p>Note: If you are behind a firewall that prevents you from accessing references using the git:// protocol, you can use the following to redirect Git to use the corresponding https repositories for Yocto only: <code>git config --global url.https://git.yoctoproject.org/.insteadOf git://git.yoctoproject.org/</code></p> <p>To compile the image as-is, use the following steps (as provided in meta-ofs):</p> <ol> <li> <p>Create and initialize the source directory.</p> <pre><code>mkdir ofs-yocto &amp;&amp; cd ofs-yocto\nrepo init -m examples/iotg-yocto-ese/manifest.xml https://github.com/OFS/meta-ofs\n</code></pre> </li> <li> <p>Fetch repositories and update the working tree.</p> <pre><code>repo sync -j 16\n</code></pre> </li> <li> <p>Build packages and create an image.</p> <pre><code>cd build\n. ../intel-embedded-system-enabling/oe-init-build-env .\nbitbake mc:x86-2021-minimal:core-image-full-cmdline\n</code></pre> </li> </ol> <p>The resulting GPT disk image is available in uncompressed (.wic) and compressed form (.wic.gz) in <code>build/tmp-x86-2021-minimal-glibc/deploy/images/intel-corei7-64/</code>. With no changes the uncompressed image size is ~21 GB.</p> <p>The image type core-image-full-cmdline includes the familiar GNU core utilities, as opposed to core-image-minimal which uses BusyBox instead.</p> <p>The example build configuration files under build/conf/ are symlinked from examples/iotg-yocto-ese/. To customise the image, start by modifying local.conf and bblayers.conf.</p> <p>The uncompressed Yocto image can be loaded onto a flash drive as discussed in section 1.5.5 Creating a Bootable USB Flash Drive for the SoC and written to NVMe as the default boot target for the SoC as demonstrated in section 2.1 Updating the F2000X-PL ICX-D SoC NVMe.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#50-verifying-the-icx-d-soc-opae-sdk","title":"5.0 Verifying the ICX-D SoC OPAE SDK","text":"<p>The reference SoC Attach FIM and unaltered FIM compilations contain Host Exerciser Modules (HEMs). These are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Full supported functionality of the HEMs is documented in the host_exerciser opae.io GitHub page. SoC Attach supports HEMs run both with and without an AFU image programmed into the board's one supported PR region. This image is available on the offial SoC Attach GitHub Page, and is programmed using <code>fpgasupdate</code> as shown in section 3.2. A few select examples run from the SoC and their expected results will be shown below.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#51-checking-telemetry-with-fpgainfo","title":"5.1 Checking Telemetry with <code>fpgainfo</code>","text":"<p>The <code>fpgainfo</code> utility displays FPGA information derived from sysfs files.</p> <p>The command argument is one of the following: <code>errors</code>, <code>power</code>, <code>temp</code>, <code>port</code>, <code>fme</code>, <code>bmc</code>, <code>phy</code>, <code>mac</code>, and <code>security</code>. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p> <p>An example output for <code>fpgainfo fme</code> is shown below. Your IDs may not match what is shown here:</p> <pre><code>$ fpgainfo fme\nIntel IPU Platform F2000X-PL\nBoard Management Controller NIOS FW version: 1.1.9\nBoard Management Controller Build version: 1.1.9\n//****** FME ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:15:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x17D4\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x50103023DFBFC8E\nBitstream Version                : 5.0.1\nPr Interface Id                  : bf74e494-ad12-5509-98ab-4105d27979f3\nBoot Page                        : user1\nUser1 Image Info                 : 98ab4105d27979f3bf74e494ad125509\nUser2 Image Info                 : None\nFactory Image Info               : None\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#52-host-exercisers","title":"5.2 Host Exercisers","text":"<p>Of these five tests listed below, the first three do not require an AFU be loaded into the board's PR region. They exercise data paths that pass exclusively through the FIM. The latter three tests exercise data through the AFU data path, and require SoC Attach release AFU Image to be configured using <code>fpgasupdate</code>.</p> <ul> <li>Run HE-MEM with 2 cachelines per request in <code>mem</code> mode, exercising the FPGA's connection to DDR. No AFU required.<p>Note: If you see the error message <code>Allocate SRC Buffer, Test mem(1): FAIL</code>, then you may need to manually allocate 2MiB Hugepages using the following: <code>echo 20 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</code></p> <pre><code># Create VF device\n$ pci_device &lt;PCIe Bus&gt;00.0 vf 3\n# Bind VF0 to vfio-pci\n$ opaei.io init -d &lt;PCIe Bus&gt;:00.1 &lt;username&gt;:&lt;username&gt;\n# Check for HE-MEM Accelerator GUID 8568ab4e-6ba5-4616-bb65-2a578330a8eb\n$ fpgainfo port -B &lt;PCIe Bus&gt;:00.0\n# Run desired HE-MEM test(s)\n$ host_exerciser --cls cl_1 --mode lpbk mem\nstarting test run, count of 1\nAPI version: 2\nAFU clock: 470 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nHost Exerciser numPendEmifReads: 0\nHost Exerciser numPendEmifWrites: 0\nNumber of clocks: 9948\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1024\nBandwidth: 3.096 GB/s\n    Test mem(1): PASS\n</code></pre> </li> </ul> <ul> <li>Generate traffic with HE-HSSI. No AFU required.<pre><code># Create VF device\n$ pci_device &lt;PCIe Bus&gt;00.0 vf 3\n# Bind VF2 to vfio-pci\n$ opaei.io init -d &lt;PCIe Bus&gt;:00.2 &lt;username&gt;:&lt;username&gt;\n# Check for HE-HSSI Accelerator GUID 823c334c-98bf-11ea-bb37-0242ac130002\n$ fpgainfo port -B &lt;PCIe Bus&gt;:00.0\n# Show number of configured ports\n$ fpgainfo phy | grep Port\n# Generate traffic for specific port number\n$ hssi --pci-address &lt;PCIe Bus&gt;:00.2 hssi_10g --num-packets 100 --port &lt;port number&gt;\n10G loopback test\nTx/Rx port: 1\nTx port: 1\nRx port: 1\neth_loopback: on\n  he_loopback: none\n  num_packets: 100\npacket_length: 64\nsrc_address: 11:22:33:44:55:66\n    (bits): 0x665544332211\n  dest_address: 77:88:99:aa:bb:cc\n    (bits): 0xccbbaa998877\n  random_length: fixed\n  random_payload: incremental\n...\n</code></pre> <p>This command will generate a log file in the directory is was run from. Check TxPackets and RxPackets for any loss. Two more supported HSSI commands are <code>hssistats</code>, which provides MAC statistics, and <code>hssimac</code>, which provides maximum TX and RX frame size.</p> </li> </ul> <ul> <li>Test memory traffic generation using MEM-TG. This will exercise and test available memory channels with a configurable memory pattern. Does not require an AFU image.<pre><code># Create VF device\n$ pci_device &lt;PCIe Bus&gt;00.0 vf 3\n# Bind VF2 to vfio-pci\n$ opaei.io init -d &lt;PCIe Bus&gt;:00.3 &lt;username&gt;:&lt;username&gt;\n# Check for MEM-TG Accelerator GUID 4dadea34-2c78-48cb-a3dc-5b831f5cecbb\n$ fpgainfo port -B &lt;PCIe Bus&gt;:00.0\n# Example MEM-TG Test\n$  mem_tg --loops 500 -w 1000 -r 0 -b 0x1 --stride 0x1 -m 0 tg_test\n</code></pre> </li> </ul> <ul> <li>HE-LPBK is designed to demo how AFUs move data between host memory and the FPGA. Will check latency, MMIO latency, MMIO bandwidth, and PCIe bandwidth.  LPBK workload requires the SoC Attach AFU be loaded into the board's PR slot.<pre><code># Create VF device\n$ pci_device &lt;PCIe Bus&gt;00.0 vf 3\n# Bind VF1 to vfio-pci\n$ opaei.io init -d &lt;PCIe Bus&gt;:00.1 &lt;username&gt;:&lt;username&gt;\n# Check for LPBK GUID 56e203e9-864f-49a7-b94b-12284c31e02b\n$ fpgainfo port -B &lt;PCIe Bus&gt;:00.0\n# Example loopback test\n$  host_exerciser --mode lpbk lpbk\n</code></pre> </li> </ul> <ul> <li>Exercise He-HSSI subsystem from the AFU. This test will generate and receieve packets from any of the 8 available ports. This HSSI workload requires the SoC Attach AFU be loaded into the board's PR slot.<pre><code># Create VF device\n$ pci_device &lt;PCIe Bus&gt;00.0 vf 3\n# Bind VF6 to vfio-pci\n$ opaei.io init -d &lt;PCIe Bus&gt;:00.2 &lt;username&gt;:&lt;username&gt;\n# Check for HSSI GUID 823c334c-98bf-11ea-bb37-0242ac130002\n$ fpgainfo port -B &lt;PCIe Bus&gt;:00.0\n# Geneate traffic for specific port\n$  hssi --pci-address &lt;bus_num&gt;:00.6 hssi_10g --num-packets 100 --port &lt;port_num&gt;\n</code></pre> <p>This command will generate a log file in the directory is was run from. Check TxPackets and RxPackets for any loss. Two more supported HSSI commands are <code>hssistats</code>, which provides MAC statistics, and <code>hssimac</code>, which provides maximum TX and RX frame size.</p> </li> </ul>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#53-additional-opae-sdk-utilities","title":"5.3 Additional OPAE SDK Utilities","text":"<p>This section will discuss OPAE SDK utilities that were not covered by previous sections. These commands are all available on the ICX-D SoC Yocto image by default. A full description and syntax breakdown for each command is located on the official OPAE SDK github.io repo.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#table-6-opae-sdk-utilities","title":"Table 6: OPAE SDK Utilities","text":"Utility Description fpgasupdate 3.2 Updating FIM, BMC and AFU with <code>fpgasupdate</code> rsu Section 3.3 Loading images with <code>rsu</code> host_exerciser Section 5.2 Host Exercisers hssi Section 5.2 Host Exercisers hssistats Section 5.2 Host Exercisers hssimac Section 5.2 Host Exercisers mem_tg Section 5.2 Host Exercisers usrclk <code>userclk</code> tool is used to set high and low clock frequency to an AFU. mmlink Remote signaltap is software tool used for debug RTL (AFU), effectively a signal trace capability that Quartus places into a green bitstream. Remote Signal Tap provides access the RST part of the Port MMIO space, and then runs the remote protocol on top. opaevfio The <code>opaevfio</code> command enables the binding/unbinding of a PCIe device to/from the vfio-pci device driver. See https://kernel.org/doc/Documentation/vfio.txt for a description of vfio-pci. opae.io An interactive Python environment packaged on top of libopaevfio.so, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device. bitstreaminfo Prints bitstream metadata. fpgaconf Lower level programming utility that is called automatically by <code>fpgasupdate</code>. <code>fpgaconf</code> writes accelerator configuration bitstreams (also referred to as \"green bitstreams\") to an FPGA device recognized by OPAE. In the process, it also checks the green bitstream file for compatibility with the targeted FPGA and its current infrastructure bitstream (the \"blue bistream\"). fpgad Periodically monitors/reports the error status reflected in the device driver's error status sysfs files. Establishes the channel by which events are communicated to the OPAE application. Programs a NULL bitstream in response to AP6 event. <code>fpgad</code> is required to be running before API calls fpgaRegisterEvent and fpgaUnregisterEvent will succeed."},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#60-setting-up-the-host","title":"6.0 Setting up the Host","text":"<p>External SoC Attach supports testing Host to FPGA latency, MMIO latency, and MMIO bandwidth. This testing is accomplished using the utility <code>host_exerciser</code> on the host, whichis included as a part of OPAE. This section will cover the installation and verification flow for a host interacting with the SoC Attach workload.</p> <p>Review Section 1.2 Server Requirements for a list of changes required on the host to support an Intel IPU Platform F2000X-PL and for a list of supported OS distributions. Installation will require an active internet connetion to resolve dependencies.</p> <p>The following software checks may be run on the host to verify the FPGA has been detected and has auto-negotatiated the correct PCIe link width/speed. These commands do not require any packages to be installed. We are using PCIe BDF <code>b1:00.0</code> as an example address.</p> <pre><code># Check that the board has enumerated successfully.\n# Your PCIe BDF may differ from what is shown below.\n$ lspci | grep accel\nb1:00.0 Processing accelerators: Intel Corporation Device bcce b1:00.1 Processing accelerators: Intel Corporation Device bcce\n\n# Check PCIe link status and speed. Width should be x16, and speed whould be 16GT/s\nsudo lspci -s b1:00.0 -vvv | grep LnkSta | grep -o -P 'Width.{0,4}'\nsudo lspci -s b1:00.0 -vvv | grep LnkSta | grep -o -P 'Speed.{0,7}'\nsudo lspci -s b1:00.1 -vvv | grep LnkSta | grep -o -P 'Width.{0,4}'\nsudo lspci -s b1:00.1 -vvv | grep LnkSta | grep -o -P 'Speed.{0,7}'\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#61-installing-the-opae-sdk-on-the-host","title":"6.1 Installing the OPAE SDK On the Host","text":"<p>The OPAE SDK software stack sits in user space on top of the OFS kernel drivers. It is a common software infrastructure layer that simplifies and streamlines integration of programmable accelerators such as FPGAs into software applications and environments. OPAE consists of a set of drivers, user-space libraries, and tools to discover, enumerate, share, query, access, manipulate, and reconfigure programmable accelerators. OPAE is designed to support a layered, common programming model across different platforms and devices. To learn more about OPAE, its documentation, code samples, an explanation of the available tools, and an overview of the software architecture, visit the opae.io page.</p> <p>The OPAE SDK source code is contained within a single GitHub repository hosted at the OPAE Github. This repository is open source and does not require any permissions to access.</p> <ol> <li> <p>Before Installing the newest version of OPAE you must remove any prior OPAE framework installations.</p> <pre><code>$ sudo apt-get remove opae*\n</code></pre> </li> <li> <p>The following system and Python3 package dependencies must be installed before OPAE may be built.</p> <pre><code>$ sudo apt-get install bison flex git ssh pandoc devscripts debhelper cmake python3-dev libjson-c-dev uuid-dev libhwloc-dev doxygen libtbb-dev libncurses-dev libspdlog-dev libspdlog1 python3-pip libedit-dev pkg-config libcli11-dev libssl-dev dkms libelf-dev gawk openssl libudev-dev libpci-dev  libiberty-dev autoconf llvm\n\n$ python3 -m pip install setuptools pybind11 jsonschema\n</code></pre> </li> <li> <p>Clone the OPAE SDK repo. In this example we will use the top level directory <code>OFS</code> for our package installs.</p> <pre><code>$ mkdir OFS &amp;&amp; cd OFS\n$ git init\n$ git clone https://github.com/OFS/opae-sdk.git\n$ cd opae-sdk\n$ git checkout tags/2.5.0-3\n\n# Verifying we are on the correct release tag\n$ git describe --tags\n2.5.0-3\n</code></pre> </li> <li> <p>Navigate to the automatic DEB package build script location and execute.</p> <pre><code>$ cd OFS/opae-sdk/packaging/opae/deb $ ./create\n\n# Verify all packages are present\n$ ls | grep opae.*.deb\nopae_2.5.0-1_amd64.deb\nopae-dbgsym_2.5.0-1_amd64.ddeb\nopae-devel_2.5.0-1_amd64.deb\nopae-devel-dbgsym_2.5.0-1_amd64.ddeb\nopae-extra-tools_2.5.0-1_amd64.deb\nopae-extra-tools-dbgsym_2.5.0-1_amd64.ddeb\n</code></pre> </li> <li> <p>Install your newly built OPAE SDK packages.</p> <pre><code>$ cd OFS/opae-sdk/packaging/opae/deb\n$ sudo dpkg -i opae*.deb\n</code></pre> <p>The OPAE tools installed on the host are identical to those installed on the SoC as shown in sections 5.0 through 5.3. A set of pre-compiled OPAE SDK artifacts are included in this release. These can be downloaded from 2023.1 OFS Release for Intel Agilex SoC Attach Reference Shell and installed without building/configuring.</p> <pre><code>$ tar xf opae-*.tar.gz\n$ sudo dpkg -i opae*.deb\n</code></pre> </li> <li> <p>Enable iommu=on, pcie=realloc, and set hugepages as host kernel parameters.</p> <p>```bash session   # Check if parameters are already enabled   $ cat /proc/cmdline   <pre><code>If you do not see *intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200*, then add them manually.\n\n```bash session\n$ sudo vim /etc/default/grub\n# Edit the value for GRUB_CMDLINE_LINUX, add the values at the end of the variable inside of the double quotes. Example: GRUB_CMDLINE_LINUX=\"crashkernel=auto resume=/dev/mapper/rhel00-swap rd.lvm.lv=rhel00/root rd.lvm.lv=rhel00/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200\"\n# Save your changes, then apply them with the following\n$ sudo grub2-mkconfig\n$ sudo reboot now\n</code></pre></p> </li> </ol> <p>After rebooting, check that <code>proc/cmdline</code> reflects your changes.</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#62-verifying-the-soc-attach-solution-on-the-host","title":"6.2 Verifying the SoC Attach Solution on the Host","text":"<p>The SoC Attach workload supports testing MMIO HW and Latency and PCIe BW and latency out of box. Execution of the <code>host_exerciser</code> binary on the host requires the OPAE SDK to be installed as shown in section 6.1 Installing the OPAE SDK On the Host. You will also need to have a proper SoC Attach FIM configured on your board as shown in section 3.2 Updating FIM, BMC and AFU with <code>fpgasupdate</code>.</p> <ol> <li> <p>Initialize PF attached to HSSI LPBK GUID with vfio-pci driver.</p> <pre><code>$ sudo opae.io init -d 0000:b1:00.0 &lt;username&gt;:&lt;username&gt;\n$ sudo opae.io init -d 0000:b1:00.1 &lt;username&gt;:&lt;username&gt;\n</code></pre> </li> <li> <p>Run <code>host_exerciser</code> loopback tests (only lpbk is supported). There are more methods of operation than are shown below - read the HE help message for more information.</p> </li> </ol> <p>```bash session</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#example-lpbk-tests","title":"Example lpbk tests.","text":"<p>sudo host_exerciser lpbk sudo host_exerciser --mode lpbk lpbk sudo host_exerciser --cls cl_4  lpbk sudo host_exerciser --perf true --cls cl_4  lpbk</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#number-of-cachelines-per-request-4","title":"Number of cachelines per request 4.","text":"<p>sudo host_exerciser --mode lpbk --cls cl_4 lpbk sudo host_exerciser --perf true --mode lpbk --cls cl_4 lpbk</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#vnumber-of-cachelines-per-request-4","title":"vNumber of cachelines per request 4.","text":"<p>sudo host_exerciser --mode read --cls cl_4 lpbk sudo host_exerciser --perf true --mode read --cls cl_4 lpbk</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#number-of-cachelines-per-request-4_1","title":"Number of cachelines per request 4.","text":"<p>sudo host_exerciser --mode write --cls cl_4 lpbk sudo host_exerciser --perf true --mode write --cls cl_4 lpbk</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#number-of-cachelines-per-request-4_2","title":"Number of cachelines per request 4.","text":"<p>sudo host_exerciser --mode trput --cls cl_4 lpbk sudo host_exerciser --perf true --mode trput --cls cl_4 lpbk</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#enable-interleave-requests-in-throughput-mode","title":"Enable interleave requests in throughput mode","text":"<p>sudo host_exerciser --mode trput --interleave 2 lpbk sudo host_exerciser --perf true --mode trput --interleave 2 lpbk</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#with-delay-option","title":"with delay option.","text":"<p>sudo host_exerciser --mode read --delay true lpbk sudo host_exerciser --mode write --delay true lpbk</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#test-all-modes-of-operation","title":"Test all modes of operation","text":"<p>host_exerciser --testall=true lpbk ```</p>"},{"location":"hw/f2000x/user_guides/ug_qs_ofs_f2000x/ug_qs_ofs_f2000x/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/","title":"Simulation User Guide: Open FPGA Stack for Intel Agilex SoC Attach FPGAs","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to user space."},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#1-overview","title":"1 Overview","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a set-up and user guide for the UVM simulation tool using OFS. After reviewing the document, you will be able to:</p> <ul> <li>Set-up the UVM verification tool suite</li> </ul> <ul> <li>Run pre-existing UVM unit tests and also create new UVM tests for your design</li> </ul> <p></p> Term Abbreviation Description Advanced\u00a0Error\u00a0Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link) Accelerator\u00a0Functional\u00a0Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.\u00a0Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region. Basic Building Block BBB Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. Best\u00a0Known\u00a0Configuration BKC The software and hardware configuration Intel uses to verify the solution. Board\u00a0Management\u00a0Controller BMC Supports features such as board power managment, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate component, such as an Intel\u00ae Max\u00ae 10 or Intel Cyclone\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA. Configuration and\u00a0Status\u00a0Register CSR The generic name for a register space which is accessed in order to interface with the module it resides in (e.g. AFU, BMC, various sub-systems and modules). Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Device\u00a0Feature\u00a0List DFL The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\u00a0This concept is the foundation for the OFS software framework. (link) FPGA\u00a0Interface\u00a0Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FPGA\u00a0Management\u00a0Engine FME Performs reconfiguration and other FPGA management functions. Each FPGA device only has one FME which is accessed through PF0. Host\u00a0Exerciser\u00a0Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Intel\u00a0Virtualization\u00a0Technology for\u00a0Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Joint Test Action Group JTAG Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. Memory\u00a0Mapped\u00a0Input/Output MMIO The memory space users may map and access both control registers and system memory buffers with accelerators. oneAPI Accelerator Support Package oneAPI-asp A collection of hardware and software components that enable oneAPI kernel to communicate with oneAPI runtime and OFS shell components. oneAPI ASP hardware components and oneAPI kernel form the AFU region of a oneAPI system in OFS. Open\u00a0FPGA\u00a0Stack OFS OFS is a software and hardware infrastructure providing an efficient approach to develop a custom FPGA-based platform or workload using an Intel, 3rd party, or custom board. Open\u00a0Programmable\u00a0Acceleration\u00a0Engine Software Development Kit OPAE SDK The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Platform\u00a0Interface\u00a0Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Platform Management Controller Interface PMCI The portion of the BMC that resides in the Agilex FPGA and allows the FPGA to communicate with the primary BMC component on the board. Partial Reconfiguration PR The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. For OFS designs, the PR region is referred to as the pr_slot. Port N/A When used in the context of the fpgainfo port command it represents the interfaces between the static FPGA fabric and the PR region containing the AFU. Remote System Update RSU The process by which the host can remotely update images stored in flash through PCIe. This is done with the OPAE software command \"fpgasupdate\". Secure Device Manager SDM The SDM is the point of entry to the FPGA for JTAG commands and interfaces, as well as for device configuration data (from flash, SD card, or through PCI Express* hard IP). Static Region SR The portion of the FPGA design that cannot be dynamically reconfigured during run-time. Single-Root\u00a0Input-Output\u00a0Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. SYCL SYCL SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Test Bench TB Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. Universal Verification Methodology UVM A modular, reusable, and scalable testbench structure via an API framework.  In the context of OFS, the UVM enviroment provides a system level simulation environment for your design. Virtual\u00a0Function\u00a0Input/Output VFIO An Input-Output Memory Management Unit (IOMMU)/device agnostic framework for exposing direct device access to userspace.\u00a0(link)"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#2-introduction-to-uvm","title":"2 Introduction to UVM","text":"<p>The Functional Verification Environment for OFS is UVM (Universal Verification Methodology) compliant and provides configurable setup for verifying various FIM features in simulation.</p> <p>The purpose of this document is to demonstrate a full chip level and unit level UVM based verification environment for the current base shell FIM architecture as well as providing examples to extend the setup for different OFS variants by reusing the existing architecture and infrastructure for UVM based verification.</p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#3-universal-testbench-architecture","title":"3 Universal Testbench Architecture","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#31-overview","title":"3.1 Overview","text":"<p>The main idea behind UVM is to develop modular, reusable, and a scalable testbench structure by providing an API framework that can be deployed across multiple projects.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#32-core-verification-concepts","title":"3.2 Core Verification Concepts","text":"<p>The following is the list of verification components that will be used to design a UVM testbench architecture:</p> <p>\u2022   Sequencer \u2022   Driver \u2022   Monitor \u2022   Scoreboard \u2022   Virtual Sequencer \u2022   Interface \u2022   Verification Environment \u2022   TOP Testbench</p> <p>Figure 1 provides the general UVM Testbench and the verification components involved in the top-level architecture.</p> <p></p> <p>Figure 1 Typical UVM Testbench</p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4-ofs-testbench-architecture","title":"4 OFS Testbench Architecture","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#41-overview","title":"4.1 Overview","text":"<p>OFS (Open FPGA Stack) provides a UVM (Universal Verification Methodology) environment for the FIM with a modular, reusable, and scalable testbench structure via an API framework.</p> <p>The framework consists of a FIM Testbench which is UVM compliant and integrates third party VIPs from Synopsys for PCI Express, Arm\u00ae AMBA\u00ae 4 AXI4-Streaming interface and Arm\u00ae AMBA\u00ae 4 AXI4Arm\u00ae AMBA\u00ae 4 AXI4-Memory Mapped interface for comprehensive verification. The user will need to acquire licenses for these VIPs to use this Testbench. UVM RAL(Register Abstraction Level) is used for CSR (Command and Status Registers) verification. </p> <p>The qualified verification IPs will help to detect incorrect protocol behavior, help to focus on FIM features and accelerate the verification process.</p> <p>Verification components include:</p> <pre><code>\u2022 FIM monitor to detect correct design behavior\n\u2022 FIM assertions for signal level integrity testing\n\u2022 Arm AMBA Arm\u00ae AMBA\u00ae 4 AXI4 scoreboards to check data integrity\n\u2022 FIM coverage to collect functional data\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#42-base-fim-dut","title":"4.2 Base FIM DUT","text":"<p>The hardware architecture of an Agilex FIM is based on the OFS hardware architecture. The following is the list of features and subsystems supported in the base shell.</p> <pre><code>\u2022   PCIe Subsystem\n\u2022   HSSI Subsystem\n\u2022   Memory Subsystem\n\u2022   HPS Subsystem\n\u2022   FME\n\u2022   AFU with PR support\n\u2022   QSFP Controllers\n\u2022   PMCI Controller, MCTP\n</code></pre> <p></p> <p>Figure 2 DUT Base Shell Diagram</p> <p>Figure 2 shows the high level architecture of an Agilex Base Shell. It has a Gen4x16, 100G Ethernet Datapath in a 2x4x25G configuration. The Agilex Base Shell is a shell that will enable a user to build other shell variants for a custom configuration. For the f2000x board there is one shell variant</p> <p>base_x16</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#43-full-chip-level-verification-archiecture-for-fim","title":"4.3 Full Chip Level Verification Archiecture for FIM","text":"<p>Figure 3 shows a graphical representation a full chip testbench that includes major RTL blocks depicted in a OFS Agilex based UVM environment </p> <p></p> <p>Figure 3 OFS FIM Testbench</p> <p>The major connection is the interface between the Xeon CPU and the FPGA where the PCIe Verification IP is connected to PCIe Subsystem. Therefore, as a full chip simulation environment, PCIe host VIP is the sole VIP/BFM used. PCIe host VIP connects to PCIe device which resides in FPGA in serial mode.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#431-testbench-components","title":"4.3.1 Testbench components","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4311-tb-top","title":"4.3.1.1 TB TOP","text":"<p>TOP is the top level testbench and consists of a FIM DUT instance and top-level UVM Verification Environment instance. It binds RTL inputs with the verification environmnet interfaces to drive stimulus. It also has clock generation and reset driving logic.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4312-fim-verification-environment","title":"4.3.1.2 FIM Verification Environment","text":"<p>This is the top most verification environment class and consists of the protocol specific PCI Express and AXI UVM environment VIP instances, Monitors, Scoreboards, Assertions, Functional coverage Modules and other verification components. It instantiates Virtual sequencers to control stimuli for FIM traffic from different sequencers of the VIPs.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4313-synopsys-vips","title":"4.3.1.3 Synopsys VIPs","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#43131-pci-vip-as-host","title":"4.3.1.3.1 PCI VIP as Host","text":"<p>This is Synopsys Licensed PCI Express Gen4 VIP and acts as Root Port. The PCI Express link is connected to the DUT using TX-RX lanes. Agent is an active component and includes a sequencer to generate TLPs, Driver to drive it on a PCI Express link and Monitor to check the protocol correctness.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#43132-axi-streaming-vip-monitors","title":"4.3.1.3.2 AXI-Streaming VIP Monitors","text":"<p>This is Synopsys Licensed AXI streaming interface Verification IP used as a Passive Agent to monitor AXI-ST links at various points. Please refer to Figure 3 to see all the AXI-ST monitors connected to different modules.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#43133-axi4-memory-mapped-vip-monitors","title":"4.3.1.3.3 AXI4-Memory Mapped VIP Monitors","text":"<p>This is Synopsys Licensed Arm\u00ae AMBA\u00ae 4 AXI4 memory mapped interface Verification IP used in passive mode to observe memory requests. For each master-slave pair, the verification environment has a VIP instantiated in passive mode for monitoring protocol violations and performing data integrity checks.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#43134-axi4-lite-vip-monitors","title":"4.3.1.3.4 AXI4-Lite VIP Monitors","text":"<p>This is Synopsys Licensed Arm\u00ae AMBA\u00ae 4 AXI4Arm\u00ae AMBA\u00ae 4 AXI4 Lite interface Verification IP used in passive mode to observe MMIO requests. For each master-slave pair, the verification environment has a VIP instantiated in passive mode for monitoring protocol violations and perfoming data integrity checks. Please refer to Figure 3 to see all the Arm\u00ae AMBA\u00ae 4 AXI4-Lite monitors connected to different modules.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#43135-axi4-lite-vip-as-pmci-master","title":"4.3.1.3.5 AXI4-Lite VIP as PMCI Master","text":"<p>This is Synopsys Licensed Arm\u00ae AMBA\u00ae 4 AXI4 Lite interface Verification IP used to drive and observe MMIO requests as PMCI master. For each master-slave pair, the verification environment has a VIP instantiated in active mode and includes a sequencer to generate MMIO requests, driver to drive these requests on AXI-4 Lite interface to BPF and a monitor for observing protocol violations and data integrity checks. </p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4314-axi4-s-scoreboard","title":"4.3.1.4 AXI4-S Scoreboard","text":"<p>The Arm\u00ae AMBA\u00ae 4 AXI4-S scoreboard checks data integrity of source and sink components. It has input transactions from VIP monitors and a TLP to AXI converter for PCIe TLP packets. It makes sure the valid TLPs or AXI transactions are not missed while traversing from Host to AFU and reverse. The scoreboard will be disabled for error testing especially for invalid TLP requests and UR responses.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4315-virtual-sequencer","title":"4.3.1.5 Virtual Sequencer","text":"<p>The virtual sequencer is the top-level sequencer which controls Enumeration, MMIO Requests, downstream and Upstream traffic as well as HSSI and Memory transactions. It makes sure that the transactions are ordered correctly as per the design specification while running a UVM test simulation.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4316-fim-monitor","title":"4.3.1.6 FIM Monitor","text":"<p>The FIM monitor is used for checking the correctness of a specific FIM feature. As an example, a user can add interrupt related checks, error generation and clearing checks, Protocol checker impacts etc. in this component. </p> <p>This would be an independent plug-n-play component and can be reused with any user developed UVM FIM TB.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4317-fim-assertions","title":"4.3.1.7 FIM Assertions","text":"<p>The assertion component is used for checking the signal level integrity of a specific FIM feature or behavior. As an example, we can add interrupt signal triggering and clear assertions, Error detection to error register bit assertions, protocol checker and clearing logic, FLR behavior assertion etc. in this top-level module. There are alos assertions to make sure the inputs are driven correctly to catch errors in a users simulation. </p> <p>This would be an independent plug-n-play component and can be reused with any user developed UVM FIM TB.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#4318-fim-functional-coverage","title":"4.3.1.8 FIM Functional Coverage","text":"<p>The FIM functional coverage component will have the functional coverage of each feature like interrupts, CSR's, MMIO requests, Byte align transactions, error reporting etc. to demonstrate a variety of FIM features. This will help us to find holes in the design as well as wide verification coverage to make sure thorough testing of a design. It will also provide a user what the FIM is capable of and how much code coverage they are testing.</p> <p>This would be an independent plug-n-play component and can be reused with any user developed UVM FIM TB.</p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#5-uvm-verification-set-up","title":"5 UVM Verification set-up","text":"<p>To run the tutorial steps in this guide requires the following development environment:</p> Item Version Intel Quartus Prime Pro Intel Quartus Prime Pro 23.1 Simulator Synopsys VCS P-2019.06-SP2-5 or newer for UVM simulation of top level FIM Simulator (Questasim) Questasim 2021.4 or newer for UVM simulation of top level FIM"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#51-uvm-prerequisite","title":"5.1 UVM Prerequisite","text":"<p>Retrieve OFS repositories.</p> <p>The OFS FIM source code is included in the OTCShare GitHub repository. Create a new directory to use as a clean starting point to store the retrieved files.  The following is a short description of each repository, followed by the git commands for cloning.  The instructions section uses the HTTPS git method for cloning repositories.  Cloning the repo using the HTTPS method requires a personal access token.  Please see this blog post for information about obtaining a personal access token Token authentication requirements for Git operations.</p> <p>Navigate to location for storage of OFS source, create the top-level source directory and clone OFS repositories.</p> <pre><code>$ mkdir release/ofs-2023.1\n$ cd release/ofs-2023.1\n$ export OFS_BUILD_ROOT=$PWD\n$ git clone --branch --recurse-submodules https://github.com/ofs-f2000x-pl.git\n\nCloning into 'ofs-f2000x-pl'...'\nUsername for 'https://github.com': &lt;&lt;Enter your git hub username&gt;&gt;\nPassword for 'https://&lt;&lt;Your username&gt;&gt;': &lt;&lt;Enter your personal access token&gt;&gt;\nremote: Enumerating objects:  ....\n...\n...\nResolving deltas  ..., done.\n\n$ cd ofs-f2000x-pl\n$ git checkout tags/ofs-2023.1-1\n</code></pre> <p>Verify that the correct tag/branch have been checked out        </p> <pre><code>$ git describe --tags\n\n$ ofs-2023.1-1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#52-license-requirements","title":"5.2 License Requirements","text":"<p>The FIM Testbench is UVM compliant and integrates third party VIP's from Synopsys for PCI Express, Arm\u00ae AMBA\u00ae 4 AXI4-Streaming interface and Arm\u00ae AMBA\u00ae 4 AXI4Arm\u00ae AMBA\u00ae 4 AXI4-Memory Mapped interface for comprehensive verification. The user will need to acquire licenses for these VIPs to use this TB. UVM RAL (Register Abstraction Layer) is used for CSR Verification.</p> <p>The Qualified Verification IPs will help to detect incorrect protocol behavior easily, help to focus on FIM features and accelerate the verification process.</p> <pre><code>\u2022 VCS &amp; DVE\n\u2022 SNPS-Assertions\n\u2022 Verdi\n\u2022 VerdiCoverage\n\u2022 VerdiSimDB\n\u2022 VerdiTransactionDebugUltra\n\u2022 VIP-AMBA-AXI-SVT\n\u2022 VIP-AMBA-STREAM-SVT\n\u2022 VIP-PCIE-SVT\n\u2022 VIP-PCIE-TS-SVT\n\u2022 VIP-PCIE-G3-OPT-SVT\n\u2022 VIP-Ethernet-SVT\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#53-software-tools-requirements","title":"5.3 Software Tools Requirements","text":"<p>The following tools are required for successful UVM set-up</p> <ul> <li>Python 3.7.7</li> <li>Synopsys PCIE and AMBA AXI UVM VIP Q-2020.03A License</li> <li>VCS R-2020.12-SP2 License       Note: Makefile can be modified to use DVE instead of Verdi</li> </ul> <ul> <li>VCS R-2020.12-SP2 License </li> </ul>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#54-creating-a-software-tools-script","title":"5.4 Creating a Software Tools Script","text":"<p>The UVM tool set-up is best done by creating a simple set-up script so all applicable tools are sourced before running the tests.</p> <p>The following environment variables can be pasted into a script and used prior to running the UVM verification environment</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#license-files","title":"License Files","text":"<pre><code>export LM_LICENSE_FILE=\nexport SNPSLMD_LICENSE_FILE=\n</code></pre> <p>The license environment variables LM_LICENSE_FILE and SNPSLMD_LICENSE_FILE can point to a server license on your system.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#general-environment-variables","title":"General Environment Variables","text":"<pre><code>export IOFS_BUILD_ROOT=$PWD\nexport OFS_ROOTDIR=&lt;user_path&gt;/ofs-f2000x-pl\nexport WORKDIR=$OFS_ROOTDIR\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#quartus-tools","title":"Quartus Tools","text":"<pre><code>export QUARTUS_HOME=&lt;user_path&gt;/intelFPGA_pro/23.1/quartus\nexport QUARTUS_ROOTDIR=$QUARTUS_HOME\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport QSYS_ROOTDIR=$QUARTUS_ROOTDIR/../qsys/bin\nexport PATH=$QUARTUS_HOME/bin:$QUARTUS_HOME/qsys/bin:$QUARTUS_HOME/sopc_builder/bin/:$PATH\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#synopsys-verification-tools","title":"Synopsys Verification Tools","text":"<pre><code>export DESIGNWARE_HOME=&lt;user_path&gt;/synopsys/vip_common/vip_Q-2020.03A\nexport PATH=$DESIGNWARE_HOME/bin:$PATH\nexport UVM_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm\nexport VCS_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel\nexport PATH=$VCS_HOME/bin:$PATH\nexport VERDIR=$OFS_ROOTDIR/verification\nexport VIPDIR=$VERDIR\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#questasim-verification-tools","title":"QuestaSIM Verification Tools","text":"<pre><code>export MTI_HOME=&lt;user_path&gt;/mentor/questasim/2021.4/linux64\nexport PATH=$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$PATH\nexport QUESTA_HOME=$MTI_HOME\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#6-running-a-uvm-simulation-test-and-analysing-results","title":"6 Running a UVM Simulation Test and Analysing Results","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#61-simulation","title":"6.1 Simulation","text":"<p>The default simulator used in the simulation script is Synopsys VCS-MX. Users can refer to the options and adopt the options for other simulators. The script is a makefile that calls vlogan, vcs and simv for compilation, elaboration and simulation, respectively.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#62-file-structure","title":"6.2 File Structure","text":"<p>After cloning the repo, the verification and ofs-common directories contain all UVM verification related files. The directory structure is shown in Figure 4 below.</p> <p></p> <p>Figure 4 UVM Verification Directory File Structure</p> <p>ofs-f2000x-pl/verification/testbench has a testbench, uvm env, virtual sequencer, RAL etc. </p> <p>ofs-f2000x-pl/tests contains all uvm tests and sequences. </p> <p>Users can run the simulation under \"ofs-f2000x-pl/verification/scripts\" directory and the simulation result is outputted to a \"sim\" directory for Synopsys VCS or sim_msim for Questasim.</p> <p>The simulation result folder is named after the test name with increasing suffix number. If user runs the same test multiple times, the suffix is incremented by 1 each time.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#63-uvm-test-suite","title":"6.3 UVM Test Suite","text":"<p>The UVM environment contains a variety of tests that have been developed to test out the FIM portion of OFS.</p> <p>The table below has four columns which describe the \"Test Name\", \"DUT Scope\", \"Test Scenario\" and the \"Checking Criteria\".</p> <p>Tests are located at ofs-f2000x-pl/ofs-common/verification/fpga_family/agilex/tests</p> Test Name DUT Scope Test Scenario Checking Criteria afu_mmio_flr_pf0_test PF0 FLR Reset Apply FLR Reset for PF0 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF0 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf0_vf0_test PF0_VF0_FLR Reset Apply FLR Reset for PF0_VF0 and deassert Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR       access are working fine afu_mmio_flr_pf0_vf1_test PF0_VF1_FLR Reset Apply FLR Reset for PF0_VF1 and deassert Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf0_vf2_test PF0_VF2_FLR Reset Apply FLR Reset for PF0_VF2 and deassert Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf1_vf0_test PF1_VF0_FLR Reset Apply FLR Reset for PF1_VF0 and deassert Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf2_test PF2 FLR Reset Apply FLR Reset for PF2 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF2 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf3_test PF3 FLR Reset Apply FLR Reset for PF3 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF3 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf4_test PF4 FLR Reset Apply FLR Reset for PF4 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF4 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_stress_5bit_tag_test AFU-StressAFU-Stress To check the AFU Stress by sending traffic with 5bit tag from all PF/VF. i.e Send traffic on HE-LPK/HE-MEM and initiating MMIO access to other PF/VFs Data checking afu_stress_8bit_tag_test AFU-Stress To check the AFU Stress by sending traffic with 5bit tag from all PF/VF. i.e Send traffic on HE-LPK/HE-MEM and initiating MMIO access to other PF/VFs Data checking afu_stress_test AFU-Stress 1. Initiate transactions to all the supported PF/VF from PCIE VIP and ensure that traffic is sent to all blocks of the AFU.                 2. Ensure that CE/HE-LB/HE-MEM/HSSI/BPF/FME are seeing traffic.                 3. Ensure that HE-LB/HE-MEM/CE sends DMWR/DMRD requests to PCIE VIP.                 4. Ensure the Mux/DeMux blocks is able to handle the traffic based on the PF's/VF's and proper muxing/demuxing happens. Data checking bar_32b_test PCIe MMIO Path Set the BAR values to 32bit and test mmio access BAR address, Register Base Offset bar_64b_test PCIe MMIO Path Set the BAR values to 64bit and test mmio access BAR address, Register Base Offset dfh_walking_test DFH DFH walking offset checking, eol checking -&gt; tb emif_csr_test EMIF CSR access data checking fme_csr_test FME CSR CSR accesses data checking fme_err_intr_test Interrupt FME Interrupt request using FME ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read fme_intr_test Interrupt FME interrupt request using RAS ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read fme_multi_err_intr_test Interrupt FME interrupt request using RAS ERROR and FME ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read plus verifying interrupt requests generated from FME and RAS ERROR bits he_hssi_csr_test HE-HSSI CSR accesses data checking he_hssi_rx_lpbk_25G_10G_test HE-HSSI Sending back to back ethernet data traffic with 25G speed on HSSI RX Port0-7 lanes using Ethernet VIPs Enable the loopback mode in HE-HSSI and compare the pkts recived on HSSI TX Port(DATA CHECKING) he_hssi_tx_lpbk_P0_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port0  lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P1_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port1 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P2_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port2 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P3_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port3 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P4_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port4 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P5_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port5 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P6_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port6 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P7_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port7 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_lpbk_cont_test HE-LPBK Continuous mode/LPBK mode, random num_lines, addresses, req_len data checking he_lpbk_csr_test HE-LPBK CSR accesses data checking he_lpbk_flr_rst_test HE-LPBK FLR RST is generated in HE_LPBK access data checking, counter checking he_lpbk_long_rst_test HE-LPBK Multiple iterations of he_lpb_seq with soft reset HE-LB in middle data checking, counter checking he_lpbk_long_test HE-LPBK Multiple iterations of he_lpb_seq with STOP HE-LB in middle data checking, counter checking he_lpbk_multi_user_intr_test HE-LPBK generate user HE_LB interrupt interrupt checking he_lpbk_rd_cont_test HE-LPBK Read only mode/ Continuous mode. Randomize num_lines, addresses, req_len data checking he_lpbk_rd_test HE-LPBK Read only mode. Randomize num_lines, addresses, req_len counter checking he_lpbk_reqlen16_test HE-LPBK To check the behavior of HE_LPK block when req_length 16 and num_lines set to 1024 Cache lines in Loopback mode data checking, counter checking he_lpbk_reqlen1_test HE-LPBK Loopback mode. 128 CLs, req_len = 1CL, random addresses data checking, counter checking he_lpbk_reqlen2_test HE-LPBK Loopback mode. 128 CLs, req_len = 2CL, random addresses data checking, counter checking he_lpbk_reqlen4_test HE-LPBK Loopback mode. 128 CLs, req_len = 4CL, random addresses data checking, counter checking he_lpbk_reqlen8_test HE-LPBK Loopback mode. 128 CLs, req_len = 8CL, random addresses data checking, counter checking he_lpbk_rst_in_middle_test PCIe MMIO Path Set HE_LPK in  all the modes randomly and iterate the transactions in loop. At the end of every loop assert the Soft reset in the middle of the transactions Register Base Offset he_lpbk_test HE-LPBK Loopback mode.  Randomize num_lines, addresses, req_len data checking, counter checking he_lpbk_thruput_contmode_test HE-LPBK Continuous mode, Read/Write mode. 50/50. Randomize num_lines, addresses, req_len data checking he_lpbk_thruput_test HE-LPBK Read/Write mode. 50/50. Randomize num_lines, addresses, req_len counter checking he_lpbk_wr_cont_test HE-LPBK Write only mode/Continuous mode. Randomize num_lines, addresses, req_len data checking he_lpbk_wr_test HE-LPBK Write only mode. Randomize num_lines, addresses, req_len counter checking he_mem_cont_test HE-MEM Continuous mode/LPBK mode, random num_lines, addresses, req_len data checking, counter checking he_mem_csr_test HE-MEM CSR accesses data checking he_mem_lpbk_long_rst_test HE-MEM Multiple iterations of he_lpb_seq with soft reset HE-LB in middle data checking, counter checking he_mem_lpbk_long_test HE-MEM Multiple iterations of he_lpb_seq with STOP HE-LB in middle data checking, counter checking he_mem_lpbk_reqlen16_test HE-MEM To check the behavior of HE_LPK block when req_length 16 and num_lines set to 1024 Cache lines in Loopback mode data checking, counter checking he_mem_lpbk_reqlen1_test HE-MEM Loopback mode. 128 CLs, req_len = 1CL, random addresses data checking, counter checking he_mem_lpbk_reqlen2_test HE-MEM Loopback mode. 128 CLs, req_len = 2CL, random addresses data checking, counter checking he_mem_lpbk_reqlen4_test HE-MEM Loopback mode. 128 CLs, req_len = 4CL, random addresses data checking, counter checking he_mem_lpbk_reqlen8_test HE-MEM Loopback mode. 128 CLs, req_len = 8CL, random addresses data checking, counter checking he_mem_lpbk_test HE-MEM Loopback mode.  Randomize num_lines, addresses, req_len data checking, counter checking he_mem_multi_user_intr_test Interrupt Back to back multiple User interrupt request from HE MEM Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read for multiple back to back request he_mem_rd_cont_test HE-MEM Read only mode/Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_rd_test HE-MEM Read only mode. Randomize num_lines, addresses, req_len counter checking he_mem_thruput_contmode_directed_test HE-MEM Set HE_MEM in Thrput Continuous mode and test data checking, counter checking he_mem_thruput_contmode_test HE-MEM Continuous mode, Read/Write mode. 50/50. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_thruput_test HE-MEM Read/Write mode. 50/50. Randomize num_lines, addresses, req_len counter checking he_mem_user_intr_test Interrupt FME interrupt request using RAS ERROR and FME ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read plus verifying interrupt requests generated from FME and RAS ERROR bits he_mem_wr_cont_test HE-MEM Write only mode/Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_wr_test HE-MEM Write only mode. Randomize num_lines, addresses, req_len counter checkingt he_random_test All HEs Enable all HEs and randomize modes data checking if in lpbk mode, counter checking helb_rd_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Read only mode Measure the performance helb_rd_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Read only mode Measure the performance helb_rd_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Read only mode Measure the performance helb_thruput_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Thruput mode Measure the performance helb_thruput_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Thruput mode Measure the performance helb_thruput_4cl_5bit_tag_test Performance Set HE_LPK in thruput mode and send traffic with req len 4 and num_lines set to 1024. Measure the Read/Write performance Measure the performance helb_thruput_4cl_8bit_tag_test Performance Set HE_LPK in thruput mode and send traffic with req len 4 and num_lines set to 1024. Measure the Read/Write performance Measure the performance helb_thruput_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Thruput mode Measure the performance helb_wr_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Write only mode Measure the performance helb_wr_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Write only mode Measure the performance helb_wr_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Write only mode Measure the performance hssi_ss_test HSSI CSR accesses data checking malformedtlp_pcie_rst_test Protocol Checker generate mllformed TLP protocol error and initiate pcie reset to clear the error Check for error malformedtlp_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. MaxTagError_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transactions are completing. mem_tg_csr_test MEM-TG CSR access data checking mem_tg_traffic_gen_test MEM-TG This test checks the MEM_TG traffic generator flow  data checking mini_smoke_test All HEs shorter simpler version of random test for turn-in sanity check data checking if in lpbk mode, counter checking mix_intr_test Interrupt Mix interrupt testcase to send multiple FME and User interrupt request simultaneously Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read plus verifying interrupt requests through different sources - FME and HE-MEM modules mmio_pcie_mrrs_128B_mps_128B_test PCIe - Max Payload/Max Read Req Size Random length mmio Write Checking valid possible combination of MPS &amp; MRRS mmio_pcie_mrrs_128B_mps_256B_test PCIe - Max Payload/Max Read Req Size Random length mmio Write Checking valid possible combination of MPS &amp; MRRS mmio_pcie_mrrs_256B_mps_128B_test PCIe - Max Payload/Max Read Req Size Random length mmio Write Checking valid possible combination of MPS &amp; MRRS mmio_pcie_mrrs_256B_mps_256B_test PCIe - Max Payload/Max Read Req Size Random length mmio Read Checking valid possible combination of MPS &amp; MRRS mmio_stress_nonblocking_test PF/VF Mux/Demux Stressing MMIO on PF/VF Mux/Demux with non-blocking MMIO reads data checking mmio_stress_test PF/VF Mux/Demux Stressing MMIO on PF/VF Mux/Demux data checking mmio_test PCIe MMIO Path MMIO targeting PF0(ST2MM, FME, PMCI, QSFP, HSSI SS), PF1, PF2,PF3, PF4, PF1.VF1, PF1.VF2 data checking mmio_unimp_test PCIe MMIO Path MMIO acccess to unimplemented addresses data checking MMIODataPayloadOverrun_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. MMIOInsufficientData_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. MMIOTimedout_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. pcie_csr_test PCIESS Earlier msix registers were in fme block but now it has moved from fme to pciess. Hence coded a seperate test for msix data checking pcie_pmci_mctp_multi_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM multiple packets received from PMCI controller over APF and BPF to PCIe HIA subsystem pcie_pmci_mctp_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM (Vendor Defined Message) single packet received from PCIe HIA subsystem to PMCI controller over APF and BPF via AXI4-lite memory write request pmci_csr_test PMCI CSR CSR accesses data checking pmci_fme_csr_test PMCI FME CSR CSR accesses data checking pmci_pcie_mctp_multi_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM multiple packets received from PMCI controller over APF and BPF to PCIe HIA subsystem pmci_pcie_mctp_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM single packet received from PMCI controller over APF and BPF to PCIe HIA subsystem pmci_pciess_csr_test PMCI PCIESS CSR CSR accesses data checking pmci_qsfp_csr_test PMCI QSFP CSR CSR accesses data checking port_gasket_csr_test PORT GASKET CSR accesses data checking qsfp_csr_test QSFP CSR accesses data checking TxMWrDataPayloadOverrun_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. TxMWrInsufficientData_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. uart_intr_test UART Checking Generates UART interrupt Check interrupt UnexpMMIORspErr_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. vdm_err_vid_test Vendor ID check generate a packet with undefined Vendor-ID from Host to PMCI_SS ID check <p></p> <p>The next section describes how to compile and build the UVM environment prior to running each UVM test and analyinsg the results in the log files </p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#64-ip-compile","title":"6.4 IP Compile","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#synopsys-vcs","title":"Synopsys VCS","text":"<p>To compile all IPs for the Synopsys VCS simulater:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk cmplib_adp\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#questasim-tbd","title":"Questasim (TBD)","text":"<p>To compile all IPs for the Questasim simulater:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk cmplib_adp\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#65-rtl-test-bench-compile","title":"6.5 RTL &amp; Test Bench Compile","text":"<p>The RTL file list for compilation is located here: verification/scripts/rtl_comb.f</p> <p>The TB file list for compilation is located here: verification/scripts/ver_list.f</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#synopsys-vcs_1","title":"Synopsys VCS","text":"<p>To compile RTL and Testbench for the Synopsys VCS simulater</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk build_adp DUMP=1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#questasim-tbd_1","title":"Questasim (TBD)","text":"<p>To compile RTL and Testbench for the Questasim simulater</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk build_adp DUMP=1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#66-ip-and-rtl-test-bench-compile","title":"6.6 IP and RTL &amp; Test Bench Compile","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#synopsys-vcs_2","title":"Synopsys VCS","text":"<p>If the user wants to compile all IPs and RTL Testbench in one command for Synopsys VCS then follow the procedure below</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk build_all DUMP=1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#questasim-tbd_2","title":"Questasim (TBD)","text":"<p>If the user wants to compile all IPs and RTL Testbench in one command for Questasim then follow the procedure below</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk build_all DUMP=1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#synopsys-vcs_3","title":"Synopsys VCS","text":"<p>To run a simulation for Synopsys VCS:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk run TESTNAME=ofs_mmio_test DUMP=1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#questasim-tbd_3","title":"Questasim (TBD)","text":"<p>To run a simulation for Questasim:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk run TESTNAME=ofs_mmio_test DUMP=1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#synopsys-vcs_4","title":"Synopsys VCS","text":"<p>To dump the waveform, \"DUMP=1\" must be added into the command line for Synopsys VCS build and simulation. </p> <pre><code>    gmake -f Makefile_VCS.mk build_adp DUMP=1\n\n    gmake -f Makefile_VCS.mk run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> <p>Or</p> <pre><code>    gmake -f Makefile_VCS.mk build_run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#questasim-tbd_4","title":"Questasim (TBD)","text":"<p>To dump the waveform, \"DUMP=1\" must be added into the command line for Questasim build and simulation. </p> <pre><code>    gmake -f Makefile_MSIM.mk build_adp DUMP=1\n\n    gmake -f Makefile_MSIM.mk run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> <p>Or</p> <pre><code>    gmake -f Makefile_MSIM.mk build_run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> <p>There are some optimizations in the Table below for convenience if you want to bypass some commands for both Synopsys VCS and Questasim:</p> Command (Synopsys VCS) Command (Questasim) Details gmake -f Makefile_VCS.mk build_all DUMP=1 gmake -f Makefile_MSIM.mk build_all DUMP=1 compile IP + compile RTL gmake -f Makefile_VCS.mk build_run TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk build_run TESTNAME= DUMP=1 compile RTL + run test gmake -f Makefile_VCS.mk do_it_all TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk do_it_all TESTNAME= DUMP=1 compile IP, RTL and run test gmake -f Makefile_VCS.mk rundb TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk rundb TESTNAME= DUMP=1 run test in sim dir + over-writes content"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#67-uvm-regression-test","title":"6.7 UVM Regression Test","text":"<pre><code>cd $VERDIR/scripts\n\npython uvm_regress.py -l -n 8 -p adp -k top_pkg -s vcs -c none\n\nFor Regression in VCS with top/test package, execute the following command \n    python uvm_regress.py -l -n 8 -p adp -k top_pkg -s vcs -c none\n\nResults are created in a sim directory ($VERDIR/sim) with individual testcase log dir\n\nFor Regression in MSIM with top/test package, execute the following command \n    python uvm_regress.py -l -n 8 -p adp -k top_pkg -s msim -c none\n</code></pre> <p>Results are created in a sim directory ($VERDIR/sim_msim) with individual testcase log dir</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#68-uvm-waveform-and-transcript-analysis","title":"6.8 UVM Waveform and Transcript Analysis","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#synopsys-vcs_5","title":"Synopsys VCS","text":"<p>Running Synopsys VCS UVM tests will generate a ofs-f2000x-pl/verification/sim directory</p> <pre><code>\u2022 All build time logs are located at ofs-f2000x-pl/verification/sim\n\n\u2022 Each testcase will have separate directory inside sim ofs-f2000x-pl/verification/sim/&lt;test_case_name&gt;\n</code></pre> <p>There are two tracker or log files that are available: runsim.log and trans.log. </p> <p>runsim.log is the simulation log file generated from Synopsys VCS. The test sequence prints useful information for debugging purpose, such as the base address for each function or block. For HE-LB and HE-MEM, key information such as SRC_ADDR, DST_ADDR, NUM_LINES, mode, req_len etc is printed out as shown in Figure 5</p> <p></p> <p>Figure 5 runsim.log</p> <p>trans.log is generated from PCIe host VIP. trans.log records all transaction information coming in or going out of the VIP. Users can find traffic direction(DIR), TLP type, Tag, Address or BDF, 3 or 4 dword header of the TLP as shown in Figure 6</p> <p></p> <p>Figure 6 trans.log</p> <p>The waveform generated is named as \"inter.vpd\". To open the waveform, go to simulation result directory and run </p> <pre><code>    dve -full64 -vpd inter.vpd &amp;\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#questasim-tbd_5","title":"Questasim (TBD)","text":"<p>Running Questasim UVM tests will generate a ofs-f2000x-pl/verification/sim_msim directory</p> <pre><code>\u2022 All build time logs are at ofs-f2000x-pl/verification/sim_msim\n\n\u2022 Each testcase will have separate directory inside sim ofs-f2000x-pl/verification/sim_msim/&lt;test_case_name&gt;\n</code></pre> <p>There are two tracker or log files that are available: runsim.log and trans.log. </p> <p>runsim.log is the simulation log file generated from Questasim. The test sequence prints useful information for debugging purpose, such as the base address for each function or block. For HE-LB and HE-MEM, key information such as SRC_ADDR, DST_ADDR, NUM_LINES, mode, req_len etc is printed out as shown in Figure 7</p> <p></p> <p>Figure 7 runsim.log</p> <p>trans.log is generated from PCIe host VIP. trans.log records all transaction information coming in or going out of the VIP. Users can find traffic direction(DIR), TLP type, Tag, Address or BDF, 3 or 4 dword header of the TLP as shown in Figure 8</p> <p></p> <p>Figure 8 trans.log</p> <p>The waveform generated is named as \"vsim.wlf\". To open the waveform, go to simulation result directory and run </p> <pre><code>    vsim -view vsim.wlf &amp;\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#69-uvm-coverage-analysis","title":"6.9 UVM Coverage Analysis","text":"<p>The following command allows to run a single testcase with coverage enabled</p> <pre><code>    gmake -f Makefile_VCS.mk cmplib_adp &amp;&amp; gmake -f Makefile_VCS.mk build_adp DUMP=1 DEBUG=1 COV_FUNCTIONAL=1&amp;&amp; gmake -f Makefile_VCS.mk run TESTNAME=&lt;TESTCASE-NAME&gt; DUMP=1 DEBUG=1 COV_FUNCTIONAL=1 &amp;\n</code></pre> <p>The following command shows how to merge and generate the coverage report</p> <pre><code>    urg -dir &lt;$VERDIR/sim/simv.vdb&gt; &lt;$VERDIR/sim/regression.vdb&gt; -format both -dbname &lt;regression_database_name&gt;\n</code></pre> <p>This will generate both urgreport directory and .vdb file Multiple regression.vdb from different regressions can be merged with the same command. <pre><code>    e.g \"urg -dir &lt;path1_till_simv.vdb&gt; &lt;path1_till_regression.vdb&gt; &lt;path2_till_regression.vdb&gt; -report &lt;dir&gt; -format both -dbname &lt;dirname&gt;\"\n</code></pre> <p>The following commands shows how to launch DVE and check the coverage reports</p> <pre><code>To open DVE of a single regression or testcase, execute:\n\n    dve -full64 -cov -covdir simv.vdb regression.vdb &amp;\n\nTo open DVE of a merged regression test, execute:\n\n    dve -full64 -cov -covdir &lt;dirname.vdb&gt; &amp;\n</code></pre> <p></p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#7-csr-verification-using-uvm-ral","title":"7 CSR Verification using UVM RAL","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#71-overview","title":"7.1 Overview","text":"<p>The UVM Register Layer provides a standard base class library that enable users to implement the object-oriented model to access the DUT registers and memories. The UVM Register Layer is also referred to as UVM Register Abstraction Layer (UVM RAL). Design registers can be accessed independently of the physical bus interface. i.e. by calling read/write methods. This is shown in Figure 9 below.</p> <p></p> <p>Figure 9 RAL UVM Testbench</p> <p>The RAL register models for different CSR's mimics the design registers. All RAL files are located here.</p> <pre><code>    ofs-f2000x-pl/verification/testbench/ral\n</code></pre> <p>The RAL model is generated through the Synopsys RALGEN tool and is used for CSR verification.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#72-ral-integration","title":"7.2 RAL Integration","text":"<p>For UVM RAL model integration to the environment, adapters for each CSR is implemented and integrated into the Testbench Environment. It is used to convert the PCIe bus sequence items into uvm_reg_bus_op and vice versa. The CSR test cases pick up all the registers from the respective CSR blocks and perform a default value, wr/rd check on them. </p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#73-ral-model-generation","title":"7.3 RAL Model Generation","text":"<p>Steps for RAL model generation</p> <p>Excel(xls) file containing the registers is required. Make sure there are separate xls files for each CSR and the worksheet name must contain the name \"reg_fields\".  </p> <p>Excel sheet snapshot example below for EMIF_CSR.xls located at /ipss/mem/rtl/adp</p> <p></p> <pre><code>\u2022 Navigate to ofs-f2000x-pl/ofs-common/verification/common/scripts/ral\n\u2022 Copy the excel file (xls) to the above area\n\u2022 In the bash terminal run mk_ral.sh &lt;Excel sheet name without extension &gt; &lt;output *.sv file name without ral_  prepended &gt;\n\u2022 The above steps generate two ral *.sv files. File with _cov suffix is a coverage enabled ral model. \n\u2022 Copy *.sv files to ofs-f2000x-pl/verification/testbench/ral\n</code></pre> <p></p> <pre><code>\u2022 As an example to generate ral_ac_ce.sv from AC_CE_CSR.xls file the command is\n\n    mk_ral.sh AC_CE_CSR ac_ce\n</code></pre> <p>This generates two ral models (ral_ac_ce.sv and ral_ac_ce_cov.sv)</p> <p>To add new registers</p> <pre><code>\u2022 To create new registers, copy existing ones and modify the cells in the xls. Make sure the last line is also a copied blank line\n\u2022 Follow all the steps of RAL model generation\n</code></pre> <p>To Generate a RAL model when a new xls sheet is created for a new component</p> <pre><code>\u2022 Copy the relevant xls sheet to ofs-f2000x-pl/ofs-common/verification/common/scripts/ral\n\u2022 Follow all the steps of RAL model generation\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#74-top-level-verification-architecture-for-csr-testing","title":"7.4 Top Level Verification Architecture for CSR testing","text":""},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#741-testbench-components","title":"7.4.1 Testbench components","text":"<p>The testbench components for RAL are defined below</p> <pre><code>\u2022 ral_reg_iofs_* (uvm_reg) generated by the steps as mentioned in section 5.3\n</code></pre> <p>The uvm register class is written by extending the uvm_reg. A register represents a set of fields that are accessible as a single entity Each register contains any number of fields, which mirror the values of the corresponding elements in hardware</p> <pre><code>\u2022 ral_block_iofs_* (uvm_block) generated in the same register file\n</code></pre> <p>A register model is an instance of a register block, which may contain any number of registers, register files, memories, and other blocks</p> <pre><code>\u2022 ral_block_ofs (uvm_block) \u2013 Contains all the CSR block instantiations\n\u2022 Reg2vip_*_adapter (uvm_reg_adapter) \u2013 This class defines an interface for converting between uvm_reg_bus_op and a specific bus transaction. For each CSR a respective adapter is present\n</code></pre> <p>All the components are defined in ofs-f2000x-pl/ofs-common/verification/testbench</p> <p>Integration of components in testbench</p> <pre><code>\u2022 The RAL blocks and adapters for each CSR is instantiated in tb_env\n\u2022 The bar range for each CSR is also set in the tb_env\n</code></pre> <p>Sample Environment Integration snippets </p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#8-modifying-uvm-testbench","title":"8 Modifying UVM Testbench","text":"<p>The next sections describe what needs to be considered when modifying the UVM, adding a new interface to the testbench and creating a new UVM test for a customised OFS Accelerator platform.</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#81-modifying-uvm-environment-for-new-shell-variant","title":"8.1 Modifying UVM environment for new Shell Variant","text":"<p>OFS f2000x comprises a shell based on PCIe Gen4x16 and is named base_x16</p> <p>This base_x16 shell is described by an RTL file list, IP File lists and setup scripts to complete the build flow</p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#82-modifying-uvm-environment-and-setting-up-compile-and-run-flow","title":"8.2 Modifying UVM environment and setting up Compile and Run flow","text":"<p>All the variants can mostly reuse the existing UVM infrastructure to setup the build and run flow</p> <pre><code>\u2022 Create directory under $OFS_BUILD_ROOT new variant e.g ofs-n9000\n\u2022 Change directory to $OFS_BUILD_ROOT/ofs-n9000/verification/scripts\n\u2022 modify Makefile it to point to the new RTL, IP and script files.\n</code></pre> <p>Following these three steps above will enable the build and sim flow to run the existing UVM TB and tests with new IOFS n9000 variant.</p> <p>Adding a new interface requires signal connections in the testbench. An additional BFM or verification IP is needed to drive the new interface. The main testbench file tb_top.sv is found at the following location</p> <pre><code>    ofs-f2000x-pl/verification/testbench\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#83-adding-a-new-ral-directory","title":"8.3 Adding a new RAL directory","text":"<p>In case the design has many register changes and the user decides to generate all the new RAL models instead of reusing from existing base RAL models, the following steps will help to create and integrate a new RALDIR in the UVM environment.</p> <pre><code>\u2022 Generate the new RAL files in desired directory. Preferably under the \"ofs-f2000x-pl/verification/common/testbench\" \n\u2022 By default, the Makefile points to base FIM RAL so set the RALDIR path in the Makefile to the new generated RAL file directory\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#84-modifying-tbtest-files-for-new-variant","title":"8.4 Modifying TB/Test files for new Variant","text":"<p>Create a define for the new variant. e.g 'define FIM_NEW. If you are modifying common files then add new logic under this define so other projects will not get affected with variant specific change.</p> <p>If there are more changes, please create separate \"testbench\" and \"test\" folders under this new variant. </p> <pre><code>\u2022 Extend variant specific env file from base env file to add variant specific changes.\n\u2022 Create new test/seq lib files in \"tests\" folder.\n\u2022 Create new variant package, add new TB/Tests/Sequence lib files and also import the base package files.\n</code></pre> <p>If you are adding new files then make sure it's included in Makefile for the build+run flow. </p>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#85-uvm-pcie-drivers","title":"8.5 UVM PCIe Drivers","text":"<p>The \"svt_pcie_driver_app_transaction_base_sequence\" is part of Synopsys PCIe VIP library. You can find the sequence definition in the following two directories</p> <pre><code>\u2022 Navigate to \"$DESIGNWARE_HOME/vip/svt/pcie_svt/Q-2020.03/sverilog/src/vcs/svt_pcie_driver_app_transaction_sequence_collection.svp\" file. All the base and PCIe sequences are defined in this file.\n\n\u2022 When the OFS UVM build command is executed, it creates \"vip\" directory under \"$OFS_BUILD_ROOT/ofs-f2000x-pl/verification\". You can also find the same sequence file at \"$IOFS_BUILD_ROOT/ofs-f2000x/verification/vip/pcie_vip/src/sverilog/vcs/svt_pcie_driver_app_transaction_sequence_collection.sv\"\n</code></pre>"},{"location":"hw/f2000x/user_guides/ug_sim_ofs/ug_sim_ofs/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/n6001/","title":"Index","text":"<p>Repository folder for Agilex OFS PCIe Attach collateral targeting Intel FPGA SmartNIC N6001-PL.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/","title":"AFU Development Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#1-introduction","title":"1. Introduction","text":"<p>This document is a design guide for the creation of an Accelerator Functional Unit (AFU) using Open FPGA Stack (OFS) for Intel\u00ae Agilex\u00ae FPGAs PCIe Attach. The AFU concept consists of separating out the FPGA design development process into two parts, the construction of the foundational FPGA Interface Manager (FIM), and the development of the Acceleration Function Unit (AFU), as shown in the diagram below.</p> <p></p> <p>This diagram shows the separation of FPGA board interface development from the internal FPGA workload creation.  This separation starts with the FPGA Interface Manager (FIM) which consists of the external interfaces and board management functions.  The FIM is the base system layer and is typically provided by board vendors. The FIM interface is specific to a particular physical platform.  The AFU makes use of the external interfaces with user defined logic to perform a specific application.  By separating out the lengthy and complicated process of developing and integrating external interfaces for an FPGA into a board allows the AFU developer to focus on the needs of their workload.  OFS for Intel\u00ae Agilex\u00ae FPGAs PCIe Attach provides the following tools for rapid AFU development:</p> <ul> <li>Scripts for both compilation and simulation setup</li> <li>Optional Platform Interface Manager (PIM) which is a set of SystemVerilog shims and scripts for flexible FIM to AFU interfacing</li> <li>Acceleration Simulation Environment (ASE) which is a hardware/software co-simulation environment scripts for compilation and Acceleration</li> <li>Integration with Open Programmable Acceleration Engine (OPAE) SDK for rapid software development for your AFU application</li> </ul> <p>Please notice in the above block diagram that the AFU region consists of static and partial reconfiguration (PR) regions where the PR region can be dynamically reconfigured while the remaining FPGA design continues to function.  Creating AFU logic for the static region is described in FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.  This guide covers logic in the AFU Main region.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#11-document-organization","title":"1.1. Document Organization","text":"<p>This document is organized as follows:</p> <ul> <li>Description of design flow</li> <li>Interfaces and functionality provided in the Intel\u00ae FPGA SmartNIC N6001-PL FIM</li> <li>Downloading and installing OFS and OPAE SDK</li> <li>Building the FIM to support the AFU example</li> <li>Synthesize the AFU example</li> <li>Hardware/Software co-simulation using ASE</li> <li>Testing the AFU example in the Intel\u00ae FPGA SmartNIC N6001-PL card</li> <li>Debugging an AFU with Remote Signal Tap</li> </ul> <p>This guide provides theory followed by tutorial steps to solidify your AFU development knowledge.</p> <p>This guide uses the Intel\u00ae FPGA SmartNIC N6001-PL as the platform for all tutorial steps. Additionally, this guide and the tutorial steps can be used with other platforms.</p> <p>If you have worked with previous Intel Programmable Acceleration products, you will find out that OFS for Intel\u00ae Agilex\u00ae FPGAs PCIe Attach is similar. However, there are differences and you are advised to carefully read and follow the tutorial steps to fully understand the design tools and flow.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#12-prerequisite","title":"1.2. Prerequisite","text":"<p>This guide assumes you have the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows including the Intel\u00ae Quartus\u00ae Prime Pro Edition design flow</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in Intel\u00ae Quartus\u00ae Prime Pro Edition software, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on timing critical paths.</li> <li>RTL and coding practices to create synthesizable logic.</li> <li>Understanding of AXI and Avalon memory mapped and streaming interfaces.</li> <li>Simulation of complex RTL using industry standard simulators (Synopsys\u00ae VCS\u00ae or Siemens\u00ae QuestaSim\u00ae).</li> <li>Signal Tap Logic Analyzer tool in the Intel\u00ae Quartus\u00ae Prime Pro Edition software.</li> </ul> <p>You are strongly encouraged to review the FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#13-acceleration-functional-unit-afu-development-flow","title":"1.3. Acceleration Functional Unit (AFU) Development Flow","text":"<p>The AFU development flow is shown below: </p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#131-understanding-platform-capabilities","title":"1.3.1. Understanding Platform Capabilities","text":"<p>The block diagram of the N6001 Board is shown below:</p> <p></p> <p>The FIM provided with this release is shown below:</p> <p></p> <p>This release FIM provides the following features:</p> <ul> <li>Host interface<ul> <li>PCIe Gen4 x 16</li> <li>5 - PF, 4 - VF, AXI-S TLP packets</li> <li>MSI-X interrupts</li> <li>Logic to demonstrate simple PCIe loopback</li> </ul> </li> <li>Network interface<ul> <li>2 - QSFP28/56 cages</li> <li>2 x 4 x 25 GbE with exerciser logic demonstrating traffic generation/monitoring</li> </ul> </li> <li>External Memory - DDR4 - 2400<ul> <li>HPS - 1GB organized as 256 Mb x 32 with 256 Mb x 8 ECC</li> <li>Channel 0, 1  -  4 GB organized as 1 Gb x 32</li> <li>Channel 2, 3 - 4 GB organized as 1 Gb x 32 with 1 Gb x 8 ECC (ECC is not implemented in this release)</li> <li>Memory exerciser logic demonstrating external memory operation</li> </ul> </li> <li>Board Management<ul> <li>SPI interface</li> <li>FPGA configuration</li> <li>Example logic showing DFH operation</li> </ul> </li> <li>Remote Signal Tap logic</li> <li>Partial reconfiguration control logic</li> <li>ARM HPS subsystem with embedded Linux<ul> <li>HPS Copy engine</li> </ul> </li> </ul>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#132-high-level-data-flow","title":"1.3.2. High Level Data Flow","text":"<p>The OFS high level data flow is shown below:</p> <p></p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#133-considerations-for-pim-usage","title":"1.3.3. Considerations for PIM Usage","text":"<p>An early decision for your AFU development is determining if the PIM will be included in your design flow. The PIM is an abstraction layer consisting of a collection of SystemVerilog interfaces and shims to enable partial AFU portability across hardware despite variations in hardware topology and native interfaces. The PIM adds a level of logic between an accelerator (an AFU) and the platform (the FIM). The use of the PIM is optional for AFU development.  Please see Connecting an AFU to a Platform using PIM for details on using the PIM and its capabilities. Please see PIM Tutorial for a detailed tutorial on using the PIM. The learning steps in the tutorial can be run with the OFS for Agilex FIM package. The installation of the FIM package is described later in this guide.  </p> <p>If you choose not to use the PIM, please see Non-PIM AFU Development for instruction on using a traditional RTL design flow. Note, the example AFU provided in OFS does not include PIM.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#134-afu-interfaces-included-with-intel-fpga-smartnic-n6001-pl","title":"1.3.4. AFU Interfaces Included with Intel\u00ae FPGA SmartNIC N6001-PL","text":"<p>The figure below shows the interfaces available to the AFU in this architecture. It also shows the design hierarchy with module names from the fim (top.sv) to the PR region AFU (afu_main.sv). One of the main differences from the Stratix 10 PAC OFS architecture to this one is the presence of the static port gasket region (port_gasket.sv) that has components to facilitate the AFU and also consists of the PR region (afu_main.sv) via the PR slot. The Port Gasket contains all the PR specific modules and logic, e.g., PR slot reset/freeze control, user clock, remote STP etc. Architecturally, a Port Gasket can have multiple PR slots where user workload can be programmed into. However, only one PR slot is supported for OFS Release for Intel Agilex. Everything in the Port Gasket until the PR slot should be provided by the FIM developer. The task of the AFU developer is to add their desired application in the afu_main.sv module by stripping out unwanted logic and instantiating the target accelerator. As shown in the figure below, here are the interfaces connected to the AFU (highlighted in green) via the PCIe Attach FIM:</p> <ol> <li>AXI Streaming (AXI-S) interface to the Host via PCIe Gen4x16</li> <li>AXI Memory Mapped Channels (4) to the DDR4 EMIF interface</li> <li>AXI Streaming (AXI-S) interface to the HSSI 25 Gb Ethernet</li> </ol> <p></p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#2-set-up-afu-development-environment","title":"2. Set Up AFU Development Environment","text":"<p>This section covers:</p> <ul> <li>Setup of the development environment.</li> <li>Retrieving and installing OFS, OPAE SDK.</li> <li>Building the PCIe Attach FIM</li> <li>Generating a relocatable AFU build-tree or build-template from the PCIe Attach FIM.</li> <li>Compiling the host_chan_mmio example AFU for the PCIe Attach FIM.</li> </ul> <p>Additionally, this section includes steps to demonstrate loading and running the host_chan_mmio example AFU in an Intel\u00ae FPGA SmartNIC N6001-PL equipped Linux server.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#21-prepare-afu-development-environment","title":"2.1. Prepare AFU development environment","text":"<p>A typical development and hardware test environment consists of a development server or workstation with FPGA development tools installed and a separate server with the target OFS compatible FPGA PCIe card installed.  The typical usage and flow of data between these two servers is shown below:</p> <p></p> <p>Note: both development and hardware testing can be performed on the same server if desired.</p> <p>This guide uses Intel\u00ae FPGA SmartNIC N6001-PL as the target OFS compatible FPGA PCIe card for demonstration steps.  The Intel\u00ae FPGA SmartNIC N6001-PL must be fully installed following the Getting Started User Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs. If using a different OFS FPGA PCIe card, contact your supplier for instructions on how to install and operate user developed AFUs.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#22-installation-of-quartus-and-ofs","title":"2.2. Installation of Quartus and OFS","text":"<p>Building AFUs with OFS for Agilex requires the build machine to have at least 64 GB of RAM.  </p> <p>The following is a summary of the steps to set up for AFU development:</p> <ol> <li>Install Quartus Prime Pro Version 23.1  for Linux with Agilex device support.</li> <li>Make sure support tools are installed and meet version requirements.</li> <li>Clone and install the <code>ofs-n6001</code> repository.</li> <li>Review the files provided in the repository.</li> <li>Install the required Quartus patches.</li> <li>Build a relocatable AFU PR-able build-tree. This will be the base FIM for your AFUs.</li> </ol> <p>Note: For the Intel\u00ae FPGA SmartNIC N6001-PL platforms a relocatable AFU build-tree is not provided, so you will build it from the PCIe Attach FIM. The PCIe Attach FIM will then be loaded in your Intel\u00ae FPGA SmartNIC N6001-PL card to support your AFUs. If you are using different OFS compatible PCIe card, skip step 6 and follow the instructions provided by your supplier.</p> <ol> <li>Install Quartus Prime Pro Version 23.1 for Linux with Agilex device support. </li> </ol> <p>Intel Quartus Prime Pro Version 23.1  is the currently verified version of Quartus used for building the FIM and AFU images. The recommended Best Known Configuration (BKC) for development with OFS is RedHat\u00ae Enterprise Linux\u00ae (RHEL) 8.6 , which is the assumed operating system for this developer guide.</p> <ul> <li>Make sure to install the following linux packages to satisfy Quartus and OFS dependencies.</li> </ul> <p><pre><code>$ sudo dnf install -y gcc gcc-c++ make cmake libuuid-devel rpm-build autoconf automake bison boost boost-devel libxml2 libxml2-devel make ncurses grub2 bc csh flex glibc-locale-source libnsl ncurses-compat-libs </code></pre> - Apply the following configurations.</p> <pre><code>$ sudo localedef -f UTF-8 -i en_US en_US.UTF-8 $ sudo ln -s /usr/lib64/libncurses.so.6 /usr/lib64/libncurses.so.5 $ sudo ln -s /usr/bin/python3 /usr/bin/python\n</code></pre> <ul> <li>Download Quartus Prime Pro Version 23.1 from Quartus Pro Prime Download.</li> </ul> <ul> <li>After running the Quartus Prime Pro installer, set the PATH environment variable to make the utilities <code>quartus</code>, <code>jtagconfig</code>, and <code>quartus_pgm</code> discoverable. Edit your bashrc file <code>~/.bashrc</code> to add the following line:</li> </ul> <pre><code>$ export PATH=$PATH:&lt;Quartus install directory&gt;/quartus/bin\n</code></pre> <p>For example, if the Quartus install directory is /home/intelFPGA_pro/23.1, then:</p> <pre><code>$ export PATH=$PATH:/home/intelFPGA_pro/23.1/quartus/bin\n</code></pre> <ul> <li>Verify that Quartus is discoverable by opening a new shell:</li> </ul> <pre><code>$ which quartus\n\n/home/intelFPGA_pro/23.1/quartus/bin/quartus\n</code></pre> <ol> <li>Make sure support tools are installed and meet version requirements.</li> </ol> <p>The OFS provided Quartus build scripts require the following tools. Verify these are installed in your development environment.</p> Item Version Python 3.7.7 GCC 7.2.0 cmake 3.11.4 git and git-lfs 1.8.3.1 perl 5.8.8 <p>To install the <code>Git Large File Storage</code> extension execute the next commands</p> <pre><code>$ curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash\n$ sudo dnf install git-lfs\n$ git lfs install\n</code></pre> <ol> <li>Clone the <code>ofs-n6001</code> repository.</li> </ol> <p>The OFS FIM source code is included in the public GitHub OFS repository. Create a new directory to use as a clean starting point to store the retrieved files.  The following is a short description of each repository, followed by the git commands for cloning.  The instructions section uses the HTTPS git method for cloning repositories.</p> <ul> <li>Navigate to the location for storage of OFS source, create the top-level source directory and clone OFS repositories.</li> </ul> <pre><code>$ mkdir ofs_fim_build_root\n$ cd ofs_fim_build_root\n$ export OFS_BUILD_ROOT=$PWD\n$ git clone --branch ofs-2023.1-1 --recurse-submodules https://github.com/OFS/ofs-n6001.git\n\nCloning into 'ofs-n6001' ...\n    ...\n    ...\n    Resolving deltas  ..., done.\n\n$ cd $OFS_BUILD_ROOT/ofs-n6001\n</code></pre> <ol> <li>Review the files provided in the repository.</li> </ol> <p>Verify the following directories are present in <code>$OFS_BUILD_ROOT</code> directory.  </p> <pre><code>$ ls\neval_scripts  ipss  license  LICENSE.txt  ofs-common README.md  sim  src  syn  tools  verification\n</code></pre> <p>The directories are arranged as shown below:</p> <pre><code>.\n\u251c\u2500\u2500 eval_scripts           ** Support tools \n\u2502   \u251c\u2500\u2500 ofs_n6001_eval.sh\n\u2502   \u2514\u2500\u2500 README_ofs_n6001_eval.txt\n\u251c\u2500\u2500 ipss    **Directory ipss consists of Platform Designer subsystems used in FIM**\n\u2502   \u251c\u2500\u2500 hssi           **2 x 4 x 25 GbE HSSI subsystem** \n\u2502   \u251c\u2500\u2500 mem            **External Memory interface subsystem**\n\u2502   \u251c\u2500\u2500 pcie           **PCIe subsystem**\n\u2502   \u251c\u2500\u2500 pmci           **BMC PMCI subsystem**\n\u2502   \u251c\u2500\u2500 qsfp           **QSFP internal register access subsystem**\n\u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 ofs-common             **Common files**\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LICENSE.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 scripts\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 sim\n\u2502\u00a0\u00a0 \u2502   \u2502   \u2514\u2500\u2500 syn\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 fpga_family\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2502   \u251c\u2500\u2500 common\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 afu_top\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 copy_engine\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 flr\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 fme\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 fme_id_rom\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 he_hssi\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 he_lb\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 he_null\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 includes\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 interrupt\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 mem_tg\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 port_gasket\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 protocol_checker\n\u2502\u00a0\u00a0 \u2502   \u2502   \u251c\u2500\u2500 remote_stp\n\u2502\u00a0\u00a0 \u2502   \u2502   \u2514\u2500\u2500 st2mm\n\u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 fpga_family\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 sim                    **Unit level simulation files**\n\u2502   \u251c\u2500\u2500 bfm\n\u2502   \u251c\u2500\u2500 common\n\u2502   \u251c\u2500\u2500 readme.txt\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u2514\u2500\u2500 unit_test\n\u251c\u2500\u2500 src                    **Source RTL files**\n\u2502   \u251c\u2500\u2500 afu_top\n\u2502   \u251c\u2500\u2500 includes\n\u2502   \u251c\u2500\u2500 pd_qsys\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u2514\u2500\u2500 top\n\u251c\u2500\u2500 syn                    **Quartus compilation settings**\n\u2502   \u251c\u2500\u2500 common\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 setup\n\u2502   \u2514\u2500\u2500 syn_top\n\u251c\u2500\u2500 tools                  \n\u2502   \u2514\u2500\u2500 pfvf_config_tool  **Tools to configure the PF/VF Mux**\n\u2514\u2500\u2500 verification          **Verification**\n    \u251c\u2500\u2500 coverage\n    \u251c\u2500\u2500 README\n    \u251c\u2500\u2500 scripts\n    \u251c\u2500\u2500 testbench\n    \u251c\u2500\u2500 tests\n    \u251c\u2500\u2500 unit_tb   \n    \u2514\u2500\u2500 verifplan\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#23-installation-of-opae-sdk","title":"2.3. Installation of OPAE SDK","text":"<p>Follow the instructions in the Getting Started Guide: Open FPGA Stack for Intel\u00ae FPGA SmartNIC N6001-PL, section 4.0 OPAE Software Development Kit to build and install the required OPAE SDK for the Intel\u00ae FPGA SmartNIC N6001-PL.</p> <p>Working with the Intel\u00ae Intel\u00ae FPGA SmartNIC N6001-PL card requires opae-2.5.0-3. Follow the instructions in the Getting Started Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae FPGA SmartNIC N6001-PL section 4.0 OPAE Software Development Kit. However, just make sure to check out the cloned repository to tag 2.5.0-3 and branch release/2.5.0.</p> <pre><code>$ git checkout tags/2.5.0-3 -b release/2.5.0\n</code></pre> <p>Note: The tutorial steps provided in the next sections assume the OPAE SDK is installed in default system locations, under the directory, <code>/usr</code>. In most system configurations, this will allow the OS and tools to automatically locate the OPAE binaries, scripts, libraries and include files required for the compilation and simulation of the FIM and AFUs.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#24-download-the-basic-building-blocks-repositories","title":"2.4. Download the Basic Building Blocks repositories","text":"<p>The <code>ofs-platform-afu-bbb</code> repository contains the PIM files as well as example PIM-based AFUs that can be used for testing and demonstration purposes. Similarly, the platform-independent BBB repository, <code>intel-fpga-bbb</code>, contains infrastructure shims, PIM-based AFU sample designs, and tutorials for further testing OFS. This guide will use the <code>host_chan_mmio</code> AFU example in the ofs-platform-afu-bbb repository and the <code>hello_world</code> sample accompanying the intel-fpga-bbb repository to demonstrate how to synthesize, load, simulate, and test a PIM-based AFU using the Intel\u00ae FPGA SmartNIC N6001-PL card with the PCIe Attach FIM.</p> <p>Execute the next commands to clone the BBB repositories.</p> <pre><code>  # Clone the ofs-platform-afu-bbb repository.\n$ cd $OFS_BUILD_ROOT\n$ git clone https://github.com/OFS/ofs-platform-afu-bbb.git\n\n# Verify retrieval\n$ cd $OFS_BUILD_ROOT/ofs-platform-afu-bbb\n$ ls\nLICENSE  plat_if_develop  plat_if_release  plat_if_tests  README.md\n\n# Clone the intel-fpga-bbb repository.\n$ cd $OFS_BUILD_ROOT $ git clone https://github.com/OPAE/intel-fpga-bbb.git # Verify retrieval\n$ cd $OFS_BUILD_ROOT/intel-fpga-bbb\n$ ls\nAUTHORS  BBB_cci_gemm  BBB_cci_mpf  BBB_ccip_async  BBB_ccip_mux  BBB_mpf_vtp  cmake  CMakeLists.txt  CONTRIBUTING.md  COPYING  drivers  platform-ifc-mgr-compat  README.md  samples\n</code></pre> <p>The documentation in the ofs-platform-afu-bbb and intel-fpga-bbb repositories further address   - The PIM concept.   - The structure of the PIM-based AFU examples.   - How to generate a release and configure the PIM.   - How to connect an AFU to an FIM.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#25-compiling-the-ofs-fim-for-the-intel-fpga-smartnic-n6001-pl","title":"2.5. Compiling the OFS FIM for the Intel\u00ae FPGA SmartNIC N6001-PL","text":"<p>Before synthesizing an AFU, one must build the FIM that will support the AFU by facilitating the infrastructure to access the FPGA, board resources, and enabling communication with the host server. To synthesize an AFUs for this FIM a relocatable PR build-tree or build-template should be generated out of the FIM.</p> <p>OFS provides a build script with the following FPGA image creation options:</p> <ul> <li>Flat compile, which combines the FIM and AFU into one FPGA image that is loaded into the entire FPGA device as a static image.</li> <li>PR compile, which creates an FPGA image consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. Additional AFUs may be loaded into the dynamic region using partial reconfiguration.</li> </ul> <p>The build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested. Each build script step will take several hours to complete. Please note, building in Quartus GUI is not supported - you must build with the provided scripts.</p> <p>The following sections describe how to set up the environment and build the provided FIM with a relocatable build-tree supporting PR. You will use this relocatable PR build-tree for all example AFU simulation and compilation steps in this guide.</p> <p>Note: For instructions to compile FIMs available for the Intel\u00ae FPGA SmartNIC N6001-PL, refer to FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs. </p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#251-setting-up-the-required-environment-variables-to-build-the-fim","title":"2.5.1. Setting Up the Required Environment Variables to build the FIM","text":"<p>Set the required environment variables as shown below. These environment variables must be set prior to simulation or compilation tasks. Please, create a simple script to set these variables and save time going forward.</p> <pre><code>$ cd $OFS_BUILD_ROOT/ofs-n6001\n$ export OFS_ROOTDIR=$PWD\n# Note, OFS_ROOTDIR is the directory where you cloned the repo, e.g. /home/MyProject/ofs-n6001 *\n# Quartus Tools\n# Note, QUARTUS_HOME is your Quartus installation directory, e.g. $QUARTUS_HOME/bin contains Quartus executable.\n$ export WORKDIR=$OFS_ROOTDIR   $ export QUARTUS_HOME=&lt;user_path&gt;/intelFPGA_pro/23.1/quartus\n$ export QUARTUS_ROOTDIR=$QUARTUS_HOME\n$ export QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\n$ export QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR\n$ export IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\n$ export IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\n$ export QSYS_ROOTDIR=$QUARTUS_ROOTDIR/../qsys/bin\n$ export PATH=$QUARTUS_HOME/bin:$QUARTUS_HOME/qsys/bin:$QUARTUS_HOME/sopc_builder/bin/:$PATH\n# Synopsys Verification Tools\n$ export DESIGNWARE_HOME=&lt;user_path&gt;/synopsys/vip_common/vip_Q-2020.03A\n$ export PATH=$DESIGNWARE_HOME/bin:$PATH\n$ export VCS_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel\n$ export PATH=$VCS_HOME/bin:$PATH\n# OPAE SDK release\n$ export OPAE_SDK_REPO_BRANCH=release/2.5.0\n\n# The following environment variables are required for compiling the AFU examples. \n# Location to clone the ofs-platform-afu-bbb repository which contains PIM files and AFU examples.\n$ export OFS_PLATFORM_AFU_BBB=$OFS_BUILD_ROOT/ofs-platform-afu-bbb\n\n# Location to clone the intel-fpga-bbb repository which contain infrastructure shims, AFU samples and tutorials.\n$ export FPGA_BBB_CCI_SRC=$OFS_BUILD_ROOT/intel-fpga-bbb  # OPAE_PLATFORM_ROOT points to a release tree configured with the Platform Interface Manager (PIM).  \n$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_pr/pr_build_template\n\n# OPAE and MPF libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.  \n$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n# Header files from OPAE and MPF must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.\n$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#252-compiling-the-pcie-attach-fim","title":"2.5.2 Compiling the PCIe Attach FIM","text":"<p>The usage of the compile build script is shown below:</p> <pre><code>Usage: ./build_top.sh [-k] [-p] [--stage=&lt;action&gt;] &lt;build target&gt; [&lt;work dir name&gt;]\nBuild a FIM instance specified by &lt;build target&gt;. The target names\n  an FPGA architecture, board and configuration.\n\nThe FIM is built in &lt;work dir name&gt;. If not specified, the target is\n  ${OFS_ROOTDIR}/work.\n\nThe -k option preserves and rebuilds within an existing work tree\n  instead of overwriting it.\n\nWhen -p is set and the FIM supports partial reconfiguration, a PR\n  template tree is generated at the end of the FIM build. The PR template\n  tree is located in the top of the work directory but is relocatable\n  and uses only relative paths. See syn/common/scripts/generate_pr_release.sh\n  for details.\n\nThe --stage option controls which portion of the OFS build is run:\n    all     - Run all build stages (default).\n    setup   - Initialize a project in the work directory.\n    compile - Run the Quartus compilation flow on a project that was already\n              initialized with \"setup\".\n    finish  - Complete OFS post-compilation tasks, such as generating flash\n              images and, if -p is set, generating a release.\n\nThe -e option runs only Quartus analysis and elaboration. It completes the\n  \"setup\" stage, passes \"-end synthesis\" to the Quartus compilation flow\n  and exits without running the \"finish\" stage.\n</code></pre> <p>The next example command, builds the PCIe Attach FIM for the Intel\u00ae FPGA SmartNIC N6001-PL and generates the relocatable PR build-tree in <code>$OFS_ROOTDIR/work_pr/pr_build_template</code>.</p> <pre><code># Build the provided base example design:\n$ cd $OFS_ROOTDIR\n$ ofs-common/scripts/common/syn/build_top.sh -p n6001 work_pr\n\n... build takes ~5 hours to complete\nCompile work directory:     &lt;$OFS_ROOTDIR&gt;/work_pr/syn/syn_top\nCompile artifact directory: &lt;$OFS_ROOTDIR&gt;/work_pr/syn/syn_top/output_files\n\n***********************************\n***\n***        OFS_PROJECT: n6001\n***        Q_PROJECT:  ofs_top\n***        Q_REVISION: ofs_top\n***        SEED: XXX\n***        Build Complete\n***        Timing Passed!\n***\n***********************************\n</code></pre> <p>The build script copies the <code>ipss</code>, <code>sim</code>, <code>src</code> and <code>syn</code> directories to the specified work directory and then these copied files are used in the Quartus compilation process. The build reports and FPGA programming files are stored under <code>&lt;work_dir&gt;/syn/syn_top/output_files</code>. The directory <code>.../output_files/timing_report</code> contains the clocks reports, failing paths, and passing margin reports.</p> <p>The build script will run PACSign (if installed) and create unsigned FPGA programming files for user1 and user2 locations of the Intel\u00ae FPGA SmartNIC N6001-PL, FPGA flash. Please note if the Intel\u00ae FPGA SmartNIC N6001-PL has the root entry hash key loaded, then PACsign must be run to add the proper key to the FPGA binary file.</p> <p>The following table provides a detailed description of the generated *.bin output files.</p> File Description ofs_top[_hps].bin This is an intermediate, raw binary file. This intermediate raw binary file is produced by taking the Quartus generated .sof file, convertint it to.pof using quartus_pfg, then converting the .pof to.hexout using quartus_cpf, and finally converting the .hexout to.bin using objcopy. Depending on whether the FPGA design contains an HPS block, a different file will be generated. ofs_top.bin - Raw binary image of the FPGA generated if there is no HPS present in the design. ofs_top_hps.bin - Raw binary image of the FPGA generated if there is an HPS present in the design. ofs_top_page1_unsigned_user1.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User1 Image. This file is used to load the FPGA flash User1 Image using the fpgasupdate tool. ofs_top_page1_user1.bin This is an input file to PACSign to generate ofs_top_page1_unsigned_user1.bin. This file is created by taking the ofs_top_[hps].bin file and assigning the User1 or appending factory block information. ofs_top_page2_unsigned_user2.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User2 Image. This file is used to load the FPGA flash User2 Image using the fpgasupdate tool. ofs_top_page2_user2.bin This is an input file to PACSign to generate ofs_top_page2_unsigned_user2.bin. This file is created by taking the ofs_top_[hps].bin file and assigning the User2 or appending factory block information."},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#253-compiling-the-fim-in-preparation-for-designing-your-afu","title":"2.5.3. Compiling the FIM in preparation for designing your AFU","text":"<p>To test the functionality and capabilities of OFS, the default FIMs integrate the following traffic generators: hssi, memory, memory-traffic-generator, and loopback.</p> <p>To save the FPGA area, the default host exercisers in the FIM can be replaced by a lightweight \"he_null\" block during compile time. Specify which host exercisers to replace in the target_configuration option provided to the build_top.sh script.</p> <p>The options supported are <code>null_he_lb</code>, <code>null_he_hssi</code>, <code>null_he_mem</code> and <code>null_he_mem_tg</code>. All options or any subset of these are supported by the build_top.sh script. To compile a FIM for minimal area consumption execute the following command.</p> <pre><code>$ cd $OFS_ROOTDIR\n$ ofs-common/scripts/common/syn/build_top.sh -p n6001:null_he,null_he_hssi,null_he_mem,null_he_mem_tg work_null_he\n</code></pre> <p>A few important points to keep in mind.</p> <p>* he_null is a minimal block with registers that responds to PCIe MMIO request. MMIO responses are required to keep PCIe alive (the end-points enabled in PCIe-SS need to service downstream requests).</p> <p>* If an exerciser with other I/O connections such has he_mem or he_hssi is replaced, then those I/O ports are simply tied off.</p> <p>* Finer grain control is provided since the user may just turn off the exercisers in Static region to save area. </p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#254-load-the-fim-into-the-flash-of-the-intel-fpga-smartnic-n6001-pl","title":"2.5.4. Load the FIM into the Flash of the Intel\u00ae FPGA SmartNIC N6001-PL","text":"<p>In this step, you will load the previously compiled PCIe Attach FIM binary into the flash of the Intel\u00ae FPGA SmartNIC N6001-PL board. AFUs developed in this guide using the PCIe Attach FIM and the generated build-tree will be compatible with the image loaded on the Intel\u00ae FPGA SmartNIC N6001-PL board.</p> <pre><code>$ cd $OFS_ROOTDIR/work_pr/syn/syn_top/output_files\n$ sudo fpgasupdate ofs_top_page1_unsigned_user1.bin &lt;N6001 SKU2 PCIe b:d.f&gt;\n$ sudo fpgasupdate ofs_top_page2_unsigned_user2.bin &lt;N6001 SKU2 PCIe b:d.f&gt;\n$ sudo rsu fpga --page=user1 &lt;N6001 SKU2 PCIe b:d.f&gt;\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#3-compiling-an-afu","title":"3. Compiling an AFU","text":"<p>In this section, you will use the relocatable PR build-tree created in the previous steps from the FIM to compile an example PIM-based AFU. This section will be developed around the <code>host_chan_mmio</code> AFU example to showcase the synthesis of a PIM-based AFU.</p> <p>The <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio</code> is a simple example demonstrating both hardware and software access to an AFU. The <code>host_chan_mmio</code> example AFU consists of the following files.</p> <pre><code>host_chan_mmio\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 avalon\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_avalon.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 axi\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_axi.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 host_chan_mmio.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon1.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon2_512rw.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi1.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 test_mmio_axi2_512rw.txt\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 main.c\n    \u251c\u2500\u2500 Makefile\n</code></pre> <p>This example AFU contains examples using both Avalon and AXI interfaces. The hw directory contains the RTL to implement the hardware functionality using Avalon and AXI interfaces. However, this guide will use the AXI version of the <code>host_chan_mmio</code> AFU to go through the compilation steps. The sw directory of the AFU contains the source code of the host application that communicates with the actual AFU hardware.</p> <p>The build steps presented below demonstrate the ease in building and running an actual AFU on the Intel\u00ae FPGA SmartNIC N6001-PL board. To successfully execute the instructions in this section, you must have set up your development environment and compiled the PCIe Attach FIM as instructed in section 2 of this document.</p> <p>Additionally, you need to set the <code>OPAE_PLATFORM_ROOT</code> environment variable to the path where the PR build-tree was generated during the PCIe Attach FIM compilation through the [-p] switch.</p> <pre><code>$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_pr/pr_build_template\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#31-create-the-afu-synthesis-environment","title":"3.1. Create the AFU Synthesis Environment","text":"<p>Here, you will create the synthesis environment to build the <code>host_chan_mmio</code> example. For this task, the PIM flow provides the script <code>afu_synth_setup</code>. See how to use it below.</p> <pre><code>usage: afu_synth_setup [-h] -s SOURCES [-p PLATFORM] [-l LIB] [-f] dst\n\nGenerate a Quartus build environment for an AFU. A build environment is\ninstantiated from a release and then configured for the specified AFU. AFU\nsource files are specified in a text file that is parsed by rtl_src_config,\nwhich is part of the OPAE base environment.\n\npositional arguments:\n  dst                   Target directory path (directory must not exist).\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA platform name.\n  -l LIB, --lib LIB     FPGA platform release hw/lib directory. If not\n                        specified, the environment variables OPAE_FPGA_HW_LIB\n                        and then BBS_LIB_PATH are checked.\n  -f, --force           Overwrite target directory if it exists.\n</code></pre> <p>Execute <code>afu_synth_setup</code> as follows to create the synthesis environment for a <code>host_chan_mmio</code> AFU that fits the PCIe Attach FIM previously constructed.</p> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio\n\n$ mkdir -p $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n$ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt hardware\n\nNow, move into the synthesis environment ```hardware``` directory just created. From there, execute the ```afu_synth``` command. The successful completion of the command will produce the ```host_chan_mmio.gbs``` file under the synthesis environment directory, ```$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware```.\n\n$ cd hardware\n$ $OPAE_PLATFORM_ROOT/bin/afu_synth\nCompiling ofs_top ofs_pr_afu\nGenerating host_chan_mmio.gbs\n==================================\n...\n...\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\nDesign meets timing\n===========================================================================\n</code></pre> <p>The previous output indicates the successful compilation of the AFU and the compliance with the timing requirements. Analyze the reports generated in case the design does not meet timing. The timing reports are stored in the directory, <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware/build/syn/syn_top/output_files/timing_report</code>.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#32-loading-and-running-host_chan_mmio-example-afu","title":"3.2. Loading and Running host_chan_mmio example AFU","text":"<p>Once the compilation finishes successfully, load the new <code>host_chan_mmio.gbs</code> bitstream file into the partial reconfiguration region of the target Intel\u00ae FPGA SmartNIC N6001-PL board. Keep in mind, that the loaded image is dynamic - this image is not stored in flash and if the card is power cycled, then the PR region is re-loaded with the default AFU.</p> <p>To load the image, perform the following steps:</p> <pre><code> $ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware\n $ sudo fpgasupdate host_chan_mmio.gbs &lt;N6001 SKU2 PCIe b:d.f&gt;\n[sudo] password for &lt;&lt;Your username&gt;&gt;: [2022-04-15 20:22:18.85] [WARNING ] Update starting. Please do not interrupt.\n[2022-04-15 20:22:19.75] [INFO    ] Partial Reconfiguration OK\n[2022-04-15 20:22:19.75] [INFO    ] Total time: 0:00:00.90\n</code></pre> <p>Set up your board to work with the newly loaded AFU.</p> <pre><code># For the following example, the N6001 SKU2 PCIe b:d.f is assumed to be B1:00.0,\n# however this may be different in your system\n# Create the Virtual Functions (VFs):\n$ sudo pci_device b1:00.0 vf 3\n# Verify:\n$ lspci -s b1:00\n b1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\n b1:00.2 Processing accelerators: Intel Corporation Device bcce\n b1:00.3 Processing accelerators: Intel Corporation Device bcce\n b1:00.4 Processing accelerators: Intel Corporation Device bcce\n b1:00.5 Processing accelerators: Intel Corporation Device bccf\n b1:00.6 Processing accelerators: Intel Corporation Device bccf\n b1:00.7 Processing accelerators: Intel Corporation Device bccf\n\n# Bind VFs to VFIO driver.  Enter your username \n$ sudo opae.io init -d 0000:b1:00.1 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Unbinding (0x8086,0xbcce) at 0000:b1:00.1 from dfl-pci\n Binding (0x8086,0xbcce) at 0000:b1:00.1 to vfio-pci\n iommu group for (0x8086,0xbcce) at 0000:b1:00.1 is 183\nAssigning /dev/vfio/183 to ceg\n Changing permissions for /dev/vfio/183 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.2 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Unbinding (0x8086,0xbcce) at 0000:b1:00.2 from dfl-pci\n Binding (0x8086,0xbcce) at 0000:b1:00.2 to vfio-pci\n iommu group for (0x8086,0xbcce) at 0000:b1:00.2 is 184\nAssigning /dev/vfio/184 to ceg\n Changing permissions for /dev/vfio/184 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.3 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Unbinding (0x1af4,0x1000) at 0000:b1:00.3 from virtio-pci\n Binding (0x1af4,0x1000) at 0000:b1:00.3 to vfio-pci\n iommu group for (0x1af4,0x1000) at 0000:b1:00.3 is 185\nAssigning /dev/vfio/185 to ceg\n Changing permissions for /dev/vfio/185 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.4 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;: Unbinding (0x8086,0xbcce) at 0000:b1:00.4 from dfl-pci\n Binding (0x8086,0xbcce) at 0000:b1:00.4 to vfio-pci\n iommu group for (0x8086,0xbcce) at 0000:b1:00.4 is 186\nAssigning /dev/vfio/186 to ceg\n Changing permissions for /dev/vfio/186 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.5 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Binding (0x8086,0xbccf) at 0000:b1:00.5 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:b1:00.5 is 315\nAssigning /dev/vfio/315 to ceg\n Changing permissions for /dev/vfio/315 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.6 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Binding (0x8086,0xbccf) at 0000:b1:00.6 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:b1:00.6 is 316\nAssigning /dev/vfio/316 to ceg\n Changing permissions for /dev/vfio/316 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.7 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Binding (0x8086,0xbccf) at 0000:b1:00.7 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:b1:00.7 is 317\nAssigning /dev/vfio/317 to ceg\n Changing permissions for /dev/vfio/317 to rw-rw----\n\n# Verify the new AFU is loaded.  The host_chan_mmio AFU GUID is \"76d7ae9c-f66b-461f-816a-5428bcebdbc5\".\n$ fpgainfo port\n//****** PORT ******//\nObject Id                        : 0xEC00001\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0xE0B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.7\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : d15ab1ed-0000-0000-0210-000000000000\n//****** PORT ******//\nObject Id                        : 0xC0B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.6\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : d15ab1ed-0000-0000-0110-000000000000\n//****** PORT ******//\nObject Id                        : 0xA0B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.5\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 76d7ae9c-f66b-461f-816a-5428bcebdbc5\n//****** PORT ******//\nObject Id                        : 0x80B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.4\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 44bfc10d-b42a-44e5-bd42-57dc93ea7f91\n//****** PORT ******//\nObject Id                        : 0x6098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 1aae155c-acc5-4210-b9ab-efbd90b970c4\n//****** PORT ******//\nObject Id                        : 0x40B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n//****** PORT ******//\nObject Id                        : 0x20B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 3e7b60a0-df2d-4850-aa31-f54a3e403501\n</code></pre> <p>Now, navigate to the directory of the <code>host_chan_mmio</code> AFU containing the host application's source code, <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw</code>. Once there, compile the <code>host_chan_mmio</code> host application and execute it on the host server to excercise the functionality of the AFU.</p> <p>Note: If OPAE SDK libraries were not installed in the default systems directories under <code>/usr</code>, you need to set the <code>OPAE_LOC</code>, <code>LIBRARY_PATH</code>, and <code>LD_LIBRARY_PATH</code> environment variables to the custom locations where the OPAE SDK libraries were installed.</p> <pre><code># Move to the sw directory of the the host_chan_mmio AFU. This directory holds the source for the host application.\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw\n$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n$ make\n\n# Run the application\n$  ./host_chan_mmio\nAFU ID:  76d7ae9cf66b461f 816a5428bcebdbc5\nAFU MMIO interface: AXI Lite\nAFU MMIO read bus width: 64 bits\n512 bit MMIO write supported: yes\nAFU pClk frequency: 470 MHz\n\nTesting 32 bit MMIO reads:\n  PASS - 4 tests\n\nTesting 32 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 64 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 512 bit MMIO writes:\n  PASS\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#33-loading-and-running-the-hello_world-example-afu","title":"3.3. Loading and running the hello_world example AFU","text":"<p>The platform-independent examples AFU repository also provides some interesting example AFUs. In this section, you will compile and execute the PIM based <code>hello_world</code> AFU. The RTL of the <code>hello_world</code> AFU receives from the host application an address via memory mapped I/O (MMIO) write and generates a DMA write to the memory line at that address. The content written to memory is the string \"Hello world!\". The host application spins, waiting for the memory line to be updated. Once available, the software prints out the string.</p> <p>The <code>hello_world</code> example AFU consists of the following files. </p> <p><pre><code>hello_world\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 avalon\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_world_avalon.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 sources.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 axi\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_world_axi.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 sources.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 ccip\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 hello_world_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 sources.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 hello_world.json\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 hello_world\n    \u251c\u2500\u2500 hello_world.c\n    \u251c\u2500\u2500 Makefile\n    \u2514\u2500\u2500 obj\n        \u251c\u2500\u2500 afu_json_info.h\n        \u2514\u2500\u2500 hello_world.o\n</code></pre> The hw directory contains the RTL to implement the hardware functionality using CCIP, Avalon, and AXI interfaces. However, this guide will use the AXI version of the AFU to go through the compilation steps. The sw directory of the AFU contains the source code of the host application that communicates with the AFU hardware.</p> <p>The following instructions can be used to compile other AFU samples accompanying this repository.</p> <ol> <li>If not done already, download and clone the repository.</li> </ol> <pre><code>$ cd $OFS_BUILD_ROOT $ git clone https://github.com/OFS/examples-afu.git\n</code></pre> <ol> <li>Install the Basic Building Blocks include files and libraries. </li> </ol> <pre><code>$ cd $OFS_BUILD_ROOT/intel-fpga-bbb\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_INSTALL_PREFIX=/usr ..\n$ make\n$ sudo make install\n</code></pre> <p>By default, the Basic Building Blocks include and library files will be installed in <code>/usr/local</code>. You can change this installation prefix to another path by adding <code>-DCMAKE_INSTALL_PREFIX=&lt;&lt;custom_path&gt;&gt;</code> to the cmake command, as above. In most cases, you should choose the same prefix for both the OPAE SDK and the Basic Building Blocks.</p> <p>If OPAE and the Basic Building Blocks are installed to standard system directories, such as <code>/usr/</code> and <code>/usr/local</code>, they may already be found on C and C++ header and library search paths. Otherwise, their installation directories must be added explicitly.</p> <p>\u00a0\u00a0\u00a0\u00a0 * Header files from OPAE and BBB must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.</p> <p>\u00a0\u00a0\u00a0\u00a0 * OPAE and BBB libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.</p> <ol> <li>Make sure to set the next environment variables.</li> </ol> <pre><code># Set the FPGA_BBB_CCI_SRC variable to the full path of the intel-fpga-bbb directory created in the git clone step above.\n$ export FPGA_BBB_CCI_SRC=$OFS_BUILD_ROOT/intel-fpga-bbb  # Header files from OPAE and MPF must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.\n$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\n\n# OPAE and MPF libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.  \n$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n# OPAE_PLATFORM_ROOT points to a release tree that has been configured with the Platform Interface Manager (PIM).  \n$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_pr/pr_build_template\n</code></pre> <ol> <li> <p>Compile the <code>hello_word</code> sample AFU.  <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world\n$ afu_synth_setup --source hw/rtl/axi/sources.txt build\n$ cd build\n$ ${OPAE_PLATFORM_ROOT}/bin/afu_synth\nCompiling ofs_top ofs_pr_afu\nGenerating hello_world.gbs\n==================================\n.\n.\n.\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'hello_world.gbs'\nDesign meets timing\n===========================================================================\n</code></pre></p> </li> <li> <p>To test the AFU in actual hardware, load the <code>hello_world.gbs</code> to the Intel\u00ae FPGA SmartNIC N6001-PL card. For this step to be successful, the PCIe Attach FIM must have already been loaded to the Intel\u00ae FPGA SmartNIC N6001-PL card following the steps described in Section 2 of this document.</p> </li> </ol> <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/build\n$ sudo fpgasupdate hello_world.gbs &lt;N6001 SKU2 PCIe b:d.f&gt;\n  [sudo] password for &lt;&lt;Your username&gt;&gt;: [2022-04-15 20:22:18.85] [WARNING ] Update starting. Please do not interrupt.\n[2022-04-15 20:22:19.75] [INFO    ] Partial Reconfiguration OK\n[2022-04-15 20:22:19.75] [INFO    ] Total time: 0:00:00.90\n</code></pre> <p>Set up your Intel\u00ae FPGA SmartNIC N6001-PL board to work with the newly loaded <code>hello_world.gbs</code> file.</p> <pre><code> # For the following example, the Intel\u00ae FPGA SmartNIC N6001-PL PCIe b:d.f is assumed to be B1:00.0,\n# however this may be different in your system\n# Create the Virtual Functions (VFs):\n$ sudo pci_device b1:00.0 vf 3\n# Verify:\n$ lspci -s b1:00\n b1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\n b1:00.2 Processing accelerators: Intel Corporation Device bcce\n b1:00.3 Processing accelerators: Intel Corporation Device bcce\n b1:00.4 Processing accelerators: Intel Corporation Device bcce\n b1:00.5 Processing accelerators: Intel Corporation Device bccf\n b1:00.6 Processing accelerators: Intel Corporation Device bccf\n b1:00.7 Processing accelerators: Intel Corporation Device bccf\n\n# Bind VFs to VFIO driver.  Enter &lt;&lt;Your username&gt;&gt;\n$ sudo opae.io init -d 0000:b1:00.1 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Unbinding (0x8086,0xbcce) at 0000:b1:00.1 from dfl-pci\n Binding (0x8086,0xbcce) at 0000:b1:00.1 to vfio-pci\n iommu group for (0x8086,0xbcce) at 0000:b1:00.1 is 183\nAssigning /dev/vfio/183 to ceg\n Changing permissions for /dev/vfio/183 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.2 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Unbinding (0x8086,0xbcce) at 0000:b1:00.2 from dfl-pci\n Binding (0x8086,0xbcce) at 0000:b1:00.2 to vfio-pci\n iommu group for (0x8086,0xbcce) at 0000:b1:00.2 is 184\nAssigning /dev/vfio/184 to ceg\n Changing permissions for /dev/vfio/184 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.3 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Unbinding (0x8086,0xbcce)  at 0000:b1:00.3 from virtio-pci\n Binding (0x8086,0xbcce)  at 0000:b1:00.3 to vfio-pci\n iommu group for (0x8086,0xbcce)  at 0000:b1:00.3 is 185\nAssigning /dev/vfio/185 to ceg\n Changing permissions for /dev/vfio/185 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.4 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;: Unbinding (0x8086,0xbcce) at 0000:v1:00.4 from dfl-pci\n Binding (0x8086,0xbcce) at 0000:b1:00.4 to vfio-pci\n iommu group for (0x8086,0xbcce) at 0000:b1:00.4 is 186\nAssigning /dev/vfio/186 to ceg\n Changing permissions for /dev/vfio/186 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.5 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Binding (0x8086,0xbccf) at 0000:b1:00.5 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:b1:00.5 is 315\nAssigning /dev/vfio/315 to ceg\n Changing permissions for /dev/vfio/315 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.6 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Binding (0x8086,0xbccf) at 0000:b1:00.6 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:b1:00.6 is 316\nAssigning /dev/vfio/316 to ceg\n Changing permissions for /dev/vfio/316 to rw-rw----\n\n$ sudo opae.io init -d 0000:b1:00.7 &lt;&lt;Your username&gt;&gt;\n [sudo] password for &lt;&lt;Your username&gt;&gt;:\n Binding (0x8086,0xbccf) at 0000:b1:00.7 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:b1:00.7 is 317\nAssigning /dev/vfio/317 to ceg\n Changing permissions for /dev/vfio/317 to rw-rw----\n\n# &lt; Verify the new AFU is loaded.  The hello_world AFU GUID is \"c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\".\n$ fpgainfo port\n\n//****** PORT ******//\nObject Id                        : 0xEE00000\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0xE098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.7\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : d15ab1ed-0000-0000-0210-000000000000\n//****** PORT ******//\nObject Id                        : 0xC098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.6\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : d15ab1ed-0000-0000-0110-000000000000\n//****** PORT ******//\nObject Id                        : 0xA098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.5\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\n//****** PORT ******//\nObject Id                        : 0x8098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.4\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 44bfc10d-b42a-44e5-bd42-57dc93ea7f91\n//****** PORT ******//\nObject Id                        : 0x6098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 1aae155c-acc5-4210-b9ab-efbd90b970c4\n//****** PORT ******//\nObject Id                        : 0x4098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n//****** PORT ******//\nObject Id                        : 0x2098000000000000\nPCIe s:b:d.f                     : 0000:B1:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 3e7b60a0-df2d-4850-aa31-f54a3e403501\n</code></pre> <ol> <li>Compile and execute the host application of the <code>hello_world</code> AFU. You should see the application outputs the \"Hello world!\" message in the terminal.</li> </ol> <pre><code># Move to the sw directory of the hello_world AFU\n$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/sw\n\n$ make\n\n# Launch the host application\n$ ./hello_world\n  Hello world!\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#34-modify-the-afu-user-clocks-frequency","title":"3.4. Modify the AFU user clocks frequency","text":"<p>An OPAE compliant AFU specifies the frequency of the <code>uclk_usr</code> and <code>uclk_usr_div2</code> clocks through the JSON file for AFU configuration located under the <code>&lt;afu_example&gt;/hw/rtl</code> directory of an AFU design. For instance, the AFU configuration file of the <code>host_chan_mmio</code> example is <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/host_chan_mmio.json</code>.</p> <p>The AFU specifies the frequency for uClk_usr in its platform configuration file using the following key:value pairs:</p> <pre><code>  \"clock-frequency-high\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n  \"clock-frequency-low\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n</code></pre> <p>These <code>key:value</code> tuples are used to configure the PLL of the target platform that provides the user clocks through the AFU clocks interface. In addition, the specified frequency affects the timing closure process on the user clocks during AFU compilation. </p> <p>Setting the value field to a float number (e.g., 315.0 to specify 315 MHz) drives the AFU generation process to close timing within the bounds set by the low and high values and sets the AFU's JSON metadata to specify the user clock PLL  frequency values.</p> <p>The following example shows the JSON file of the <code>host_chan_mmio</code> to set the AFU uClk to 500 MHz and uClk_div2 to 250 MHz.</p> <pre><code>{\n   \"version\": 1,\n   \"afu-image\": {\n      \"power\": 0,\n      \"clock-frequency-high\": 500,\n      \"clock-frequency-low\": 250,\n      \"afu-top-interface\":\n         {\n            \"class\": \"ofs_plat_afu\"\n         },\n      \"accelerator-clusters\":\n         [\n            {\n               \"name\": \"host_chan_mmio\",\n               \"total-contexts\": 1,\n               \"accelerator-type-uuid\": \"76d7ae9c-f66b-461f-816a-5428bcebdbc5\"\n            }\n         ]\n   }\n}\n</code></pre> <p>Save the changes to <code>host_chan_mmio.json</code> file, then execute the <code>afu_synth_setup</code> script to create a new copy of the AFU files with the modified user clock settigns.</p> <p><pre><code>$ mkdir -p $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n$ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_n6001_afu_clks\n\nCopying build from /home/&lt;user_area&gt;/ofs-n6001/work_pr/pr_build_template/hw/lib/build...\nConfiguring Quartus build directory: build_n6001_afu_clks/build\nLoading platform database: /home/&lt;user_area&gt;/ofs-n6001/work_pr/pr_build_template/hw/lib/platform/platform_db/ofs_agilex_adp.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting platform/platform_afu_top_config.vh\nWriting platform/platform_if_addenda.qsf\nWriting ../hw/afu_json_info.vh\n</code></pre> Compile the <code>host_chan_mmio</code> AFU with the new frequency values.</p> <pre><code>$ cd build_n6001_afu_clks\n$ $OPAE_PLATFORM_ROOT/bin/afu_synth\n</code></pre> <p>During the compilation phase, you will observe the Timing Analyzer uses the specified user clock frequency values as the target to close timing.</p> <p></p> <p></p> <p>AFU developers must ensure the AFU hardware design meets timing. The compilation of an AFU that fails timing shows a message similar to the following.</p> <pre><code>.\n.\n.\n\nWrote host_chan_mmio.gbs\n\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\n*** Design does not meet timing\n  *** See build/syn/syn_top/output_files/timing_report\n\n===========================================================================\n</code></pre> <p>The previous output indicates the location of the timing reports for the AFU designer to identify the failing paths and perform the necessary design changes. Next, is a listing of the timing report files from a <code>host_chan_mmio</code> AFU that fails to meet timing after modifying the user clock frequency values.</p> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/build_n6001_afu_clks\n$ ls build/syn/syn_top/output_files/timing_report\n\nclocks.rpt  clocks.sta.fail.summary  clocks.sta.pass.summary\n</code></pre> <p>Warning: AFU developers must inform software developers of the maximum operating frequency (Fmax) of the user clocks to avoid any unexpected behavior of the accelerator and potentially of the overall system.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#4-simulating-an-afu-using-ase","title":"4. Simulating an AFU using ASE","text":"<p>The Application Simulation Environment (ASE) is a hardware/software co-simulation environment for your AFU. See diagram below illustrating ASE operation:</p> <p></p> <p>ASE uses the simulator Direct Programming Interface (DPI) to provide HW/SW connectivity.  The PCIe connection to the AFU under testing is emulated with a transactional model.</p> <p>The following list describes ASE operation:</p> <ul> <li>Attempts to replicate the transactions that will be seen in real system.</li> <li>Provides a memory model to AFU, so illegal memory accesses can be identified early.</li> <li>Not a cache simulator.</li> <li>Does not guarantee synthesizability or timing closure.</li> <li>Does not model system latency.</li> <li>No administrator privileges are needed to run ASE.  All code is user level.</li> </ul> <p>The remainder of this section is a tutorial providing the steps on how to run ASE with either Synopsys\u00ae VCS\u00ae or Siemens\u00ae QuestaSim\u00ae using an example AFU and the AFU build tree previously created in this guide.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#41-set-up-steps-to-run-ase","title":"4.1. Set Up Steps to Run ASE","text":"<p>In this section you will set up your server to support ASE by independently downloading and installing OPAE SDK and ASE. Then, set up the required environment variables.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#411-install-opae-sdk","title":"4.1.1. Install OPAE SDK","text":"<p>Follow the instructions documented in the Getting Started Guide: Open FPGA Stack for Intel\u00ae Agilex\u00ae FPGAs Targeting the Intel\u00ae FPGA SmartNIC N6001-PL, section 4.0 OPAE Software Development Kit to build and install the required OPAE SDK for the Intel\u00ae FPGA SmartNIC N6001-PL card.</p> <p>The N6001 SKU2 card requires 2.5.0-3. Follow the instructions provided in the Getting Started Guide: Open FPGA Stack for Intel\u00ae Agilex\u00ae FPGAs Targeting the Intel\u00ae FPGA SmartNIC N6001-PL, section 4.0 OPAE Software Development Kit. However, just make sure to check out the cloned repository to tag 2.5.0-3 and branch release/2.5.0.</p> <pre><code>$ git checkout tags/2.5.0-3 -b release/2.5.0\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#412-install-ase-tools","title":"4.1.2 Install ASE Tools","text":"<p>ASE is an RTL simulator for OPAE-based AFUs. The simulator emulates both the OPAE SDK software user space API and the AFU RTL interface. The majority of the FIM as well as devices such as PCIe and local memory are emulated with simple functional models.</p> <p>ASE must be installed separatedly from the OPAE SDK. However, the recommendation is to install it in the same target directory as OPAE SDK.</p> <ol> <li> <p>If not done already, set the environment variables as described in section, Set Up AFU Development Environment.</p> </li> <li> <p>Clone the <code>opae-sim</code> repository.</p> </li> </ol> <p><pre><code>$ cd $OFS_BUILD_ROOT\n$ git clone https://github.com/OFS/opae-sim.git\n$ cd opae-sim  $ git checkout tags/2.5.0-2 -b release/2.5.0\n</code></pre> 2. Building ASE requires the include file <code>mock/opae_std.h</code>. If the OPAE SDK was installed under the default system directories, the C_INCLUDE_PATH variable must be set as follows. </p> <pre><code>$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.5.0-3.el8.x86_64/tests/framework\n</code></pre> <ol> <li>Create a build directory and build ASE to be installed under the default system directories along with OPAE SDK.</li> </ol> <pre><code>$ mkdir build\n$ cd build\n$ cmake  -DCMAKE_INSTALL_PREFIX=/usr ..\n$ make\n</code></pre> <p>Optionally, if the desire is to install ASE binaries in a different location to the system's default, provide the path to CMAKE through the CMAKE_INSTALL_PREFIX switch, as follows.</p> <pre><code>$ cmake -DCMAKE_INSTALL_PREFIX=&lt;&lt;/some/arbitrary/path&gt;&gt; ..  </code></pre> <ol> <li>Install ASE binaries and libraries under the system directory <code>/usr</code>.</li> </ol> <pre><code>$ sudo make install  </code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#413-setup-required-ase-environment-variables","title":"4.1.3. Setup Required ASE Environment Variables","text":"<p>The values set to the following environment variables assume the OPAE SDK and ASE were installed in the default system directories below <code>/usr</code>. Setup these variables in the shell where ASE will be executed. You may wish to add these variables to the script you created to facilitate configuring your environment.</p> <pre><code>$ cd /usr/bin\n$ export PATH=$PWD:$PATH\n$ cd /usr/lib/python*/site-packages\n$ export PYTHONPATH=$PWD\n$ cd /usr/lib\n$ export LIBRARY_PATH=$PWD\n$ cd /usr/lib64\n$ export LD_LIBRARY_PATH=$PWD\n$ cd $OFS_BUILD_ROOT/ofs-platform-afu-bbb\n$ export OFS_PLATFORM_AFU_BBB=$PWD\n$ cd $OFS_ROOTDIR/work_pr/pr_build_template\n$ export OPAE_PLATFORM_ROOT=$PWD\n## For VCS, set the following:\n$ export VCS_HOME=&lt;Set the path to VCS installation directory&gt;\n$ export PATH=$VCS_HOME/bin:$PATH\n## For QuestaSIM, set the following:\n$ export MTI_HOME=&lt;path to Modelsim installation directory&gt;\n$ export PATH=$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$PATH\n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#42-simulating-the-host_chan_mmio-afu","title":"4.2. Simulating the host_chan_mmio AFU","text":"<p>The <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio</code> is a simple example demonstrating both hardware and software access to an AFU. The <code>host_chan_mmio</code> example AFU consists of the following files:</p> <pre><code>host_chan_mmio\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 avalon\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_avalon.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_avalon_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_avalon.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 axi\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_axi.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi512.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 ofs_plat_afu_axi_from_ccip.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 ofs_plat_afu_axi.sv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 host_chan_mmio.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon1.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_avalon2_512rw.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi0_from_ccip.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 test_mmio_axi1.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 test_mmio_axi2_512rw.txt\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 main.c\n    \u251c\u2500\u2500 Makefile\n</code></pre> <p>This example AFU contains examples using both Avalon and AXI interface buses. This guide will use the AXI version of the <code>host_chan_mmio</code> AFU.</p> <p>ASE uses client-server application architecture to deliver hardware/software co-simulation.  You require one shell for the hardware based simulation and another shell where the software application is running. The hardware is started first with a simulation compilation and simulator startup script, once the simulator has loaded the design, it will wait until the software process starts. Once the software process starts, the simulator proceeds.  Transaction logging and waveform capture is performed.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#421-set-up-and-run-the-hw-simulation-process","title":"4.2.1 Set Up and Run the HW Simulation Process","text":"<p>You will run the <code>afu_sim_setup</code> script to create the scripts for running the ASE environment.  The <code>afu_sim_setup</code> script has the following usage:</p> <pre><code>usage: afu_sim_setup [-h] -s SOURCES [-p PLATFORM] [-t {VCS,QUESTA,MODELSIM}]\n                     [-f] [--ase-mode ASE_MODE] [--ase-verbose]\n                     dst\n\nGenerate an ASE simulation environment for an AFU. An ASE environment is\ninstantiated from the OPAE installation and then configured for the specified\nAFU. AFU source files are specified in a text file that is parsed by\nrtl_src_config, which is also part of the OPAE base environment.\n\npositional arguments:\n  dst                   Target directory path (directory must not exist).\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA Platform to simulate.\n  -t {VCS,QUESTA,MODELSIM}, --tool {VCS,QUESTA,MODELSIM}\n                        Default simulator.\n  -f, --force           Overwrite target directory if it exists.\n  --ase-mode ASE_MODE   ASE execution mode (default, mode 3, exits on\n                        completion). See ase.cfg in the target directory.\n  --ase-verbose         When set, ASE prints each CCI-P transaction to the\n                        command line. Transactions are always logged to\n                        work/ccip_transactions.tsv, even when not set. This\n                        switch sets ENABLE_CL_VIEW in ase.cfg.\n</code></pre> <p>Run <code>afu_sim_setup</code> to create the ASE simulation environment for the <code>host_chan_mmio</code> example AFU. The <code>'-t VCS'</code> option indicates to prepare the ASE simulation environment for Synopsys\u00ae VCS\u00ae.</p> <pre><code>$ mkdir -p $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n\n$ afu_sim_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt -t VCS simulation\n\nCopying ASE from /opae-sdk/install-opae-sdk/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\n\nTool Brand: VCS\nLoading platform database: /ofs-n6001/work_pr/build_tree/hw/lib/platform/platform_db/ofs_agilex_adp.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> creates the ASE scripts in the directory <code>host_chan_mmio_sim</code> where the <code>afu_sim_setup</code> script was run.  Start the simulator as shown below:</p> <pre><code>$ cd simulation\n$ make\n$ make sim\n</code></pre> <p>This process launches the AFU hardware simulator. Before moving to the next section, pay attention to the simulator output highlighted in the image below.</p> <p></p> <p>The simulation artifacts are stored in host_chan_mmio/work and consist of:</p> <pre><code>log_ase_events.tsv\nlog_ofs_plat_host_chan.tsv \nlog_ofs_plat_local_mem.tsv \nlog_pf_vf_mux_A.tsv \nlog_pf_vf_mux_B.tsv \n</code></pre>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#422-set-up-and-run-the-sw-process","title":"4.2.2 Set Up and Run the SW Process","text":"<p>Open an additional shell to build and run the host application that communicates with the actual AFU hardware. Set up the same environment variable you have set up in the shell you have been working on until this point. </p> <p>Additionally, as indicated by the hardware simulator output that is currently executing in the \"simulator shell\", copy and paste the line <code>\"export ASE_WORKDIR=...\"</code>, into the new \"software shell\". See the last image of the previous section.</p> <p><pre><code>$ export ASE_WORKDIR= &lt;&lt;as directed in HW simulation shell&gt;&gt;\n</code></pre> Then, go to the sw directory of the <code>host_chan_mmio</code> AFU example to compile the host application.</p> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw  $ make\n\nafu_json_mgr json-info --afu-json=../hw/rtl/host_chan_mmio.json --c-hdr=obj/afu_json_info.h\nWriting obj/afu_json_info.h\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c main.c -o obj/main.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c test_host_chan_mmio.c -o obj/test_host_chan_mmio.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/connect.c -o obj/connect.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/csr_mgr.c -o obj/csr_mgr.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/hash32.c -o obj/hash32.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/test_data.c -o obj/test_data.o\ncc -o host_chan_mmio obj/main.o obj/test_host_chan_mmio.o obj/connect.o obj/csr_mgr.o obj/hash32.o obj/test_data.o  -z noexecstack -z relro -z now -pie -luuid -lopae-c-ase\n</code></pre> <p>Now, launch the host application to exercise the AFU hardware running on the simulator shell. The next image shows the AFU hardware simulation process on the left side shell. The right hand shell shows the host application's output of a successful simulation.</p> <pre><code>$ with_ase ./host_chan_mmio\n  [APP]  Initializing simulation session ...\nRunning in ASE mode\nAFU ID:  76d7ae9cf66b461f 816a5428bcebdbc5\nAFU MMIO interface: AXI Lite\nAFU MMIO read bus width: 64 bits\n512 bit MMIO write supported: yes\nAFU pClk frequency: 470 MHz\n\nTesting 32 bit MMIO reads:\n  PASS - 4 tests\n\nTesting 32 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 64 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 512 bit MMIO writes:\n  PASS\n  [APP]  Deinitializing simulation session\n  [APP]         Took 1,003,771,568 nsec\n  [APP]  Session ended\n</code></pre> <p> </p> <p>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</p> <pre><code>$ make wave\n</code></pre> <p>This brings up the VCS\u00ae simulator GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the afu instance located under, <code>ase_top | ase_top_plat | ofs_plat_afu | afu</code> , as shown below.</p> <p></p> <p>Right click on the <code>afu (afu)</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p></p> <p></p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#43-simulating-the-hello_world-afu","title":"4.3 Simulating the hello_world AFU","text":"<p>In this section you will quickly simulate the PIM-based <code>hello_world</code> sample AFU accompanying the examples-afu repository.</p> <ol> <li> <p>Set the environment variables as described in section 4.1. Set Up Steps to Run ASE.</p> </li> <li> <p>Prepare an RTL simulation environment for the AXI version of the <code>hello_world</code> AFU.</p> <p>Simulation with ASE requires two software processes, one to simulate the AFU RTL and the other to run the host software that excercises the AFU. To construct an RTL simulation environment under the directory <code>simulation</code>, execute the following.</p> <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world\n$ mkdir -p $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/n6001\n$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/n6001\n$ afu_sim_setup -s $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/hw/rtl/axi/sources.txt simulation\n\nCopying ASE from /usr/local/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\nTool Brand: VCS\nLoading platform database: /home/&lt;user_area&gt;/ofs-n6001/work_pr/pr_build_template/hw/lib/platform/platform_db/ofs_agilex_adp.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> script constructs an ASE environment in the <code>hello_world_sim</code> subdirectory. If the command fails, confirm that the path to the afu_sim_setup is on your PATH environment variable (in the OPAE SDK bin directory) and that your Python version is at least 2.7.</p> </li> <li> <p>Build and execute the AFU RTL simulator.</p> <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/n6001/simulation\n$ make\n$ make sim  </code></pre> <p>The previous commands will build and run the Synopsys\u00ae VCS\u00ae RTL simulator, which prints a message saying it is ready for simulation. The simulation process also prints a message instructing you to set the ASE_WORKDIR environment variable in a second shell.</p> </li> <li> <p>Open a second shell where you will build and execute the host software. In this new \"software shell\", set up the environment variables you have set up so far in the \"hardware simulation\" shell.</p> </li> <li> <p>Also, set the ASE_WORKDIR environment variable following the instructions given in the \"hardware simulation\" shell.</p> <p><pre><code>$ export ASE_WORKDIR=$OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/n6001/simulation/work\n</code></pre> 6. Then, move to the sw directory of the <code>hello_world</code> AFU sample to build the host software.</p> <pre><code>$ cd $OFS_BUILD_ROOT/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/sw\n$ make      </code></pre> </li> <li> <p>Run the <code>hello_world</code> host application to resume the work of the RTL simulation. The host software process and the RTL simulation execute in lockstep. If successful, you should see the Hello world! output.</p> <pre><code>$ with_ase ./hello_world\n\n[APP]  Initializing simulation session ...\nHello world!\n  [APP]  Deinitializing simulation session\n  [APP]         Took 43,978,424 nsec\n  [APP]  Session ended\n</code></pre> <p>The image below shows the simulation of the AFU hardware and the execution of the host application side-by-side.</p> <p></p> </li> </ol> <p></p> <p></p> <ol> <li> <p>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</p> <pre><code>make wave\n</code></pre> <p>This brings up the DVE GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the afu instance located under, <code>ase_top | ase_top_plat | ofs_plat_afu | hello_afu</code>, as shown below.</p> </li> </ol> <p></p> <p>Right click on the <code>hello_afu</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p></p> <p></p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#5-adding-remote-signal-tap-logic-analyzer-to-debug-the-afu","title":"5. Adding Remote Signal Tap Logic Analyzer to debug the AFU","text":"<p>The OPAE SDK provides a remote Signal Tap facility. It also supports the following in system debug tools included with the Intel Quartus Prime Pro Edition:</p> <ul> <li>In-system Sources and Probes</li> <li>In-system Memory Content Editor</li> <li>Signal Probe</li> <li>System Console</li> </ul> <p>This section is a short guide on adding remote Signal Tap instances to an AFU for in system debugging. You can follow the steps in the following sections, in order of execution to create an instrumented AFU. The <code>host_chan_mmio</code> AFU is used in this guide as the target AFU to be instrumented.</p> <p>You need a basic understanding of Signal Tap. Please see the Signal Tap Logic Analyzer: Introduction &amp; Getting Started Web Based Training for more information.</p> <p>You will run with a Signal Tap GUI running locally on the server with the Intel\u00ae FPGA SmartNIC N6001-PL as shown below:</p> <p></p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#51-adding-rstp-to-the-host_chan_mmio-afu","title":"5.1. Adding RSTP to the host_chan_mmio AFU","text":"<p>RSTP is added to an AFU by:</p> <ol> <li>Defining signals to be instrumented in Signal Tap.  This creates a new *.stp file.</li> <li>Modify ofs_top.qpf to include the new *.stp file</li> <li>Modify ofs_top.qsf</li> <li>Modify ofs_pr_afu.qsf </li> <li>Run $OPAE_PLATFORM_ROOT/bin/afu_synth to build the PR-able image containing the RSTP instance</li> </ol> <p>You can use these detailed steps to add Signal Tap to your AFU.</p> <ol> <li> <p>Set path to platform root directory and create the host_chan_mmio AFU Quartus project for adding Signal Tap.: <pre><code>$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_pr/pr_build_template\n\n # we will now build a new host_chahnel_mmio example based on Signal Tap\n\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio\n\n$ mkdir -p $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001\n$ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt hardware_stp\n</code></pre></p> </li> <li> <p>Navigate to host_chan_mmio AFU Quartus project and open the project using Quartus GUI.</p> </li> </ol> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware_stp/build/syn/syn_top\n\n$ quartus ofs_top.qpf &amp;\n</code></pre> <ol> <li> <p>Once the project is loaded in Quartus, run Analysis &amp; Synthesis <code>Processing | Start | Start Analysis &amp; Synthesis</code>. When complete, review the project hierarchy as shown in the Project Navigator.  This example will add Signal Tap probe points to the AFU region.  Reviewing the code will give insight into the function of this block.  You can bring up the code in the Project Navigator by expanding afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu, right click, select Locacte Node - Locate in Design File as shown below. </p> </li> <li> <p>Bring up Signal Tap to create the *.stp file.  In the Quartus GUI, go to Tools - Signal Tap Logic Analyzer.  In the New File from Template pop up, click <code>Create</code> to accept the default template.  The Signal Tap Logic Analyzer window comes up.</p> </li> <li> <p>Set up the clock for the Signal Tap logic instance by clicking <code>...</code> button as shown below: </p> </li> <li> <p>The Node Finder comes up and you will click <code>...</code> as shown below to bring up the hierarchy navigator: </p> </li> <li> <p>In the Select Hierarchy Level, navigate to top - afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu and click <code>Ok</code>.</p> </li> <li> <p>Enter <code>*clk*</code> in the <code>Named:</code> box and click <code>Search</code>.  This brings up matching terms.  Click <code>mmio64_if.clk</code> and <code>&gt;</code>.  Verify your Node Finder is as shown below and then click <code>Ok</code>: </p> </li> <li> <p>Double click the <code>Double-click to add nodes</code> and once again, click <code>...</code> and navigate to top - afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu and click <code>Ok</code>.  Enter <code>mmio64_reg*</code> and click <code>Search</code>. Then click <code>&gt;&gt;</code> to add these signals to the STP instance as shown below:    </p> <p>Then click <code>Insert</code> and <code>Close</code>.</p> </li> <li> <p>Save the newly created STP by clicking <code>File - Save As</code> and in the save as navigate to $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware_stp/build/syn/syn_top and save the STP file as <code>host_chan_mmio.stp</code> as shown below:</p> </li> </ol> <p></p> <p>Select <code>Yes</code> when asked to add host_chan_mmio.stp to current project.  Close Signal Tap window.</p> <ol> <li>Edit <code>ofs_top.qsf</code> to add host_chan_mmio.stp file and enable STP.  Open $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware_stp/build/syn/syn_top/ofs_top.qsf in an editor and add the lines shown below:</li> </ol> <pre><code>set_global_assignment -name ENABLE_SIGNALTAP ON\nset_global_assignment -name USE_SIGNALTAP_FILE host_chan_mmio.stp\nset_global_assignment -name SIGNALTAP_FILE host_chan_mmio.stp\n</code></pre> <p>Save the ofs_top.qsf.</p> <ol> <li>Edit <code>ofs_pr_afu.qsf</code> to add host_chan_mmio.stp file and enable STP.  Open $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware_stp/build/syn/syn_top/ofs_pr_afu.qsf in an editor and add the lines shown below:</li> </ol> <p><pre><code>set_global_assignment -name VERILOG_MACRO \"INCLUDE_REMOTE_STP\"\nset_global_assignment -name ENABLE_SIGNALTAP ON\nset_global_assignment -name USE_SIGNALTAP_FILE host_chan_mmio.stp\nset_global_assignment -name SIGNALTAP_FILE host_chan_mmio.stp\n</code></pre> Save the ofs_pr_afu.qsf and close Quartus.</p> <ol> <li>The host_chan_mmio AFU Quartus project is ready to be built.  In your original build shell enter the following commands:</li> </ol> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware_stp\n$ $OPAE_PLATFORM_ROOT/bin/afu_synth\n\n...\n...\nWrote host_chan_mmio.gbs\n\n===========================================================================\n PR AFU compilation complete\n AFU gbs file is 'host_chan_mmio.gbs'\n  Design meets timing\n===========================================================================\n</code></pre> <ol> <li>Once compilation completes, the new host_chan_mmio.gbs file that contains the Signal Tap instance can be loaded.</li> </ol> <pre><code> # For the following example, the N6001 SKU2 PCIe b:d.f is assumed to be b1:00.0,\n # however this may be different in your system\n\n# Load FIM\n$ sudo fpgasupdate $OFS_ROOTDIR/work_pr/syn/syn_top/output_files/ofs_top_page1_unsigned_user1.bin b1:00.0\n$ sudo fpgasupdate $OFS_ROOTDIR/work_pr/syn/syn_top/output_files/ofs_top_page2_unsigned_user2.bin b1:00.0\n$ sudo rsu bmcimg b1:00.0\n\n# Load AFU\n$ sudo fpgasupdate host_chan_mmio.gbs b1:00.0\n[2021-12-04 07:16:59,101] [WARNING ] Update starting. Please do not interrupt.\n[2021-12-04 07:16:59,740] [INFO    ] \nPartial Reconfiguration OK\n</code></pre> <ol> <li>Use the OPAE SDK mmlink tool to create a TCP/IP connection to your Intel Agilex card under test.  The mmlink command has the following format:</li> </ol> <pre><code>Usage:\nmmlink\n&lt;Segment&gt;             --segment=&lt;SEGMENT NUMBER&gt;\n&lt;Bus&gt;                 --bus=&lt;BUS NUMBER&gt;           OR  -B &lt;BUS NUMBER&gt;\n&lt;Device&gt;              --device=&lt;DEVICE NUMBER&gt;     OR  -D &lt;DEVICE NUMBER&gt;\n&lt;Function&gt;            --function=&lt;FUNCTION NUMBER&gt; OR  -F &lt;FUNCTION NUMBER&gt;\n&lt;Socket-id&gt;           --socket-id=&lt;SOCKET NUMBER&gt;  OR  -S &lt;SOCKET NUMBER&gt;\n&lt;TCP PORT&gt;            --port=&lt;PORT&gt;                OR  -P &lt;PORT&gt;\n&lt;IP ADDRESS&gt;          --ip=&lt;IP ADDRESS&gt;            OR  -I &lt;IP ADDRESS&gt;\n&lt;Version&gt;             -v,--version Print version and exit\n</code></pre> <p>Enter the command below to create a connection using port 3333:</p> <pre><code>$ sudo mmlink -P 3333 -B 0xb1\n\n ------- Command line Input START ----\n\n Socket-id             : -1\n Port                  : 3333\n IP address            : 0.0.0.0\n ------- Command line Input END   ----\n\nPORT Resource found.\nServer socket is listening on port: 3333\n</code></pre> <p>Leave this shell open with the mmlink connection.</p> <ol> <li>In this step you will open a new shell and enable JTAG over protocol.  You must have Quartus 23.1 Programmer loaded on the N6001 server for local debugging.</li> </ol> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/127.0.0.1:3333/0\n\n# Verify connectivity with jtagconfig --debug\n\n$ jtagconfig --debug\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/127.0.0.1:3333/0]\n   (JTAG Server Version 21.4.0 Build 67 12/06/2021 SC Pro Edition)\n    020D10DD   VTAP10 (IR=10)\n    Design hash    86099113E08364C07CC4\n    + Node 00406E00  Virtual JTAG #0\n\n  Captured DR after reset = (020D10DD) [32]\n  Captured IR after reset = (155) [10]\n  Captured Bypass after reset = (0) [1]\n  Captured Bypass chain = (0) [1]\n</code></pre> <ol> <li>Start Quartus Signal Tap GUI, connect to target, load stp file by navigating to $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware_stp/build/syn/syn_top. The Quartus Signal Tap must be the same version of Quartus used to compile the host_chan_mmio.gbs. Quartus Prime Pro Version 23.1 is used in the steps below:</li> </ol> <pre><code>$ cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/n6001/hardware_stp/build/syn/syn_top\n$ quartus_stpw host_chan_mmio.stp &amp;\n</code></pre> <p>This command brings up Signal Tap GUI. Connect to the Signal Tap over protocol by selecting the <code>Hardware</code> button on the right side of the GUI and click the \"Please Select\" pull down as shown below:</p> <p></p> <p>JTAG over protocol selected:</p> <p></p> <p>This connection process will take approximately 2-3 minutes for the Signal Tap instance to indicate \"Ready to acquire\".</p> <ol> <li> <p>Set the trigger condition for a rising edge on signal <code>arvalid</code> signal.</p> </li> <li> <p>In the Signal Tap window, enable acquisition by pressing key <code>F5</code>, the Signal Tap GUI will indicate \"Acquisition in progress\". Create and bind the VFs, then run the host_chan_mmio application following 3.2. Loading and Running host_chan_mmio example AFU, and observe that the Signal Tap instance has triggered. You should see signals being captured in the Signaltap GUI.</p> </li> </ol> <p>See captured image below:</p> <p></p> <p>To end your Signal Tap session, close the Signal Tap GUI, then in the mmlink shell, enter <code>ctrl c</code> to kill the mmlink process. To remove the JTAG over protocol connection: <pre><code># This is assuming the JTAG over protocol is instance '1', as shown during jtagconfig --debug\n$ jtagconfig --remove 1\n</code></pre></p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#6-how-to-modify-the-pfvf-mux-configuration","title":"6. How to modify the PF/VF MUX configuration","text":"<p>For information on how to modify the PF/VF mapping for your own design, refer to the FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</p>"},{"location":"hw/n6001/dev_guides/afu_dev/ug_dev_afu_ofs_n6001/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/","title":"FPGA Interface Manager Developer Guide for Intel Agilex PCIe Attach: Open FPGA Stack","text":"<p>Last updated: August 01, 2023 </p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#1-introduction","title":"1. Introduction","text":""},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#11-about-this-document","title":"1.1. About This Document","text":"<p>Open FPGA Stack (OFS) addresses the demand for FPGA acceleration boards and workloads by providing a powerful methodology for the rapid development of FPGA Acceleration systems.  This methodology addresses the challenges and responsibilities of the board, platform, and workload developers by providing a complete FPGA project consisting of RTL and simulation code, build scripts, and software.  This provided FPGA project can be rapidly customized to meet new market requirements.</p> <p>OFS separates the FPGA design into two areas: FPGA Interface Manager (FIM) and workload (or Acceleration Function Unit) as shown in the figure below:</p> <p></p> <p>As can be seen in this diagram, the OFS FPGA structure has a natural separation into two distinct areas: </p> <ul> <li>FPGA Interface Manager (FIM or sometimes called the \"the shell\") containing:<ul> <li>FPGA external interfaces and IP cores (e.g. Ethernet, DDR-4, PCIe, etc)</li> <li>PLLs/resets</li> <li>FPGA - Board management infrastructure</li> <li>Interface to Acceleration Function Unit (AFU)</li> </ul> </li> <li>Acceleration Function Unit (\"the workload\")<ul> <li>Uses the FIM interfaces to perform useful work inside the FPGA</li> <li>Contains logic supporting partial reconfiguration</li> <li>Remote Signal Tap core for remote debugging of workload</li> </ul> </li> </ul> <p>This document serves as a design guide for FPGA developers, system architects, and hardware developers using OFS as a starting point for the creation of an FPGA Interface Manager (FIM) for a custom FPGA acceleration board.   </p> <p>This guide is organized as follows: </p> <ul> <li>Introduction</li> <li>Top Level Block Diagram description<ul> <li>Control and data flow</li> </ul> </li> <li>Description of Sub-systems<ul> <li>Command/status registers (CSR) and software interface</li> <li>Clocking, resets, and interfaces</li> <li>E-Tile Ethernet Subsystem</li> <li>Externally attached memory</li> </ul> </li> <li>High-level development flow description<ul> <li>Installation of OFS RTL and development packages</li> <li>Compiling FIM</li> <li>Simulation  </li> </ul> </li> <li>Demonstration steps illustrating how to change areas of the design</li> <li>Debugging</li> </ul> <p>This document uses the Intel\u00ae FPGA SmartNIC N6001-PL as the main example platform to illustrate key points and demonstrate how to extend the capabilities provided in OFS.  The demonstration steps serve as a tutorial for the development of your OFS knowledge.  </p> <p>This document covers OFS architecture lightly. For more details on the OFS architecture, please see Open FPGA Stack Technical Reference Manual for Intel Agilex FPGA PCIe Attach</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#12-release-capabilities","title":"1.2. Release Capabilities","text":"<p>The OFS FIM BASE  Agilex supports the following features.</p> FIM Intel Platform Intel\u00ae FPGA PAC D5005 PCIe Configuration Gen4 x16 SR-IOV support Yes - (5-PF, 4-VF) AXI ST datapath 512b @ 400MHz Transceiver Subsystem Configuration 2x4x25G <p>The FIM also integrates:</p> <ul> <li>Exercisers demonstrating PCIe, external memory, and E-Tile Ethernet Subsystem</li> <li>FME CSR</li> <li>Remote Signal Tap</li> <li>Partial Reconfiguration</li> </ul> <p>The Host exercisers are provided for the quick evaluation of the FIM and can be leveraged for the verification of the platform's functionality and capabilities.  The host exercisers can be removed by the designer to release FPGA real estate to accommodate a new workload functions. To compile the FIM without host exercisers go to [Compiling the FIM in preparation for designing your AFU].</p> <p>OFS is extensible to meet the needs of a broad set of customer applications.  The general use cases listed below are examples where the OFS base design is easily extended to build a custom FIM:</p> <ol> <li>Use OFSdesign example as-is     - Porting the code to another platform that is identical to OFSreference platform changing targeted FPGA device and pinout     - Change I/O assignments without changing design</li> <li>Update the configuration of peripheral IP in OFSdesign example, not affecting FIM architecture     - External memory settings     - E-Tile Ethernet Subsystem analog settings</li> <li>Remove/update peripheral feature in OFSdesign example, not affecting FIM architecture     - External memory speed/width change     - Change 25G Ethernet to 10G or 100G Ethernet IP     - Change number of VFs supported</li> <li>Add new features as an extension to OFSdesign example, not affecting the FIM architecture     - Add/remove external memory interface to the design     - Add/remove user clocks for the AFU     - Add/remove IP to the design with connection to the AFU</li> </ol>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#13-prerequisites","title":"1.3. Prerequisites","text":""},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#131-tutorial-prerequisites","title":"1.3.1. Tutorial Prerequisites","text":"<p>To run the FPGA compilation steps covered in this guide, requires the following:</p> <ol> <li>Workstation or server with a Quartus Prime Pro Version 23.1  installed on a Quartus supported Linux distribution.  See [Operating System Support].  The Linux distribution known to work with this version of OFS is {{ env.N6001_HOST_OS_L }}. Note, Windows is not supported.</li> <li>Compilation targeting Intel\u00ae Agilex\u00ae FPGA devices requires a minimum of 64 GB of RAM.</li> <li>Simulation of lower level functionality (not chip level) is supported by Synopsys\u00ae VCS and Mentor Graphics\u00ae QuestaSim SystemVerilog simulators.</li> <li>Simulation of chip level requires Synopsys\u00ae VCS and VIP</li> </ol> <p>To test FPGA image files on hardware, this version of OFS only targets Intel\u00ae FPGA SmartNIC N6001-PL. You may modify the build scripts and pin files to target different boards with Intel\u00ae Agilex\u00ae FPGA devices.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#132-base-knowledge-and-skills-prerequisites","title":"1.3.2. Base Knowledge and Skills Prerequisites","text":"<p>The OFS is an advanced application of FPGA technology. This guide assumes you have the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows using Intel\u00ae Quartus\u00ae Prime Pro Edition.</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in Intel\u00ae Quartus\u00ae Prime Pro Edition, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on timing critical paths.</li> <li>RTL (System Verilog) and codingOFS hardware GitHub site practices to create synthesized logic.</li> <li>RTL simulation tools.</li> <li>Intel\u00ae Quartus\u00ae Prime Pro Edition Signal Tap Logic Analyzer tool software.</li> </ul>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#133-development-environment","title":"1.3.3. Development Environment","text":"<p>To run the tutorial steps in this guide requires this development environment:</p> Component Version FPGA Platform Intel\u00ae FPGA SmartNIC N6001-PL, release notes OPAE SDK 2.5.0-3 Kernel Drivers ofs-2023.1-6.1-1 OneAPI-ASP ofs-2023.1-1 OFS FIM Source Code for Intel\u00ae FPGA SmartNIC N6001-PL ofs-2023.1-1 OFS Platform AFU BBB ofs-2023.1-1 Intel Quartus Prime Pro Edition Design Software* Quartus Prime Pro Version 23.1 for Linux Operating System RedHat\u00ae Enterprise Linux\u00ae (RHEL) 8.6"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#2-top-level-description","title":"2. Top Level Description","text":"<p>The FIM targets operation in the Intel\u00ae FPGA SmartNIC N6001-PL, the block diagram is shown below.  </p> <p> </p> <p>The Intel\u00ae FPGA SmartNIC N6001-PL FPGA I/O banking is shown below: </p> <p></p> <p>The key Intel\u00ae FPGA SmartNIC N6001-PL FPGA interfaces are:</p> <ul> <li>Host interface      - PCIe Gen4 x 16</li> <li>Network interface<ul> <li>2 - QSFP28/56 cages</li> <li>Current FIM supports 8 x 25 GbE, other interfaces can be created  </li> </ul> </li> <li>External Memory - DDR4 - 2400<ul> <li>HPS - 1GB organized as 256 Mb x 32 with 256 Mb x 8 ECC</li> <li>Channel 0, 1  -  4 GB organized as 1 Gb x 32</li> <li>Channel 2, 3 - 4 GB organized as 1 Gb x 32 with 1 Gb x 8 ECC (ECC is not implemented this release) </li> </ul> </li> <li>Board Management<ul> <li>SPI interface</li> <li>FPGA configuration</li> </ul> </li> </ul>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#21-top-level-fpga","title":"2.1. Top Level FPGA","text":"<p>The internal FPGA architecture is shown below:</p> <p></p> <p>The following Platform Designer IP subsystems are used to implement the following:</p> <ul> <li>690604: PCIe Subsystem IP User Guide (Note: you must login to myIntel and request entitled access)</li> <li>686148: Memory Subsystem IP User Guide (Note: you must login to myIntel and request entitled access)</li> <li>773413: Ethernet Subsystem Intel FPGA IP</li> </ul> <p>Documentation on the above Platform Designer IP subsystems is available by request to your Intel support team.</p> <p>To access these Intel FPGA IP Subsystem documents. Please go here and search for the previous ID numbers.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#22-fim-fpga-resource-usage","title":"2.2. FIM FPGA Resource Usage","text":"<p>The provided design includes both required board management and control functions as well as optional interface exerciser logic that both creates transactions and validates operation.  These exceriser modules include:</p> <ul> <li>HE_MEM - this module creates external memory transactions to the DDR4 memmory and then verifies the responses.</li> <li>HE_MEM-TG -The Memory Traffic Generator (TG) AFU provides a way for users to characterize local memory channel bandwidth with a variety of traffic configuration features including request burst size, read/write interleave count, address offset, address strobe, and data pattern.</li> <li>HE_HSSI - this module creates ethernet transactions to the E-Tile Ethernet Subsystem and then verifies the responses. The FIM uses a small portion of the available FPGA resources.  The table below shows resource usage for a base FIM built with 2 channels of external memory, a small AFU instantiated that has host CSR read/write, external memory test and Ethernet test functionality.</li> </ul> <p>Note: The host exerciser modules allow you to evaluate the FIM in hardware and are removed when you begin development. </p> <p>The resource usage for a Base FIM :</p> Entity Name ALMs needed ALM Utilization % M20Ks M20K Utilization % top 181,018.30 37.15 784 11.03 afu_top 104,994.20 21.55 287 4.04 pcie_wrapper 36,565.00 7.51 195 2.74 hssi_wrapper 20,132.10 4.13 173 2.43 mem_ss_top 9,092.80 1.87 76 1.07 pmci_wrapper 4,269.30 0.88 26 0.37 alt_sld_fab_0 2,726.90 0.56 13 0.18 bpf 1,364.60 0.28 0 0.00 qsfp_top 620.10 0.13 4 0.06 fme_top 615.30 0.13 6 0.08 qsfp_top 614.00 0.13 4 0.06 rst_ctrl 17.90 0.00 0 0.00 sys_pll 0.50 0.00 0 0.00 hps_ss 0.00 0.00 0 0.00 <p>The resource usage for a Minimal FIM :</p> Entity Name ALMs needed ALM Utilization % M20Ks M20K Utilization % top 91,564.60 18.79 422 5.94 pcie_wrapper 36,736.80 7.54 193 2.71 afu_top 35,113.70 7.21 112 1.58 mem_ss_top 9,429.30 1.94 76 1.07 pmci_wrapper 4,390.50 0.90 26 0.37 alt_sld_fab_0 1,771.20 0.36 9 0.13 bpf 1,349.20 0.28 0 0.00 dummy_csr 703.40 0.14 0 0.00 dummy_csr 701.00 0.14 0 0.00 dummy_csr 694.10 0.14 0 0.00 fme_top 657.20 0.13 6 0.08 rst_ctrl 16.50 0.00 0 0.00 sys_pll 0.50 0.00 0 0.00 hps_ss 0.00 0.00 0 0.00"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#3-description-of-sub-systems","title":"3. Description of Sub-Systems","text":""},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#31-host-control-and-data-flow","title":"3.1. Host Control and Data Flow","text":"<p>The host control and data flow is shown in the diagram below:</p> <p></p> <p>The control and data paths are composed of the following:</p> <ul> <li>Host Interface Adapter (PCIe)</li> <li>Low Performance Peripherals<ul> <li>Slow speed peripherals (JTAG, I2C, Smbus, etc)</li> <li>Management peripherals (FME)</li> </ul> </li> </ul> <ul> <li>High Performance Peripherals<ul> <li>Memory peripherals</li> <li>Acceleration Function peripherals (eg. AFUs)</li> <li>HPS Peripheral</li> </ul> </li> </ul> <ul> <li>Fabrics<ul> <li>Peripheral Fabric (multi drop)</li> <li>AFU Streaming fabric (point to point)</li> </ul> </li> </ul> <p>Peripherals are connected to one another using AXI in either:</p> <ul> <li>Via the peripheral fabric (AXI4-Lite, multi drop)</li> <li>Via the AFU streaming fabric (AXI-S, point to point)</li> </ul> <p>Peripherals are presented to software as:</p> <ul> <li>OFS managed peripherals that implement DFH CSR structure.  </li> <li>Native driver managed peripherals (i.e. Exposed via an independent PF, VF)</li> </ul> <p>The peripherals connected to the peripheral fabric are primarily Intel OPAE managed resources, whereas the peripherals connected to the AFU are \u201cprimarily\u201d managed by native OS drivers. The word \u201cprimarily\u201d is used since the AFU is not mandated to expose all its peripherals to Intel OPAE. </p> <p>OFS uses a defined set of CSRs to expose the functionality of the FPGA to the host software.  These registers are described in FIM MMIO Regions</p> <p>If you make changes to the FIM that affect the software operation, then OFS provides a mechanism to communicate that information to the proper software driver that works with your new hardware.  The FPGA Device Feature List (DFL) Framework Overview is followed to provide compatibility with OPAE software.  Please see FPGA Device Feature List (DFL) Framework Overview for a description of DFL operation from the driver perspective.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#4-high-level-development-flow","title":"4. High Level Development Flow","text":"<p>The OFS provides a framework of FPGA synthesizable code, simulation environment, and synthesis/simulation scripts.  FIM designers can take the provided code and scripts and modify existing code or add new code to meet your specific product requirements.</p> <p>FIM development for a new acceleration card consists of the following steps:</p> <ol> <li>Installation of OFS and familiarization with scripts and source code </li> <li>Development of high level block diagram with your specific functionality <ol> <li>Determination of requirements and key performance metrics</li> <li>Selection of IP cores</li> <li>Selection of FPGA device</li> <li>Software memory map</li> </ol> </li> <li>Selection and implementation of FIM Physical interfaces including: <ol> <li>External clock sources and creation of internal PLL clocks</li> <li>General I/O</li> <li>Transceivers</li> <li>External memories</li> <li>FPGA programming methodology</li> </ol> </li> <li>Device physical implementation <ol> <li>FPGA device pin assignment</li> <li>Inclusion of logic lock regions</li> <li>Creation of timing constraints</li> <li>Create Quartus FIM test project and validate: <ol> <li>Placement</li> <li>Timing constraints</li> <li>Build script process</li> <li>Review test FIM FPGA resource usage</li> </ol> </li> </ol> </li> <li>Select FIM to AFU interfaces and development of PIM </li> <li>FIM design implementation <ol> <li>RTL coding</li> <li>IP instantiation</li> <li>Development of test AFU to validate FIM</li> <li>Unit and device level simulation</li> <li>Timing constraints and build scripts</li> <li>Timing closure and build validation</li> </ol> </li> <li>Creation of FIM documentation to support AFU development and synthesis </li> <li>Software Device Feature discovery </li> <li>Hardware/software integration, validation and debugging </li> <li>High volume production preparation </li> </ol> <p>The FIM developer works closely with the hardware design of the target board, software development and system validation.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#41-installation-of-ofs","title":"4.1. Installation of OFS","text":"<p>In this section you set up a development machine for compiling the OFS FIM. These steps are separate from the setup for a deployment machine where the FPGA acceleration card is installed.  Typically, FPGA development and deployment work is performed on separate machines, however, both development and deployment can be performed on the same server if desired.  Please see the [Getting Started Guide: Open FPGA Stack] for instructions on installing software for deployment of your FPGA FIM, AFU and software application on a server.  </p> <p>Building the OFS FIM requires the build machine to have at least 64 GB of RAM.  </p> <p>The following is a summary of the steps to set up for FIM development:</p> <ol> <li>Install Quartus Prime Pro Version 23.1 Linux with Intel\u00ae Agilex\u00ae FPGA device support</li> <li>Make sure support tools are installed and meet version requirements</li> <li>Clone the <code>ofs-n6001</code> repository</li> <li>Install required Quartus patches which are included in the cloned <code>ofs-n6001</code> repository</li> <li>Review the files provided in the repo</li> <li>Test installation by building the FIM</li> </ol> <p>Intel Quartus Prime Pro Version 23.1 is the currently verified version of Quartus used for building the FIM and AFU images.  Porting to newer versions of Quartus may be performed by developers, however, you will need to verify operation. The recommended Best Known Configuration (BKC) for development of the OFS FIM is RedHat\u00ae Enterprise Linux\u00ae (RHEL) 8.6, which is the assumed operating system for this developer guide. </p> <p>Prior to installing Quartus, perform the following steps to satisfy the required dependencies.</p> <p><pre><code>  $ sudo dnf install -y gcc gcc-c++ make cmake libuuid-devel rpm-build autoconf automake bison boost boost-devel libxml2 libxml2-devel make ncurses grub2 bc csh flex glibc-locale-source libnsl ncurses-compat-libs </code></pre> - Apply the following configurations.</p> <pre><code>  $ sudo localedef -f UTF-8 -i en_US en_US.UTF-8 $ sudo ln -s /usr/lib64/libncurses.so.6 /usr/lib64/libncurses.so.5 $ sudo ln -s /usr/bin/python3 /usr/bin/python\n</code></pre> <ol> <li> <p>Download [Quartus Prime Pro Linux version].</p> </li> <li> <p>After running the Quartus Prime Pro installer, set the PATH environment variable to make utilities <code>quartus</code>, <code>jtagconfig</code>, and <code>quartus_pgm</code> discoverable. Edit your bashrc file <code>~/.bashrc</code> to add the following line:</p> <pre><code>export PATH=&lt;Quartus install directory&gt;/quartus/bin:$PATH\nexport PATH=&lt;Quartus install directory&gt;/qsys/bin:$PATH\n</code></pre> <p>For example, if the Quartus install directory is /home/intelFPGA_pro/23.1 then the new line is:</p> <pre><code>export PATH=/home/intelFPGA_pro/23.1/quartus/bin:$PATH\nexport PATH=/home/intelFPGA_pro/23.1/qsys/bin:$PATH\n</code></pre> </li> <li> <p>Verify, Quartus is discoverable by opening a new shell:</p> <pre><code>$ which quartus\n/home/intelFPGA_pro/23.1/quartus/bin/quartus\n</code></pre> </li> </ol> <p>The OFS provided Quartus build scripts require the following tools:</p> Item Version Python 3.7.7 GCC 7.2.0 cmake 3.11.4 git with git-lfs 1.8.3.1 <p>To install the <code>Git Large File Storage (LFS)</code> extension execute the next commands</p> <pre><code>curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash\nsudo dnf install git-lfs\ngit lfs install\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#411-clone-the-ofs-git-repo","title":"4.1.1. Clone the OFS Git Repo","text":"<p>Retrieve the OFS FIM source code from the GitHub repository. Create a new directory to use as a clean starting point to store the retrieved files.  The following is a short description of each repository, followed by the git commands for cloning.  The instructions section uses the HTTPS git method for cloning repositories.  Cloning the repo using the HTTPS method requires a personal access token.  Please see this blog post for background information the need for personal access token [Token authentication requirements for Git operations]. Please see [Creating a personal access token].  The classic personal access token has been verified to work properly. </p> <ul> <li>Navigate to location for storage of OFS source, create the top-level source directory and clone OFS repositories using the clone command listed below.</li> </ul> <pre><code>mkdir IOFS_BUILD_ROOT\ncd IOFS_BUILD_ROOT\nexport IOFS_BUILD_ROOT=$PWD\ngit clone --recurse-submodules https://github.com/OFS/ofs-n6001\n    ... Cloning into 'ofs-n6001' ...\n    remote: Enumerating objects:  ....\n    ...\n    ...\n    Resolving deltas  ..., done.\n\ncd ofs-n6001\ngit checkout --recurse-submodules tags/ofs-2023.1-1\n\n#check if you have ofs-common\ngit submodule status\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#42-directory-structure-of-ofs","title":"4.2. Directory Structure of OFS","text":"<p>First verify the following directories and files are present in $IOFS_BUILD_ROOT/ofs-n6001 directory.  </p> <pre><code>ls -1\n......\neval_scripts\nipss\nlicense\nLICENSE.txt\nofs-common\nREADME.md\nsim\nsrc\nsyn\ntools\nverification\n</code></pre> <p>The directories are arranged as shown below: <pre><code>find . -mindepth 1 -maxdepth 2 -type d -not -path '*/\\.*' -print | sed -e 's/[^-][^\\/]*\\//--/g' -e 's/--/|  /g' -e 's/|-/|   /g'\n|  eval_scripts\n|  ipss\n|  |  hssi\n|  |  mem\n|  |  pcie\n|  |  pmci\n|  |  qsfp\n|  license\n|  ofs-common\n|  |  scripts\n|  |  src\n|  |  tools\n|  |  verification\n|  sim\n|  |  bfm\n|  |  common\n|  |  scripts\n|  |  unit_test\n|  src\n|  |  afu_top\n|  |  includes\n|  |  pd_qsys\n|  |  top\n|  syn\n|  |  scripts\n|  |  setup\n|  |  syn_top\n|  tools\n|  |  pfvf_config_tool\n|  verification\n|  |  coverage\n|  |  scripts\n|  |  testbench\n|  |  tests\n|  |  unit_tb\n|  |  verifplan\n</code></pre></p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#421-install-quartus-patches","title":"4.2.1. Install Quartus Patches","text":"<p>The FIM uses a UART IP core that requires a license in order to create programming files.  The patch for installing the license is located in $IOFS_BUILD_ROOT/ofs-n6001/license.  Please follow the steps below to install this license patch.</p> <pre><code>cd $IOFS_BUILD_ROOT/ofs-n6001/license\nsudo ./quartus-0.0-0.02iofs-linux.run\n</code></pre> <p>Once patch install is complete, verify successful installation:</p> <pre><code>quartus_sh --version\n\nQuartus Prime Shell\nVersion 23.1\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#43-compiling-the-ofs-fim","title":"4.3. Compiling the OFS FIM","text":"<p>The following sections describe how to set up the environment and build the provided FIM and AFU. Follow these steps as a tutorial to learn the build flow.  You will use this environment and build scripts for the creation of your specialized FIM.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#431-setting-up-required-environment-variables","title":"4.3.1. Setting Up Required Environment Variables","text":"<p>Set required environment variables as shown below.  These environment variables must be set prior to simulation or compilation tasks so creating a simple script to set these variables saves time. </p> <pre><code>cd /home/user/IOFS_BUILD_ROOT\nexport IOFS_BUILD_ROOT=$PWD\nexport QUARTUS_MAINPATH=/home/intelFPGA_pro/23.1 export QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus export QUARTUS_HOME=$QUARTUS_ROOTDIR export QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR export QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR export IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip export IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip export INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld export QSYS_ROOTDIR=$QUARTUS_ROOTDIR/../qsys/bin export OFS_ROOTDIR=$IOFS_BUILD_ROOT/ofs-n6001\nexport WORKDIR=$OFS_ROOTDIR export VERDIR=$OFS_ROOTDIR/verification/ofs-n6001/common:$OFS_ROOTDIR/verification export OFS_PLATFORM_AFU_BBB=$IOFS_BUILD_ROOT/ofs-platform-afu-bbb export OPAE_SDK_REPO_BRANCH=release/$OPAE_SDK_VERSION\nexport OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_dir/build_tree    export LIBRARY_PATH=$IOFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib export LD_LIBRARY_PATH=$IOFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib64 export OPAE_LOC=/install-opae-sdk export PYTHONPATH=/root/.local/lib/python3.7.7/site-packages/ export QUARTUS_NUM_PARALLEL_PROCESSORS=8 export TOOLS_LOCATION=/home/guest export DESIGNWARE_HOME=$TOOLS_LOCATION/synopsys/vip_common/vip_Q-2020.03A\nexport UVM_HOME=$TOOLS_LOCATION/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm export VCS_HOME=$TOOLS_LOCATION/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel export MTI_HOME=$TOOLS_LOCATION/intelFPGA_pro/questa_fse export PATH=$PATH:$QUARTUS_HOME/bin:$QUARTUS_HOME/qsys/bin:$QUARTUS_HOME/sopc_builder/bin/:$IOFS_BUILD_ROOT/opae-sdk/install-opae-sdk/bin:$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$DESIGNWARE_HOME/bin:$VCS_HOME/bin\n\nexport LM_LICENSE_FILE=\"your_path\"\nexport DW_LICENSE_FILE=\"your_path\"\nexport SNPSLMD_LICENSE_FILE=\"your_path\"\n#in case your need proxy\nexport no_proxy=\"your_path\"\nexport http_proxy=\"your_path\" export https_proxy=\"your_path\"\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#432-compiling-the-intel-fpga-smartnic-n6001-pl-fim","title":"4.3.2. Compiling the Intel\u00ae FPGA SmartNIC N6001-PL FIM","text":"<p>The Intel\u00ae FPGA SmartNIC N6001-PL FIM is built with bash script <code>$OFS_ROOTDIR/ofs-common/scripts/common/syn/build_top.sh</code>.  There are several setup files that must be put in place before and during the compile - as a result, building the Intel\u00ae FPGA SmartNIC N6001-PL FIM from the Quartus GUI is not supported - you must use the the <code>build_top.sh</code> script for Intel\u00ae FPGA SmartNIC N6001-PL FIM compilation.</p> <p>The usage of the compile build script is shown below: <pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh [-p] n6001 work_dir # --Please see  $OFS_ROOTDIR/ofs-common/scripts/common/syn/README for detailed information on this script\n</code></pre></p> <p>The <code>build_top.sh</code> script copies files from the files in ofs-n6001 to your specified work_dir, then the files in work_dir are used for the Quartus compile process.  In most cases, you will perform design work the <code>ipss</code>, <code>src</code>, <code>sim</code>, <code>syn</code> and <code>verification</code> directories and run the build_top.sh script to copy the source design files into work_dir for the Quartus build process.  </p> <p>The build_top.sh script has the -k option which will do the build process on an existing work_dir without copying source files.  The -k option is useful when you want to add Signal Tap to a build.</p> <p>The <code>build_top.sh</code> script has the following build options:</p> <ul> <li>A PR (default build option) compile which creates a FPGA image with design partitions consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. The AFU image may be loaded into the dynamic region using partial reconfiguration.  </li> <li>Flat compile which combines the FIM and AFU into one FPGA image that is loaded into the entire FPGA device.  The Flat compile removes all floorplanning design partitions and partial reconfiguration control logic.  Removal of patitions can be useful for some designs and FIM development scenarios.</li> </ul> <p>The build_top.sh script has options for removing exercisers.  These options are described in [Compiling the FIM in preparation for designing your AFU].</p> <p>The <code>build_top.sh</code> script includes the -p option which creates a re-locatable design tree for use design flows where the FIM development and AFU workload are separate design teams.  See [Create a Relocatable PR Directory Tree] for more details.</p> <p>The build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested.   </p> <p>In the next example, you will build the provided example design using the default build options with partial reconfiguation blocks, partial reconfigation region and all exercisers AFU blocks included.  </p> <pre><code>#Build the provided base example design:\ncd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh n6001 work_n6001\n\n#    ... build takes ~3 hours to complete\nCompile work directory:     &lt;$IOFS_BUILD_ROOT&gt;/ofs-n6001/work_n6001/syn/syn_top\nCompile artifact directory: &lt;$IOFS_BUILD_ROOT&gt;/ofs-n6001/work_n6001/syn/syn_top/output_files\n\n***********************************\n***\n***        OFS_PROJECT: n6001\n***        Q_PROJECT:  ofs_top\n***        Q_REVISION: ofs_top\n***        SEED: 1\n***        Build Complete\n***        Timing Passed!\n***\n***********************************\n</code></pre> <p>The build script copies the <code>ipss</code>, <code>ofs-common</code>, <code>sim</code>, <code>src</code>,<code>syn</code> and <code>tools</code> directories to the specified work directory and then these copied files are used in the Quartus compilation process.</p> <p>Some key output files are described below:</p> <p>/syn/syn_top == Quartus project (ofs_top.qpf) and other Quartus specific files /syn/syn_top/output_files == Directory with build reports and FPGA programming files.  The programming files are: <p>The build script will run PACSign (if installed) and create an unsigned FPGA programming files for both user1 and user2 locations of the Intel\u00ae FPGA SmartNIC N6001-PL FPGA flash.  Please note, if the Intel\u00ae FPGA SmartNIC N6001-PL has the root entry hash key loaded, then PACsign must be run to add the proper key to the FPGA binary file.</p> <p>The following table provides a detailed description of the generated *.bin files.</p> File Description ofs_top[_hps].bin This is an intermediate, raw binary file. This intermediate raw binary file is produced by taking the Quartus generated .sof file, and converting it to *.pof using quartus_pfg, then converting the *.pof to *.hexout using quartus_cpf, and finally converting the *.hexout to *.bin using objcopy. Depending on whether the FPGA design contains an HPS block, a different file will be generated. **ofs_top.bin* - Raw binary image of the FPGA generated if there is no HPS present in the design. ofs_top_hps.bin - Raw binary image of the FPGA generated if there is an HPS present in the design. ofs_top_page1.bin This is the binary of the Factory Image and is the input to PACSign utility to generate ofs_top_page1_unsigned.bin binary image file. This image will carry binary content for the HPS if it is included in the SOF image. ofs_top_page0_factory.bin This is an input file to PACSign to generate ofs_top_page0_unsigned_factory.bin. ofs_top_page0_unsigned_factory.bin This is the unsigned PACSign output generated for the Factory Image. ofs_top_page1_user1.bin This is an input file to PACSign to generate ofs_top_page1_unsigned_user1.bin. This file is created by taking the ofs_top_[hps].bin file and assigning the User1 or appending factory block information. ofs_top_page1_unsigned_user1.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User1 Image. This file is used to load the FPGA flash User1 Image using the fpgasupdate tool. ofs_top_page2_user2.bin This is an input file to PACSign to generate ofs_top_page2_unsigned_user2.bin. This file is created by taking the ofs_top_[hps].bin file and assigning the User2 or appending factory block information. ofs_top_page2_unsigned_user2.bin This is the unsigned FPGA binary image generated by the PACSign utility for the User2 Image. This file is used to load the FPGA flash User2 Image using the fpgasupdate tool. If your design contains an Intel\u00ae Agilex\u00ae FPGA Hard Processor System, then the build assembly process combines the FPGA ofs_top.sof programming file with /syn/n6001/common/setup/u-boot-spl-dtb.hex to produce: ofs_top_hps.sof. <p>The build/output_files/timing_report Directory contains clocks report, failing paths and passing margin reports. </p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#433-create-a-relocatable-pr-directory-tree","title":"4.3.3. Create a Relocatable PR Directory Tree","text":"<p>If you are developing a FIM to be used by another team developing AFU workload(s), scripts are provided that create a relocatable PR directory tree. ODM and board developers will make use of this capability to enable a broad set of AFUs to be loaded on a board using PR.</p> <p>You can create this relocatable PR directory tree by either:</p> <ul> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh followed by running /ofs-common/scripts/common/syn/generate_pr_release.sh</li> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh with optional -p switch included</li> </ul> <p>The generate_pr_release.sh has the following command structure:</p> <p><pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/generate_pr_release.sh -t &lt;path to generated release tree&gt; *Board Build Target* &lt;work dir from build_top.sh&gt;\n\n#Where:\n# -t &lt;path to generated release tree&gt; = location for your relocatable PR directory tree\n# *Board Build Target* is the name of the board target/FIM e.g. n6001\n# &lt;work dir from build_top.sh&gt; \n</code></pre> Here is an example of running the generate_pr_release.sh script:</p> <pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/generate_pr_release.sh -t work_n6001/build_tree n6001  work_n6001\n</code></pre> <p>The resulting relocatable build tree has the following structure:</p> <p><pre><code>cd $OFS_ROOTDIR/work_n6001/build_tree\n\nfind . -mindepth 1 -maxdepth 3 -not -path '*/\\.*' -print | sed -e 's/[^-][^\\/]*\\//--/g' -e 's/--/\u251c\u2500\u2500 /g' -e 's/|-/\u2502   \u251c\u2500\u2500 /g' -e '$s/\u251c\u2500\u2500/\u2514\u2500\u2500/' -e 's/\u2502   \u251c\u2500\u2500 \\([^ ]\\)/\u2502   \u251c\u2500\u2500 \\1/' -e 's/\u2502   \u251c\u2500\u2500 \u2502   \u251c\u2500\u2500/\u2502   \u2502   \u251c\u2500\u2500/'\n\u251c\u2500\u2500 bin\n\u251c\u2500\u2500 \u251c\u2500\u2500 afu_synth\n\u251c\u2500\u2500 \u251c\u2500\u2500 qar_gen\n\u251c\u2500\u2500 \u251c\u2500\u2500 update_pim\n\u251c\u2500\u2500 \u251c\u2500\u2500 run.sh\n\u251c\u2500\u2500 \u251c\u2500\u2500 build_env_config\n\u251c\u2500\u2500 README\n\u251c\u2500\u2500 hw\n\u251c\u2500\u2500 \u251c\u2500\u2500 lib\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 build\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 fme-ifc-id.txt\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 platform\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 fme-platform-class.txt\n\u251c\u2500\u2500 \u251c\u2500\u2500 blue_bits\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 ofs_top_hps.sof\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 ofs_top.sof\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 ofs_top_page0_unsigned_factory.bin\n\u251c\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 ofs_top_page1_unsigned_user1.bin\n\u2514\u2500\u2500 \u251c\u2500\u2500 \u251c\u2500\u2500 ofs_top_page2_unsigned_user2.bin\n</code></pre> This build tree can be moved to a different location and used for AFU development of PR-able AFU to be used with this board.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#434-flat-build","title":"4.3.4. Flat Build","text":"<p>To run the <code>build_top.sh</code> script for a flat compile, add the build setting <code>n6001:flat</code> as shown below:</p> <p><pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh n6001:flat work_n6001_flat\n</code></pre> Note: The flat compile removes the PR region and PR IP.  You cannot use the -P <code>build_top.sh</code> option when using the <code>n6001:flat</code> compile setting.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#44-unit-level-simulation","title":"4.4. Unit Level Simulation","text":"<p>Unit level simulation of key components is provided. These simulations provide verification of the following areas:</p> <ul> <li>E-Tile Ethernet Subsystem</li> <li>PCIe</li> <li>External Memory</li> <li>Core FIM</li> </ul> <p>The Unit Level simulations work with Synopsys VCS and Mentor Graphics Questa sim simulators. Readme files are provided explaining how to run the simulation of each component.  To run a simulation of <code>dfh_walker</code> that simulates host access to the internal DFH registers, perform the following steps.</p> <ol> <li> <p>Set the environment variables listed in section, Setting Up Required Environment Variables.</p> </li> <li> <p>Generate the IP simulation files for all Unit level simulations.  Once the IP simulation files are generated, you can run all of the Unit Simulation tests.</p> </li> </ol> <pre><code>cd $OFS_ROOTDIR/ofs-common/scripts/common/sim\n\n# Run the script \"sh gen_sim_files.sh &lt;target&gt;\"\nsh gen_sim_files.sh n6001\n</code></pre> <ol> <li>Launch the actual DFH Walker unite test.</li> </ol> <p><pre><code>cd $OFS_ROOTDIR/sim/unit_test/dfh_walker/\n# If simulator is not specified, then VCS simulator is used\nsh run_sim.sh\n\n# For Questasim, use the following command:\nsh run_sim.sh MSIM=1\n# For VCS-MX, use the following command:\nsh run_sim.sh VCSMX=1\n.\n.\n.\n\nAFU is out of reset ...\n\n********************************************\n Running TEST(0) : test_dfh_walking\n********************************************\nREAD64: address=0x00000000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x4000000010000000\n\nFME_DFH\n   Address   (0x0)\nDFH value (0x4000000010000000)\nREAD64: address=0x00001000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000020000001\n\nTHERM_MNGM_DFH\n   Address   (0x1000)\nDFH value (0x3000000020000001)\nREAD64: address=0x00003000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000010000007\n\nGLBL_PERF_DFH\n   Address   (0x3000)\nDFH value (0x3000000010000007)\nREAD64: address=0x00004000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x30000000e0001004\n\nGLBL_ERROR_DFH\n   Address   (0x4000)\nDFH value (0x30000000e0001004)\nREAD64: address=0x00012000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000010000013\n\nQSFP0_DFH\n   Address   (0x12000)\nDFH value (0x3000000010000013)\nREAD64: address=0x00013000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x30000000d0000013\n\nQSFP1_DFH\n   Address   (0x13000)\nDFH value (0x30000000d0000013)\nREAD64: address=0x00020000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000200001012\n\nPMCI_DFH\n   Address   (0x20000)\nDFH value (0x3000000200001012)\nREAD64: address=0x00040000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000200000014\n\nST2MM_DFH\n   Address   (0x40000)\nDFH value (0x3000000200000014)\nREAD64: address=0x00060000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x300000001000100f\n\nHSSI_DFH\n   Address   (0x60000)\nDFH value (0x300000001000100f)\nREAD64: address=0x00061000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000010000024\n\nVUART_DFH\n   Address   (0x61000)\nDFH value (0x3000000010000024)\nREAD64: address=0x00062000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x30000000e0001009\n\nEMIF_DFH\n   Address   (0x62000)\nDFH value (0x30000000e0001009)\nREAD64: address=0x00070000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000010001005\n\nPG_PR_DFH\n   Address   (0x70000)\nDFH value (0x3000000010001005)\nREAD64: address=0x00071000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x4000000010001001\n\nPG_PORT_DFH\n   Address   (0x71000)\nDFH value (0x4000000010001001)\nREAD64: address=0x00072000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000010001014\n\nPG_USER_CLK_DFH\n   Address   (0x72000)\nDFH value (0x3000000010001014)\nREAD64: address=0x00073000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x30000000d0002013\n\nPG_REMOTE_STP_DFH\n   Address   (0x73000)\nDFH value (0x30000000d0002013)\nREAD64: address=0x00080000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000010000002010\n\nAFU_ERR_DFH\n   Address   (0x80000)\nDFH value (0x3000010000002010)\nTest status: OK\n\n********************\n  Test summary\n********************\n   test_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n</code></pre> The simulation transcript is displayed while the simulation runs.  The transcript is saved in $OFS_ROOTDIR/sim/unit_test/dfh_walker/sim_vcs/transcript for review after the simulation completes.  The simulation waveform database is saved as vcdplus.vpd for post simulation review. You are encouraged to run the additional simulation examples to learn about each key area of the OFS shell.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5-creating-a-custom-fim","title":"5. Creating a Custom FIM","text":"<p>The remaining sections of this guide describe how to perform customizations of areas of the FIM.  In each section, it is assumed that:</p> <ol> <li>You have a clean, unmodified clone of the OFS repo.  See [Clone the OFS Git Repo].</li> <li>After cloning, you set environment variables.  See Setting Up Required Environment Variables.</li> </ol>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#51-creating-the-hello-fim-example","title":"5.1. Creating the Hello FIM example","text":"<p>If you intend to add a new module to the FIM area, then you will need to inform the host software of the new module. The FIM exposes its functionalities to host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO). This set of CSR registers and their operation is described in FIM MMIO Regions. See FPGA Device Feature List (DFL) Framework Overview for a description of the software process to read and process the linked list of Device Feature Header (DFH) CSRs within a FPGA.</p> <p>This example adds a simple DFH register and 64bit scratchpad register connected to the Board Peripheral Fabric (BPF). You can use this example as the basis for adding a new feature to your FIM. </p> <p>Hello FIM register can be verified by Unit Level simulation, Universal Verification Methodology (UVM) simulation, and running in hardware on the Intel\u00ae FPGA SmartNIC N6001-PL card. </p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#511-board-peripheral-fabric-bpf","title":"5.1.1. Board Peripheral Fabric (BPF)","text":"<p>Hello FIM is connected to Board Peripheral Fabric (BPF). BPF is an interconnect generated by Platform Designer.</p> <p></p> <p>You can create/Modify/generate the BPF manually in Platform Designer or more conveniently by executing an auxiliary script. Both methods will be described shortly.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#512-mmio-region","title":"5.1.2. MMIO Region","text":"<p>This section shows the base addresses of all modules. </p> Offset Feature CSR set 0x00000 FME AFU 0x10000 PCIe Interface 0x12000 QSFP Controller 0 0x13000 QSFP Controller 1 0x14000 E-Tile Ethernet  Interface 0x15000 EMIF 0x16000 Hello FIM 0x20000 PMCI Controller 0x40000 ST2MM (Streaming to Memory-Mapped) 0x60000 VUART 0x70000 PR Control &amp; Status (Port Gasket) 0x71000 Port CSRs (Port Gasket) 0x72000 User Clock (Port Gasket) 0x74000 Remote SignalTap (Port Gasket) 0x80000 AFU Errors (AFU Interface Handler)"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#513-hello-fim-csr","title":"5.1.3. Hello FIM CSR","text":"<p>Hello FIM CSR consists of three registers below. The DFH and Hello FIM ID registers are read-only. The Scratchpad register supports read and write accesses.</p> Offset Attribute Description Default Value 0x016000 RO DFH(Device Feature Headers) register 0x30000000c0000100 0x016030 RW Scrachpad register 0x0 0x016038 RO Hello FIM ID register 0x6626070150000034"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#514-list-of-all-files-to-edit","title":"5.1.4. List of all files to edit","text":"<p>A list below shows all files in $OFS_ROOTDIR that will be modified or created. The build_top.sh script copies files from $OFS_ROOTDIR into the target work directory and then the copied files are used in the Quartus build process.</p> Category Status Path File Description Design Files Modify syn/syn_top ofs_top.qsf Quartus setting file Source Modify src/top top.sv Top RTL Platform Designer Modify src/pd_qsys/fabric bpf.txt DFL region define file Modify src/pd_qsys/fabric bpf.qsys BPF Qsys file Simulation Modify sim/scripts rtl_pcie.f Define RTL files for simulation Verification Modify verification/tests/sequences mmio_seq.svh MMIO testbench Modify verification/tests/sequences dfh_walking_seq.svh DFH Walking testbench Modify verification/scripts Makefile_VCS.mk Makefile for VCS"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#515-setup-enviroment-variables","title":"5.1.5. Setup Enviroment Variables","text":"<p>To compile and simulate this design, tools and environment must be set up as previously described for the compilation of the Intel\u00ae FPGA SmartNIC N6001-PL FIM.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#516-file-modification","title":"5.1.6. File Modification","text":"<p>This section describes the steps to add the Hello FIM module to the FIM. The steps in this simple example are the basis for modifying the FIM for more complex functions.</p> <ol> <li> <p>syn/syn_top/ofs_top.qsf</p> <p>a. Define the <code>INCLUDE_HELLO_FIM</code> Verilog macro to the <code>Verilog Macros</code> section. This will enable instantiation of the Hello FIM module. If this is not set, a dummy register will be instantiation instead.</p> <pre><code>######################################################\n# Verilog Macros\n######################################################\n.....\nset_global_assignment -name VERILOG_MACRO \"INCLUDE_HELLO_FIM\"     # Includes Hello FIM\n</code></pre> </li> <li> <p>syn/syn_top/ofs_top_sources.tcl    a. Add <code>hello_fim_design_files.tcl</code> to the list of subsystems in the Design Files section.</p> <pre><code>############################################\n# Design Files\n############################################\n...\n# Subsystems\n...\nset_global_assignment -name SOURCE_TCL_SCRIPT_FILE ../setup/hello_fim_design_files.tcl\n</code></pre> </li> <li> <p>syn/setup/hello_fim_design_files.tcl</p> <p>a. Create <code>hello_fim_design_files.tcl</code> with the following contents:</p> <pre><code># Copyright 2023 Intel Corporation.\n#\n# THIS SOFTWARE MAY CONTAIN PREPRODUCTION CODE AND IS PROVIDED BY THE\n# COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# Hello FIM Files\n#--------------------\nset_global_assignment -name SYSTEMVERILOG_FILE $::env(BUILD_ROOT_REL)/src/hello_fim/hello_fim_com.sv\nset_global_assignment -name SYSTEMVERILOG_FILE $::env(BUILD_ROOT_REL)/src/hello_fim/hello_fim_top.sv\n</code></pre> </li> <li> <p>src/pd_qsys/fabric/fabric_design_files.tcl</p> <p>a. Add <code>bpf_hello_fim_slv.ip</code> to the list of files in the BPF section.</p> <pre><code>#--------------------\n# BPF\n#--------------------\n...\nset_global_assignment -name IP_FILE ../ip_lib/src/pd_qsys/fabric/ip/bpf/bpf_hello_fim_slv.ip\n</code></pre> </li> <li> <p>src/top/top.sv</p> <p>a. Add <code>bpf_hello_fim_slv_if</code> to AXI4-Lite Interfaces:</p> <pre><code>// AXI4-lite interfaces\nofs_fim_axi_lite_if #(.AWADDR_WIDTH(12), .ARADDR_WIDTH(12)) bpf_hello_fim_slv_if();\n</code></pre> <p>b. Modify the value of <code>NEXT_DFH_OFFSET</code> of <code>mem_ss_top</code> from <code>24'h6B000</code> to <code>24'h1000</code></p> <pre><code>//*******************************\n// Memory Subsystem\n//*******************************\n`ifdef INCLUDE_DDR4\nmem_ss_top #(\n.FEAT_ID          (12'h009),\n.FEAT_VER         (4'h1),\n.NEXT_DFH_OFFSET  (24'h1000),\n.END_OF_LIST      (1'b0)\n) mem_ss_top (\n</code></pre> <p>c. Modify the value of <code>NEXT_DFH_OFFSET</code> of the Memory Subsystem <code>dummy_csr</code> from <code>24'h6B000</code> to <code>24'h1000</code></p> <pre><code>// Placeholder logic if no mem_ss\ndummy_csr #(\n.FEAT_ID          (12'h009),\n.FEAT_VER         (4'h1),\n.NEXT_DFH_OFFSET  (24'h1000),\n.END_OF_LIST      (1'b0)\n) emif_dummy_csr (\n</code></pre> <p>d. Add Hello FIM instance and dummy CSR after the Memory Subsystem. Set the <code>NEXT_DFH_OFFSET</code> to <code>24'h6A000</code> for both</p> <pre><code>//*******************************\n// Hello FIM Subsystem\n//*******************************\n`ifdef INCLUDE_HELLO_FIM\nhello_fim_top #(\n.ADDR_WIDTH       (12),\n.DATA_WIDTH       (64),\n.FEAT_ID          (12'h100),\n.FEAT_VER         (4'h0),\n.NEXT_DFH_OFFSET  (24'h6A000),\n.END_OF_LIST      (1'b0)\n) hello_fim_top_inst (\n.clk (clk_csr),\n.reset(~rst_n_csr),\n.csr_lite_if    (bpf_hello_fim_slv_if)         );\n`else\ndummy_csr #(   .FEAT_ID          (12'h100),\n.FEAT_VER         (4'h0),\n.NEXT_DFH_OFFSET  (24'h6A000),\n.END_OF_LIST      (1'b0)\n) hello_fim_dummy (\n.clk         (clk_csr),\n.rst_n       (rst_n_csr),\n.csr_lite_if (bpf_hello_fim_slv_if)\n);\n`endif </code></pre> </li> <li> <p>/src/top/top.sv</p> <p>a. Add `bpf_hello_fim_slv_if to the interface descriptions</p> <pre><code>...\n...\nofs_fim_axi_lite_if.master bpf_hello_fim_slv_if\n</code></pre> <p>b. Add <code>bpf_hello_fim_slv_if</code> to the module</p> <pre><code>module top (\n...\n);\n//*******************************\n// BPF\n//*******************************\nbpf bpf (\n.clk_clk              (clk_csr                   ),\n.rst_n_reset_n        (rst_n_csr                 ),\n.....\n.....\n.bpf_hello_fim_slv_awaddr    (bpf_hello_fim_slv_if.awaddr     ),\n.bpf_hello_fim_slv_awprot    (bpf_hello_fim_slv_if.awprot     ),\n.bpf_hello_fim_slv_awvalid   (bpf_hello_fim_slv_if.awvalid    ),\n.bpf_hello_fim_slv_awready   (bpf_hello_fim_slv_if.awready    ),\n.bpf_hello_fim_slv_wdata     (bpf_hello_fim_slv_if.wdata      ),\n.bpf_hello_fim_slv_wstrb     (bpf_hello_fim_slv_if.wstrb      ),\n.bpf_hello_fim_slv_wvalid    (bpf_hello_fim_slv_if.wvalid     ),\n.bpf_hello_fim_slv_wready    (bpf_hello_fim_slv_if.wready     ),\n.bpf_hello_fim_slv_bresp     (bpf_hello_fim_slv_if.bresp      ),\n.bpf_hello_fim_slv_bvalid    (bpf_hello_fim_slv_if.bvalid     ),\n.bpf_hello_fim_slv_bready    (bpf_hello_fim_slv_if.bready     ),\n.bpf_hello_fim_slv_araddr    (bpf_hello_fim_slv_if.araddr     ),\n.bpf_hello_fim_slv_arprot    (bpf_hello_fim_slv_if.arprot     ),\n.bpf_hello_fim_slv_arvalid   (bpf_hello_fim_slv_if.arvalid    ),\n.bpf_hello_fim_slv_arready   (bpf_hello_fim_slv_if.arready    ),\n.bpf_hello_fim_slv_rdata     (bpf_hello_fim_slv_if.rdata      ),\n.bpf_hello_fim_slv_rresp     (bpf_hello_fim_slv_if.rresp      ),\n.bpf_hello_fim_slv_rvalid    (bpf_hello_fim_slv_if.rvalid     ),\n.bpf_hello_fim_slv_rready    (bpf_hello_fim_slv_if.rready     ),\n</code></pre> </li> <li> <p>src/hello_fim</p> <p>a. Create <code>src/hello_fim</code> directory</p> <pre><code>mkdir $OFS_ROOTDIR/src/hello_fim\n</code></pre> </li> <li> <p>src/hello_fim/hello_fim_top.sv</p> <p>a. Create <code>hello_fim_top.sv</code> with the following contents:</p> <pre><code>// ***************************************************************************\n//                               INTEL CONFIDENTIAL\n//\n//        Copyright (C) 2023 Intel Corporation All Rights Reserved.\n//\n// The source code contained or described herein and all  documents related to\n// the  source  code  (\"Material\")  are  owned  by  Intel  Corporation  or its\n// suppliers  or  licensors.    Title  to  the  Material  remains  with  Intel\n// Corporation or  its suppliers  and licensors.  The Material  contains trade\n// secrets  and  proprietary  and  confidential  information  of  Intel or its\n// suppliers and licensors.  The Material is protected  by worldwide copyright\n// and trade secret laws and treaty provisions. No part of the Material may be\n// used,   copied,   reproduced,   modified,   published,   uploaded,  posted,\n// transmitted,  distributed,  or  disclosed  in any way without Intel's prior\n// express written permission.\n//\n// No license under any patent,  copyright, trade secret or other intellectual\n// property  right  is  granted  to  or  conferred  upon  you by disclosure or\n// delivery  of  the  Materials, either expressly, by implication, inducement,\n// estoppel or otherwise.  Any license under such intellectual property rights\n// must be express and approved by Intel in writing.\n//\n// You will not, and will not allow any third party to modify, adapt, enhance, \n// disassemble, decompile, reverse engineer, change or create derivative works \n// from the Software except and only to the extent as specifically required by \n// mandatory applicable laws or any applicable third party license terms \n// accompanying the Software.\n//\n// -----------------------------------------------------------------------------\n// Engineer     : \n// Create Date  : Nov 2021\n// Module Name  : hello_fim_top.sv\n// Project      : IOFS\n// -----------------------------------------------------------------------------\n//\n// Description: \n// This is a simple module that implements DFH registers and \n// AVMM address decoding logic.\nmodule hello_fim_top  #(\nparameter ADDR_WIDTH  = 12, parameter DATA_WIDTH = 64, parameter bit [11:0] FEAT_ID = 12'h001,\nparameter bit [3:0]  FEAT_VER = 4'h1,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h1000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput  logic    clk,\ninput  logic    reset,\n// -----------------------------------------------------------\n//  AXI4LITE Interface\n// -----------------------------------------------------------\nofs_fim_axi_lite_if.slave   csr_lite_if\n);\nimport ofs_fim_cfg_pkg::*;\nimport ofs_csr_pkg::*;\n//-------------------------------------\n// Signals\n//-------------------------------------\nlogic [ADDR_WIDTH-1:0]              csr_waddr;\nlogic [DATA_WIDTH-1:0]              csr_wdata;\nlogic [DATA_WIDTH/8-1:0]            csr_wstrb;\nlogic                               csr_write;\nlogic                               csr_slv_wready;\ncsr_access_type_t                   csr_write_type;\nlogic [ADDR_WIDTH-1:0]              csr_raddr;\nlogic                               csr_read;\nlogic                               csr_read_32b;\nlogic [DATA_WIDTH-1:0]              csr_readdata;\nlogic                               csr_readdata_valid;\nlogic [ADDR_WIDTH-1:0]              csr_addr;\nlogic [63:0]                        com_csr_writedata;\nlogic                               com_csr_read;\nlogic                               com_csr_write;\nlogic [63:0]                        com_csr_readdata;\nlogic                               com_csr_readdatavalid;\nlogic [5:0]                         com_csr_address;\n// AXI-M CSR interfaces\nofs_fim_axi_mmio_if #(\n.AWID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.AWADDR_WIDTH (ADDR_WIDTH),\n.WDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH),\n.ARID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.ARADDR_WIDTH (ADDR_WIDTH),\n.RDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH)\n) csr_if();\n// AXI4-lite to AXI-M adapter\naxi_lite2mmio axi_lite2mmio (\n.clk       (clk),\n.rst_n     (~reset),\n.lite_if   (csr_lite_if),\n.mmio_if   (csr_if)\n);\n//---------------------------------\n// Map AXI write/read request to CSR write/read,\n// and send the write/read response back\n//---------------------------------\nofs_fim_axi_csr_slave #(\n.ADDR_WIDTH (ADDR_WIDTH),\n.USE_SLV_READY (1'b1)\n) csr_slave (\n.csr_if             (csr_if),\n.csr_write          (csr_write),\n.csr_waddr          (csr_waddr),\n.csr_write_type     (csr_write_type),\n.csr_wdata          (csr_wdata),\n.csr_wstrb          (csr_wstrb),\n.csr_slv_wready     (csr_slv_wready),\n.csr_read           (csr_read),\n.csr_raddr          (csr_raddr),\n.csr_read_32b       (csr_read_32b),\n.csr_readdata       (csr_readdata),\n.csr_readdata_valid (csr_readdata_valid)\n);\n// Address mapping\nassign csr_addr             = csr_write ? csr_waddr : csr_raddr;\nassign com_csr_address      = csr_addr[5:0];  // byte address\nassign csr_slv_wready       = 1'b1 ;\n// Write data mapping\nassign com_csr_writedata    = csr_wdata;\n// Read-Write mapping\nalways_comb\nbegin\ncom_csr_read             = 1'b0;\ncom_csr_write            = 1'b0;\ncasez (csr_addr[11:6])\n6'h00 : begin // Common CSR\ncom_csr_read       = csr_read;\ncom_csr_write      = csr_write;\nend   default: begin\ncom_csr_read       = 1'b0;\ncom_csr_write      = 1'b0;\nend\nendcase\nend\n// Read data mapping\nalways_comb begin\nif (com_csr_readdatavalid) begin\ncsr_readdata       = com_csr_readdata;\ncsr_readdata_valid = 1'b1;\nend\nelse begin\ncsr_readdata       = '0;\ncsr_readdata_valid = 1'b0;\nend\nend\nhello_fim_com  #(\n.FEAT_ID          (FEAT_ID),\n.FEAT_VER         (FEAT_VER),\n.NEXT_DFH_OFFSET  (NEXT_DFH_OFFSET),\n.END_OF_LIST      (END_OF_LIST)\n) hello_fim_com_inst (\n.clk                   (clk                     ),\n.reset                 (reset                   ),\n.writedata             (com_csr_writedata       ),\n.read                  (com_csr_read            ),\n.write                 (com_csr_write           ),\n.byteenable            (4'hF                    ),\n.readdata              (com_csr_readdata        ),\n.readdatavalid         (com_csr_readdatavalid   ),\n.address               (com_csr_address         )\n);\nendmodule\n</code></pre> </li> <li> <p>src/hello_fim/hello_fim_com.sv</p> <p>a. Create <code>hello_fim_com.sv</code> with the following contents:</p> <pre><code>module hello_fim_com #(\nparameter bit [11:0] FEAT_ID = 12'h001,\nparameter bit [3:0]  FEAT_VER = 4'h1,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h1000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput clk,\ninput reset,\ninput [63:0] writedata,\ninput read,\ninput write,\ninput [3:0] byteenable,\noutput reg [63:0] readdata,\noutput reg readdatavalid,\ninput [5:0] address\n);\nwire reset_n = !reset;  reg [63:0] rdata_comb;\nreg [63:0] scratch_reg;\nalways @(negedge reset_n ,posedge clk)  if (!reset_n) readdata[63:0] &lt;= 64'h0; else readdata[63:0] &lt;= rdata_comb[63:0];\nalways @(negedge reset_n , posedge clk)\nif (!reset_n) readdatavalid &lt;= 1'b0; else readdatavalid &lt;= read;\nwire wr = write;\nwire re = read;\nwire [5:0] addr = address[5:0];\nwire [63:0] din  = writedata [63:0];\nwire wr_scratch_reg = wr &amp; (addr[5:0]  == 6'h30)? byteenable[0]:1'b0;\n// 64 bit scratch register\nalways @( negedge  reset_n,  posedge clk)\nif (!reset_n)  begin\nscratch_reg &lt;= 64'h0;\nend\nelse begin\nif (wr_scratch_reg) begin scratch_reg &lt;=  din;  end\nend\nalways @ (*)\nbegin\nrdata_comb = 64'h0000000000000000;\nif(re) begin\ncase (addr)  6'h00 : begin\nrdata_comb [11:0]   = FEAT_ID ;  // dfh_feature_id  is reserved or a constant value, a read access gives the reset value\nrdata_comb [15:12]  = FEAT_VER ;  // dfh_feature_rev    is reserved or a constant value, a read access gives the reset value\nrdata_comb [39:16]  = NEXT_DFH_OFFSET ;  // dfh_dfh_ofst is reserved or a constant value, a read access gives the reset value\nrdata_comb [40]     = END_OF_LIST ;        //dfh_end_of_list\nrdata_comb [59:40]  = 20'h00000 ;  // dfh_rsvd1     is reserved or a constant value, a read access gives the reset value\nrdata_comb [63:60]  = 4'h3 ;  // dfh_feat_type  is reserved or a constant value, a read access gives the reset value\nend\n6'h30 : begin\nrdata_comb [63:0]   = scratch_reg; end\n6'h38 : begin\nrdata_comb [63:0]       = 64'h6626_0701_5000_0034;\nend\ndefault : begin\nrdata_comb = 64'h0000000000000000;\nend\nendcase\nend\nend\nendmodule\n</code></pre> </li> <li> <p>src/pd_qsys/fabric/bpf.txt</p> <p>a. Add <code>hello_fim</code> as a slave in the BPF, and enable as a master for it.</p> <pre><code>#### - '#' means comment\n# NAME   TYPE      BASEADDRESS    ADDRESS_WIDTH    SLAVES\napf         mst     n/a             21             fme,pcie,hssi,qsfp0,qsfp1,emif,pmci,hello_fim\n...\nhello_fim   slv     0x16000         12             n/a\n</code></pre> </li> <li> <p>Execute the helper script to re-generate the BPF design files</p> <pre><code>cd $OFS_ROOTDIR/src/pd_qsys/fabric/\nsh gen_fabrics.sh\n</code></pre> </li> <li> <p>After the script completes, the <code>bpf_hello_fim_slv.ip</code> can be found in <code>$OFS_ROOTDIR/src/pd_qsys/fabric/ip/bpf</code></p> </li> </ol> <p>After the shell script finishes, you can find the generated bpf_hello_fim_slv.ip file in src/pd_qsys/fabric/ip/bpf/. This is the ip variant of the axi4lite shim that bridges the Hello FIM module with the BPF. The updated bpf.qsys file is located in src/pd_qsys/fabric. You can view the updated bpf file in Platform designer as follows.</p> <pre><code>cd $OFS_ROOTDIR/src/pd_qsys/fabric\nqsys-edit bpf.qsys --quartus-project=$OFS_ROOTDIR/syn/syn_top/ofs_top.qpf\n</code></pre> <p>The image below shows the BPF that integrates the bpf_hello_fim_slv axi4lite shim, generated through the helper script gen_fabrics.sh.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#517-platform-designer-for-bpf","title":"5.1.7. Platform Designer for BPF","text":""},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5171-modify-bpf-automatically-through-helper-script","title":"5.1.7.1. Modify BPF automatically through helper script","text":"<ol> <li>Define into the DFL region define file, src/pd_qsys/fabric/bpf.txt the hello_fim Device Feature Header at base addres 0x16000. Follow the example below.</li> </ol> REGISTER NAME FABRIC BASE ADDRESS ADDRESS WIDTH ... ... ... ... qsfp0 bpf-slv 0x12000 12 qsfp1 bpf-slv 0x13000 12 hssi bpf-slv 0x14000 12 hello_fim bpf-slv 0x16000 12 pmci bpf-slv 0x20000 17 ... ... ... ... <p>This DFL definition file will be later used by the helper script for the automatic generation of the Board Peripheral Fabric.</p> <ol> <li>Modify the DFL unused range definition file  src/pd_qsys/fabric/bpf.txt.</li> </ol> <p><pre><code># NAME   FABRIC      BASEADDRESS    ADDRESS_WIDTH SLAVES\napf         mst     n/a             18            fme,pcie,pmci,qsfp0,qsfp1,emif,hssi\nfme         mst     n/a             20            apf          pmci        mst     n/a             21            fme,pcie,pmci,qsfp0,qsfp1,pmci_lpbk,emif,hssi\npmci_lpbk   mst     n/a             20            apf\nfme         slv     0x00000         16        n/a\napf         slv     0x00000         20        n/a\npcie        slv     0x10000         12        n/a\nqsfp0       slv     0x12000         12        n/a\nqsfp1       slv     0x13000         12        n/a\nhssi        slv     0x14000         12        n/a\nemif        slv     0x15000         12        n/a\nhello_fim   slv     0x16000         12        n/a\npmci        slv     0x20000         17        n/a\npmci_lpbk   slv     0x100000        20        n/a\n</code></pre> This update is very important since the ST2MM bridge filters out any communication that fall within the unused ranges.</p> <ol> <li>Execute the helper script, src/pd_qsys/fabric/gen_fabrics.sh, to update the BPF.</li> </ol> <p><pre><code>cd $OFS_ROOTDIR/src/pd_qsys/fabric\nsh gen_fabrics.sh\n</code></pre> After the shell script finishes, you can find the generated bpf_hello_fim_slv.ip file in src/pd_qsys/fabric/ip/bpf/. This is the ip variant of the axi4lite shim that bridges the Hello FIM module with the BPF. The updated bpf.qsys file is located in src/pd_qsys/fabric. You can view the updated bpf file in Platform designer as follows.</p> <pre><code>cd $OFS_ROOTDIR/src/pd_qsys/fabric\nqsys-edit bpf.qsys --quartus-project=$OFS_ROOTDIR/syn/syn_top/ofs_top.qpf\n</code></pre> <p>The image below shows the BPF that integrates the bpf_hello_fim_slv axi4lite shim, generated through the helper script gen_fabrics.sh.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5172-modify-bpf-manually-in-platform-designer","title":"5.1.7.2. Modify BPF manually in Platform Designer","text":"<p>The following steps show how to manually add in Platform Designer the new axi4lite port for the HelloFIM module.</p> <p>Run commands below, and launch Platform Designer.</p> <pre><code>cd $OFS_ROOTDIR/src/pd_qsys/fabric\nqsys-edit bpf.qsys --quartus-project=$OFS_ROOTDIR/syn/syn_top/ofs_top.qpf\n</code></pre> <p>Double click axi4lite_shim in the Project Window to add a new port.</p> <p></p> <p>In the dialog box that appears, set 12 to AW as address width, set \"bpf_hello_fim_slv\" as HDL entry name, and click \"Finish\". </p> <p></p> <ul> <li>Modify the export label to \"bpf_hello_fim_slv\".</li> <li>Set the Start Address to \"0x0001_6000\". </li> <li>Connect the input clock port to the out_clk port of the bpf_clock_bridge component.</li> <li>Connect the input reset port to the out_reset port of the bpf_reset_bridge component.</li> <li>Connect the input altera_axi4lite_slave port to the altera_axi4lite_master output port of both bpf_pmci_mst and bpf_apf_mst components.</li> <li>Click \"Generate HDL...\".</li> </ul> <p>Then, in the Generation dialog that appears Modify the simulation settings as below, and click \"Generate\".</p> <p></p> <p>After generation, close Platform Designer.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#518-unit-level-simulation-of-hello-fim-design","title":"5.1.8. Unit Level Simulation of Hello FIM Design","text":"<p>The following section describes the file modifications that need to be made to perform unit level simulations of the Hello FIM design, followed by instructions for running the unit level simulations simulations.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5181-unit-level-simulation-file-modification","title":"5.1.8.1. Unit Level Simulation File Modification","text":"<p>Perform the following steps to modify the Unit Level simulation files to support the Hello FIM design.</p> <ol> <li> <p>$OFS_ROOTDIR/sim/unit_test/dfh_walker/test_csr_defs.sv</p> <p>a. Add a <code>HELLO_FIM_IDX</code> entry to the <code>t_dfh_idx</code> enumeration:</p> <pre><code>typedef enum {\nFME_DFH_IDX,\nTHERM_MNGM_DFH_IDX,\nGLBL_PERF_DFH_IDX,\nGLBL_ERROR_DFH_IDX,\nQSFP0_DFH_IDX,\nQSFP1_DFH_IDX,\nHSSI_DFH_IDX,\nEMIF_DFH_IDX,\nHELLO_FIM_DFH_IDX,\nPMCI_DFH_IDX,\nST2MM_DFH_IDX,\nPG_PR_DFH_IDX,\nPG_PORT_DFH_IDX,\nPG_USER_CLK_DFH_IDX,\nPG_REMOTE_STP_DFH_IDX,\nAFU_ERR_DFH_IDX,\nMAX_DFH_IDX\n} t_dfh_idx;\n</code></pre> <p>b. Add an entry for <code>HELLO_FIM_IDX</code> into the <code>get_dfh_names()</code> function:</p> <pre><code>function automatic dfh_name[MAX_DFH_IDX-1:0] get_dfh_names();\ndfh_name[MAX_DFH_IDX-1:0] dfh_names;\ndfh_names[FME_DFH_IDX]         = \"FME_DFH\";\ndfh_names[THERM_MNGM_DFH_IDX]  = \"THERM_MNGM_DFH\";\ndfh_names[GLBL_PERF_DFH_IDX]   = \"GLBL_PERF_DFH\";\ndfh_names[GLBL_ERROR_DFH_IDX]  = \"GLBL_ERROR_DFH\";\ndfh_names[QSFP0_DFH_IDX]       = \"QSFP0_DFH\";\ndfh_names[QSFP1_DFH_IDX]       = \"QSFP1_DFH\";\ndfh_names[HSSI_DFH_IDX]        = \"HSSI_DFH\";\ndfh_names[EMIF_DFH_IDX]        = \"EMIF_DFH\";\ndfh_names[HELLO_FIM_DFH_IDX]   = \"HELLO_FIM_DFH\";\ndfh_names[PMCI_DFH_IDX]        = \"PMCI_DFH\";\ndfh_names[ST2MM_DFH_IDX]       = \"ST2MM_DFH\";\ndfh_names[PG_PR_DFH_IDX]       = \"PG_PR_DFH\";\ndfh_names[PG_PORT_DFH_IDX]     = \"PG_PORT_DFH\";\ndfh_names[PG_USER_CLK_DFH_IDX] = \"PG_USER_CLK_DFH\";\ndfh_names[PG_REMOTE_STP_DFH_IDX] = \"PG_REMOTE_STP_DFH\";\ndfh_names[AFU_ERR_DFH_IDX] = \"AFU_ERR_DFH\";\nreturn dfh_names;\nendfunction\n</code></pre> <p>c. Modify the expected DFH value of the EMIF and from <code>64'h3_00000_06B000_1009</code> to <code>64'h3_00000_001000_1009</code> and add the expected value for <code>HELLO_FIM</code> as <code>64'h3_00000_06A000_0100</code>:</p> <pre><code>function automatic [MAX_DFH_IDX-1:0][63:0] get_dfh_values();\nlogic[MAX_DFH_IDX-1:0][63:0] dfh_values;\ndfh_values[FME_DFH_IDX]        = 64'h4000_0000_1000_0000;\ndfh_values[THERM_MNGM_DFH_IDX] = 64'h3_00000_002000_0001;\ndfh_values[GLBL_PERF_DFH_IDX]  = 64'h3_00000_001000_0007;\ndfh_values[GLBL_ERROR_DFH_IDX] = 64'h3_00000_00e000_1004;\ndfh_values[QSFP0_DFH_IDX]      = 64'h3_00000_001000_0013;\ndfh_values[QSFP1_DFH_IDX]      = 64'h3_00000_001000_0013;\ndfh_values[HSSI_DFH_IDX]       = 64'h3_00000_001000_100f;\ndfh_values[EMIF_DFH_IDX]       = 64'h3_00000_001000_1009;\ndfh_values[HELLO_FIM_DFH_IDX]  = 64'h3_00000_06A000_0100;\ndfh_values[PMCI_DFH_IDX]       = 64'h3_00000_080000_1012;\ndfh_values[ST2MM_DFH_IDX]      = 64'h3_00000_030000_0014;\ndfh_values[PG_PR_DFH_IDX]      = 64'h3_00000_001000_1005;\ndfh_values[PG_PORT_DFH_IDX]     = 64'h4_00000_001000_1001;\ndfh_values[PG_USER_CLK_DFH_IDX] = 64'h3_00000_001000_1014;\ndfh_values[PG_REMOTE_STP_DFH_IDX] = 64'h3_00000_00d000_2013;\ndfh_values[AFU_ERR_DFH_IDX] = 64'h3_00001_000000_2010;\nreturn dfh_values;\nendfunction\n</code></pre> </li> <li> <p>Regenerate the simulation files</p> </li> </ol> <pre><code>cd $OFS_ROOTDIR/ofs-common/scripts/common/sim\nsh gen_sim_files.sh n6001\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#519-unit-level-test-of-the-hellofim","title":"5.1.9. Unit Level test of the HelloFIM","text":"<p>To quickly check whether the BPF can successfully communicate with the HelloFIM, execute the test_dfh_walking Unit Level Simulation. Go to sim/unit_test/dfh_walker and execute the run_sim.sh script as follows.</p> <pre><code>cd $OFS_ROOTDIR/sim/unit_test/dfh_walker\nsh run_sim.sh </code></pre> <p>Check the output for the presence of the <code>HELLO_FiM</code> module at address <code>0x16000</code>:</p> <pre><code>********************************************\nRunning TEST(0) : test_dfh_walking\n********************************************\n\n...\n\nREAD64: address=0x00016000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000010001009\n\nEMIF_DFH\n   Address   (0x15000)\nDFH value (0x3000000010001009)\nREAD64: address=0x00016000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x30000006a0000100\n\nHELLO_FIM_DFH\n   Address   (0x16000)\nDFH value (0x30000006a0000100)\nREAD64: address=0x00080000 bar=0 vf_active=0 pfn=0 vfn=0\n** Sending TLP packets **\n   ** Waiting for ack **\n   READDATA: 0x3000000800001012\n\nPMCI_DFH\n   Address   (0x80000)\nDFH value (0x3000000800001012)\n...\n\nTest status: OK\n\n********************\nTest summary\n********************\n   test_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5110-uvm-verfication-of-the-hellofim","title":"5.1.10. UVM Verfication of the HelloFIM","text":"<p>Perform the following steps to modify the UVM simulation files to support the Hello FIM design.</p> <ol> <li> <p>$OFS_ROOTDIR/verification/tests/sequences/dfh_walking_seq.svh</p> <p>a. Modify the <code>dfh_offset_array</code> to insert the Hello FIM.</p> </li> </ol> <pre><code>dfh_offset_array = new[16];\ndfh_offset_array[ 0] = tb_cfg0.PF0_BAR0;                    // FME_DFH                0x8000_0000\ndfh_offset_array[ 1] = dfh_offset_array[ 0] + 64'h0_1000;   // THERM_MNGM_DFH         0x8000_1000\ndfh_offset_array[ 2] = dfh_offset_array[ 1] + 64'h0_2000;   // GLBL_PERF_DFH          0x8000_3000\ndfh_offset_array[ 3] = dfh_offset_array[ 2] + 64'h0_1000;   // GLBL_ERROR_DFH         0x8000_4000\ndfh_offset_array[ 4] = dfh_offset_array[ 3] + 64'h0_E000;   // QSFP0_DFH              0x8001_2000\ndfh_offset_array[ 5] = dfh_offset_array[ 4] + 64'h0_1000;   // QSFP1_DFH              0x8001_3000\ndfh_offset_array[ 6] = dfh_offset_array[ 5] + 64'h0_1000;   // HSSI_DFH               0x8001_4000\ndfh_offset_array[ 7] = dfh_offset_array[ 6] + 64'h0_1000;   // EMIF_DFH               0x8001_5000\ndfh_offset_array[ 8] = dfh_offset_array[ 7] + 64'h0_1000;   // HELLO_FIM_DFH          0x8001_6000\ndfh_offset_array[ 9] = dfh_offset_array[ 8] + 64'h6_a000;   // PMCI_DFH               0x8008_0000\ndfh_offset_array[ 10] = dfh_offset_array[ 9] + 64'h8_0000;  // ST2MM_DFH              0x8010_0000\ndfh_offset_array[ 11] = dfh_offset_array[10] + 64'h3_0000;  // PG_PR_DFH_IDX          0x8013_0000\ndfh_offset_array[ 12] = dfh_offset_array[11] + 64'h0_1000;  // PG_PORT_DFH_IDX        0x8013_1000\ndfh_offset_array[ 13] = dfh_offset_array[12] + 64'h0_1000;  // PG_USER_CLK_DFH_IDX    0x8013_2000\ndfh_offset_array[ 14] = dfh_offset_array[13] + 64'h0_1000;  // PG_REMOTE_STP_DFH_IDX  0x8013_3000\ndfh_offset_array[ 15] = dfh_offset_array[14] + 64'h0_D000;  // PG_AFU_ERR_DFH_IDX     0x8014_0000\n</code></pre> <ol> <li>$OFS_ROOTDIR/verification/tests/sequences/mmio_seq.svh</li> </ol> <p>a. Add test code related to the Hello FIM. This code will verify the scratchpad register at 0x16030 and read only the register at 0x16038.</p> <pre><code>// HELLO_FIM_Scratchpad 64 bit access\n`uvm_info(get_name(), $psprintf(\"////Accessing PF0 HELLO_FIM_Scratchpad Register %0h+'h16030////\", tb_cfg0.PF0_BAR0), UVM_LOW)\nassert(std::randomize(wdata));\naddr = tb_cfg0.PF0_BAR0+'h1_6000+'h30;\nmmio_write64(.addr_(addr), .data_(wdata));\nmmio_read64 (.addr_(addr), .data_(rdata));\nif(wdata !== rdata)\n`uvm_error(get_name(), $psprintf(\"Data mismatch 64! Addr = %0h, Exp = %0h, Act = %0h\", addr, wdata, rdata))\nelse\n`uvm_info(get_name(), $psprintf(\"Data match 64! addr = %0h, data = %0h\", addr, rdata), UVM_LOW)\naddr = tb_cfg0.PF0_BAR0+'h1_6000+'h38;\nwdata = 64'h6626_0701_5000_0034;\nmmio_read64 (.addr_(addr), .data_(rdata));\nif(wdata !== rdata)\n`uvm_error(get_name(), $psprintf(\"Data mismatch 64! Addr = %0h, Exp = %0h, Act = %0h\", addr, wdata, rdata))\nelse\n`uvm_info(get_name(), $psprintf(\"Data match 64! addr = %0h, data = %0h\", addr, rdata), UVM_LOW)\n</code></pre> <p>Note: uvm_info and uvm_error statements will put a message into log file.</p> <ol> <li> <p>$OFS_ROOTDIR/verification/scripts/Makefile_VCS.mk</p> <p>a. Add <code>INCLUDE_HELLO_FIM</code> define option to enable Hello FIM on UVM</p> <pre><code>VLOG_OPT += +define+INCLUDE_HELLO_FIM\n</code></pre> </li> <li> <p>Re-generate the UVM files</p> <pre><code>cd $VERDIR/scripts\n</code></pre> <p>a. Clean the output of previous builds</p> <pre><code>gmake -f Makefile_VCS.mk clean\n</code></pre> <p>b. Compile the IP files</p> <pre><code>gmake -f Makefile_VCS.mk cmplib_adp\n</code></pre> <p>c. Build the RTL and Test Benches</p> <pre><code>gmake -f Makefile_VCS.mk build_adp DUMP=1 </code></pre> </li> </ol>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5192-run-uvm-dfh-walker-simulation","title":"5.1.9.2. Run UVM DFH Walker Simulation","text":"<p>Perform the following steps to run the UVM DFH Walker Simulation.</p> <ol> <li> <p>Run the DFH Walker simulation</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_VCS.mk run TESTNAME=dfh_walking_test DUMP=1\n</code></pre> </li> <li> <p>The output logs are stored in the $VERDIR/sim/dfh_walking_test directory. The main files to note are described in Table 5-3:</p> <p>Table 5-3 UVM Output Logs</p> File Name Description runsim.log A log file of UVM trans.log A log file of transactions on PCIe bus inter.vpd A waveform for VCS </li> <li> <p>Run the following command to quickly verify- that the Hello FIM module was successfully accessed. In the example below, the message <code>DFH offset Match! Exp = 80016000 Act = 80016000</code> shows that the Hello FIM module was successfully accessed.</p> <pre><code>cd $VERDIR/sim/dfh_walking_test\ncat runsim.log | grep \"DFH offset\"\n</code></pre> <p>Expected output:</p> <pre><code>UVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 111950000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp = 80000000 Act = 80000000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 112586000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80001000 Act = 80001000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 113222000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80003000 Act = 80003000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 113858000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80004000 Act = 80004000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 114494000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80012000 Act = 80012000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 115147000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80013000 Act = 80013000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 115801000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80014000 Act = 80014000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 116628000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80015000 Act = 80015000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 117283000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80016000 Act = 80016000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 117928000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80080000 Act = 80080000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 118594000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80100000 Act = 80100000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 119248000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80130000 Act = 80130000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 119854000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80131000 Act = 80131000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 120460000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80132000 Act = 80132000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 121065000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80133000 Act = 80133000\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/dfh_walking_seq.svh(73) @ 121672000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] DFH offset Match! Exp= 80140000 Act = 80140000\n</code></pre> </li> </ol>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5193-run-uvm-mmio-simulation","title":"5.1.9.3. Run UVM MMIO Simulation","text":"<p>Perform the following steps to run the UVM MMIO Simulation.</p> <ol> <li> <p>Run the MMIO test</p> <pre><code>cd $VERDIR/scripts\ngmake -f Makefile_VCS.mk run TESTNAME=mmio_test DUMP=1\n</code></pre> </li> <li> <p>Run the following commands to show the result of the scratchpad register and Hello FIM ID register. You can see the \"Data match\" message indicating that the registers are successfuly verified.</p> <pre><code>cd $VERDIR/sim/mmio_test\ncat runsim.log | grep \"Data\" | grep 1603\n</code></pre> <p>Expected output:</p> <pre><code>UVM_INFO /home/ofs-n6001/verification/tests/sequences/mmio_seq.svh(68) @ 115466000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] Data match 64! addr = 80016030, data = 880312f9558c00e1\nUVM_INFO /home/ofs-n6001/verification/tests/sequences/mmio_seq.svh(76) @ 116112000000: uvm_test_top.tb_env0.v_sequencer@@m_seq [m_seq] Data match 64! addr = 80016038, data = 6626070150000034\n</code></pre> </li> </ol>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5110-compile-the-intel-fpga-smartnic-n6001-pl-design-with-hello-fim","title":"5.1.10 Compile the Intel\u00ae FPGA SmartNIC N6001-PL Design with Hello FIM","text":"<p>Perform the following to compile the Hello FIM design.</p> <ol> <li> <p>Ensure the pre-requisites described in Section 5.1.5 are satisfied.</p> </li> <li> <p>Ensure that Quartus Prime Pro Version 23.1 is in your $PATH</p> </li> <li> <p>Compile the design</p> <pre><code>$OFS_ROOTDIR/ofs-common/scripts/common/syn/build_top.sh n6001 work_hello_fim\n</code></pre> </li> <li> <p>Once compilation is complete, the output files can be found in the <code>$OFS_ROOTDIR/work_hello_fim/syn/syn_top/output_files</code> directory.</p> </li> </ol>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5111-program-the-intel-fpga-smartnic-n6001-pl-with-the-hello_fim","title":"5.1.11 Program the Intel\u00ae FPGA SmartNIC N6001-PL with the hello_fim","text":"<p>Program the OFS FIM to Intel\u00ae FPGA SmartNIC N6001-PL card.</p> <p>Run <code>fpgainfo</code> command to confirm current design. The PCIe <code>s:b:d.f</code> and Bitstream Id are 0000:B1:00.0 and 360571655976424377, respectively.</p> <pre><code>$ sudo fpgainfo fme\nIntel Acceleration Development Platform n6001\nBoard Management Controller NIOS FW version: 3.11.0\nBoard Management Controller Build version: 3.11.0\n//****** FME ******//\nObject Id                        : 0xED00000\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 360571655976424377\nBitstream Version                : Pr Interface Id                  : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\nBoot Page                        : user1\nFactory Image Info               : User1 Image Info                 : User2 Image Info                 : </code></pre> <p>Move to <code>$OFS_ROOTDIR/work_hello_fim/syn/syn_top/output_files</code>. You can see <code>ofs_top_page1_unsigned_user1.bin</code> file to run 'ls'.</p> <pre><code>$ ls\nhps_bootloader_handoff.bin        ofs_top.fit.rpt                          ofs_top_page2_unsigned_user2.bin  mfg_ofs_fim_reversed.bin          ofs_top.fit.summary                      ofs_top_page2_user2.bin           ofs_pr_afu.done                   ofs_top.flow.rpt                         ofs_top.pin                       ofs_pr_afu.drc.partitioned.rpt    ofs_top.green_region.pmsf                ofs_top.sld                       ofs_pr_afu.syn.rpt                ofs_top.green_region.rbf                 ofs_top.sof                       ofs_top.asm.rpt                   ofs_top_hps.bin                          ofs_top.sta.rpt\nofs_top.done                      ofs_top_hps.hexout                       ofs_top.sta.summary\nofs_top.drc.partitioned.rpt       ofs_top_hps.pof                          ofs_top.static.msf     ofs_top.drc.synthesized.rpt       ofs_top_hps_pof.map                      ofs_top.syn.rpt\nofs_top.fit.finalize.rpt          ofs_top_hps.sof                          ofs_top.syn.summary\nofs_top.fit.place.rpt             ofs_top_page0_factory.bin                ofs_top.tq.drc.signoff.rpt\nofs_top.fit.plan.rpt              ofs_top_page0_unsigned_factory.bin       timing_report\nofs_top.fit.retime.rpt            ofs_top_page1_unsigned_user1.bin  ofs_top.fit.route.rpt             ofs_top_page1_user1.bin           </code></pre> <p>Run the <code>fpgasupdate</code> command to program the HelloFim to the Intel\u00ae FPGA SmartNIC N6001-PL.</p> <pre><code>$  sudo fpgasupdate ofs_top_page1_unsigned_user1.bin 0000:b1:00.0\n</code></pre> <p>Run the <code>rsu</code> command to re-configure FPGA on the Intel\u00ae FPGA SmartNIC N6001-PL.</p> <pre><code>$ sudo rsu bmcimg --page=user1 0000:b1:00.0\n</code></pre> <p>Run the <code>fpgainfo</code> command again to verify the HelloFIM Bitstream Id.</p> <pre><code>$ sudo fpgainfo fme\n\nOpen FPGA Stack Platform\nBoard Management Controller NIOS FW version: 3.11.0\nBoard Management Controller Build version: 3.11.0\nPBA: B#FB2CG1@AGF14-A0P2\nMMID: 217000\nSN: Q171211700050\n//****** FME ******//\nObject Id                        : 0xED00000\nPCIe s:b:d.f                     : 0000:b1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x0000\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 360571655976424377\nBitstream Version                : Pr Interface Id                  : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\nBoot Page                        : user1\nFactory Image Info               : User1 Image Info                 : User2 Image Info                 : </code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5112-verify-the-hello-fim-on-the-intel-fpga-smartnic-n6001-pl-using-opaeio-tool","title":"5.1.12 Verify the Hello FIM on the Intel\u00ae FPGA SmartNIC N6001-PL Using opae.io Tool","text":"<p>This section will describe how to access Hello FIM register via opae.io tool.</p> <p>Run the following command to confirm driver software on 0000:b1:00.0.</p> <pre><code>$ opae.io ls\nopae.io 0.2.3\n[0000:b1:00.0] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.1] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.4] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.2] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n</code></pre> <p>Run the following command to initialize opae.io tool.</p> <pre><code>$ sudo opae.io init -d 0000:b1:00.0 $USER\nUnbinding (0x8086,0xbcce) at 0000:b1:00.0 from dfl-pci\nBinding (0x8086,0xbcce) at 0000:b1:00.0 to vfio-pci\niommu group for (0x8086,0xbcce) at 0000:b1:00.0 is 186\nAssigning /dev/vfio/186 to $USER\nChanging permissions for /dev/vfio/186 to rw-rw----\n</code></pre> <p>Run the following command again to confirm driver software on 0000:b1:00.0.</p> <pre><code>$ opae.io ls\nopae.io 0.2.3\n[0000:b1:00.0] (0x8086, 0xbcce) Intel n6001 ADP (Driver: vfio-pci)\n[0000:b1:00.1] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.4] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.2] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n</code></pre> <p>Run the following command to walk through DFH register. You can see \"offset: 0x16000\" message.</p> <pre><code>$ opae.io walk -d 0000:b1:00.0\n\nfset: 0x0000, value: 0x4000000010000000\n   dfh: id = 0x0, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4\noffset: 0x1000, value: 0x3000000020000001\n    dfh: id = 0x1, rev = 0x0, next = 0x2000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x3000, value: 0x3000000010000007\n    dfh: id = 0x7, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x4000, value: 0x30000000e0001004\n    dfh: id = 0x4, rev = 0x1, next = 0xe000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x12000, value: 0x3000000010000013\n    dfh: id = 0x13, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x13000, value: 0x3000000010000013\n    dfh: id = 0x13, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x14000, value: 0x3000000010002015\n    dfh: id = 0x15, rev = 0x2, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x15000, value: 0x3000000010001009\n    dfh: id = 0x9, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x16000, value: 0x30000006a0000100\n    dfh: id = 0x100, rev = 0x0, next = 0x6a000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x80000, value: 0x3000000800002012\n    dfh: id = 0x12, rev = 0x2, next = 0x80000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x100000, value: 0x3000000300000014\n    dfh: id = 0x14, rev = 0x0, next = 0x30000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x130000, value: 0x3000000010001005\n    dfh: id = 0x5, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x131000, value: 0x4000000010001001\n    dfh: id = 0x1, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4\noffset: 0x132000, value: 0x3000000010001014\n    dfh: id = 0x14, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x133000, value: 0x30000000d0002013\n    dfh: id = 0x13, rev = 0x2, next = 0xd000, eol = 0x0, reserved = 0x0, feature_type = 0x3\noffset: 0x140000, value: 0x3000010000002010\n    dfh: id = 0x10, rev = 0x2, next = 0x0, eol = 0x1, reserved = 0x0, feature_type = 0x3\n</code></pre> <p>Run the following commands to read all registers in Hello FIM.</p> <pre><code>$ opae.io -d 0000:b1:00.0 -r 0 peek 0x16000\n0x30000000c0000100\n\n$ opae.io -d 0000:b1:00.0 -r 0 peek 0x16030\n0x0\n\n$ opae.io -d 0000:b1:00.0 -r 0 peek 0x16038\n0x6626070150000034\n</code></pre> <p>Run the following commands to verify the scratchpad register at 0x16030.</p> <pre><code>$ opae.io -d 0000:b1:00.0 -r 0 poke 0x16030 0x123456789abcdef\n\n$ opae.io -d 0000:b1:00.0 -r 0 peek 0x16030\n0x123456789abcdef\n\n$ opae.io -d 0000:b1:00.0 -r 0 poke 0x16030 0xfedcba9876543210\n$ opae.io -d 0000:b1:00.0 -r 0 peek 0x16030\n0xfedcba9876543210\n\n$ opae.io -d 0000:b1:00.0 -r 0 poke 0x16030 0x0123456789abcdef\n$ opae.io -d 0000:b1:00.0 -r 0 peek 0x16030\n0x123456789abcdef\n</code></pre> <p>Run the following commands to release opae.io tool.</p> <pre><code>$ sudo opae.io release -d 0000:b1:00.0\nReleasing (0x8086,0xbcce) at 0000:b1:00.0 from vfio-pci\nRebinding (0x8086,0xbcce) at 0000:b1:00.0 to dfl-pci\n</code></pre> <p>Run the following command again to confirm driver software on 0000:b1:00.0.</p> <pre><code>$ opae.io ls\n[0000:b1:00.0] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.1] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.4] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n[0000:b1:00.2] (0x8086, 0xbcce) Intel n6001 ADP (Driver: dfl-pci)\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#52-debugging-the-fim-with-signal-tap","title":"5.2. Debugging the FIM with Signal Tap","text":"<p>For debugging issues within the FIM, Signal Tap can be used to gain internal visibility into your design. This section describes the process of adding a Signal Tap instance to your Hello FIM design example described previously.</p> <p>For more detailed information on Signal Tap please see:</p> <ul> <li>Understanding of Signal Tap fundamentals - please review Quartus Prime Pro Edition User Guide: Debug Tools (RDC Document ID 683819).</li> </ul> <p>Signal Tap uses the Intel FPGA Download Cable II USB device to provide access. Please see [Intel FPGA Download Cable II] for more information and this device is widely available via distributors for purchase.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#521-adding-signal-tap-to-the-hello-fim-example","title":"5.2.1. Adding Signal Tap to the Hello FIM example","text":"<ol> <li> <p>The following steps guide you through the process of adding a Signal Tap instance to your design. The added Signal Tap instance provides hardware to capture the desired internal signals and connect the stored trace information via JTAG. Please be aware that the added Signal Tap hardware will consume FPGA resources and may require additional floorplanning steps to accommodate these resources. Some areas of the FIM use logic lock regions and these regions may need to be re-sized. These steps assume the use of the n6001.</p> <p>The steps below use the hello_fim example to add Signal Tap, however the general process can be used for any design.</p> <ol> <li> <p>The design must have been compiled before adding Signal Tap. If using the previously built Hello FIM design, copy the work directory and rename it so that we have a work directory dedicated to the Hello FIM Signal Tap design.</p> <pre><code>cp -r $OFS_ROOTDIR/work_hello_fim $OFS_ROOTDIR/work_hello_fim_with_stp\n</code></pre> </li> <li> <p>Open the Hello FIM Signal Tap project in the Intel Quartus Prime Pro GUI. The Intel Quartus Prime Pro project is named ofs_top.qpf and is located in the work directory $OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top/ofs_top.qpf.</p> </li> <li> <p>Once the project is loaded, select Tools &gt; Signal Tap Logic Analyzer to open the Signal Tap GUI.</p> </li> </ol> </li> </ol> <p></p> <p>4. Accept the \"Default\" selection and click \"Create\".</p> <p></p> <ol> <li>This brings up the Signal Tap Logic Analyzer window as shown below</li> </ol> <p></p> <ol> <li>Set up the clock for the STP instance. This example instruments the hello_fim_top module previously intetegrated into the FIM. If unfamiliar with code, it is helpful to use the Quartus Project Navigator to find the block of interest and open the design instance for review. For example, see the image below using Project Navigator to open the top module where hello_fim_top_inst is instantiated.</li> </ol> <p></p> <p></p> 7. Assign the clock for sampling the Signal Tap instrumented signals of interest. Note, that the clock selected should correspond to the signals you want to view for best trace fidelity. Different clocks can be used, however, there maybe issues with trace inaccuracy due to sampling time differences. In the middle right of the Signal Tap window, under Signal Configuration, Clock:, select \"\u2026\" as shown below: <p></p> <p></p> 8. In the Node Finder tool that popped up, input \"hello_fim_top_inst|clk\" into the \"Named:\" textbox and click \"Search\". Select \"clk\" in the Matching Nodes list and click the \"&gt;\" button to select this clock as shown below. Click \"OK\" to close the Node Finder dialog. <p></p> <p></p> 9. Update the sample depth and other Signal Tap settings as needed for your debugging criteria. <p></p> <ol> <li>In the Signal Tap GUI add the nodes to be instrumented by double-clicking on the \"Double-click to add nodes\" legend.</li> </ol> <p></p> <p></p> 11. This brings up the Node Finder to add the signals to be traced. Select the signals that appear from the  search patterns hello_fim_top_inst|reset and hello_fim_top_inst|csr_lite_if*. Click Insert and close the Node Finder dialog. <p></p> <p></p>  12. To provide a unique name for your Signal Tap instance, select \"auto signaltap_0\", right-click, and select Rename Instance (F2). Provide a descriptive name for your instance, for example, \"STP_For_Hello_FIM\". <p></p> <p></p> 13. Save the newly created Signal Tap file, and give it the same name as the instance. <p></p> <p></p> 14. In the dialog that pops up, click \"Yes\" to add the newly created Signal Tap file to the project settings files. <p></p> <p></p> <p><pre><code>   # Answer 'Yes' to add the following lines to the end of the project's **ofs_top.qsf** file.\nset_global_assignment -name ENABLE_SIGNALTAP ON\n   set_global_assignment -name USE_SIGNALTAP_FILE STP_For_Hello_FIM.stp\n   set_global_assignment -name SIGNALTAP_FILE STP_For_Hello_FIM.stp\n</code></pre> Close all Quartus GUIs.</p> <ol> <li> <p>Compile the project with the Signal Tap file added to the project. Use the -k switch to perform the compilation using the files under the working directory you just edited and not the original ones from the cloned repository. </p> <pre><code>   $ ofs-common/scripts/common/syn/build_top.sh -k n6001 work_hello_fim_with_stp\n</code></pre> </li> <li> <p>Make sure the compile completes successfully and meets timing, see below.</p> <pre><code>   ***********************************\n   ***\n   ***        OFS_PROJECT: n6001\n   ***        Q_PROJECT:  ofs_top\n   ***        Q_REVISION: ofs_top\n   ***        SEED: 106\n***        Build Complete\n   ***        Timing Passed!\n   ***\n   ***********************************\n</code></pre> </li> </ol> <p>Alternatively, you can copy the ofs_top.qsf and STP_For_Hello_FIM.stp files from the Hello FIM with STP work directory to replace the original files in the cloned OFS repository. In this scenario, all further FIM compilation projects will include the Signal Tap instance integrated into the design. Execute the following commands for this alternative flow:</p> <p>Copy the modified file \"work_hello_fim_with_stp/syn/syn_top/ofs_top.qsf\" over to the source OFS repository, into \"syn/syn_top/\".</p> <pre><code>cd $OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top\ncp ofs_top.qsf $OFS_ROOTDIR/syn/syn_top\ncp STP_For_Hello_FIM.stp $OFS_ROOTDIR/syn/syn_top\n</code></pre> <p>Compile the FIM using the files from the OFS repository to create a new work directory.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh n6001 work_hello_fim_with_stp_from_src_repo\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#522-downloading-ofs_top_hpssof-into-the-fpga-using-jtag","title":"5.2.2 Downloading ofs_top_hps.sof into the FPGA using JTAG","text":"<p>Every successful run of <code>build_top.sh</code> script creates the file $OFS_ROOTDIR/syn/syn_top/output_files/ofs_top_hps.sof which can be used with the Intel Download Cable II to load the image into the FPGA using the Intel\u00ae FPGA SmartNIC N6001-PL JTAG access connector. </p> <p>NOTE: You are encouraged to initially load the **ofs_fim_hps.sof file for testing new versions of your FIM because if there is an issue with your new FIM that prevents the host from accessing the FPGA via PCIe, then you can load a known good ofs_fim_hps.sof file to recover.**</p> <p>The following steps load the ofs_fim_hps.sof created in the previous section into the Intel\u00ae Agilex\u00ae FPGA using the Intel FPGA Download Cable.  Use these FPGA loading steps for initial testing of newly created FIMs. You will also use the Intel Download II Cable to access the Signal Tap instance via JTAG.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5221-connecting-to-intel-download-cable-ii","title":"5.2.2.1 Connecting to Intel Download Cable II","text":"<p>The Intel\u00ae FPGA SmartNIC N6001-PL has a 10 pin JTAG header on the top side of the board.  This JTAG header provides access to either the Intel\u00ae Agilex\u00ae FPGA or MAX\u00ae 10 BMC device.  The steps below instruct you in how to set DIP switches on the back side of the board to dynamically select either the Intel\u00ae Agilex\u00ae FPGA or MAX\u00ae 10 device on the JTAG chain.</p> <p>1. Set SW1.1=ON as shown in the next image. The switches are located at the back of the Intel\u00ae FPGA SmartNIC N6001-PL.</p> <p></p> <p>Connect an Intel\u00ae FPGA Download II Cable to the JTAG header of the Intel\u00ae FPGA SmartNIC N6001-PL as shown in picture below.   This picture shows the Intel\u00ae FPGA SmartNIC N6001-PL card installed in the middle bay, top slot of a SuperMicro\u00ae SYS-220HE-FTNR server where the lower slot does not have card installed allowing the Intel\u00ae Download II cables to pass through removed the slot access. </p> <p></p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#5222-programming-the-fpga-image-using-jtag","title":"5.2.2.2 Programming the FPGA Image using JTAG","text":"<p>Access the Intel\u00ae Agilex\u00ae FPGA through the JTAG interface by writing the FIM's PMCI PMCI registers at address 0x2040c and 0x20400.</p> <p>Important: Execute the commands as root user.</p> <p>Note: The commands below use Intel\u00ae FPGA SmartNIC N6001-PL board PCIe B.D.f of b1:00, please use the correct PCIe B.D.f for your target Intel\u00ae FPGA SmartNIC N6001-PL card.</p> <pre><code> sudo su\n# Enter the root password.\nopae.io init -d 0000:b1:00.0 $USER\nopae.io -d 0000:b1:00.0 -r 0 poke 0x2040c 0x100000000\nopae.io -d 0000:b1:00.0 -r 0 poke 0x20400 0x37800000002\nopae.io release -d 0000:b1:00.0\n\nexit\n</code></pre> <p>Note: Every time you load a new FPGA SOF file, you will need to execute the above commands prior to running the Quartus programmer.</p> <ol> <li> <p>The SOF file is located in the work directory $OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top/output_files/ofs_top_hps.sof. If the target FPGA is on a different server, then transfer ofs_top_hps.sof and STP_For_Hello_FIM.stp files to the server with the target FPGA.</p> </li> <li> <p>You can use a Full Quartus Installation or Standalone Quartus Prime Programmer &amp; Tools running on the machine where the Intel\u00ae FPGA SmartNIC N6001-PL is installed or on a separte machine sucha as a laptop.</p> <p>You can download the Quartus II Prime Programmer and Tools by clicking on the \"Additional Software\" tab as shown in the FPGA download page. The Quartus II prime Programmer and Tools come with Quartus programmer as well as System Console which are needed to program the flash devices.</p> </li> </ol> <p>Note If using the Intel FGPA download Cable on Linux, add the udev rule as described in Intel\u00ae FPGA Download Cable (formerly USB-Blaster) Driver for Linux*.</p> <ol> <li> <p>Verify the cable is successfully connected with the jtagconfig command. You should see the next output, which indicates the JTAG interface targets the Intel\u00ae Agilex\u00ae FPGA.</p> <pre><code>jtagconfig\n\n1) USB-BlasterII [1-6]\n4341A0DD   AGFB014R24A\n</code></pre> <p>Note: The jtagconfig command is located in $QUARTUS_ROOTDIR/bin.  If you are running jtagconfig from another directory, you may see \"jtagconfig: command not found...\". The  workaround is to add the location of the command to the PATH environment variable.     <pre><code>export PATH=$PATH:$QUARTUS_ROOTDIR/bin\n</code></pre></p> </li> <li> <p>Temporarily disable the PCIe AER feature. This is required because when you program the FPGA using JTAG, the Intel\u00ae FPGA SmartNIC N6001-PL PCIe link goes down for a moment causing a server surprise link down event. To prevent this server event, temporarily disable PCIe AER and remove the root port connected to the Intel\u00ae FPGA SmartNIC N6001-PL PCIe slot using the following steps:</p> </li> </ol> <p>Find the root port connected to the Intel\u00ae FPGA SmartNIC N6001-PL.  In this example, the Intel\u00ae FPGA SmartNIC N6001-PL is assigned PCIe BDF b1:00, so you will use Linux lspci tree command to determine the root port.  </p> <p><pre><code>    $ lspci -t\n\n...\n    ...\n     +-[0000:e2]-+-00.0\n |           +-00.1\n |           +-00.2\n |           \\-00.4\n +-[0000:c9]-+-00.0\n |           +-00.1\n |           +-00.2\n |           \\-00.4\n +-[0000:b0]-+-00.0\n |           +-00.1\n |           +-00.2\n |           +-00.4\n |           \\-02.0-[b1]--+-00.0   *****Here is the desired Intel\u00ae FPGA SmartNIC N6001-PL on B1:00*****\n |                        +-00.1\n |                        +-00.2\n |                        +-00.3\n |                        \\-00.4\n...\n...\n</code></pre> From the lspci -t command, the root port PCIe BDF is b0:02.0.</p> <p>Disable AER on the Intel\u00ae FPGA SmartNIC N6001-PL PCIe root port and remove the root port using the commands entered as root.</p> <p><pre><code>sudo su\n# type in the root password.      \n</code></pre> <pre><code>setpci -s 0000:b0:02.0 ECAP_AER+0x08.L=0xFFFFFFFF\nsetpci -s 0000:b0:02.0 ECAP_AER+0x14.L=0xFFFFFFFF\necho 1 &gt; /sys/bus/pci/devices/0000\\:b0\\:02.0/remove\n</code></pre></p> <ol> <li> <p>Launch \"Quartus Prime Programmer\" software with the following command.</p> <pre><code>quartus_pgmw\n</code></pre> <p>Click on Hardware Setup, select USB-Blaster II in the Current Selected Hardware list, and ensure the JTAG Hardware Frequency is set to 16Mhz (The default is 24MHz).</p> <p></p> </li> </ol> <p>The following command can be used alternatively, <code>jtagconfig \u2013setparam \u201cUSB-BlasterII\u201d JtagClock 16M</code>.</p> <ol> <li> <p>Click the Auto Detect and make sure the Intel\u00ae Agilex\u00ae FPGA Device is shown in the JTAG chain.</p> <p></p> </li> <li> <p>Intel\u00ae Agilex\u00ae FPGA .sof Programming.       Right-click on the first cell below the 'File' column and click on 'Change file'</p> <p> </p> </li> <li> <p>Select the generated ofs_top_hps.sof file for the Intel\u00ae Agilex\u00ae FPGA with the Signal Tap instrumented Hello FIM example. Remember that the output files are located under work_x16_adp_hello_fim_with_stp/syn/syn_top/output_files/.</p> <p></p> </li> <li> <p>Check the checkbox below \"Program/Configure\" column and click on 'Start' to program this .sof file. After successful programming, you can close the \"Quartus Prime Programmer\" software. You can answer 'No' if a dialog pops up asking to save the 'Chain.cdf' file. This completes the Intel\u00ae Agilex\u00ae FPGA .sof programming.</p> </li> <li> <p>Rescan PCIe Bus as root user. Important, enter the command as root:</p> <p><pre><code>sudo su\n   # type in the root password.\n</code></pre> <pre><code>echo 1 &gt; /sys/bus/pci/rescan\nexit\n</code></pre></p> </li> <li> <p>Verify the Intel\u00ae FPGA SmartNIC N6001-PL is present by comparing the $OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top/fme_id.txt value to the PR Interface Id value read from <code>fpgainfo fme</code> - the two values should be identical:</p> <p>```bash  sudo fpgainfo fme      Intel Acceleration Development Platform     Board Management Controller NIOS FW version: 3.11.0      Board Management Controller Build version: 3.11.0      //****** FME ******//     Object Id                        : 0xEE00000     PCIe s:b:d.f                     : 0000:98:00.0     Device Id                        : 0xBCCE     Socket Id                        : 0x00     Ports Num                        : 01     Bitstream Id                     : 360571655976424377      Bitstream Version                :      Pr Interface Id                  : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c      Boot Page                        : user1</p> </li> </ol> <p>cat $OFS_ROOTDIR/work_hello_fim_with_stp/syn/syn_top/fme_id.txt     4514ee67-ca01-5def-9fa5-a1ef30d0c76c     ```</p> <p>Note: To later re-direct the JTAG back to the MAX 10 device, execute the following commands.</p> <p><code># opae.io init -d 0000:b1:00.0 $USER          # opae.io -d 0000:b1:00.0 -r 0 poke 0x2040c 0x000000000          # opae.io -d 0000:b1:00.0 -r 0 poke 0x20400 0x37800000002          # opae.io release -d 0000:b1:00.0</code></p> <p>Optionally, rather than dynamically commanding Intel\u00ae Agilex\u00ae FPGA/MAX10 selection with the PMCI register settings, you can fix the selection with the following switch settings shown in the table below:</p> SW1.1 SW2 JTAG Target OFF OFF Intel\u00ae Agilex\u00ae FPGA OFF ON MAX\u00ae 10 FPGA ON X Intel\u00ae Agilex\u00ae FPGA if PMCI register <code>0x2040c=0x1</code>, <code>0x20404=0x378</code>, and <code>0x20400=0x2</code> ON X Intel\u00ae Agilex\u00ae FPGA if PMCI register <code>0x2040c=0x1</code>, <code>0x20404=0x378</code>, and <code>0x20400=0x2</code>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#523-signal-tap-trace-acquisition-of-hello-fim-signals","title":"5.2.3. Signal Tap trace acquisition of Hello FIM signals","text":"<ol> <li> <p>Once the instrumented HelloFIM SOF file is downloaded into the Intel\u00ae Agilex\u00ae FPGA, start the Quartus Signal Tap GUI.</p> <p><pre><code>quartus_stpw\n#The Signal Tap GUI comes up.\n</code></pre> 2. In the Signal Tap GUI, open your STP file. Your STP file settings will load.</p> <p> 3. In the right pane of the Signal Tap GUI, in Hardware: selection box, select the cable \"USB-BlasterII\".</p> <p></p> </li> <li> <p>Make sure the Intel\u00ae Agilex\u00ae FPGA Device is displayed in the Device: list as shown below. If not, click the 'Scan Chain' button to re-scan the JTAG device chain.</p> <p></p> </li> <li> <p>If not already set, you can create the trigger conditions, for example.</p> <p></p> </li> <li> <p>Start analysis by selecting the 'STP_For_Hello_FIM' instance and pressing 'F5'. You should see a green message indicating the Acquisition is in progress. Then, move to the 'Data Tab to observe the signals captured.</p> <p></p> </li> <li> <p>To generate traffic in the 'csr_lite_if' signals of the Hello FIM module, go back to the terminal and walk the DFH list or peek/poke the Hello FIM registers as was done during the creation of the Hello FIM design example. For instance, the next image shows the activity of the instrumented signals when walking the DFH list with the commands below.</p> <pre><code>   $ opae.io init -d 0000:b1:00.0 $USER\n   $ opae.io walk -d 0000:b1:00.0\n   $ opae.io release -d 0000:b1:00.0\n</code></pre> <p></p> </li> <li> <p>The PCIe AER feature is automatically re-enabled by rebooting the server. </p> </li> </ol> <p>This concludes the example on how to instrument an OFS FIM with the Quartus Prime Signal Tap Logic Analyzer.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#6-compiling-the-fim-in-preparation-for-designing-your-afu","title":"6. Compiling the FIM in preparation for designing your AFU","text":"<p>The default Host Exercisers in the FIM can be replaced by a \"he_null\" block during compile-time. There are a few things to note:</p> <p>* \"he_null\" is a minimal block with registers that responds to PCIe MMIO request. MMIO responses are required to keep PCIe alive (end points enabled in PCIe-SS needs service downstream requests).</p> <p>* If an exerciser with other I/O connections such has \"he_mem\" or \"he_hssi\" is replaced, then then those I/O ports are simply tied off.</p> <p>* The options supported are <code>null_he_lb</code>, <code>null_he_hssi</code>, <code>null_he_mem</code> and <code>null_he_mem_tg</code>. Any combination, order or all can be enabled at the same time. </p> <p>* Finer grain control is provided since the user may just turn off the exercisers in Static region to save area. </p> <p>To compile a FIM for where the exercisers are removed and replaced with a he_null module and keeping the PF/VF multiplexor connections, execute the following command.</p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p n6001:null_he_lp          ,null_he_hssi,null_he_mem,null_he_mem_tg work_null_he\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#7-how-to-resize-the-partial-reconfiguration-region","title":"7. How to resize the Partial Reconfiguration region","text":"<p>The OFS for Intel\u00ae Agilex\u00ae FPGA flow provides the FIM code to the user to enable full customization for your application needs.</p> <p>To take advantage of the available resources in the Intel\u00ae Agilex\u00ae FPGA for an AFU design, you can adjust the size of the AFU PR partition. An example reason for the changing the size of PR region is if you add more logic to the FIM region, then you may need to adjust the PR region to fit the additional logic into the static region.  Similarly, if you reduce logic in the FIM region, then you can adjust the PR region to provide more logic resources for the AFU.</p> <p>After the compilation of the FIM, the resources usage broken down by partitions as reported in the following two files <pre><code>$OFS_ROOTDIR/syn/syn_top/output_files/ofs_top.fit.place.rpt\n$OFS_ROOTDIR/syn/syn_top/output_files/ofs_top.fit.rpt\n</code></pre></p> <p>The next is a report of the resources usage by partitions defined for the FIM. </p> <p></p> <p>In this case, the default size for the afu_top|port_gasket|pr_slot|afu_main PR partition is large enough to hold the logic of the default AFU, which is mainly occupied by the Host Exercisers. However, larger designs might require additional resources.</p> <p>To customize the resources allocated to the AFU in the PR regions follow the next iterative process.</p> <ol> <li>The OFS flow provides the TCL file <code>$OFS_ROOTDIR/syn/setup/pr_assignments.tcl</code> which defines the PR partition where the AFU is allocated.</li> </ol> <p></p> <ol> <li> <p>Use Quartus Chip Planner to identify the locations of the resources available within the Intel\u00ae Agilex\u00ae FPGA chip for placement and routing your AFU. You need to identify a pair of coordinates, the origin (X0, Y0) and top right corner (X1, Y1) of the new or existing rectangles to modify as shown in the following image. </p> <p>The image below shows the coodinates for Region1.</p> </li> </ol> <p></p> <p>The coordinates of the top right corner of the lock regions are computed indirectly based on the Width and Height, as follows.</p> <pre><code>X1 = X0 + Width \nY1 = Y0 + Height\n</code></pre> <ol> <li> <p>Make changes to the pr_assignments.tcl based on your findings in Quartus Chip Planner. You can modify the size and location of existing lock regions or add new ones and assign them to the AFU PR partition.</p> </li> <li> <p>Recompile your FIM and create the PR relocatable build tree using the following commands.</p> </li> </ol> <p><pre><code>cd $OFS_ROOTDIR    ofs-common/scripts/common/syn/build_top.sh -p n6001 work_&lt;your directory&gt;\n</code></pre> 6. Analyze the resource utilization report per partition produced after recompiling the FIM.</p> <ol> <li>Perform further modification to the PR regions until the results are satisfactory. Make sure timing constraints are met.</li> </ol> <p>For more information on how to optimize the floor plan of your Partial Reconfiguration design refer to the following online documentation.</p> <ul> <li>Analyzing and Optimizing the Design Floorplan</li> </ul> <ul> <li>Partial Reconfiguration Design Flow - Step 3: Floorplan the Design</li> </ul>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#8-how-to-modify-the-memory-subsystem","title":"8. How to modify the Memory Subsystem","text":"<p>OFS allows performing modifications on the subsystems in the FIM. To customize the Memory Subsystem follow these instructions.</p> <ol> <li>Within the cloned OFS repository, go to the directory containing the Memory Subsystem IP file <code>mem_ss_fm.ip</code>.</li> </ol> <pre><code>cd $OFS_ROOTDIR/ipss/mem/qip/mem_ss\n</code></pre> <ol> <li>Open the Memory Subsystem IP file in Platform Designer to perform the required edits. </li> </ol> <pre><code>qsys-edit mem_ss_fm.ip  </code></pre> <p>The IP Parameter Editor GUI comes up with the default tab \"TCAM\" selected as shown below:</p> <p></p> <ol> <li>Select the \"Memory Interfaces\" tab and then select the tab \"Interface 4\"    The figure below shows the GUI of the platform designer with the current configuration of the Memory Subsystem.</li> </ol> <p></p> <p>As an example, the figure below highlights the drop-down list option to change the width of the data bus (Memory DQ width) to the HPS subsystem, from a 40-bits wide (with ECC) configuration to a 32-bits wide (no ECC) configuration. Similarly, Platform Designer allows performing configuration edits to any of the available memory interfaces.</p> <p></p> <p>The next step is to generate the HDL code that reflects the configuration edits performed. For this, click the Generate HDL... button at the bottom right corner of the Platform Designer window. In the dialog that appears next, review and modify the HDL generation options and click the Generate button at the bottom right corner of the dialog.</p> <p></p> <p>Once the generation process is finished, close the Platform designer dialogs. </p> <ol> <li>Open the <code>$OFS_ROOTDIR/src/top/top.sv</code> file. Comment out line 37, and declare a non_ecc interface in line 38, as shown in the figure below.</li> </ol> <p></p> <ol> <li>Similarly, open the <code>$OFS_ROOTDIR/ipss/mem/rtl/mem_ss_top.sv</code> file. Comment out line 35, and declare a non_ecc interface in line 46, as shown in the figure below.</li> </ol> <p></p> <ol> <li>Since the ECC feature of the DDR interace to the HPS has been disabled, the physical pin assignments to corresponding byte (DQ/DQS signals) are not required. Thus, comment out the location_assigments below the line \"# HPS DQS4 (ECC)\" in the file <code>$OFS_ROOTDIR/syn/setup/emif_loc.tcl</code>. Use the figure below as reference.</li> </ol> <p></p> <p>The configuration edits were performed to affect the original set of files of the cloned OFS repository. Therefore, these modifications will be carried over to any new FIM compilation performed hereafter. Recall that the FIM compilation process links and copies files over from the cloned and just modified OFS repository to the FIM compilation work directory given as input to the compilation scripts.</p> <ol> <li>Back in the terminal, execute the <code>build_top.sh</code> command to compile a new FIM that incorporates the newly configured Memory Subsystem. The next command example performs the compile of the BASE x16 FIM in a clean work directory named work_x16_adp__MemSS_HPS_32b_NoECC.</li> </ol> <pre><code># Return to the root directory of the OFS repository\ncd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh n6001 work_x16_adp_MemSS_HPS_32b_NoECC\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#9-how-to-compile-the-fim-with-no-hssi-for-the-intel-fpga-smartnic-n6001-pl","title":"9. How to compile the FIM with no hssi for the Intel\u00ae FPGA SmartNIC N6001-PL","text":"<p>The FIM n6001:no_hssi is derived from the base Intel\u00ae FPGA SmartNIC N6001-PL FIM, with the transceiver subsystem removed. To perform the flat compile of the n6001:no_hssi, pass the <code>no_hssi</code> option to the <code>build_top.sh</code> script, as follows. </p> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh n6001:no_hssi,flat work_N6001_base_x16_adp_no_hssi\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#10-how-to-change-the-pcie-device-id-and-vendor-id","title":"10. How to change the PCIe device ID and Vendor ID","text":"<p>The PCIe configuration registers contains the Vendor, Device and Subsystem Vendor ID registers which are used in PCIe add-in cards to uniquely identify the card for assignment to software drivers.  OFS has these registers set with Intel values for out of the box usage.  If you are using OFS for a PCIe add in card that your company manufactures, then update the PCIe Subsytem Subsystem ID and Vendor ID registers as described below and change OPAE provided software code to properly operate with your company's register values.</p> <p>The Vendor ID is assigned to your company by the PCI-SIG (Special Interest Group). The PCI-SIG is the only body officially licensed to give out IDs. You must be a member of PCI-SIG to request your own ID. Information about joining PCI-SIG is available here: PCI-SIG. You select the Subsystem Device ID for your PCIe add in card.</p> <p>Follow the instructions below to customize the PCIe device ID and Vendor ID of the Intel\u00ae FPGA SmartNIC N6001-PL.</p> <p>You can display the current settings using the command <code>lspci -nvmms &lt;PCIe B.D.f&gt;</code> as shown below:</p> <pre><code>$ lspci -nvmms 98:00\nSlot:   98:00.0\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nRev:    01\nNUMANode:       1\n\nSlot:   98:00.1\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\n\nSlot:   98:00.2\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\n\nSlot:   98:00.3\nClass:  1200\nVendor: 1af4\nDevice: 1000\nSVendor:        1af4\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\n\nSlot:   98:00.4\nClass:  1200\nVendor: 8086\nDevice: bcce\nSVendor:        8086\nSDevice:        1771\nPhySlot:        1\nNUMANode:       1\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#101-changing-the-pcie-subsystem-device-id-and-vendor-id","title":"10.1. Changing the PCIe Subsystem Device ID and Vendor ID","text":"<p>You will use IP Parameter Editor to modify the PCIe configuration registers.</p> <ol> <li>Navigate to the PCIe Subsystem IP file and bring up IP Parameter Editor to change values.</li> </ol> <p><pre><code>cd $OFS_ROOTDIR/ipss/pcie/qip\nqsys-edit pcie_ss.ip\n\n#The above command starts up the IP Parameter Editor GUI.  Close any tool pop-ups.\n</code></pre> The Editor comes up as shown below:</p> <p></p> <ol> <li>Scroll down through the PCIe subsystem settings tabs to the PCIe Interfaces 0 Ports Settings tab as shown below:</li> </ol> <p></p> <p>Select the PCIe0 Device Identification Registers tab. You can edit the values of Vendor ID, Device ID, Subsystem Vendor ID and Subsystem Device ID for each PF/VF in use.</p> <ol> <li>Once you have made changes, click Generate HDL and save. </li> <li>Build your new FPGA image with build_top.sh script</li> </ol> <pre><code>cd $OFS_ROOTDIR\n#Set required OFS environment variables\n./ofs-common/scripts/common/syn/build_top.sh -p n6001 work_pcie_vid\n</code></pre> <p>Once your image is built and passes timing, be aware that OPAE FPGA management commands require recognition of the FPGA PCIe Device ID for control.  If there is a problem between OPAE management recognition of FPGA PCIe values, then control of the card will be lost.  For this reason, you are strongly encouraged to use the [JTAG FPGA Download method]  to load the test FPGA image.  If there is a problem with the SOF image working with your host software that is updated for the new PCIe settings, then you can load a known good SOF file to recover.  Once you sure that both the software and FPGA work properly, you can load the FPGA into FPGA flash using the OPAE command <code>fpgasupdate</code>.</p> <p>The changes to software required to work with new PCIe settings are described in [Software Reference Manual: Open FPGA Stack]</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#11-migrating-intel-fpga-smartnic-n6001-pl-to-a-different-device-part-number","title":"11. Migrating Intel\u00ae FPGA SmartNIC N6001-PL to a different device part number","text":"<p>The following instructions enable a user to change the device part number of the Intel\u00ae FPGA SmartNIC N6001-PL. Please beware that this release works with Intel\u00ae Agilex\u00ae FPGA devices that have P tile for PCIe and E tile for Ethernet.  Other tiles will take further work.</p> <p>A user my want to change the device part number for the following reasons</p> <p>1) Migrate to same device package but with a larger density 2) Migrate to a different package and with a larger or same density</p> <p>The default device for the Intel\u00ae FPGA SmartNIC N6001-PL is AGFB014R24A2E2V</p> <p>The instructions below will describe how to change the device to a different package and with a larger density</p> <pre><code>cd $OFS_ROOTDIR\n</code></pre> <p>The following command will be used to to alter the device part number throughout $OFS_ROOTDIR directory</p> <pre><code>grep -rli 'default_OPN' * | xargs -i@ sed -i 's/default_OPN/new_OPN/g' @\n</code></pre> <p>where there are two fields to change</p> <pre><code>default_OPN\nnew_OPN\n</code></pre> <p>So in this case below the user changes the default device part number from AGFB014R24A2E2V to AGFB022R25A2E2V</p> <pre><code>grep -rli 'AGFB014R24A2E2V' * | xargs -i@ sed -i 's/AGFB014R24A2E2V/AGFB022R25A2E2V/g' @\n</code></pre> <p>This  changes all occurrences of the default device (AGFB014R24A2E2V) in the $OFS_ROOTDIR directory to the new device number (AGFB022R25A2E2V)</p> <p>Since the new device is targeting a different package the current pin location constraints will not work and the user will have to comment out all pin location constraints in the following files located at $OFS_ROOTDIR/syn/setup</p> <pre><code>emif_loc.tcl\nhps_loc.tcl\npmci_loc.tcl\ntop_loc.tcl\n</code></pre> <p>e.g </p> <pre><code>#set_location_assignment PIN_CU26 -to hssi_rec_clk[0]\n</code></pre> <p>The user must then run the $OFS_ROOTDIR/ofs-common/scripts/common/syn/build_top.sh script to check if the design fits. More than likely the user will need to place some Transceiver refclk pins (normal Txcvr and PCIe refclk) to guide the fitter. Please adjust the pin constraints based on the messages in the fitter.</p> <p>Quartus compilation will then be successful. To preserve the pin assignments the user must then hard code all of the new pin assignments back into the following files to provide deterministic results.</p> <pre><code>emif_loc.tcl\nhps_loc.tcl\npmci_loc.tcl\ntop_loc.tcl\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#12-how-to-change-e-tile-ethernet-subsystem-from-8-x-25-gbe-to-8-x-10-gbe","title":"12. How to change E-Tile Ethernet Subsystem from 8 X 25 GbE to 8 X 10 GbE","text":"<p>This section describes steps to change the E-Tile Ethernet Subsystem from 8 X 25 GbE to 8 X 10 GbE. </p> <ol> <li>Edit E-Tile Ethernet  IP Subsystem $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip to be 8 X 10 GbE using IP Platform Editor.</li> </ol> <p><pre><code>cd $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss\nqsys-edit hssi_ss_8x25g.ip\n</code></pre> 2. The IP Parameter Editor comes up - expect 2-5 minutes for this process to complete.  When pop-up indicates Open System Completed, click 'Close'.  The General Configuration window comes up, scroll down and switch ports 0 to 7 from 25GbE to 10GbE as shown below:</p> <pre><code>![](images\\ip_param_editor_10g_1.png)\n</code></pre> <ol> <li> <p>Click the IP Configuration tab and note the default settings of OFF for AN/LT and SYNCE.  You may optionally change these settings based on your application needs. The settings for P0 IP cover ports 0 to 3.  The settings for P4 cover ports 4 to 7.</p> <p></p> </li> <li> <p>Click \"P0 Configuration\" tab and note the default settings for maximum frame size.  You may optionally change these settings based on your application needs.  Set \"P4 Configuration\" as needed. </p> <p></p> </li> <li> <p>Leave other settings at default values.</p> </li> <li>Click <code>File</code> and <code>Save As</code> hssi_ss_8x10g.  Click <code>Generate HDL</code> in the bottom right hand corner of IP Editor and enable simulation support.</li> <li> <p>Edit $OFS_ROOTDIR/ipss/hssi/eth_design_files.tcl to comment out 8x25g and add in 8x10g.ip <pre><code>#-----------------\n# HSSI SS IP\n#-----------------\n#set_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_8x10g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/ptp_iopll/ptp_sample_clk_pll.ip\n</code></pre></p> </li> <li> <p>Edit $OFS_ROOTDIR/syn/syn_top/ofs_top.qsf and $OFS_ROOTDIR/syn/syn_top/ofs_pr_afu.qsf to add new macro definition:</p> </li> </ol> <pre><code>set_global_assignment -name VERILOG_MACRO \"ETH_10G\"                  # Change Ethernet from 8x25 to 8x10 GbE\n</code></pre> <ol> <li>Build new 8x10G FIM.</li> </ol> <pre><code>cd $OFS_ROOTDIR\nofs-common/scripts/common/syn/build_top.sh -p n6001 work_8x10gbe\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#13-how-to-change-e-tile-ethernet-subsystem-from-8-x-25-gbe-to-2-x-100-gbe","title":"13. How to change E-Tile Ethernet Subsystem from 8 X 25 GbE to 2 X 100 GbE","text":"<p>This section describes steps to change the E-Tile Ethernet Subsystem from 8 X 25 GbE to 2 x 100 GbE. </p> <ol> <li>Edit E-Tile Ethernet  IP Subsystem $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip to be 2 X 100 GbE using IP Platform Editor.</li> </ol> <p><pre><code>cd $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss\nqsys-edit hssi_ss_8x25g.ip\n</code></pre> 2. The IP Parameter Editor comes up - expect 2-5 minutes for this process to complete.  When pop-up indicates Open System Completed, click 'Close'.  The General Configuration window comes up, change ports to 2 and set \"PORT0_PROFILE\" and \"PORT4_PROFILE\" to \"100GCAUI-4\" as shown below:</p> <p>\u200b   </p> <ol> <li> <p>Click the IP Configuration tab and note the default settings of OFF for AN/LT.  You may optionally change these settings based on your application needs.</p> <p></p> </li> <li> <p>Click \"P0 Configuration\" tab and note the default settings for maximum frame size.  You may optionally change these settings based on your application needs.  Set \"P4 Configuration\" as needed. </p> </li> </ol> <p>\u200b   </p> <ol> <li>Leave other settings at default values.</li> <li> <p>Click <code>File</code> and <code>Save As</code> hssi_ss_2x100g.  Click <code>Generate HDL</code> in the bottom right hand corner of IP Editor and enable simulation support.</p> </li> <li> <p>Edit $OFS_ROOTDIR/ipss/hssi/eth_design_files.tcl to comment out 8x25g and add in 2x100g.ip</p> </li> </ol> <pre><code>#-----------------\n# E-Tile Ethernet  SS IP\n#-----------------\n#set_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_8x25g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_2x100g.ip\nset_global_assignment -name IP_FILE               ../ip_lib/ipss/hssi/qip/ptp_iopll/ptp_sample_clk_pll.ip\n</code></pre> <ol> <li>Edit $OFS_ROOTDIR/syn/syn_top/ofs_top.qsf and $OFS_ROOTDIR/syn/syn_top/ofs_pr_afu.qsf to add new macro definition:</li> </ol> <p><pre><code>set_global_assignment -name VERILOG_MACRO \"ETH_100G\"         Change Ethernet from 8x25 to 2x100 GbE\n</code></pre> 9. In Quartus 23.1, you will need to update $OFS_ROOTDIR/syn/setup/eth_top.sdc:</p> <pre><code>#Timing for 100G\nset_false_path -from [get_clocks {sys_pll|iopll_0_clk_100m}] -to [get_clocks {hssi_wrapper|hssi_ss|hssi_ss_0|U_hssi_ss_ip_wrapper|U_hssi_ss_ip_top_p*|alt_ehipc3_fm_0|alt_ehipc3_fm_top_p*|alt_ehipc3_fm_hard_inst|E100GX4_FEC.altera_xcvr_native_inst|xcvr_native_s10_etile_0_example_design_4ln_ptp|tx_clkout|ch0}]; set_false_path -from [get_clocks {hssi_wrapper|hssi_ss|hssi_ss_0|U_hssi_ss_ip_wrapper|U_hssi_ss_ip_top_p*|alt_ehipc3_fm_0|alt_ehipc3_fm_top_p*|alt_ehipc3_fm_hard_inst|E100GX4_FEC.altera_xcvr_native_inst|xcvr_native_s10_etile_0_example_design_4ln_ptp|tx_clkout|ch0}] -to [get_clocks {sys_pll|iopll_0_clk_100m}];   </code></pre> <ol> <li>Build new 2x100G FIM.</li> </ol> <pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh -p n6001 work_2x100gbe\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#14-how-to-add-more-transceiver-channels-to-an-existing-fim-design","title":"14. How to add more Transceiver channels to an existing FIM design","text":"<p>The next section will describe how to add 4 extra ethernet channels to the existing Intel\u00ae FPGA SmartNIC N6001-PL FIM base_x16 design which uses the 8x25G (2x4x25G) as the default ethernet configuration.</p> <p>In this exercise we will add 4 extra channels to make a total of 12 channels. This configuration will be called 12x25G.</p> <p>Navigate to the following directory.</p> <p><pre><code>cd $OFS_ROOTDIR/ipss/hssi/qip/hssi_ss\n</code></pre> Copy <code>hssi_ss_8x25g.ip</code> to <code>hssi_ss_12x25g.ip</code>.</p> <p><pre><code>cp hssi_ss_8x25g.ip hssi_ss_12x25g.ip\n</code></pre> Then, open the <code>hssi_ss_12x25g.ip</code> file in platform designer and proceed to add 4 more transceiver channels copying the same configuration as the original 8 transceiver channels. Remove any errors in platform designer before generating the IP.</p> <p>The following table describes the files that need to be changed next and the modification that needs to be made to add four extra Ethernet channels.</p> File Modification ipss/hssi/eth_design_files.tcl Add assignment (after line 39) set_global_assignment -name IP_FILE ../ip_lib/ipss/hssi/qip/hssi_ss/hssi_ss_12x25g.ip ipss/hssi/rtl/hssi_wrapper.sv Comment out old Ethernet configuration IP file (line 427) //hssi_ss_8x25g  Add New Ethernet Configuration IP file (after line 427) hssi_ss_12x25g  Add the following code for the 4 extra Ethernet channels (after line 1524)  <code>ifdef INCLUDE_HSSI_PORT_8 assign serial_rx_p[PORT_8] = qsfp_serial[2].rx_p[0]; assign serial_rx_n[PORT_8] = 1'b0; assign qsfp_serial[2].tx_p[0] = serial_tx_p[PORT_8];</code>endif <code>ifdef INCLUDE_HSSI_PORT_9 assign serial_rx_p[PORT_9] = qsfp_serial[2].rx_p[1]; assign serial_rx_n[PORT_9] = 1'b0; assign qsfp_serial[2].tx_p[1] = serial_tx_p[PORT_9];</code>endif <code>ifdef INCLUDE_HSSI_PORT_10 assign serial_rx_p[PORT_10] = qsfp_serial[2].rx_p[2]; assign serial_rx_n[PORT_10] = 1'b0; assign qsfp_serial[2].tx_p[2] = serial_tx_p[PORT_10];</code>endif <code>ifdef INCLUDE_HSSI_PORT_11 assign serial_rx_p[PORT_11] = qsfp_serial[2].rx_p[3]; assign serial_rx_n[PORT_11] = 1'b0; assign qsfp_serial[2].tx_p[3] = serial_tx_p[PORT_11];</code>endif ipss/hssi/rtl/inc/ofs_fim_eth_plat_defines.svh Add the following code (after line 130)  <code>define INCLUDE_HSSI_PORT_8</code>define INCLUDE_HSSI_PORT_9 <code>define INCLUDE_HSSI_PORT_10</code>define INCLUDE_HSSI_PORT_11 ipss/hssi/rtl/inc/ofs_fim_eth_plat_if_pkg.sv Change parameters to reflect the addition of 4 Ethernet channels ie from 8 to 12 and the addition of one extra QSFP cage ie from 2 to 3  localparam MAX_NUM_ETH_CHANNELS = 12; // Ethernet Ports (line 32) localparam NUM_QSFP_PORTS = 3; // QSFP cage on board (line 34) localparam NUM_ETH_CHANNELS = 12; // Ethernet Ports (line 63) <p>Since the new device is targeting a different package the current pin location constraints will not work and the user will have to comment out all pin location constraints in the following files located at $IOFS_BUILD_ROOT/ofs-n6001/syn/setup</p> <pre><code>emif_loc.tcl\nhps_loc.tcl\npmci_loc.tcl\ntop_loc.tcl\n</code></pre> <p>For example:</p> <pre><code>#set_location_assignment PIN_CU26 -to hssi_rec_clk[0]\n</code></pre> <p>the user must then run the <code>ofs-common/scripts/common/syn/build_top.sh</code> script to check if the design fits. More than likely the user will need to place some Transceiver refclk pins (normal Txcvr and PCIe refclk) to guide the fitter. Please adjust the pin contraints based on the messages in the fitter.</p> <p>Quartus compilation will then be successful. To preserve the pin assignments the user must then hard code all of the new pin assignments back into the following files to provide deterministic results.</p> <pre><code>emif_loc.tcl\nhps_loc.tcl\npmci_loc.tcl\ntop_loc.tcl\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#15-how-to-modify-the-pfvf-mux-configuration","title":"15. How to modify the PF/VF MUX configuration","text":"<p>The PF/VF Configuration Tool allows you to easily reconfigure the default number of PFs and VFs on your design. To modify the PF/VF configuration, you must: </p> <ol> <li> <p>Decide which PCIe PF/VFs require modification.  If you are modifying host side PF/VF configuration, you must edit file <code>pcie_host.ofss</code> file found in <code>$OFS_ROOTDIR/tools/pfvf_config_tool</code>.  </p> <p>The code given below show the default pcie_host.ofss file:</p> <pre><code>[ProjectSettings]\nplatform = n6001 family = Agilex\nfim = base_x16\nPart = AGFB014R24A2E2V\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = True\n\n[pf0]\n[pf1]\n</code></pre> <p>This default configuration is made up of two physical functions (PF), and neither of them has any virtual functions (VF). </p> </li> <li> <p>Modify the OFSS file with the new PF/VF configuration.</p> <p>An example modification to the OFSS file is shown below.  In this example we have changed the configuration to: 6 PFs in total, 4 VFs in PF0, 1 VF in PF2, and 2 VFs on PF3.  You can add up to 8 PFs and could conceivably add up to the number of VFs supported by the PCIe IP.  Note more PFs/VFs will use more FPGA resources, which may cause fitter challenges.</p> <pre><code>[ProjectSettings]\nplatform = n6001 family = Agilex\nfim = base_x16\nPart = AGFB014R24A2E2V\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = True\n\n[pf0]\nnum_vfs = 4\n[pf1]\n[pf2]\nnum_vfs = 1\n[pf3]\nnum_vfs = 2\n[pf4]\n[pf5]\n</code></pre> </li> <li> <p>Run the <code>gen_ofs_settings.py</code> script found in <code>$OFS_ROOTDIR/ofs-fim-common/tools/pfvf_config_tool</code>.</p> <pre><code>./gen_ofs_settings.py\u00a0 --ini $OFS_ROOTDIR/tools/pfvf_config_tool/&lt;PCIE_SOURCE&gt;.ofss --platform $ADP_PLATFORM\n</code></pre> <p>For example, execute the following command to generate Host settings in an n6001 design:</p> <pre><code>./gen_ofs_settings.py\u00a0 --ini $OFS_ROOTDIR/tools/pfvf_config_tool/pcie_host.ofss --platform n6001\n</code></pre> <p>This script reconfigures the FIM by:</p> <p>a. Updating the PF/VF Mux Package APIs:</p> <pre><code>* $OFS_ROOTDIR/src/afu_top/mux/top_cfg_pkg.sv\n* $OFS_ROOTDIR/src/includes/ofs_fim_cfg_pkg.sv\n</code></pre> <p>b. Adding/removing AFU endpoints</p> <pre><code>* PF0 VFs - afu_main.port_afu_instances\n* All other functions: afu_top.fim_afu_instances\n* New AFUs will be instantiated as HE-NULL (he_null.sv) AFUs\n</code></pre> <p>c. Updating the pcie_ss.sh \"ip-deploy\" file</p> <ol> <li>Generating the new pcie_ss.ip file ($OFS_ROOTDOR/ipss/pcie/ss/pcie_ss.ip)</li> <li>Adding scratch register reads/writes to sim/csr_test for added functions</li> <li>Updating the simulation filelists ($OFS_ROOTDIR/sim/common/pfvf_sim_pkg.sv)</li> </ol> <p>If the port gasket is enabled in the OFSS file, all functions in the PR region must be a virtual function (VF) on physical function 0 (PF0) and are routed to Port AFU Instances (port_afu_instances.sv) in the port gasket.  You can enable the port gasket in the ini (*.ofss file) by adding <code>pg_enable = True</code> under the <code>num_vfs</code> in PF0. </p> <pre><code>[ProjectSettings]\nplatform = n6001 family = Agilex\nfim = base_x16\nPart = AGFB014R24A2E2V\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = False\n\n[pf0]\npg_enable = True\nnum_vfs = 3\n</code></pre> <p>If the port gasket is disabled, the virtual functions on PF0 are routed to FIM AFU Instances (fim_afu_instances.sv) in the static region.  All physical functions and virtual functions not on PF0 are routed to the FIM AFU Instances module (fim_afu_instances.sv) in afu_top.</p> <p>After you run the <code>gen_ofs_settings.py</code> script you should see a final success report:</p> <pre><code>Info: Regenerate these scripts whenever you make any change to any Quartus-generated IP in your project.\nInfo: Finished: Create simulation script\nsh: /home/applications.fpga.ofs.rtl/env_not_shipped/n6001/update_sim.sh: No such file or directory\nSuccess!  Thank you for using the IP-Deploy Tool\n</code></pre> </li> <li> <p>Recompile the FIM using the <code>build_top.sh</code> script described in Section 4.3.2 of this guide. </p> </li> <li> <p>Verify the correct functionality of new the PF/VF Mux configuration.</p> <p>New PF/VF are seamlessly connected to their own CSR stub, which can be read at DFH Offset 0x0. You can bind to the function and perform <code>opae.io peek</code> commands to read from the stub CSR. Similarly, perform <code>opae.io poke</code> commands to write into the stub CSRs. Use this mechanism to verify that the new PF/VF Mux configuration allows to write and read back values from the stub CSRs. </p> <p>The GUID for every new PF/VF CSR stub is the same.   </p> <pre><code>   NULL_GUID_L           = 64'haa31f54a3e403501\n   NULL_GUID_H           = 64'h3e7b60a0df2d4850\n\n&gt; **Limitations:** Setting 0 virtual functions on PF0 is not supported. This is because the **PR** region cannot be left unconnected. A loopback may need to be instantiated in this special case.\n\nLoad the newly compiled FIM to the card to test the functionality of the new PF/VF functions. Use the following commands to verify the number of PFs/VFs created:\n\n```bash\n</code></pre> <p>sudo lspci -vvv -s b1:00.0 | grep VF     ```</p> <pre><code>Example output:\n\n```bash\n</code></pre> <p>Initial VFs: 4, Total VFs: 4, Number of VFs: 0, Function Dependency Link: 00  VF offset: 6, stride: 1, Device ID: bccf                  ```</p> <pre><code>&gt;**Note:** The PCIe B:D.F associated with your board may be different. Use the `fpgainfo fme` command to see the PCIe B:D:F for your board.\n</code></pre> </li> </ol>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#16-how-to-create-a-minimal-fim","title":"16. How to Create a Minimal FIM","text":"<p>In this example, the exercisers and E-Tile Ethernet  subsection are removed and a new AFU PR area is used to make use of the added area from the removed components.  This minimal FIM is useful for HDL applications.</p> <p>To create this minimal FIM, perform the following steps:</p> <ol> <li>The OFS FIM repo provides a PR assignments TCL file for this minimal FIM.  You will copy the minimal PR assignments TCL file into pr_assignments.tcl file location for use in the FIM build process:</li> </ol> <p><pre><code>## Save current pr_assignments.tcl file into pr_assignments_base.tcl for later use\ncd $OFS_ROOTDIR\nmv syn/setup/pr_assignments.tcl syn/setup/pr_assignments_base.tcl\n## Move \"Slim\" PR assignment file into pr_assignments.tcl - this file is used in the build process\ncp syn/setup/pr_assignments_slim.tcl syn/setup/pr_assignments.tcl\n</code></pre> 2. Change the PF/VF configuration to support only 1 PF with 1 VF.  You will edit <code>$OFS_ROOTDIR/tools/pfvf_config_tool/pcie_host.ofss</code> to be as shown below:</p> <p><pre><code>nano $OFS_ROOTDIR/tools/pfvf_config_tool/pcie_host.ofss\n\n[ProjectSettings]\nplatform = n6001 family = Agilex\nfim = base_x16\nPart = AGFB014R24A2E2V\nIpDeployFile = pcie_ss.sh\nIpFile = pcie_ss.ip\nOutputName = pcie_ss\nComponentName = pcie_ss\nis_host = True\n\n[pf0]\nnum_vfs = 1\npg_enable = True\n\ncd $OFS_ROOTDIR/ofs-common/tools/pfvf_config_tool/\n</code></pre> 3. Save the modified ofs_dev.ofss file and build a new configuration.</p> <pre><code>python3 gen_ofs_settings.py --ini $OFS_ROOTDIR/tools/pfvf_config_tool/pcie_host.ofss --platform n6001\n</code></pre> <ol> <li>Compile the new FIM with exercisers removed.</li> </ol> <pre><code>cd $OFS_ROOTDIR\n./ofs-common/scripts/common/syn/build_top.sh -p n6001:null_he_lp,null_he_hssi,null_he_mem,null_he_mem_tg,no_hssi work_null_he_no_hssi\n</code></pre> <p>The build will complete with reduced resources as compared to the base version.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#17-single-event-upset-reporting","title":"17. Single Event Upset Reporting","text":"<p>A Single Event Upset (SEU) is the change in state of a storage element inside a device or system. They are caused by ionizing radiation strikes that discharge the charge in storage elements, such as configuration memory cells, user memory and registers.</p> <p>Error Detection CRC (EDCRC) circuitry in the MAX\u00ae 10 is used to detect SEU errors. The CRC function is enabled in Quartus to enable CRC status to be reported to the Intel\u00ae Agilex\u00ae FPGA via the dedicated CRC_ERROR pin.</p> <p>With the EDCRC there is no method to determine the severity of whether the SEU error is non-critical or catastrophic. Hence once the SEU error is detected, the Host system must initiate the Card BMC reset procedure.</p> <p>SEU errors can be read from either the MAX\u00ae 10 SEU Status Register or the PMCI Subsystem SEU Error Indication Register. The processes to read these registers are described in greater detail in the [BMC User Guide: Section 15 Single Event Upset Reporting].</p> <p>Additionally, refer to the Intel Agilex SEU Mitigation User Guide for more information on SEU detection and mitigation.</p>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#18-adding-fim-image-info","title":"18. Adding FIM Image Info","text":"<p>When using your newly created FPGA images, there are fields in the OPAE fpgainfo fme tool providing information on the FPGA image that is loaded in the FPGA flash.  This information is added with the <code>PACSign</code> tool.  When loading the FPGA binary file with OPAE tool fpgasupdate, the FPGA flash is written with the binary to load the FPGA, additionally, the FPGA flash has areas to store user entered information.  The OPAE tool fpgainfo fme reads this area and presents the information read back.</p> <p>The OPAE SDK tool called PACSign appends the FPGA image information to the FPGA binary file.  By default, the <code>ofs-common/scripts/common/syn/build_top.sh</code> script runs the PACSign tool with the FPGA Information field set to a checksum hex value generated by <code>syn_top/build_flash/gen_image_info_hex.py</code>.   </p> <p>To change the value loaded in the FPGA info field, you can run the PACSign tool to add either hex or ASCII information.</p> <p>For example, adding the hex value \"DEADBEEF12349876AAAA555512345678\", do the following:</p> <pre><code>PACSign SR -y -s 0 -b DEADBEEF12349876AAAA555512345678-t UPDATE -H openssl_manager -i ofs_top_page1_unsigned_user1.bin -o my_fpgainfo_user1.bin\n\n# Once completed, you can review the binary file using OPAE SDK tool `bitstreaminfo` to read information fields\nbitstreaminfo my_fpgainfo_user1.bin\n#.....\nFile my_fpgainfo_user1.bin:\nBlock 0:\n        Block 0 magic =         0xb6eafd19\n        Content length =        0x02467100\n        Content type =          SR\n        Cert type =             UPDATE\n        Slot number =           0\nProtected content SHA-256:\n                        0x509661a69aa42e84d11573e87e75e976a47c9e6bce86253e77422f85eb4f07b1\n        Calculated protected content SHA-256:\n                        0x509661a69aa42e84d11573e87e75e976a47c9e6bce86253e77422f85eb4f07b1\n                Match\n        Protected content SHA-384:\n                        0xced3a0d7837767e40be8dd9b72b6eefd121d68c42c9aa040345534cca27c45d4910fe8e917163c19a8317e7485a2f5f9\n        Calculated protected content SHA-384:\n                        0xced3a0d7837767e40be8dd9b72b6eefd121d68c42c9aa040345534cca27c45d4910fe8e917163c19a8317e7485a2f5f9\n                Match\n        Bitstream Version =             DEADBEEF12349876AAAA555512345678\nBlock 1:\n        Block 1 magic = 0xf27f28d7\n                Root Entry magic =              0xa757a046\n                Root Entry curve magic =        0xc7b88c74\n                Root Entry permissions =        0xffffffff\n                Root Entry key ID =             0xffffffff\n                Root public key X =             0x0000000000000000000000000000000000000000000000000000000000000000\n                Root public key Y =             0x0000000000000000000000000000000000000000000000000000000000000000\n\nExpected root entry hash =      0xf8ff7e0a52a378483c85301df49c7d55ffd26f794121bdb8b102d7e1c3132bb9\n\nCSK magic =                     0x14711c2f\n                CSK curve magic =               0xc7b88c74\n                CSK permissions =               0xffffffff\n                CSK key ID =                    0x00000000\n                Code signing key X =            0x0000000000000000000000000000000000000000000000000000000000000000\n                Code signing key Y =            0x0000000000000000000000000000000000000000000000000000000000000000\n                CSK signature magic =           0xde64437d\n                Signature R =                   0x0000000000000000000000000000000000000000000000000000000000000000\n                Signature S =                   0x0000000000000000000000000000000000000000000000000000000000000000\n\nExpected CSK hash =             0xbe8a02e7932d98aff66584598978d84412e3c641927efac2cb786a1754cfcd4e\n\nBlock 0 Entry magic =           0x15364367\n                Block 0 Entry signature magic = 0xde64437d\n                Signature R =                   0x0000000000000000000000000000000000000000000000000000000000000000\n                Signature S =                   0x0000000000000000000000000000000000000000000000000000000000000000\nPayload:\n        80 20 00 04 a9 12 94 46 0c 00 00 00 00 20 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n...\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n</code></pre> <p>You can load this image using <code>fpgasupdate</code> and then read the value using <code>fpgainfo fme</code>.</p> <p>ASCII upto characters can also be loaded for upto 32 - 8 bit ASCII characters by putting the quotes as shown below:</p> <pre><code>PACSign SR -y -s 0 -b \"My new FPGA 1234\" -t UPDATE -H openssl_manager -i ofs_top_page1_unsigned_user1.bin -o my_new_fpga_user1.bin\n</code></pre>"},{"location":"hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/","title":"Hard Processor System Software Developer Guide: OFS for Intel Agilex FPGAs Targeting Intel\u00ae N6000/1-PL FPGA SmartNIC Platform","text":"<p>Quartus Prime Pro Version: 23.1</p> <p>Last updated: Last updated: August 01, 2023 </p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#file-types","title":"File Types","text":"Extension Description ITS File (*.its) The image source file which describes the contents of the image and defines various properties used during boot. Actual contents to be included in the image (kernel, ramdisk, etc.) are specified in the image source file as paths to the appropriate data files. ITB File (*.itb) Produced as output from <code>mkimage</code>, using an image source file. Contains all the referenced data (kernel, ramdisk, SSBL, etc.) and other information needed by UBoot to handle the image properly. This image is transferred to the target and booted. DTB File (*.dtb) The Device Tree Blob is loaded into memory by U-Boot during the boot process, and a pointer to it is shared with the kernel. This file describes the system's hardware layout to the kernel. FIT Image (*.fit) Format used for uImage payloads developed by U-Boot. On aarch64 the kernel must be in image format and needs a device tree to boot. SPL (*.spl) The Secondary Program Loader is a small binary which is embedded in a FIM SOF and loaded into board DDR4 RAM when the FPGA is initially configured. This file is responsible for loading U-Boot into system RAM."},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#10-introduction","title":"1.0 Introduction","text":"<p>The Open FPGA Stack (OFS) is a modular collection of hardware platform components, open source upstreamed software, and broad ecosystem support that enables an efficient path to develop a custom FPGA platform. OFS Provides a framework of FPGA synthesizable code, a simulation environment and synthesis/simulation scripts.  The updated OFS architecture for Intel Agilex FPGA devices improves upon the modularity, configurability and scalability of the first release of the OFS architecture while maintaining compatibility with the original design.  The primary components of the FPGA Interface Manager or shell of the reference design are:</p> <ul> <li>PCIe Subsystem</li> <li>HSSI Subsystem</li> <li>Memory Subsystem</li> <li>Hard Processor System (HPS)</li> <li>Reset Controller</li> <li>FPGA Management Engine (FME)</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from Host or AFU</li> <li>SPI Interface to BMC controller</li> </ul> <p>The Intel\u00ae N6000-PL and N6001-PL FPGA SmartNIC Platforms are acceleration cards that use the OFS infrastructure. The key difference between these two platforms is:</p> <ul> <li>Intel\u00ae N6000-PL SmartNIC Platform has a bifurcated PCIe bus with Gen4x8 interfacing to the the Intel Agilex FPGA and Gen4x8 interfacing to an Intel E810 SmartNIC.  This platform is targeted specifically for VRAN, UPF and vCSR applications.  The FPGA designs targeting these vertical market applications were generated using the OFS infrastructure.</li> <li>Intel\u00ae N6001-PL SmartNIC Platform has a Gen4x16 interface directly to the Intel Agilex FPGa and is not populated with an Intel E810 SmartNIC.  This platform is the reference platform for the OFS reference designs for Intel Agilex FPGA.  </li> </ul> <p>Note: throughout this document \"Intel N6000/1-PL FPGA SmartNIC Platform\" denotes both cards. This document describes the software package that runs on the Hard Processor System (HPS) which is a key component within both platforms.</p> <p>The Intel N6000/1-PL FPGA SmartNIC Platform has a customized build script that can be used to both set up a development environment and build the essential pieces of the HPS software image. This script, <code>meta-bake.py</code>, has its own dedicated Section 3.1 Building U-Boot which can be used to quickly get started with the HPS build flow. It is recommended you use this build script to construct the first and second stage bootloader files, as it will handle all of the setup and patching required to build out your complete Yocto image. You can familiarize yourself with the contents of this package in its public GitHub repository located at https://github.com/OPAE/meta-opae-fpga/tree/main/tools/meta-bake. All other information included for individual components is included for learning purposes only and is not meant as a recipe for image creation.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#11-reference-documents","title":"1.1 Reference Documents","text":"<p>This document pulls much of its information from related Agilex FPGA documentation hosted on intel.com. Reading these references is not required for initial platform bring up, but will serve to further your knowledge of the FPGA SoC boot and configuration process.</p> <p>Table 1. Reference Documents</p> Document Title Intel\u00ae Agilex\u2122 Hard Processor System Technical Reference Manual Intel\u00ae Agilex\u2122 SoC FPGA Boot User Guide Intel\u00ae Agilex\u2122 Configuration User Guide"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#12-reference-images","title":"1.2 Reference Images","text":"<p>Intel has provided a set of two pre-compiled ITB images that can be used for exploration and evaluation of the HPS bring-up flow. These images contain the complete SSBL package specific to the board and can be copied to the N6000/1-PL SmartNIC Platform with an HPS enabled FIM loaded. Refer to Section 4.1 Example Boot for an example on how to use the built-in copy engine IP in tandem with the host-side <code>cpeng</code> software to transfer an SSBL.</p> <p>The package is found on the official OFS 2023.1 Release on GitHub. Two ITB artifacts are included at the bottom of the page under Assets - one with the Vendor Authorized Boot (VAB) certificate included, and one without. Which you choose to load depends on whether the currently loaded FIM requires VAB authentication. Section 4.3 Example Boot contains instructions on the boot flow using these files for platform bring up.</p> <p>The default username for these two images is <code>root</code> and the password is empty. A good place to start after loading the ITB is to set up SSH for file transfers and the remote console, as seen in 8.0 Connecting remotely to the HPS using <code>ssh</code>.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#20-architecture-overview","title":"2.0 Architecture Overview","text":"<p>The OFS architecture is classified into:</p> <ul> <li>1. Host Interface Adapters (PCIe)</li> <li>2. Low Performance Peripherals</li> <ul> <li>2.1. Slow speed peripherals (example: JTAG, I2C, SMBus, and so on)</li> <li>2.2. Management peripherals (example: FPGA FME)</li> </ul> <li>3. High Performance Peripherals</li> <ul> <li>3.1. Memory peripherals</li> <li>3.2. Acceleration Function Units (AFUs)</li> <li>3.3. HPS Peripheral</li> </ul> <li>4. Fabrics</li> <ul> <li>4.1. Peripheral Fabric (multi drop)</li> <li>4.2. AFU Streaming fabric (point to point)</li> </ul> </ul> <p>The HPS is connected to the AFU and implements all the board specific flows that customers require to begin the application development using the HPS such as host communication, firmware load and update, integration with OFS, and memory. The HPS implements a basic Hello World software application and is intended as a starting point for customers to begin development with HPS.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#21-hps-peripherals","title":"2.1 HPS Peripherals","text":"<p>Figure 1  Intel Agilex FPGA HPS Peripherals</p> <p></p> <p>The Intel Agilex\u2122 SoC integrates a full-featured Arm\u00ae Cortex-A53\u00ae MPCore Processor.</p> <p>The Cortex-A53 MPCore supports high-performance applications and provides the capability for secure processing and virtualization.</p> <p>Each CPU in the processor has the following features:</p> <ul> <li>Support for 32-bit and 64-bit instruction sets.</li> <li>To pipeline with symmetric dual issue of most instructions.</li> <li>Arm NEON\u00ae Single Instruction Multiple Data (SIMD) co-processor with a Floating-Point Unit (FPU)</li> <li>Single and double-precision IEEE-754 floating point math support</li> <li>Integer and polynomial math support.</li> <li>Symmetric Multiprocessing (SMP) and Asymmetric Multiprocessing (AMP) modes.</li> <li>Armv8 Cryptography Extension.</li> <li>Level 1 (L1) cache:</li> <li>32 KB two-way set associative instruction cache.</li> <li>Single Error Detect (SED) and parity checking support for L1 instruction cache.</li> <li>32 KB four-way set associative data cache.</li> <li>Error checking and correction (ECC), Single Error Correct, Double Error Detect (SECDED) protection for L1 data cache.</li> <li>Memory Management Unit (MMU) that communicates with the System MMU (SMMU).</li> <li>Generic timer.</li> <li>Governor module that controls clock and reset.</li> <li>Debug modules:</li> <li>Performance Monitor Unit.</li> <li>Embedded Trace Macrocell (ETMv4).</li> <li>Arm CoreSight\u00ae cross trigger interface, the four CPUs share a 1 MB L2 cache with ECC, SECDED protection.</li> </ul> <p>A Snoop Control Unit (SCU) maintains coherency between the CPUs and communicates with the system Cache Coherency Unit (CCU). At a system level, the Cortex-A53 MPCore interfaces to a Generic Interrupt Controller (GIC), CCU, and System Memory Management Unit (SMMU).</p> <p>Beyond the Arm Cortex-A53 MPCore Processor, the HPS integrates a variety of useful peripherals for use in your design, such as Ethernet, USB, Memory Controller, on-chip RAM, SPI, UART and more. Refer to the Intel\u00ae Agilex\u2122 Hard Processor System Technical Reference Manual for more information.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#22-zarlink-device","title":"2.2 Zarlink Device","text":"<p>The Microchip\u00ae Zarlink device ZL30793 is used for time synchronization. It acts as the protocol engine that drives IEEE 1588-2008 PTP protocol. The Zarlink device is connected to the HPS side and the programming interface is SPI. The FPGA bitstream containing the HPS has the First Stage Bootloader (FSBL) only. This enable commands to be given from a terminal program connected through UART.</p> <p>The software in HPS can access the Clock generator through SPI to enable write and read operations controlled by the terminal program. It can also read the status of the hold over and Loss of Lock signals and control the LED.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#23-copy-engine","title":"2.3 Copy Engine","text":"<p>A host with OPAE SDK and Linux DFL installed will provide the <code>hps</code> OPAE command with related options to transfer images from host to the HPS image. The module in the OFS FIM and HPS software that performs this transfer is called the Copy Engine (CPE), which is included by default within the HPS image.</p> <p>Refer to the Getting Started Guide: \u00ae Open FPGA Stack for Intel Agilex FPGAs for platform and software installation instructions.</p> <p>The CPE software is patched into Linux on the HPS in Yocto through the meta-intel-fpga-refdes layer. This service is daemonized and requires <code>systemd</code> in order to operate. This service will communicate with the HPS IP integrated in the FIM in order to coordinate and monitor file transfers from the host CPE software to DDR connected the HPS. The CPE HPS-side software takes advantage of the built-in I/O lightweight kernel module to communicate with the FIM's HPS IP. It can restart the transfer if the initial transfer of the image is not successful. The CPE can also serve as reference on how to integrate your own systemd service in the Linux build running on the HPS.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#24-boot-flow","title":"2.4 Boot Flow","text":"<p>The boot flow for the Agilex OFS design for the Intel N6000/1-PL FPGA SmartNIC Platform is an FPGA-first boot flow, meaning the Intel Agilex Secure Device Manager (SDM) configures the FPGA first and then boots the HPS. Alternatively, you can boot the HPS first and then configure the FPGA core as part of the Second-Stage Boot Loader (SSBL) or after the Operating System (OS) boots. HPS-first boot is not covered in this document, but for more information please refer to the Intel\u00ae Agilex\u2122 SoC FPGA Boot User Guide.</p> <p>For the FPGA-first boot flow supported by the Intel Agilex OFS FIM, the First Stage Bootloader is part of FPGA bitstream. The available Secure Device Manager (SDM) in the FPGA initially configures the FPGA core and periphery in this mode. The first stage bootloader is produced as a part of a U-Boot build and cna be manually inserted into a Quartus generated SOF file as shown in step 7 of Section 9.2 Configuring the HPS.</p> <p>After completion, the HPS boots. All the I/O, including the HPS-allocated I/O, are configured, and brought out of tri-state. If the HPS is not booted:</p> <ul> <li>The HPS is held in reset</li> <li>HPS-dedicated I/O are held in reset</li> <li>HPS-allocated I/O are driven with reset values from the HPS.</li> <li>If the FPGA is configured before the HPS boots, then the boot flow looks as shown in the example figure below.</li> </ul> <p>Figure 2. Typical FPGA First Configuration Steps</p> <p></p> <p>The flow includes the Time from Power-on-Reset (TPOR) to boot completion (TBoot_Complete).</p> <p>Table 2. FPGA Configuration First Stages</p> Time Boot Stage Device State TPOR to T1 POR Power-on reset T1 to T2 SDM: Boot ROM 1. SDM samples the MSEL pins to determine the configuration scheme and boot source. 2. SDM establishes the device security level based on eFuse values. 3. SDM initializes the device by reading the configuration firmware (initial part of the bitstream) from the boot source. 4. SDM authenticates and decrypts the configuration firmware (this process occurs as necessary throughout the configuration). 5. SDM starts executing the configuration firmware. T2 to T3 SDM: Configuration Firmware 1. SDM I/O are enabled. 2. SDM configures the FPGA I/O and core (full configuration) and enables the rest of your configured SDM I/O. 3. SDM loads the FSBL from the bitstream into HPS on-chip RAM. 4. SDM enables HPS SDRAM I/O and optionally enables HPS debug. 5. FPGA is in user mode. 6. HPS is released from reset. CPU1-CPU3 are in a wait-for-interrupt (WFI) state. T3 to T4 First-Stage Boot Loader (FSBL) 1. HPS verifies the FPGA is in user mode. 2. The FSBL initializes the HPS, including the SDRAM. 3. The user application through the host must request the copy engine using the OPAE command hps to transfer the itb image (SSBL +Linux) to the HPS DRAM. 4. HPS peripheral I/O pin mux and buffers are configured. Clocks, resets, and bridges are also configured. 5. HPS I/O peripherals are available. T4 to T5 Second-Stage Boot Loader (SSBL) 1. HPS bootstrap completes. 2. OS is loaded into SDRAM. T5 to TBoot\\Complete Operating System (OS) The OS boots and applications are scheduled for runtime launch. <p>When using the Pre-boot Execution Environment (PXE) boot mechanism, you must use an option ROM. OFS FIM does not have PXE boot implemented in the HPS.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#25-authorization","title":"2.5 Authorization","text":"<p>The HPS FSBL is part of the static region (SR) FPGA bitstream. Intel provides the capability to sign the FPGA bitstream binaries so that they can be authenticated when remotely updated and when configuring the FPGA. Signing of the SR bitstream is a two-stage process where you must sign with:</p> <pre><code>1. `quartus_sign` tool\n2. OPAE `PACSign` tool\n</code></pre> <p>Signing with PACSign ensures the security of the BMC RSU update process to the flash, and requires a compatible binary file. Quartus signing provides ensures security when the bitstream is configured through the SDM into the Intel Agilex FPGA device using Vendor Authorized Boot.</p> <p>Vendor Authorized Bootloader (VAB) considers the SDM as a trusted root entity such that when firmware is authenticated and booted and is running on the SDM with dedicated crypto HW IP blocks, it is considered a trusted entity. As such it is trusted to perform the authentication and authorization steps for subsequent bitstreams.</p> <p>Each subsequent loaded object after the SDM boot firmware does not need to re-implement the authentication and authorization functions. The authentication and authorization functions are centralized. Arm Trusted Firmware (ATF) is used to make a trusted execution environment (TEE) in the HPS. The source code for both Arm Trusted firmware and the First Stage Boot Loader (FSBL) is provided in the GitHub.</p> <p>The SSBL + Linux is a part of an itb file and may also be signed with Quartus_sign and PACSign for authentication. This process is demonstrated in Section 9.2 Configuring the HPS.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#30-environment-setup","title":"3.0 Environment Setup","text":""},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#31-building-u-boot","title":"3.1 Building U-Boot","text":"<p>When creating a development environment using <code>meta-bake.py</code> both U-Boot and the patches required to work with the Intel N6000/1-PL FPGA SmartNIC Platform are located at /meta-opae-fpga/tools/meta-bake/build/agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-socfpga/1_v2021.07+gitAUTOINC+24e26ba4a0-r0/build/socfpga_agilex_n6000_defconfig. To review the required patches applied to U-Boot, navigate to /meta-opae-fpga/tools/meta-bake/build/agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-socfpga/1_v2021.07+gitAUTOINC+24e26ba4a0-r0/git/patches. From there, using git commands such as <code>git status</code> and <code>git branch</code> will show changes to the build environment. </p> <p>Currently the meta-bake build flow requires a specific environment and software dependencies. Refer to section 6.1 Running meta-bake.py for more information. </p> <p>Invoke the <code>meta-bake.py</code> build script to build your entire image, including U-Boot.</p> <pre><code>$ cd /meta-opae-fpga/tools/meta-bake\n$ ./meta-bake.py --conf n6000/layers.yaml builddir\n</code></pre> <p>This build process is highly system dependent and can take upwards of 1 hour to complete. Make sure you have at least 200 GB of free space on the system before running a build.</p> <p>To build U-Boot manually after execution of <code>meta-bake.py</code> navigate to /meta-bake/build/agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-srcfpga/1_v2021.07+gitAUTOINC+24e26ba4a0-r0/build/socfpga_agilex_n6000_defconfig and run <code>make</code>. After running meta-bake.py, you can rebuild U-Boot to incorporate any changes you have made. Navigate to the U-Boot directory at /meta-opae-fpga/tools/meta-bake/build/agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-socfpga/1_v2021.07+gitAUTOINC+24e26ba4a0-r0/build/socfpga_agilex_n6000_defconfig and run the following commands to rebuild.</p> <pre><code>$ wget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.2-2020.11/binrel/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\n$ tar xf gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\n$ rm gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\n$ export CROSS_COMPILE=`pwd`/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-\n$ export ARCH=arm64\n$ make -j `nproc`\n</code></pre> <p>This recompile will result in a new ITB SSBL which may be loaded on an Intel FPGA SmartNIC N6000/1 platform. Several components of the ITB image are present under the U-Boot directory but are not rebuilt as a part of this flow. These files will need to be replaced before rebuilding U-Boot for changes to take affect.</p> <p>U-Boot comes with its own <code>dumpimage</code> tool, which can be used to identify an image and extract and identify its contents. This tool is built by default under /u-boot-socfpga/tools, and in the <code>meta-bake.py</code> environment setup under /meta-opae-fpga/tools/meta-bake/build/agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-socfpga/1_v2021.07+gitAUTOINC+24e26ba4a0-r0/build/socfpga_agilex_n6000_defconfig/tools. This tool can also be used to extract specific components of the ITB file.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#32-yocto","title":"3.2 Yocto","text":"<p>Yocto is an open source toolkit used to create Linux distributions and commonly used for creating Linux images and bootloaders for embedded environments. A Yocto build environment is made up of one or more layers, with each layer consisting of recipes that get processed to build/install components in a layer. The workhorse of a Yocto build is the program called <code>bitbake</code>. This program processes the recipes to compile and build packages and images for the target platform. For SoC platforms, like the HPS, the ARM cross compiler is required.</p> <p>The build script used for the Agilex SoC GSRD, <code>create-linux-distro-release</code>, is a bash script that automates the build of Linux images of different types (gsrd, nand, etc.) that are compatible with a target FPGA platform (agilex, stratix10, etc.). This script has been ported to Python 3 and modified to build an environment for the Intel FPGA SmartNIC N6000/1 platform, named <code>meta-bake.py</code>. This script pulls in the necessary patches and additional changes needed to support the platform.</p> <p>In general, <code>meta-bake.py</code> pulls Yocto layers/recipes from public repositories, configures a Yocto build environment, and builds an image for a supported FPGA platform. The Yocto layer is always the first to be built, and includes the <code>bitbake</code> utility. The following table lists remote repositories hosting Yocto meta data source used by <code>meta-bake.py</code> and <code>create-linux-distro</code> as well as source code used for building binaries that make up the Linux image (kernel and rootfs).</p> <p>Note: Not all repositories can be viewed in a web browser. All can be cloned using git.</p> Repository Description https://git.yoctoproject.org/git/poky Base build tools and meta data layers https://git.openembedded.org/meta-openembedded Layers for OE-core packages https://git.yoctoproject.org/git/meta-intel-fpga Meta data layers for Intel FPGA SoC platforms https://github.com/altera-opensource/meta-intel-fpga-refdes BSP layer for Intel SoC FPGA GSRD https://github.com/altera-opensource/linux-socfpga Linux kernel source repository for socfpga https://github.com/altera-opensource/u-boot-socfpga U-Boot bootloader source repository for socfpga https://github.com/altera-opensource/arm-trusted-firmware Source for ATF <p>Recipes in the meta-intel-fpga-refdes layer mostly inherit from and extend recipes in other layers. The following table lists the new or modified recipes (in meta-intel-fpga-refdes) necessary to support an Intel FPGA SmartNIC N6000/1 HPS boot image.</p> Component Recipe Description Linux Kernel recipes-kernel/linux/linux-socfpga-lts_5.10.bbappend Recipe to append the GSRC SoC FPGA device tree to the Yocto build U-Boot recipes-bsp/u-boot/u-boot-socfpga_v2021.07.bbappend Recipe to fetch and build socfpga U-Boot. Modified to support N6000/1 in U-Boot. This also creates a shell script, *mkuboot-fit.sh. copy-engine recipes-bsp/copy-engine/copy-engine-0.1.bb New recipe to build copy-engine daemon in rootfs. N6000/1 Image recipes-images/poky/n6000-image-minimal.bb New recipe to create the N6000/1 image with copy-engine and linuxptp packages installed. <p>mkuboot-fit.sh is meant to be called after a Yocto build to create the U-Boot FIT image for N6000/1, and is called automatically by <code>meta-bake.py</code>. This is a workaround for the Yocto build order which builds the bootloader (U-Boot) before building the Linux image rootfs. Because the rootfs is part of the U-Boot FIT image, the rootfs must be built before building the bootloader. The result of calling this script is copying the rootfs (as a .cpio file) to the U-Boot source file tree and calling <code>make</code> in the U-Boot build tree. When called again with the rootfs present, the resulting image will contain the rootfs. This is performed automatically as a part of the <code>meta-bake.py</code> build flow.</p> <p>See here for more information regarding Yocto. Several reference designs found in rocketboards.org use Yocto for building the Linux image and/or bootloader. For the N6000/1 image and boot flow, the Yocto build script for the Agilex SoC Golden System Reference Design has been adapted to automate building the boot loader, Linux Image, and filesystem needed to support N6000/1 devices.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#321-customizing-the-yocto-image","title":"3.2.1 Customizing the Yocto Image","text":"<p>The following is a list of customizations made for building Yocto to run on the Intel FPGA SmartNIC N6000/1-PL platform.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#3211-extending-the-u-boot-recipe","title":"3.2.1.1 Extending the U-Boot recipe","text":"<p>A recipe extension file (recipes-bsb/u-boot/u-boot-socfpga_v2021.07.bbappend) has been added to the meta-intel-fpga-refdes layer which accomplishes the following:</p> <ul> <li>Adds patches using Yocto's patching mechanism</li> <li>Introduces a new U-Boot config, socfpga_agilex_n6000_defconfig, and associates it with a keyword, <code>agilex-n6000</code>, that can be referenced in Yocto configuration files. These patches are necessary until those changes are merged into the public u-boot-socfpga repository. This config works for both Smartnic Platforms.</li> <li>Creates mkuboot-fit.sh script file with variables for U-Boot source and build directories that will get expanded to the actual paths that Yocto uses for fetching/building U-Boot. Along with this recipe file, relevant patch files have been added. Once the changes are in the U-Boot repository, the patches and any references to them must be removed.</li> </ul>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#3212-patching-the-linux-kernel","title":"3.2.1.2 Patching The Linux Kernel","text":"<p>The kernel extension recipe, meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts_5.10.bbappend, in the meta-intel-fpga-refdes layer, has been modified to add a patch file using Yocto's patching mechanism. This patch file adds the device tree for N6000/1 and is only necessary until this change is merged into the public linux-socfpga repository.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#3213-adding-custom-user-space-software","title":"3.2.1.3 Adding Custom User Space Software","text":"<p>A new recipe, meta-intel-fpga-refdes/recipes-bsp/copy-engine-0.1.bb and relevant source files, have been added to the meta-intel-fpga-refdes layer. This recipe includes instructions for building the copy-engine program as well as installing it as a systemd service. Yocto will build this into an RPM package that gets installed into any image that includes it in the <code>IMAGE_INSTALL</code> variable. This recipe may be used as a guide for installing additional user space software.</p> <p>You may also create a new Hello World application and add it to the Yocto build as shown below.</p> <ol> <li>Generate a BSD 3-Clause License and create an MD5 hash of it.</li> </ol> <pre><code>Copyright (c) 2023, User's Name All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Company Name nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </code></pre> <p>After license creation you will need to create an MD5 Hash of the clause. On Linux you can either pipe the raw text into <code>echo \"text\" | md5sum</code>, or create a new file and point to it <code>md5sum licensefile.txt</code>.</p> <ol> <li>Create a BB recipe file, following the same directory structure as other Yocto recipes.</li> </ol> <pre><code>$ cd /meta-opae-fpga/tools/meta-bake/build/meta-intel-fpga-refdes\n$ mkdir -p recipe-example/helloworld &amp;&amp; cd recipe-example/helloworld\n</code></pre> <p>Create recipe file <code>helloworld.bb</code> in directory helloworld.</p> <pre><code>SUMMARY = \"Example hello world\" DESCRIPTION = \"helloworld in HPS\" AUTHOR = \"Your Name &lt;your.email@address.com&gt;\" LICENSE = \"BSD-3-Clause\" LIC_FILES_CHKSUM = \"file://${COMMON_LICENSE_DIR}/BSD-3-Clause;md5=&lt;Your MD5 Hash&gt;\" inherit systemd pkgconfig SRC_URI = \"file://helloworld.c\" S = \"${WORKDIR}\" do_compile() { ${CC} ${CFLAGS} ${LDFLAGS} helloworld.c -o helloworld }\ndo_install() { install -d ${D}${bindir} install -m 0755 helloworld ${D}${bindir} } </code></pre> <ol> <li>Create source file <code>helloworld.c</code> in the same helloworld directory.</li> </ol> <pre><code>#include &lt;stdio.h&gt; void main void() { Printf(\u201c\\nHello World\\n\u201d) } </code></pre> <ol> <li>Re-run <code>./meta-bake.py --conf n6000/layers.yaml &lt;Build Directory&gt;</code>. This will a new programmable SSBL that contains your Hello World program. Program the resulting ITB file as shown in Section 4.3 Example Boot and verify the application has been included in your build.</li> </ol>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#3214-adding-kernel-driver-software","title":"3.2.1.4 Adding Kernel Driver Software","text":"<p>New recipes for custom kenel modules can be created at /build/meta-intel-fpga-refdes/recipes-kernel/linux/, and instructed to include custom module code. These can be patched in, included as a part of a new branch, or included by default if upstreamed. For more information visit the YoctoProject's Linux Kernel Development Manual. An example file from N6000/1 that can be used as an example is /build/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts_5.10.bbappend.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#3215-creating-an-image-type","title":"3.2.1.5 Creating an Image Type","text":"<p>A new recipe, meta-intel-fpga-refdes/recipes-images/poky/n6000-image-minimal.bb, has been added that includes directives to install the copy-engine package (built in this layer) as well as the <code>linuxptp</code> package (available in other layers). In addition to including these packages, this recipe includes a rootfs post processing command that removes the Linux kernel image files from the rootfs. This is done because the Linux kernel is part of the U-Boot FIT image and therefore not used from the rootfs. Removing this redundant file reduces the final U-Boot FIT image by about 30Kb. This recipe may be modified or used as a guide to add additional user space software.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#3216-testing-and-debugging","title":"3.2.1.6 Testing and Debugging","text":"<p>As mentioned previously, the script will erase source files every time it is executed. This means that any changes made locally will be lost when the script is run again after making these changes. The example below shows how to test local changes without executing the script again.</p> <pre><code>$ cd build\n$ source poky/oe-init-build-env agilex-gsrd-rootfs/\n$ bitbake n6000-image-minimal\n$ ./agilex-n6000-rootfs/tmp/deploy/images/agilex/mkuboot-fit.sh\n</code></pre>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#40-booting-the-hps","title":"4.0 Booting the HPS","text":""},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#41-ofs-fim-boot-overview","title":"4.1 OFS FIM Boot Overview","text":"<p>This implementation of an FPGA First boot flow requires that the FSBL poll on a given register before continuing to boot the HPS. Once this register indicates it is (copy engine) ready, the FSBL loads a monolithic U-Boot FIT image at a given offset 0x02000000.</p> <p>This image is made up of the following components:</p> <ul> <li>U-Boot bootloader also referred to as second stage bootloader</li> <li>Linux Kernel image</li> <li>Root filesystem (rootfs) consisting of kernel modules as well as user space software.</li> </ul>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#42-booting-ofs-fim-for-intel-agilex-fpga","title":"4.2 Booting OFS FIM for Intel Agilex FPGA","text":"<p>As mentioned before, the Intel N6000/1-PL FPGA SmartNIC boot flow is an FPGA-first boot flow which requires that the Intel Agilex FPGA to be configured with the necessary components (SPL/FSBL, copyengine) in order for the HPS to boot.</p> <p>SD/eMMC is not supported for FSBL for HPS first</p> <ul> <li>First Stage Bootloader (FSBL): u-boot-spl-dtb.hex is embedded into FPGA image</li> <li>Monolithic FIT Image Downloaded from Host, u-boot.itb contains the following components<p>1) Second Stage Bootloader (SSBL): U-Boot + U-Boot Device Tree</p> <p>2) Linux kernel, Image, + Linux Device Tree</p> <p>3) Linux RAM based Root File System</p> </li> </ul> <ul> <li>First Stage Bootloader (FSBL) is U-boot-spl</li> <li>U-boot-spl is built when U-Boot is built</li> <li>Artifact is u-boot-spl-dtb.hex<ul> <li>The user has to check into build location : ofs-n6001/syn/setup/vab_sw/u-boot-spl-dtb.hex</li> <li>Then run the command</li> <li>quartus/pfg -c -o hps/path=u-boot-spl-dtb.hex orig.sof orig/fsbl.sof</li> </ul> </li> </ul> <p>Things to consider while developing your ITB image:</p> <pre><code>- The size of the u-boot.itb matters.\n- FIT is downloaded to [0x2000000](https://github.com/altera-opensource/u-boot-socfpga/blob/541b6afcb183ddb350ad367c9b63cc6db94c1f6e/configs/socfpga_agilex_n6010_defconfig#L4)\n- Linux Device Tree and RootFS are unpacked to high memory\n- Linux is unpacked to an address specified in the FIT, [0xb600000](https://github.com/altera-opensource/u-boot-socfpga/blob/541b6afcb183ddb350ad367c9b63cc6db94c1f6e/arch/arm/dts/socfpga_agilex_n6010-u-boot.dtsi#L4)\n- If size of u-boot.itb is greater than 0xb600000 \u2013 0x2000000, then FIT will be corrupted mid extraction, resulting in unpredictable kernel crashes.\n</code></pre> <p>This example assumes the following preconditions have been met prior to booting HPS:</p> <p>1) A SOF file synthesized with the SPL (u-boot-spl-dtb.hex).</p> <p>2) Copy engine IP with relevant registers accessible to host and HPS.</p> <p>Once the host FPGA boots with the required bitstream, the SPL in the HPS begins polling a register in the copy engine. One way to get an indication that the HPS is ready to continue past the SPL is to use a terminal emulator on a host with a serial cable connected to the FPGA's UART port. To transfer the U-Boot FIT image, use the <code>hps cpeng</code> subcommand from the host. Note, the <code>hps</code> program can be installed as part of installing the OPAE SDK and Linux DFL suite of packages.</p> <p><code>hps</code> command details are located in Section 5.0 HPS Command Usage.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#43-example-boot","title":"4.3 Example Boot","text":"<p>This example assumes the following preconditions have been met prior to booting HPS:</p> <ul> <li>A SOF file synthesized with the SPL (u-boot-spl-dtb.hex).</li> <li>Copy engine IP with relevant registers accessible to host and HPS.</li> </ul> <p>Once the host FPGA boots with the required bitstream, the SPL in the HPS will begin polling a register in the copy engine. One way to get an indication that the HPS is ready to continue past the SPL is to use a terminal emulator on a host with a serial cable connected to the FPGA's UART port.</p> <p>To transfer the U-Boot FIT image, use the <code>hps</code> program with <code>cpeng</code> subcommand from the host. Note, the <code>hps</code> program is installed as part of installing the OPAE SDK suite of packages. See here for information on running the <code>hps</code> program. The following example assumes your N6000/1 board is at PCIe BDF 0000:b1:00.0.</p> <pre><code># Bind vfio-pci driver to Copy Engine PCIe Physical Function\n$ sudo opae.io init -d b1:00.4 root\n# Load the HPS SSBL\n$ hps cpeng -f u-boot.itb\n[2021-09-25 01:59:25.538] [cpeng] [info] starting copy of file:u-boot.itb, size: 116725656, chunk size: 4096\n[2021-09-25 01:59:29.935] [cpeng] [info] last chunk 1944, aligned 2048\n[2021-09-25 01:59:29.935] [cpeng] [info] transferred file in 28498 chunk(s)\n[2021-09-25 01:59:29.935] [cpeng] [info] waiting for ssbl verify...\n[2021-09-25 01:59:33.848] [cpeng] [info] ssbl verified\n[2021-09-25 01:59:33.848] [cpeng] [info] waiting for kernel verify...\n[2021-09-25 01:59:39.626] [cpeng] [info] kernel verified\n</code></pre> <p>This will transfer the U-Boot FIT image via the copy engine IP to the HPS DDR and then signal completion of the transfer to the copy engine. Once the copy engine completes the actual transfer, it will write to the register the HPS SPL is polling on allowing the SPL to load the U-Boot bootloader which will in turn boot into the Linux image embedded in the U-Boot FIT image. If a terminal emulator is connected to the UART as described above, a user can observe U-Boot and Linux running on the HPS.</p> <ol> <li>Validate the HPS SSBL has been loaded by checking for its heartbeat.</li> </ol> <pre><code>$ hps heartbeat\n[2021-09-25 01:59:42.722] [heartbeat] [info] heartbeat value: 0x30015\n[2021-09-25 01:59:43.722] [heartbeat] [info] heartbeat value: 0x40015\n[2021-09-25 01:59:44.722] [heartbeat] [info] heartbeat value: 0x50015\n[2021-09-25 01:59:45.723] [heartbeat] [info] heartbeat value: 0x60015\n[2021-09-25 01:59:46.723] [heartbeat] [info] heartbeat value: 0x70015\n</code></pre> <ol> <li>Login to HPS as user, root, with no password over serial connection. This process is covered in 8.0 Connecting remotely to the HPS using <code>ssh</code>.</li> </ol> <pre><code>agilex login: root\nroot@agilex:~# ls\nroot@agilex:~# ls /\nbin dev home lib mnt root sbin sys usr\nboot etc init media proc run srv tmp var\nroot@agilex:~#\n</code></pre>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#50-hps-command-usage","title":"5.0 HPS Command Usage","text":""},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#51-synopsis","title":"5.1 Synopsis","text":"<pre>hps OPTIONS SUBCOMMAND SUBCOMMAND\\_OPTIONS</pre>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#52-description","title":"5.2 Description","text":"<p>hps is an application to aid in the development, deployment, and debugging of an HPS (hard processor system) on an Intel Agilex device using OFS. The current version of the hps program assumes an AFU (accelerator functional unit) is configured into the FPGA that can be discovered/accessed through an OPAE library and used for communicating with the HPS. When invoked with one of its subcommands, hps will enumerate the AFU for that subcommand before executing it.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#53-options","title":"5.3 Options","text":"<pre>-h,--help\n\nPrint this help message and exit\n\n-p,--pci-address address\n\nUse address in the filter for locating the AFU where address must be in\n\nthe following format: [domain]\\bus\\:\\device\\.\\function\\\n\n-l,--log-level \\level\\\n\nstdout logging level. Must be one of:\n\n{trace,debug,info,warning,error,critical,off}\n\nDefault is info.\n\n-s,--shared\n\nopen in shared mode, default is off\n\n-t,--timeout timeout\n\nProgram timeout in milliseconds. Default is 60000 ms.</pre>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#54-subcommands","title":"5.4 Subcommands","text":""},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#541-cpeng","title":"5.4.1 cpeng","text":"<p>The copy engine command is used to program copy engine AFU registers to copy an image file from the host into the FPGA DDR. When the HPS boots, the first stage boot loader loads an image from a specific offset in DDR that will be used to transition into the second stage boot loader and subsequently boot into the embedded Linux that is also part of this image.</p> cpeng  options description -h,--help Print this help message and exit -f,--filename filename Path to image file to copy. Default is u-boot.itb -d,--destination offset DDR Offset. Default is 0x2000000. -t,--timeout cpeng timeout Timeout of cpeng command in microseconds. Default is 1 sec (1000000 usec). -r,--data-request-limit size Can be 64, 128, 512, or 1024 and represents the PCIe request size in bytes that the copy engine IP will use. This is encoded to 0, 1, 2, or 3 and written to the copy engine DATA\\REQUEST\\LIMIT register. Default is 512. -c,--chunk size Split the copy into chunks of size size. 0 indicates no chunks. Chunk sizes must be aligned with data request limit. Default is 4096. --soft-reset Issue a soft reset only. --skip-ssbl-verify Do not wait for ssbl verify. --skip-kernel-verify Do now wait for kernel verify."},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#542-heartbeat","title":"5.4.2 heartbeat","text":"<p>This subcommand reads the value in the HPS2HOST register to check for a hearbeat. This compares the value to previous value read and determines the HPS is alive if the value is incrementing. This relies on the hps running the hello-cpeng program in heartbeat mode which will increment the upper 16 bits in the HPS2HOST register. Please see a typical sequence of using the rsu and hps commands as below for a device with BDF 15:00:0</p> <pre><code>rsu fpga -p user1 15:00.0\nsudo opae.io release -d 15:00.0\nsudo opae.io init -d 15:00.4 root:root\nhps cpeng -f u-boot-userkey-vab.itb\ntimeout 5 hps heartbeat\nsudo opae.io release -d 15:00.0\nhps cpeng -f u-boot-userkey-vab.itb\n</code></pre> <p>The above command will transfer the U-Boot FIT image via the copy engine IP to the HPS DDR and then signal completion of the transfer to the copy engine. After the copy engine completes the actual transfer, it writes to the register the HPS SPL is polling on allowing the SPL to load the U-Boot bootloader which in turn boots into the Linux image embedded in the U-Boot FIT image. If a terminal emulator is connected to the UART as described above, a user can observe U-Boot and Linux running on the HPS.</p> <p>First FSBL is loaded and executed by FPGA configuration. Then Board/Server gets powered on. FPGA Configuration is done via JTAG followed by a reboot</p> <p>The FSBL will send the following output the serial port: <pre><code>U-Boot SPL 2021.07-00312-g32c0556437 (Sep 17 2021 - 08:42:45 -0700)\nReset state: Cold\nMPU 1200000 kHz\nL4 Main 400000 kHz\nL4 sys free 100000 kHz\nL4 MP 200000 kHz\nL4 SP 100000 kHz\nSDMMC 50000 kHz\nDDR: Warning: DRAM size from device tree (1024 MiB)\nmismatch with hardware (2048 MiB).\nDDR: 1024 MiB\nSDRAM-ECC: Initialized success with 239 ms\nwaiting for host to copy image\n</code></pre></p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#60-meta-bakepy","title":"6.0 meta-bake.py","text":"<p>A script called meta-bake.py has been added to allow for more control of configuration/customization of recipes and their dependencies. This script separates the data from the logic by requiring that data be expressed in a yaml configuration file. This file contains the following confiration data:</p> <ul> <li>machine - The FPGA/SoC platform to build for, choices are agilex, stratix10, arria10, cyclone5</li> <li>image - The image type to build, choices are gsrd, nand, pcie, pr, qsqpi, sgmii, tse, n6000</li> <li>target - The build target to build. This is typically a Yocto image to build.</li> <li>fit - Make a monolothic FIT image after the Yocto build. This will use U-Boot source and binaries as well as the rootfs made for the image.</li> <li>repos - A list of repositories to pull for Yocto recipes. This information is made up of:<ul> <li>name - The project name (this is also the directory where source is clone to)</li> <li>url - The URL to pull the source from</li> <li>branch - The branch to checkout</li> <li>add_layers - Can be either True or a list of sub-directories to add as layers in bblayers.conf</li> <li>patch - Path to a file to use to patch the source code</li> <li>keep - When set to true, this will leave the source tree untouched on subsequent runs</li> </ul> </li> <li>upstream_versions - Dependencies/versions to use for either Linux kernel, U-Boot, and/or ATF. This information is made up of:<ul> <li>name - Project name</li> <li>version - version to configure recipes that use it</li> <li>branch - branch to use, will use git hash in recipe</li> <li>url - URL to pull the source from</li> <li>disabled - when set to True, this project will be ignored</li> </ul> </li> <li>local - Used to configure local.conf used by Yocto/bitbake build. This information is made up of:<ul> <li>remove - List of keys to remove from local.conf</li> <li>values - Dictionary of key/value pairs to use to insert into local.conf. Any existing key/value pairs will be overwritten.</li> </ul> </li> </ul>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#61-running-meta-bakepy","title":"6.1 Running meta-bake.py","text":"<p>To create an U-Boot fit and spl image for N6000/1 platforms, run the following command after meeting these setup conditions:</p> <ul> <li>Host PC with Ubuntu 20.04 LTS<ul> <li>ARM cross compiler<ul> <li>set CROSS_COMPILE environment variable to: /bin/aarch64-linux-gnu-     - e.x. export CROSS_COMPILE=aarch64-linux-gnu- <li>set ARCH to: arm64     - e.x. export ARCH=arm64</li> <li>At least 100 Gb of disk space</li> <li>Tested on OFS 3.0.0</li> <p>This script does not require any bare-metal accesses to perform its build and can be run from a VM with no alterations. Ensure that the Ubuntu 20.04 Guest VM you create has enough to space to perform the entire build (recommend at least 200 GiB total space), as does the drive it is stored on. You will need to configure proxy access in the VM if required for your environment. You can use any VM technology; having <code>ssh</code> enabled in the VM will allow you to more easily transfer the completed build files back to the host system but is not required.</p> <p>Package dependencies to build Yocto on each supported OS can be found on the Yocto Quick Start page.</p> <pre><code>wget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.2-2020.11/binrel/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\nrm gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\nexport CROSS_COMPILE=`pwd`/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-\nexport ARCH=arm64\n./meta-bake.py build\n</code></pre> <p>After running this build, the images you need to boot the HPS are located under build/agilex-n6000-images. Follow the steps in Section 4.3 Example Boot to finish bringing up your board.</p> <p>This script will do the following:</p> <ul> <li>Parse layers.yaml for configuration to use for build</li> <li>Download recipe repositories (including poky) listed in <code>repos</code> secion of layers.yaml</li> <li>Apply refdes-n6000 patch to meta-intel-fpga-refdes source tree</li> <li>Configure Yocto build in build directory</li> <li>Source build/poky/oe-init-build-env passing in agilex-n6000-rootfs. This will initialize conf files.</li> <li>Configure build/agilex-n6000-rootfs/conf/local.conf using values in <code>local</code> section of layers.yaml          * Note: IMAGE_FSTYPES is configured to include <code>cpio</code></li> <li>Configure build/agilex-n6000-rootfs/conf/bblayers.conf using layer specification in <code>repos</code> section of layers.yaml</li> <li>Run Yocto build for target listed in layers.conf</li> <li>Call <code>bitbake n6000-image-minimal</code></li> <li>Get environment variables to locate rootfs cpio file as well as U-Boot source and build directories</li> <li>Copy rootfs created by Yocto build for U-Boot</li> <li>Copy rootfs cpio file (n6000-image-minimal-agilex*.rootfs.cpio) to U-Boot build directory for selected configuration (socfpga_agilex_n6000_defconfig)</li> <li>Call U-Boot build in directory for selected configuration</li> <li>Copy FIT image (u-boot.itb) to images directory, build/agilex-n6000-images</li> <li>Many important images are copied to build/agilex-n6000-images, which may be useful if using VAB</li> </ul>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#62-required-changes","title":"6.2 Required Changes","text":"<p>The patch file applied on top of the meta-intel-fpga-refdes repository introduces patches to:</p> <ul> <li>Add patch files so that Yocto can modify Linux kernel to add configuration for creating a device tree binary (DTB) compatible with N6000/1</li> <li>Add patch files so that Yocto can modify the bootloader in U-Boot to support booting with the assistance of the copy engine IP</li> <li>Modify rootfs to include copy-engine daemon as well as other packages that can be useful for debug</li> </ul> <p>These changes may eventually be merged into upstream repositories for linux-socfpga, u-boot-socfpga, and meta-intel-fpga-refdes. Once all changes make their way into the repositories for the aforementioned projects, it will no longer be necessary to apply patches.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#63-manual-build","title":"6.3 Manual Build","text":"<p>One may use <code>meta-bake.py</code> to only pull down required repositories and configure a Yocto build environment by using the --skip-build command line argument. To initiate a build after this, <code>source poky/oe-init-build-env</code> passing in a directory as the only argument. This will set up the user's environment to be able to run bitbake. To build the Yocto image, run <code>bitbake n6000-image-minimal</code>. This will build all the components necessary to build a FIT image. Once the build is complete, U-Boot make system may be used to make the FIT. The U-Boot build directory for the selected configuration can be found in the Yocto build environment directory at: <pre><code>$ cd tmp/work/agilex-poky-linux/u-boot-socfpga/1_v2021.07+gitAUTOINC+24e26ba4a0-r0/build/socfpga_agilex_n6000_defconfig\n</code></pre> Once in this directory, ensure that the necessary files are present in here in order to assemble the FIT image (u-boot.itb) <pre><code>$ cp ../../../../../../deploy/images/agilex/n6000-image-minimal-agilex.cpio rootfs.cpio\n$ ls Image linux.dtb rootfs.cpio\nImage  linux.dtb  rootfs.cpio\n$ make\n</code></pre></p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#64-manual-vab-signing","title":"6.4 Manual VAB Signing","text":"<ul> <li>By default, <code>meta-bake.py</code> will sign and certify the proper files for use with VAB. Below is an example on how to perform the manual VAB Signing Process.</li> </ul> <p>Make sure Quartus already installed and its tools added to environment. Example PATH=$PATH:/home/intelFPGA\\pro/21.3/quartus/bin/</p> <pre><code>$ cd HPS_VAB\n$ quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase userkey_root_private.pem\n$ quartus_sign --family=agilex --operation=make_public_pem userkey_root_private.pem userkey_root_public.pem\n$ quartus_sign --family=agilex --operation=make_rootuserkey_root_public.pem userkey_root_public.qky\n$ chmod +x fcs_prepare\n$ ./fcs_prepare --hps_cert bl31.bin -v\n$ quartus_sign --family=agilex --operation=SIGN --qky=userkey_root_public.qky --pem=userkey_root_private.pem unsigned_cert.ccert signed_cert_bl31.bin.ccert\n\n# ATF Sign\n$ ./fcs_prepare --finish signed_cert_bl31.bin.ccert --imagefile bl31.bin\n$ mv hps_image_signed.vab signed-bl31.bin\n$ rm unsigned_cert.ccert\n\n# u-boot-nodtb\n$ ./fcs_prepare --hps_cert u-boot-nodtb.bin -v\n\n#signed_u-boot-nodtb.bin.ccert\n$ quartus_sign --family=agilex --operation=SIGN --qky=userkey_root_public.qky --pem=userkey_root_private.pem unsigned_cert.ccert signed_u-boot-nodtb.bin.ccert\n\n# u-boot-nodtb.bin Sign\n$ ./fcs_prepare --finish signed_u-boot-nodtb.bin.ccert --imagefile u-boot-nodtb.bin\n$ mv hps_image_signed.vab signed-u-boot-nodtb.bin\n$ rm unsigned\\_cert.ccert\n\n# u-boot.dtb\n$ ./fcs_prepare --hps_cert u-boot.dtb -v\n\n#signed_u-boot.dtb.ccert\n$ quartus_sign --family=agilex --operation=SIGN --qky=userkey_root_public.qky --pem=userkey_root_private.pem unsigned_cert.ccert signed_u-boot.dtb.ccert\n\n# u-boot.dtb Sign\n$ ./fcs_prepare --finish signed_u-boot.dtb.ccert --imagefile u-boot.dtb\n$ mv hps_image_signed.vab signed-u-boot.dtb\n$ rm unsigned_cert.ccert\n\n# Image\n$ ./fcs_prepare --hps/cert Image -v\n\n#signed_Image.ccert\n$ quartus_sign --family=agilex --operation=SIGN --qky=userkey_root_public.qky --pem=userkey_root_private.pem unsigned_cert.ccert signed_Image.ccert\n\n# Image Sign\n$ ./fcs_prepare --finish signed_Image.ccert --imagefile Image\n$ mv hps_image_signed.vab signed-Image\n$ rm unsigned_cert.ccert\n\n# linux.dtb\n$ ./fcs_prepare --hps_cert linux.dtb -v\n\n#signed_linux.dtb.ccert\n$ quartus_sign --family=agilex --operation=SIGN --qky=userkey_root_public.qky --pem=userkey_root_private.pem unsigned_cert.ccert signed_linux.dtb.ccert\n\n# linux.dtb Sign\n$ ./fcs_prepare --finish signed_linux.dtb.ccert --imagefile linux.dtb\n$ mv hps_image_signed.vab signed-linux.dtb\n$ rm unsigned_cert.ccert\n\n# rootfs.cpio\n$ ./fcs_prepare --hps_cert rootfs.cpio -v\n\n#signed_rootfs.cpio.ccert\n$ quartus_sign --family=agilex --operation=SIGN --qky=userkey_root_public.qky --pem=userkey_root_private.pem unsigned_cert.ccert signed_rootfs.cpio.ccert\n\n# rootfs.cpio\n$ ./fcs_prepare --finish signed_rootfs.cpio.ccert --imagefile rootfs.cpio\n$ mv hps_image_signed.vab signed-rootfs.cpio\n$ rm unsigned_cert.ccert\n</code></pre> <p>Copy the following files to u-boot-socfpga folder:</p> <p><pre><code>#Copy the image back to uboot folder\n$ cp signed-bl31.bin ../u-boot-socfpga/\n$ cp signed-u-boot-nodtb.bin ../u-boot-socfpga/\n$ cp signed-u-boot.dtb ../u-boot-socfpga/\n$ cp signed-Image ../u-boot-socfpga/\n$ cp signed-linux.dtb ../u-boot-socfpga/\n$ cp signed-root\n$ fs.cpio ../u-boot-socfpga/\n</code></pre> Recompile the U-Boot</p> <pre><code>$ git clone https://github.com/altera-opensource/u-boot-socfpga\n$ cd u-boot-socfpga\n$ export CROSS\\COMPILE=aarch64-none-linux-gnu-; export ARCH=arm\n$ make socfpga/agilex/n6000/vab/defconfig\n$ make -j 24\n$ cd ..\n</code></pre> <p>Figure 3.1 N6000/1 Configs</p> <p></p> <p>If you not see the defconfig desired, please checkout the correct branch version. Example config shown above is socfpga_v2021.10.</p> <p>If the memory device tree it mismatches with your hardware (figure below), change the memory device tree at u-boot-socfpga/arch/arm/dts/socfpga_agilex_n6000-u-boot.dtsi</p> <p>To make it 2GB, change as</p> <p><pre><code>memory {\n\n\\* 2GB \\*\n\nreg = &lt;0 0x00000000 0 0x40000000&gt;,&lt;0 0x00000000 0 0x40000000&gt;;\n\n};\n</code></pre> Figure 3.2 Device tree mismatches example</p> <p></p> <p>Refer to 6. Host Side Startup</p> <p><pre><code>$ sudo opae.io init -d 4b:00.4 root:root\n$ hps cpeng -f u-boot.itb\n$ timeout 5 hps heartbeat\n</code></pre> The error happen (Figure below) when the Images do not sign with VAB.</p> <p>Figure 3.3 VAB certificate error example</p> <p></p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#70-debugging","title":"7.0 Debugging","text":"<p>Debugging the HPS from the host side is standard HPS debugging. The primary debug tool is UART on the HPS and Arm DS-5 debugger.</p> <p>A UART connection can be enabled on the board using the following procedure:</p> <ol> <li> <p>Connect the HPS Debug Card and HPS UART to the Intel N6000/1-PL FPGA SmartNIC Platform board</p> </li> <li> <p>Open Putty with the following setting <pre><code>    Port:COM4\n\n    Baudrate:115200\n\n    Data bits : 8\n\n    Stop bits : 1\n\n    Parity : None\n\n    Flow Control : None\n</code></pre></p> </li> <li> <p>Reboot the Intel N6000/1-PL FPGA SmartNIC Platform board by typing <code>reboot</code> in the shell. You will be able to see the HPS UART traffic in the putty. If any issues are encountered in this step, check the HPS UART connection and the UART driver.</p> </li> <li> <p>Check the PCI bdf ( lspci | grep acc ) or fpgainfo fme at the shell prompt.</p> </li> <li> <p>Run the rsu and fpga\\reconfig scripts with respective arguments to print the logs.</p> </li> </ol>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#80-connecting-remotely-to-the-hps-using-ssh","title":"8.0 Connecting remotely to the HPS using <code>ssh</code>","text":"<p>The HPS running on the Intel FPGA N6000/1-PL SmartNIC Platform can be remotely accessed to via the utility <code>ssh</code>, allowing the user to run commands and copy files. SSH must be run over a Point-To-Point Protocol daemon that has been included in the HPS software (as a part of the meta-openembedded layer, in the recipes-daemons/ippool recipe). In this example, the HPS is set up as a PPP Server, and the host OS is set up as a PPP Client. Serial communication between the host and HPS is accomplished via HPS UART1, which communicates through the FIM to the Soft UART on the FPGA, who in turn communicates with the host over PCIe.</p> <p>The following steps assume the SSBL has not yet been loaded onto the HPS. If it has, a cold boot will reset the system.</p> <ol> <li>The HPS Copy Engine Module is available for access on PF 4 via the PF/VF Mux on the FPGA. This port needs to be bound to driver <code>vfio-pci</code> (the following example assumes PCIE BDF 0000:b1:00.0). Substitute your device's BDF address and desired user/group access permissions into the following command.</li> </ol> <pre><code>$ sudo opae.io init -d 0000:b1:00.4 &lt;USER&gt;[:&lt;GROUP&gt;]\nUnbinding (0x8086,0xbcce) at 0000:b1:00.4 from dfl-pci\nBinding (0x8086,0xbcce) at 0000:b1:00.4 to vfio-pci\niommu group for (0x8086,0xbcce) at 0000:b1:00.4 is 190\nAssigning /dev/vfio/190 to DCPsupport\nChanging permissions for /dev/vfio/190 to rw-rw----\n</code></pre> <ol> <li>When an HPS enabled SOF or BIN with the FSBL is loaded onto the FPGA, a message will be displayed on the host OS (seen via <code>dmesg</code>) after boot once the serial port has been registered with the dfl-uart driver. The UART driver is included as a part of the linux-dfl driver package. An example output from <code>dmesg</code> is shown below (search dmesg using <code>dmesg | grep dfl-uart</code>):</li> </ol> <pre><code>[    7.343014] dfl-uart dfl_dev.7: serial8250_register_8250_port 2\n</code></pre> <p>The device file that corresponds with serial UART port 2 is <code>/dev/ttyS2</code> (format is <code>/dev/ttyS&lt;port number&gt;</code>). A serial communication program can be used to view the HPS boot in realtime, then log in and run commands when boot has completed. Minicom is the program that will be used in this example, although others will work. Install Minicom using DNF <code>sudo dnf install minicom</code>. </p> <ol> <li>Minicom requires configuration changes before it can listen to the serial device. Using the built-in menu accessed by <code>sudo minicom -s</code>, ensure the information under \"Serial port setup\" matches the following, where the serial device corresponds with the serial port discussed previously:</li> </ol> <pre><code> +-----------------------------------------------------------------------+\n    | A -    Serial Device      : /dev/ttyS2                                |\n|                                                                       |\n| C -   Callin Program      :                                           |\n| D -  Callout Program      :                                           |\n| E -    Bps/Par/Bits       : 115200 8N1                                |\n| F - Hardware Flow Control : Yes                                       |\n| G - Software Flow Control : No                                        |\n|                                                                       |\n|    Change which setting?                                              |\n+-----------------------------------------------------------------------+\n</code></pre> <ol> <li> <p>Save and exit the configuration menu. Run Minicom using the command <code>sudo minicom</code> and keep the terminal open and connected.</p> </li> <li> <p>Load the SSBL onto the HPS using a second terminal. This requires a built ITB image.</p> </li> </ol> <pre><code>$ hps cpeng -f u-boot.itb\n</code></pre> <ol> <li>You should see the HPS boot sequence continue through your Minicom terminal. Once boot has completed, log in using the user <code>root</code> with an empty password.</li> </ol> <pre><code>...\n...\n...\n[  OK  ] Finished Load/Save Random Seed.\n[  OK  ] Finished OpenSSH Key Generation.\n\nPoky (Yocto Project Reference Distro) 3.3.6 agilex ttyS0\n\nagilex login: root\nroot@agilex:~#\n</code></pre> <ol> <li>Configure the running Yocto image on the HPS as a PPP server. Run the following command through Minicom on the HPS (connects address 192.168.250.2 on the HPS to 192.168.250.1 on the host):</li> </ol> <pre><code>root@agilex:~# pppd noauth passive 192.168.250.1:192.168.250.2\n[  410.465450] PPP generic driver version 2.4.2\n...\n</code></pre> <ol> <li>Exit the Minicom program running on the host using <code>^A X</code>. Execute the following command on the host to establish a PPP connection as the client (if not installed on the host, run <code>sudo dnf install ppp</code>):</li> </ol> <pre><code>$ sudo pppd ttyS2 115200 crtscts lock local noauth passive debug\n</code></pre> <ol> <li>A new network interface device registered to ppp should be visible.</li> </ol> <pre><code>$ ip -4 addr\n...\n8: ppp0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 3\ninet 192.168.250.2 peer 192.168.250.1/32 scope global ppp0\n       valid_lft forever preferred_lft forever\n</code></pre> <p>With both the client and server communicating, <code>ssh</code> and <code>scp</code> can be used to run commands and transfer files using IPv4 address 192.168.250.1 on the host. An example operation run on the host OS is shown below:</p> <pre><code>[user@localhost ]: scp file_package.tar.gz root@192.168.250.1\n</code></pre> <p>Note: If you are developing software for the HPS and altering system settings, it is possible for <code>ssh</code> to prohibit a connection due to a false man-in-the-middle attack warning. The flag <code>&lt;ssh/scp&gt; -o StrictHostKeyChecking=no</code> can be used to ignore the warning.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#90-example-design-enabling-emmc-i2c-and-uart-in-platform-design","title":"9.0 Example Design - Enabling eMMC, I2C and UART in Platform Design","text":"<p>The following section will walk through the process by which eMMC, I2C, and UART can be added to the FIM and the HPS image. The goal of this section is to allow the HPS to configure eMMC memory on boot and uses WNC's FPGA SmartNIC Series as a reference.</p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#91-configuring-the-fim","title":"9.1 Configuring the FIM","text":"<ol> <li>Configure eMMC, I2C, and UAET in Platform Designer. ACtual pin assignments are determined by the WNC board schematic. In Quartus, navigate to the HPS Processor Subsystem Intel Agilex FPGA IP -&gt; Pin Mux and Peripherals -&gt; Advanced -&gt; Advanced IP Placement.</li> </ol> <p>Check your pin assigments for the eMMC, UART and I2C in the Pin Planner. If these assignments are not present, then they can be found at the following link. Based on the changes shown above, the UART pins are removed on HPS IO3 and IO4 what are mapped on AG6 and AB1.</p> <p></p> <ol> <li>Click Apply Selections-&gt;Generate HDL</li> </ol> <p></p> <ol> <li>Check for instantiation in <code>top.sv</code>. Click Generate -&gt; Show Instatiation Template.</li> </ol> <p></p> <p>The following image demonstrates eMMC and I2C properly instatiated in <code>top.sv</code>.</p> <p></p> <ol> <li>Add the following to the hps_ss modules in <code>top.sv</code>.</li> </ol> <p></p> <p></p> <ol> <li>Compile the design.</li> </ol> <p></p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#92-configuring-the-hps","title":"9.2 Configuring the HPS","text":"<ol> <li>Enable mmc and DesignWare Memory Card interface flags in U-Boot (.config). After building U-Boot with <code>meta-bake.py</code>, this file is located at /agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-socfpga//build/socfpga_agilex_n6000_defconfig/.config. <pre><code>CONFIG_CMD_MMC=y //Enable mmc command tool in uboot CONFIG_MMC_DW=y // support DesignWare Memory Card Interface\n</code></pre> <ol> <li>Enable and configure I2C and eMMC in U-Boot (socfpga_agilex_n6000.dts). After building U-Boot with <code>meta-bake.py</code>, this file is located at /agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-socfpga/git/arch/arm/dts/socfpga_agilex_n6000.dts. <ol> <li>Enable and configure I2C and eMMC in the Linux device tree (socfpga_agilex_n6000.dts). After building U-Boot with <code>meta-bake.py</code>, this file is located at /agilex-n6000-rootfs/tmp/work-shared/agilex/kernel-source/arch/arm64/boot/dts/intel/socfpga_agilex_n6000.dts. <ol> <li>Compile Linux by navigating to the directory agilex-n6000-rootfs/tmp/work/agilex-poky-linux/linux-socfpga-lts/5.10.60-lts+gitAUTOINC+c35d63f9c7-r0/linux-agilex-standard-build and running the following:</li> </ol> <pre><code>$ make -j `nproc` Image dtbs  </code></pre> <ol> <li>Add the software utilities<code>util-linux-mkfs e2fsprogs.mke2fs e2fsprogs</code> in to the Linux RootFS. Thes utilities will be used to create a filsystem (ext4, FAT32, etc.) and partition the eMMC. Make the following changes in meta-intel-fpga-refdes/recipes-images/poky/n6000-image-minimal.bb.</li> </ol> <ol> <li> <p>As an output from the Linux compilation from step 4 you will produce the files Image and socfpga_agilex_n6000.dtb. Transfer both over to the socfpga_agilex_n6000_defconfig directory. Rename socfpga_agilex_n6000.dtb to linux.dtb. Compile U-Boot by running <code>make</code> in directory agilex-n6000-rootfs/tmp/work/agilex-poky-linux/u-boot-socfpga/1_v2021.07+gitAUTOINC+24e26ba4a0-r0/build/socfpga_agilex_n6000_defconfig/. This compilation will produce both <code>spl/u-boot-spl-dtb.hex</code> and <code>u-boot.itb</code>. </p> </li> <li> <p>Combines these files with your SOF FSBL bootloader (created in Section 9.1 Configuring the FIM).</p> </li> </ol> <pre><code>$ quartus_pfg -c ofs_top.sof ofs_top_hps.sof -o hps_path=u-boot-spl-dtb.hex\n$ quartus_pfg -c  ofs_top_hps_pof_flash.pfg //to pof file and flash to qspi\n</code></pre> <p>Program the FSBL enabled SOF onto the FPGA and warm reboot the server for changes to take affect. After reboot has completed use the following commands to program the SSBL.</p> <pre><code>$ sudo opae.io release -d d8:00.0\n$ sudo opae.io init -d d8:00.4 root:root\n$ hps cpeng -f u-boot.itb\n</code></pre> <p>During HPS boot you should see the following message if the eMMC has been properly configured.</p> <p></p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#93-emmc-testing-from-the-hps","title":"9.3 eMMC Testing from the HPS","text":"<p>The following memory test was run from the U-Boot shell.</p> <ol> <li>Erase eMMC using a start block offset 0x400.</li> </ol> <pre><code>$ mmc erase 0x400 20\n</code></pre> <p></p> <p>Write test data (at 0x00A00000) into the eMMC offset 0x400.</p> <pre><code>$ mmc write 0x00A00000 0x400 10\n</code></pre> <p></p> <p>Read test data (at 0x00A00040) back from eMMC offset 0x400.</p> <pre><code>$ mmc read 0x00A00040 0x400 10\n</code></pre> <p></p> <p>Data comparison at memory offset 0x00A00000 and 0x00A00040. Data should match.</p> <pre><code>$ cmp.l 0x00A00000 0x00A00040 10.\n</code></pre> <p></p> <p>The following memory test was run from Linux running on the HPS.</p> <ol> <li>Display the eMMC and its partitions.</li> </ol> <pre><code>$ fdisk -l\n</code></pre> <p></p> <ol> <li>Create a primary partition on the eMMC.</li> </ol> <p></p> <ol> <li>Verify the partition has been created.</li> </ol> <p></p> <ol> <li>Format the ext3 filesystem in the partition you just created (p1).</li> </ol> <p></p> <ol> <li>Create the directory <code>mydata</code> in /mnt. Mount the eMMC p1 partition to <code>/mnt/mydata</code> and verify the filsystem mount was successful.</li> </ol> <pre><code>$ mkdir -p /mnt/mydata\n$ mount /dev/mmcblk0p1 /mnt/mydata\n$ df\n</code></pre> <p></p> <ol> <li>Create a new text file and write some data in it - \"Hello World!\". After the device has been written to run <code>sync</code>, unmount eMMC p1 partition and verify the unmount was successful.</li> </ol> <pre><code>$ sync\n$ umount /dev/mmcblk0p1\n$ df\n</code></pre> <p></p>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#layersyaml-reference","title":"layers.yaml Reference","text":"<pre><code>machine: agilex\nimage: n6000\ntarget: n6000-image-minimal\nfit: true\nuboot-dtb: [u-boot-nodtb.bin, u-boot.dtb]\nlinux-binary: [bl31.bin, linux.dtb, rootfs.cpio, Image]\nroot-public-qky: userkey_root_public.qky\nroot-private-pem: userkey_root_private.pem\nroot-public-pem: userkey_root_public.pem\nrepos:\n- name: poky\nurl: https://git.yoctoproject.org/git/poky.git\nbranch: hardknott\n- name: meta-intel-fpga\nurl: https://git.yoctoproject.org/git/meta-intel-fpga.git\nbranch: hardknott\nadd_layers: true\n- name: meta-intel-fpga-refdes\nurl: https://github.com/altera-opensource/meta-intel-fpga-refdes.git\n#url__: https://github.com/intel-innersource/os.linux.yocto.reference-design.meta-intel-fpga-refdes.git\n#url: git@github.com:intel-innersource/os.linux.yocto.reference-design.meta-intel-fpga-refdes.git\n#branch: rrojo/n6000\nbranch: hardknott\npatch: refdes-n6000-ppp.patch\nkeep: true\nadd_layers: true\n- name: meta-openembedded\nurl: https://github.com/openembedded/meta-openembedded.git\nbranch: hardknott\nadd_layers:\n- meta-oe\n- meta-networking\n- meta-python\n- name: fcs_prepare\nurl: https://github.com/altera-opensource/fcs_apps.git\nbranch: fcs_prepare\ningredients:\nlinux:\nname: linux-socfpga\nversion: '5.10.100'\nbranch: socfpga-5.10.100-lts\nurl: https://github.com/altera-opensource/linux-socfpga.git\nuboot:\nname: u-boot-socfpga\nversion: '2021.07'\nbranch: socfpga_v2021.07\nurl: https://github.com/altera-opensource/u-boot-socfpga.git\natf:\ndisabled: true\nversion: '2.4.1'\nbranch: socfpga_v2.4.1\nurl: https://github.com/altera-opensource/arm-trusted-firmware.git\nlocal:\nremove:\n- MACHINE\n- UBOOT_CONFIG\n- IMAGE\n- SRC_URI\nvalues:\nMACHINE: $machine\nDL_DIR: $build_dir/downloads\nDISTRO_FEATURES_append: \" systemd\"\nVIRTUAL-RUNTIME_init_manager: systemd\nIMAGE_TYPE: $image\nIMAGE_FSTYPES: \"+=cpio tar.gz\"\nPREFERRED_PROVIDER_virtual/kernel: linux-socfpga-lts\nPREFERRED_VERSION_linux-socfpga-lts: 5.10%\nUBOOT_CONFIG: agilex-n6000\nPREFERRED_PROVIDER_virtual/bootloader: u-boot-socfpga\nPREFERRED_VERSION_u-boot-socfpga: v2021.07%\n</code></pre>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#faqs","title":"FAQs","text":"<p>Below are the Frequently Asked Questions:</p> <ol> <li> <p>How will you get the software stack for HPS (FSBL, U-Boot, Kernel)? Or will there be a package available to them on Git, Intel RDC?</p> <p>Answer : HPS software has been around for quite a long time. Support for the OFS and the N6000-PL FPGA SmartNIC Platform will be upstreamed and available from rocketboards.com, just like any other HPS based project.</p> </li> <li> <p>What are the recommended steps for building the binaries and where will those be located?</p> <p>Answer: There are many documents on building the binaries at rocketboards.com. Any reference binaries can be stored at rocketboards.com as well.</p> </li> <li> <p>What are the host side commands used to put the binaries to Copy Engine and from there to HPS?</p> <p>Answer: There is a single command, hps to download the single binary through the Copy Engine to the HPS.</p> </li> <li> <p>What are the host side commands used to reset the HPS from Host side?</p> <p>Answer: This functionality is planned to be added to the hps command.</p> </li> <li> <p>What is the procedure used to debug the HPS from Host side?</p> <p>Answer: Debugging the HPS from the host side is standard HPS debugging. The primary debug tool is UART on the HPS and the Arm DS debugger.</p> </li> <li> <p>Do we have performance metrics about HPS, like whether any bench marking information available with any sample application is available?</p> <p>Answer: Any performance metrics on the HPS would be available on rocketboards.com.</p> </li> <li> <p>What is the PXE boot flow and what is required to enable the same?</p> <p>Answer: On some configurations, HPS is treated as a fully-fledged SoC and can PXE boot itself. But you must add this functionality.</p> </li> </ol>"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#further-links","title":"Further Links","text":"Description Link OFS Getting Started User Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs https://ofs.github.io/hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/ Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs https://ofs.github.io/hw/n6001/dev_guides/fim_dev/ug_dev_fim_ofs_n6001/ Open FPGA Stack Technical Reference Manual for Intel Agilex FPGA PCIe Attach https://ofs.github.io/hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/ AFU Development Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs https://ofs.github.io/hw/N6001/dev_guides/afu_dev/ug_dev_afu_n6001/ Simulation User Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs https://ofs.github.io/hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/ FPGA Device Feature List (DFL) Framework Overview https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev/Documentation/fpga/dfl.rst#fpga-device-feature-list-dfl-framework-overview ofs-platform-afu-bbb https://github.com/OFS/ofs-platform-afu-bbb Connecting an AFU to a Platform using PIM https://github.com/OFS/ofs-platform-afu-bbb/blob/master/plat_if_develop/ofs_plat_if/docs/PIM_AFU_interface.md example AFUs https://github.com/OFS/examples-afu.git PIM Tutorial https://github.com/OFS/examples-afu/tree/main/tutorial Non-PIM AFU Development https://github.com/OFS/examples-afu/tree/main/tutorial Intel FPGA IP Subsystem for PCI Express IP User Guide https://github.com/OFS/ofs.github.io/docs/hw/common/user_guides/ug_qs_pcie_ss.pdf Memory Subsystem Intel FPGA IP User Guide https://github.com/OFS/ofs.github.io/docs/hw/common/user_guides/ug_qs_mem_ss.pdf OPAE.io https://opae.github.io/latest/docs/fpga_tools/opae.io/opae.io.html OPAE GitHub https://github.com/OFS/opae-sdk README_ofs_n6001_eval.txt https://github.com/OFS/ofs-n6001/blob/release/ofs-2023.1/eval_scripts/README_ofs_n6001_eval.txt FIM MMIO Regions https://ofs.github.io/hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#mmio_regions evaluation script https://github.com/OFS/ofs-n6001/tree/release/ofs-2023.1/eval_scripts OFS https://github.com/OFS OFS GitHub page https://ofs.github.io DFL Wiki https://github.com/OPAE/linux-dfl/wiki"},{"location":"hw/n6001/dev_guides/hps_dev/hps_developer_ug/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"hw/n6001/doc_modules/Glossary/","title":"Glossary","text":"Term Abbreviation Description Advanced\u00a0Error\u00a0Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link) Accelerator\u00a0Functional\u00a0Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.\u00a0Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region. Basic Building Block BBB Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. Best\u00a0Known\u00a0Configuration BKC The software and hardware configuration Intel uses to verify the solution. Board\u00a0Management\u00a0Controller BMC Supports features such as board power managment, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate component, such as an Intel Max10 or Intel Cyclone10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA. Configuration and\u00a0Status\u00a0Register CSR The generic name for a register space which is accessed in order to interface with the module it resides in (e.g. AFU, BMC, various sub-systems and modules). Data Parallel C++ DPC++ DPC++ is Intel\u2019s implementation of the SYCL standard. It supports additional attributes and language extensions which ensure DCP++ (SYCL) is efficiently implanted on Intel hardware. Device\u00a0Feature\u00a0List DFL The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\u00a0This concept is the foundation for the OFS software framework. (link) FPGA\u00a0Interface\u00a0Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FPGA\u00a0Management\u00a0Engine FME Performs reconfiguration and other FPGA management functions. Each FPGA device only has one FME which is accessed through PF0. Host\u00a0Exerciser\u00a0Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Intel\u00a0Virtualization\u00a0Technology for\u00a0Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Joint Test Action Group JTAG Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. Memory\u00a0Mapped\u00a0Input/Output MMIO The memory space users may map and access both control registers and system memory buffers with accelerators. oneAPI Accelerator Support Package oneAPI-asp A collection of hardware and software components that enable oneAPI kernel to communicate with oneAPI runtime and OFS shell components. oneAPI ASP hardware components and oneAPI kernel form the AFU region of a oneAPI system in OFS. Open\u00a0FPGA\u00a0Stack OFS OFS is a software and hardware infrastructure providing an efficient approach to develop a custom FPGA-based platform or workload using an Intel, 3rd party, or custom board. Open\u00a0Programmable\u00a0Acceleration\u00a0Engine Software Development Kit OPAE-SDK The OPAE-SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Platform\u00a0Interface\u00a0Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Platform Management Controller Interface PMCI The portion of the BMC that resides in the Agilex FPGA and allows the FPGA to communicate with the primary BMC component on the board. Partial Reconfiguration PR The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. For OFS designs, the PR region is referred to as the pr_slot. Port N/A When used in the context of the fpgainfo port command it represents the interfaces between the static FPGA fabric and the PR region containing the AFU. Remote System Update RSU The process by which the host can remotely update images stored in flash through PCIe. This is done with the OPAE software command \"fpgasupdate\". Secure Device Manager SDM The SDM is the point of entry to the FPGA for JTAG commands and interfaces, as well as for device configuration data (from flash, SD card, or through PCI Express* hard IP). Static Region SR The portion of the FPGA design that cannot be dynamically reconfigured during run-time. Single-Root\u00a0Input-Output\u00a0Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. SYCL SYCL SYCL (pronounced \"sickle\") is a royalty-free, cross-platform abstraction layer that enables code for heterogeneous and offload processors to be written using modern ISO C++ (at least C++ 17). It provides several features that make it well-suited for programming heterogeneous systems, allowing the same code to be used for CPUs, GPUs, FPGAs or any other hardware accelerator. SYCL was developed by the Khronos Group, a non-profit organization that develops open standards (including OpenCL) for graphics, compute, vision, and multimedia. SYCL is being used by a growing number of developers in a variety of industries, including automotive, aerospace, and consumer electronics. Test Bench TB Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. Universal Verification Methodology UVM A modular, reusable, and scalable testbench structure via an API framework.  In the context of OFS, the UVM enviroment provides a system level simulation environment for your design. Virtual\u00a0Function\u00a0Input/Output VFIO An Input-Output Memory Management Unit (IOMMU)/device agnostic framework for exposing direct device access to userspace.\u00a0(link)"},{"location":"hw/n6001/doc_modules/Notices_%26_Disclaimers/","title":"Notices & Disclaimers","text":""},{"location":"hw/n6001/doc_modules/Notices_%26_Disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/","title":"FPGA Interface Manager Technical Reference Manual for Intel Agilex PCIe Attach: Open FPGA Stack","text":""},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1-overview","title":"1 Overview","text":""},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document describes the hardware architecture for the PCIe attach reference FIM of the Open FPGA Stack (OFS) targeting the Intel\u00ae Agilex\u00ae FPGA.  After reviewing this document you should understand the features and functions of the components that comprise the FPGA Interface Manager (FIM), also known as the \"shell.\"</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#12-introduction-to-open-fpga-stack","title":"1.2 Introduction to Open FPGA Stack","text":"<p>The Open FPGA Stack (OFS) is a modular infrastructure of hardware platform components, open source upstreamed software, and broad ecosystem support that enables an efficient path to develop a custom FPGA platform.  OFS provides a framework of FPGA synthesizable code, simulation environment and synthesis/simulation scripts.  The key components of OFS include:</p> <ul> <li>Target development platforms such as Intel-branded Programmable Acceleration Cards (PACs), Acceleration Development Platforms (ADPs) and third-party platforms.</li> </ul> <ul> <li>Board Management Controller RTL and firmware that supports telemetry monitoring and capability for remote configuration updates.</li> </ul> <ul> <li>Source accessible, modular FPGA Interface  manager (FIM) RTL with a UVM infrastructure unit tests that can be leveraged for your own custom FIM design. The FIM can be thought of as the FPGA shell that provides the I/O ring and timing closed management components for the FPGA.</li> </ul> <ul> <li>Basic building blocks for interconnect and PF/VF translation and arbitration; Platform Interface Manager (PIM) which provides Avalon\u00ae bus compliant interfaces.</li> </ul> <ul> <li>AFU examples both in the git repository and workload examples provided by 3rd party vendors.</li> </ul> <ul> <li>A OneAPI acceleration support package (oneapi-asp) that provides a bridge layer that is used by OneAPI runtime to communicate with the kernel.</li> </ul> <ul> <li>Unit level simulation test suite</li> </ul> <ul> <li>System level simulation through a unified verification methodology (UVM)</li> </ul> <ul> <li>OPAE software development kit (APIs, upstreamed Linux drivers and software tools)</li> </ul> <ul> <li>Support for other frameworks to be built on top of the OPAE such as DPDK </li> </ul> <p>These components are available under the https://github.com/OFS site.</p> <p>The OFS hardware repository supports hardware development and simulation.  Repositories for OFS high level design support and board management controller RTL and firmware source code are also provided.  These repositories can be found in the Intel Opensource Technology GitHub location, which requires entitlement access.  To request access, please contact your local Intel sales representative.</p> <p>Table 1-2 OFS Hardware Repositories</p> Repository Contains ofs-n6001 Contains FIM or shell RTL, automated compilation scripts, and unit tests and UVM framework. oneapi-asp Contains the hardware and software components you need to develop your own OneAPI board support package ofs-platform-afu-bbb Contains the files and scripts to build the platform interface manager. ofs-examples-afu Contains AFU examples you can use. ofs-bmc Provides the OFS Board Management Controller RTL, firmware, scripts and collateral targeting the Intel\u00ae FPGA SmartNIC N6001-PL which can be leveraged for your own OFS design. <p>Table 1-3 OFS Software Repositories</p> OPAE Git Repository Folder Contains opae-sdk Contains the files for building and installing OPAE SDK from source. linux-dfl Contains OFS Linux drivers that are being upstreamed to the Linux kernel. opae-sim Contains the files for an AFU developer to build the Accelerator Functional Unit Simulation Environment (ASE) for workload development. <p>Providing the hardware and software source code and supporting test frameworks in a GitHub repository allows you to customize your designs with the latest versions easily.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#13-ofs-features","title":"1.3 OFS Features","text":"<p>The OFS architecture within the FPGA comprises two partitions:</p> <ul> <li>FPGA Interface Manager (FIM)</li> </ul> <ul> <li>Accelerator Functional Unit (AFU)</li> </ul> <p>The FIM or shell provides platform management functionality, clocks, resets and interface access to the host and peripheral features of the acceleration platform. The FIM architecture along with the supporting OPAE software supports features such as partial reconfiguration and virtualization. The FIM provides a standard Arm\u00ae AMBA\u00ae 4 AXI4 datapath interface. The FIM resides in the static region of the FPGA.</p> <p>The AFU partition is provided for custom acceleration workloads and may contain both static and partial reconfiguration regions.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#14-fpga-interface-manager-fim","title":"1.4 FPGA Interface Manager (FIM)","text":"<p>The primary components of the FPGA Interface Manager or shell of this reference design are: </p> <ul> <li>PCIe Subsystem</li> <li>HSSI Subsystem</li> <li>Memory Subsystem</li> <li>Hard Processor System</li> <li>Reset Controller</li> <li>FPGA Management Engine</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from Host or AFU</li> <li>Platform Management Controller Interface (PMCI) to the board management controller</li> </ul> <p>The AFU Region provides design space for custom workloads and contains both static and partial reconfiguration regions.  Partial reconfiguration allows you to update your specific logic blocks or entire workload while the rest of your static design is still in operation.</p> <p>Note that the BMC RTL and firmware that works with this OFS design provided in a separate entitled repository.  Please email ofs.github@intel.com if you would like to use our BMC code for your own design.</p> <p>Figure 1-2 OFS for OFS FIM for Agilex OFS Block Diagram</p> <p></p> <p>The table provides an overview of the OFS features targeting the Intel\u00ae Agilex\u00ae FPGA.  This reference FIM (shell) is a starting point for your custom FPGA design.  With this initial starting point, you can add or subtract interfaces or ports to different Agilex devices.</p> <p>Table 1-4 OFS FIM for Intel\u00ae Agilex\u00ae FPGA Features</p> Key Feature Description PCIe P-tile PCIe* Gen4x16 Virtualization Includes support for 5 physical functions/4 virtual functions with ability to expand to the P-tile PCIe Hard IP maximum (8PFs, 2K VFs per each Endpoint). Memory 5 DDR Channels:* One HPS DDR4 bank, x40 (x32 Data and x8 ECC), 1200 MHz, 1GB each* Four Fabric DDR4 banks, x32 (no ECC), 1200 MHz, 4GB Ethernet Eight Arm\u00ae AMBA\u00ae 4 AXI4-Stream channels of 25G Ethernet interfacing to an E-tile Ethernet Subsystem. Hard Processor System 64-bit quad core Arm\u00ae Cortex\u00ae-A53 MPCore with integrated peripherals. Configuration and Board Manageability * FPGA Management Engine that provides general control of common FPGA tasks (ex. error reporting, partial reconfiguration)* Platform Controller Management Interface (PMCI) Module contained within the Agilex FPGA that interfaces through Avalon-Streaming x8 QuadSPI and SPI to a Board Management Controller Partial Reconfiguration Partial Reconfiguration region supported in hardware and software OneAPI OneAPI Acceleration Support Package (ASP) provided with compiled FIM to support OneAPI Runtime Software Support * Linux DFL drivers targeting OFS FIMs* OPAE Software Development Kit* OPAE Tools"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#subsystem-interfaces","title":"Subsystem Interfaces","text":"<p>The PCIe, Memory and Ethernet interfaces in this design use a new flexible subsystem design that provides a standard Arm\u00ae AMBA\u00ae 4 AXI4 interface.  To access these Intel FPGA IP Subsystem documents. Please go to the links below: * Intel FPGA IP Subsystem for PCI Express IP User Guide * Memory Subsystem Intel FPGA IP User Guide * Ethernet Subsystem Intel FPGA IP User Guide (public document)</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#hard-processor-system-hps","title":"Hard Processor System (HPS)","text":"<p>The HPS SoC contains a 64-bit quad core ARM\u00ae Cortex\u00ae-A53 MPCore with a variety of integrated modules such as on-chip RAM, Ethernet, USB, UARTs and SPI controllers and memory controllers.  For more information about the Intel Agilex HPS, please refer to the Intel Agilex Hard Processor System Technical Reference Manual.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#fpga-management-engine-fme","title":"FPGA Management Engine (FME)","text":"<p>The FIM contains only one FME, regardless of the number of host interfaces to the FIM. The FME provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA.</p> <p>Any feature, such as a memory interface or global error control that you want to control through FME, must expose its capability to host software drivers.  New features are exposed to the FME by adding a device feature header (DFH) register at the beginning of the feature's control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link.  For more information about DFHs, refer to the FPGA Device Feature List Framework Overview.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#streaming-datapath","title":"Streaming Datapath","text":"<p>The FIM implements an AXI4-Stream bus protocol for data transfer in the FIM. AXI4-Stream channels send data packets to and from the host channel IP without data abstraction. Memory-mapped I/O (MMIO) CSR accesses are routed to the ST2MM module, which converts the AXI4-Stream to an AXI4 memory-mapped protocol.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#virtualization","title":"Virtualization","text":"<p>This design supports virtualization by making use of the virtualization functionality in the PCIe Hard IP and mapping packets to the appropriate physical or virtual function through a PF/VF multiplexer.  </p> <p>This reference FIM example supports 5 PFs and 4 VFs; however, you may extend your configuration to whatever the PCIe Hard IP can support or your application requires.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#141-afu","title":"1.4.1 AFU","text":"<p>An AFU is an acceleration workload that interfaces with the FIM. The AFU boundary in this design comprises both static and partial reconfiguration (PR) regions.  You can decide how you want to partition these two areas or if you want your AFU region to only be a partial reconfiguration region.  A port gasket within the design provides all the PR specific modules and logic required for partial reconfiguration. Only one partial reconfiguration region is supported in this design.</p> <p>Similar to the FME, the port gasket exposes its capability to the host software driver through a DFH register placed at the beginning of the port gasket CSR space. In addition, only one PCIe link can access the port register space.  </p> <p>In this design, the AFU region is comprised of:</p> <ul> <li>AFU Interface handler to verify transactions coming from AFU region.</li> <li>PF/VF Mux to route transactions to and from corresponding AFU components: </li> <li>ST2MM module.</li> <li>Null Host exerciser (HE_NULL) stub.</li> <li>PCIe loopback host exerciser (HE-LB).</li> <li>HSSI host exerciser (HE-HSSI).</li> <li>Memory Host Exerciser (HE-MEM).</li> <li>Traffic Generator to memory (HE-MEM-TG).     Port Gasket (PRG). </li> <li>HPS Copy Engine.</li> <li>Arm\u00ae AMBA\u00ae 4 AXI4 Streaming to Memory Map (ST2MM) Module that routes MMIO CSR accesses to FME and board peripherals.</li> <li>Host exercisers to test PCIe, memory and HSSI interfaces (these can be removed from the AFU region after your FIM design is complete to provide more resource area for workloads)</li> <li>Basic HPS Copy Engine to copy second-stage bootloader and Linux OS image from Host DDR to HPS DDR.  </li> <li>Port gasket and partial reconfiguration support.</li> <li>Component for handling PLDM over MCTP over PCIe Vendor Defined Messages (VDM)</li> </ul> <p>For this design the PF/VF Mux provides the following mappings (found in src/afu_top/mux/top_cfg_pkg.sv):</p> <p>Table 1-5 PF/VF Mapping</p> Module PF/VF Mapping AXI4 Stream to Memory Mapped Module (ST2MM) PF0 Memory Host Exerciser (HE_MEM) PF0-VF0 HSSI Host Exerciser (HE_HSSI) PF0-VF1 Memory Traffic Generator (HE_MEM_TG) PF0-VF2 Null Host exerciser (HE_NULL) stub PF1-VF0 PCIe Loopback (HE_LB) PF2 Null Host exerciser (HE_NULL) stub PF3 HPS Copy Engine Module PF4 <p>Figure 1-3 AFU Diagram </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#142-platform-interface-manager","title":"1.4.2 Platform Interface Manager","text":"<p>The PIM provides a way to abstract the AXI4-Stream interface to the AFU by providing a library of shims that convert the host channel native packet into other protocols such as AXI4 memory-mapped, Avalon\u00ae streaming (Avalon-ST) or Avalon\u00ae memory-mapped (Avalon-MM). </p> <p>The FPGA or AFU developer implements these interface abstractions in the AFU region (afu_main) of the design.  </p> <p>For more information, refer to AFU Development Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#143-platform-feature-discovery","title":"1.4.3 Platform Feature Discovery","text":"<p>This reference design comes with specific Intel FPGA drivers that are upstreamed to linux-dfl.  These drivers abstract the hardware and operating system specific details of the platform to the host. </p> <p>The FIM implements a device feature header (DFH) at the beginning of each host-discoverable feature in a linked list format that allows an FPGA platform driver running on the host to discover FME, port, and AFU features. </p> <p>You must implement a 64-bit DFH Device Feature Header register at the beginning (first 8B aligned address) of the feature CSR space for a new feature to be discovered or enumerated by a driver.  </p> <p>During host discovery, the driver traverses the DFH of the first feature from the first address on PF0 BAR0. Based on the information in the DFH, a driver can determine the CSR address range of the feature and other associated details. The end of the DFH contains a \"next DFH offset\" field that points the driver to the DFH of the next feature. </p> <p>The software must continue traversing the linked list until it sees the EOL (End-Of-List) bit set to 1 in the \"next DFH offset\" field it inspects.  A 1 indicates this is the last feature in the feature set. The figure below gives a simple illustration of the feature discovery by traversing the DFH registers. This model is similar to how PCIe enumeration occurs.</p> <p>Figure 1-4 Device Feature Header Linked List Traversal</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#144-ofs-reference-design","title":"1.4.4 OFS Reference Design","text":"<p>OFS provides FIM designs you can use as a starting point for your own custom design. These designs target a specific programmable acceleration card or development kit and exercise key FPGA device interfaces. </p> <p>The Intel Agilex\u00ae code line for OFS targets the Intel N6001-PL FPGA SmartNIC Platform.  FIM designs are released to https://github.com/OFS/ofs-n6001 for evaluation and use. </p> <p>In addition to the OFS FIM for Agilex that targets the Intel N6001-PL FPGA SmartNIC Platform, vertical market FIMs are available for the Intel N6000-PL SmartNIC Platform. </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#145-fim-simulation","title":"1.4.5 FIM Simulation","text":"<p>OFS provides unit tests and a UVM environment for the FIM and a framework for new feature verification. UVM provides a modular, reusable, and scalable testbench structure by providing an API framework that can be deployed across multiple projects. </p> <p>The FIM testbench is UVM compliant and integrates third-party verification IPs from Synopsys that require a license. </p> <p>Verification components include:</p> <ul> <li>FIM monitor to detect correct design behavior</li> </ul> <ul> <li>FIM assertions for signal level integrity testing</li> </ul> <ul> <li>Arm\u00ae AMBA\u00ae 4 AXI4 scoreboards to check data integrity</li> </ul> <ul> <li>FIM coverage to collect functional data</li> </ul> <p>The verification infrastructure can be found here for evaluation and use. Please refer to the Simulation User Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs for more information.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#2-ofs-high-level-architecture","title":"2 OFS High Level Architecture","text":"<p>OFS provides distinct data paths that simplify the design and integration process for adding or removing interface modules:</p> <ul> <li>High Bandwidth data path for AFU-attached high-performance peripherals (HSSI, Memory, HPS, workload).</li> <li>Low Bandwidth data path for OFS management and slow peripheral components (JTAG, I2C, SMBus).</li> <li>AFU Peripheral Fabric (APF) to Board Peripheral Fabric (BPF) path to communicate with interface control and status registers (CSRs) and board components.</li> <li>Peer-to-peer datapath between AFU components.</li> <li>Peer-to-peer datapath between BPF components.</li> </ul> <p>Depending on your design goals, you can present peripherals to software as:</p> <ul> <li>OFS managed peripherals with a device feature header that is part of a device feature list.</li> <li>Native driver managed peripherals that are exposed through an independent physical function or virtual function.</li> </ul> <p>Figure 2-1 OFS Datapath Structure</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#3-pcie-subsystem","title":"3 PCIe Subsystem","text":"<p>The FIM's PCIe Subsystem is a hierarchical design that targets the P-tile PCIe* hard IP and is configured to support Gen4 speeds and Arm\u00ae AMBA\u00ae 4 AXI4 Data Mover functional mode.  The IP supports SR-IOV and is configured to provide 5 PFs and 4 VFs.  Native PCIe TLP packets are sent through the PCIe using Arm\u00ae AMBA\u00ae 4 AXI4 Stream Protocol.  Before they reach the AFU, the packets go through an adapter in the subsystem that converts any headers to a data mover format.  Tag allocation and management for packets sent from the application to the host are done by the PF/VF Mux that is part of the AFU region.</p> <p>Figure 3-1 OFS FIM RX-TX Datapath</p> <p></p> <p>Some key features of the PCIe interface are:</p> Feature OFS for Intel Agilex FPGA PCIe Subsystem Configuration Mode PCIe Gen4x16 Port Mode Native Endpoint SR-IOV 5PFs, 4VFs MSI-X Support Yes Functional Mode Data Mover Profile Basic TLP Bypass No Header Packing Scheme Simple Data Width 512-bit (64-byte) AXI-ST Clock Frequency 400 MHz Tags Supported 128 Reordering No reordering of requests, no completion reordering Maximum Payload Size 512 Bytes Memory Requests Supported 1CL, 2CL, 4CL MMIO transaction Size 4B, 8B Control Shadow Interface Enabled Completion Timeout Interface Enabled <p>The PCIe PF, VF and Base Address Register (BAR) configuration can be modified in the PCIe Subsystem Platform Designer GUI interface.  The current implementation for the OFS FIM for Agilex FPGA is as follows:</p> <p>Table 3-1 Function and BAR Table for OFS for Agilex FPGA</p> PF VF Feature BAR BAR Size PF0 - OFS Managed Peripherals (PCIe, Memory, Ethernet) BAR0 512 KB PF0 - AFU Peripherals BAR0 256 KB PF0 - Board Peripherals BAR0 256 KB PF0 - MSI-X BAR4 16 KB PF0 VF0 Memory Host Exerciser (HE-MEM) BAR0 256 KB PF0 VF1 HSSI Host Exerciser (HE-HSSI) BAR0 256 KB PF0 VF2 Memory Traffic Generator (HE-MEM-TG) BAR0 256 KB PF1 VF0 Null Host exerciser (HE_NULL) BAR0 4 KB PF2 PCIe Loopback (HE-LB) BAR0 256 KB PF3 Null Host exerciser (HE_NULL) BAR0 4 KB PF4 HPS Copy Engine BAR0 4 KB"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#31-pcie-subsystem-header-format","title":"3.1 PCIe Subsystem Header Format","text":"<p>The first 32 bytes of the TLP from the PCIe subsystem denotes the PCIe header. There are two types of header format supported \u2013 Power User Mode header and Data Mover mode header. The tuser_vendor[0] bit on the AXI4-Stream channel indicates the header format of the TLP; tuser_vendor[0] =0 indicates Power User Mode header and tuser_vendor[0] =1 indicates Data Mover Mode header.</p> <p>The OFS FIM for Intel Agilex FPGA implements the Data Mover Functional Mode.  With this implementation, the application has the flexibility to use either mode for PCIe transaction, as shown in the following table. For more detailed information about the PCIe Subsystem, see the PCIe Subsystem Intel FPGA User Guide. </p> <p>Table 3-2 PCIe Subsystem Header Format Support for OFS for Agilex FPGA</p> Direction Type Power User Data Mover Host to Endpoint MWr, MRd Yes No Host to Endpoint CPL/CPLd Yes Yes Host to Endpoint Msg Yes No Endpoint to Host MWr, MRd Yes Yes Endpoint to Host Intr Yes (MWr) Yes Endpoint to Host CPL/CPLd Yes Yes Endpoint to Host Msg Yes Yes"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#311-power-user-header-format","title":"3.1.1 Power User Header Format","text":"<p>The Power User Format provides user complete control over PCIe Hard IP. The user can implement functionality of interest with finer control over PCIe Transaction Layer Packet (TLP), credit handling and various mode provided by HIP. </p> <p>The lower 16 bytes of the Power User Format are standard PCIe header as defined by PCIe specification, and the upper 16 bytes are specific to the PCIe Subsystem Intel FPGA IP. </p> <p>Table 3-3 Power User Header Format</p> <p></p> <p>The mapping of the PCIe defined header to the lower 16 bytes of the AXI4-Stream data channel is shown in the figure below. Each double word (DW) or 4 bytes in the PCIe header is mapped from big-endian to little-endian on AXI-S data channel.  </p> <p>Figure 3-2 Power User Header Mapping to Arm\u00ae AMBA\u00ae 4 AXI4 Channel</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#312-data-mover-header-format","title":"3.1.2 Data Mover Header Format","text":"<p>The data mover mode allows high bandwidth data transfers to and from Host memory. It hides the complexity of handling PCIe TLPs. This format provides a simple interface for reading and writing to Host Memory. The data mover checks link partner credits before transmitting packets. It also provides MSI-X interrupt generation capability. </p> <p>In Data Mover Mode, the lower 16 bytes are data mover specific and do not follow a PCIe standard header.  </p> <p>Table 3-4 Data Mover Header Format</p> <p></p> <p>The mapping of the data mover header to the lower 16 bytes of the AXI-S data channel is shown below. Each byte in the data mover header is mapped directly to the AXI-S data channel.  </p> <p>Figure 3-3 Data Mover Header Mapping to Arm\u00ae AMBA\u00ae 4 AXI4 Channel</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#32-pcie-subsystem-interface-module","title":"3.2 PCIe Subsystem Interface Module","text":"<p>The PCIe Subsystem Interface module (/ipss/pcie/rtl/pcie_ss_if.sv), provides the supporting interface between software and the PCIe subsystem.  </p> <p>The interface module provides the following:</p> <ul> <li>Device Feature Header Registers</li> <li>Control and Status Registers</li> <li>Indirect access to PCIe subsystem CSR registers through a CSR mailbox in the PCIe Subsystem Interface.</li> </ul>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#33-data-mover-request-cycles","title":"3.3 Data Mover Request Cycles","text":"<p>For Host read request cycles using the OFS FIM for Intel Agilex FPGA:</p> <ul> <li>All requests in the RX direction will be MMIO. </li> <li>Requester ID from the request does get sent to the AFU. It is the AFU's responsibility to send back a completion to the host with the correct completer ID. </li> <li>Prefix is not supported. </li> <li>Memory Mapped (MM) Mode is not supported.</li> <li>Slot Number is 0.</li> <li>Base address is not sent to the AFU.</li> <li>Local Address field is not used.</li> </ul> <p>For AFU/application request cycles using the OFS FIM for Intel Agilex FPGA:</p> <ul> <li>All requests in the TX direction will be Memory Read/Write. </li> <li>The tag must be generated by the AFU/application.</li> <li>Prefix is not supported. </li> <li>MM Mode is not supported.</li> <li>Slot Number is 0 (non-0 only for switch)</li> <li>VF Active, VF number and PF number are obtained from Data Mover Header Packet.</li> </ul> <p>Figure 3-4 Data Mover Request Cycles</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#34-data-mover-completion-cycles","title":"3.4 Data Mover Completion Cycles","text":"<p>For Host completion cycles using the OFS FIM for Intel Agilex FPGA:</p> <ul> <li>All completions in the RX direction will be Data Completions. </li> <li>Prefix is not supported.</li> <li>MM Mode is not supported.</li> <li>Slot Number is 0.</li> <li>Data packet responses (for Memory Read requests from AFU) from the PCIe SS may come out of order when the size is &gt;64B.</li> </ul> <p>For AFU/application completion cycles using the OFS FIM for Intel Agilex FPGA: * All requests in the TX direction will be Memory Read/Write.  * Requester ID is generated within the FIM. * That tag must be generated by the AFU/application. * Prefix is not supported.  * MM Mode is not supported. * Slot Number is 0. * VF Active, VF Number and PF number are obtained from the Data Mover Header Packet. </p> <p>Figure 3-5 Data Mover Completion Cycles</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#4-platform-interface-manager","title":"4 Platform Interface Manager","text":"<p>The FIM interfaces to an application in the AFU region through AXI4-Stream channels.  This format allows the AFU to access the host channel's raw interface without any translation. </p> <p>As a FIM developer, you have the option to provide the raw data format associated with the host interface channel to the workload or AFU developer or you can provide an intermediate protocol using Platform Interface Manager Components or your own custom interface.</p> <p>If you expose the raw AXI4-Stream interface of the FIM, workload developers also have the option to convert to a desired protocol using the PIM resources as well.  </p> <p>Refer to the AFU Developer Guide and the FPGA Interface Manager Developer Guide for more information on using the PIM in your design.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#5-interconnect-fabric","title":"5 Interconnect Fabric","text":"<p>There are three types of interconnect fabric in the OFS FIM design:  * AXI4-Stream PF/VF mux/demux fabric  * AFU Peripheral Fabric (APF)  * Board Peripheral Fabric (BPF)</p> <p>Figure 5-1 Interonnect Fabric Diagram</p> <p></p> <p>TLP packets sent from upstream PCIe Subsystem on AXI4-Stream channel are demultiplexed in the AXI4-Stream PF/VF mux/demux fabric and routed to the respective PF/VF function based on the PF/VF information in the TLP header, such as vf_active or the PF/VF number. In the opposite direction, TLP packets from downstream PF/VF function are muxed in the fabric and sent to PCIe subsystem over AXI4-Stream channel.</p> <p>All host MMIO requests targeting PF0 BAR0 are routed to the ST2MM module. The ST2MM converts MMIO TLP packets into AXI-Lite memory requests and places the requests onto AFU Peripheral Fabric (APF). AFU peripherals, such as OFS managed AFU features and ST2MM, and Board Peripheral Fabric (BPF) are interconnected by APF. The BPF is the interconnect fabric one hierarchy below APF which connects all the board peripherals. Both APF and BPF allow multiple AXI4-Lite master and slave interconnect topology.</p> <p>If you are modifying the APF or BPF connections, you must use Platform Designer to generate the fabrics directly.  Please refer to the FPGA Interface Manager Developer Guide for directions on what files must be modified and how to generate the interconnect.</p> <p>For modifying the PF/VF mux you must update the tools/pfvf_config_tool/pcie_host.ofss file and run the ofs-fim-common/pfvf_config_tool/gen_ofs_settings.py script to initiate the PCIe SS and PF/VF mux parameters to be regenerated before running the FIm build script.  </p> <p>For details on these modifications, please refer to the Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.  </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#51-afu-peripheral-fabric-apf","title":"5.1   AFU Peripheral Fabric (APF)","text":"<p>The AFU Peripheral Fabric (APF) is a 64-bit Arm AXI4-lite compliant interconnect fabric that connects AFU peripheral modules to board peripheral modules through the Board Peripheral Fabric (BPF). </p> <p>The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time. </p> <p>The address mapping for components interconnected by the APF is listed below. All components are mapped to PF0 BAR0 and implement AXI-lite slave interface. Note that none of the features in the APF mapping are designed to act as a master.</p> <p>Table 5-1 APF Address Mapping</p> Address Size (Byte) Feature 0x00000\u20130x3FFFF 256K Board Peripherals(See BPF address mapping) AFU Peripherals 0x40000 \u2013 0x4FFFF 64K ST2MM 0x50000 \u2013 0x5FFFF 64K Reserved 0x60000 \u2013 0x60FFF 4K UART 0x61000 \u2013 0x6FFFF 4K Reserved 0x70000 \u2013 0x7FFFF 56K PR Gasket:4K= PR Gasket DFH, control and status4K= Port DFH4K=User Clock52K=Remote STP 0x80000 \u2013 0x80FFF 4K AFU Error Reporting"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#52-board-peripheral-fabric-bpf","title":"5.2   Board Peripheral Fabric (BPF)","text":"<p>The Board Peripheral Fabric is the 64-bit AXI4-Lite compliant interconnect fabric that connects board peripheral modules to APF. The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time.</p> <p>The address mapping for components interconnected by BPF is listed below. All components are mapped to PF0 BAR0 and implement AXI4-lite slave interface. The Master column indicates if a component also implements AXI4-lite master interface which can send requests to the BPF.</p> <p>Table 5-2 BPF Address Mapping</p> Address Size (Byte) Feature Master 0x00000 \u2013 0x0FFFF 64K FME (FME, Error, etc) No 0x10000 \u2013 0x10FFF 4K PCIe Interface No 0x11000 \u2013 0x11FFF 4K Reserved - 0x12000 \u2013 0x12FFF 4K QSFP Controller 0 No 0x13000 \u2013 0x13FFF 4K QSFP Controller 1 No 0x14000 \u2013 0x14FFF 4K Ethernet Subsystem No 0x20000 \u2013 0x3FFFF 128K PMCI Controller Yes"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#53-arm-amba-4-axi4-stream-pfvf-muxdemux","title":"5.3 Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF Mux/Demux","text":"<p>The Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF Mux/Demux routes the PCIe TLP packets from the PCIe subsystem AXI4-Stream RX channel to downstream PF/VF based on the pf_num and vf_num information in the PCIe TLP header.</p> <p>The Arm\u00ae AMBA\u00ae 4 AXI4-Stream PF/VF mux arbitrates PCIe TLP packets from downstream PF/VF to the PCIe SS AXI-S TX channel. The PF/VF Mux/Demux is an M X N switch that allows any M port to target any N port, and any N port to target any M port, where M is the number of host/upstream ports, and N is the numbers functions/downstream ports.   </p> <p>The fpga top package file, <code>/src/afu_top/mux/top_cfg_pkg.sv</code>, contains the PF/VF parameters and mappings.</p> <p>Figure 5-2 PF/VF Mux</p> <p></p> <p>The PF/VF mux integration is part of afu_top (<code>/src/afu_top/mux/top_cfg_pkg.sv</code>).  There are two independent TX PF/VF MUX trees, labeled \"A\" and \"B\".</p> <p>Both an A and a B port are passed to each AFU component with a unique PF/VF. You can design your AFU components to send all requests to the primary A port or partition requests across both A and B ports. A typical high-performance AFU sends read requests to the B port and everything else to the A port, giving the arbiter freedom to keep both the host TX and RX channels busy.</p> <p>In the reference FIM provided for Intel Agilex OFS, the A and B TX trees have been multiplexed down to a single channel for A and another for B. The A/B multiplexer merges them into a single TX stream that will be passed to the tag remapper.</p> <p>The tag remapper provides unique tags as required by the PCIe specification.  Tags are not provided by the PCIe Subsystem FPGA IP.  When creating your own AFU you can leverage this module to generate unique tags.</p> <p>Note that the primary PF/VF Mux A supports RX and TX ports.  For the secondary PF/VF Mux B only TX ports are supported and the RX input to the Mux is tied off.  </p> <p>The default mapping is shown below:</p> <p>Table 5-3 PF/VF Mapping</p> Module PF/VF Mapping AXI4 Stream to Memory Mapped Module (ST2MM) PF0 Memory Host Exerciser (HE_MEM) PF0-VF0 HSSI Host Exerciser (HE_HSSI) PF0-VF1 Memory Traffic Generator (HE_MEM_TG) PF0-VF2 Virtio Loopback Stub (Virtio_LB) PF1-VF0 PCIe Loopback (HE_LB) PF2 Virtio Loopback Stub (Virtio_LB) PF3 HPS Copy Engine Module PF4 <p>For information on how to modify the PF/VF mapping for your own design, refer to the Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#54-afu-interface-handler","title":"5.4 AFU Interface Handler","text":"<p>The AFU Interface Handler resides inline between the PCIe AXI4-Stream Adapter and the AXI4-Stream PF/VF Demux/Mux logic. Its main function is to provide: * Unique PCIe tags \u2013 Each PCIe transaction shares the 512 tags across all VFs in the AFU region * AFU error logging for all VFs in the AFU region</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#541-unified-tag-remapping","title":"5.4.1 Unified Tag Remapping","text":"<p>When a FPGA function sends out a read cycle, it allocates a unique tag which is subsequently used to identify the read completion.  The tag is considered busy; it cannot be assigned to another read cycle until read completion.  While a tag may be unique within a unit, two different units could unknowingly send out two read cycles of the same tag.  The PCIe subsystem requires unique tags for all read cycles irrespective of their origins.  Therefore, a mechanism is needed to uniquify tag globally across different units.</p> <p>OFS contains a tag remapper (<code>/ofs-fim-common/src/common/tag_remap/tag_remap.sv</code>) that intercepts the read cycle, finds a globally unique tag, and replaces the original tag value.  It also restores the original tag value when returning completion to the read requester.  tag_remap is placed between the AXI4-Stream interface of the PCIE subsystem and the PF/VF Mux/Demux.</p> <p>The logic is described as follows:</p> <ol> <li>A sub-module (<code>/ofs-fim-common/src/common/tag_remap/ofs_fim_tag_pool.sv</code>) maintains a pool of available tags.</li> <li>TX read requests are held until a tag is available from the pool by setting tvalid=0 to the host, and tready=0 to the PF/VF Mux/Demux.</li> <li>When a TX read is dispatched, the tag is marked busy in the pool.</li> <li>The original tag is stored in tag_reg, so it can be recovered when returning a completion to the unit/function.</li> <li>Because completion to a read request can split into multiple smaller transfer sizes, responses are monitored and the final completion is detected using PCIe TLP rules.</li> <li>Tags are released in the pool only when all requested data are transferred.</li> <li>When the completion returns, the original tag is restored from <code>tag_reg</code>.</li> </ol>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#542-afu-error-handling","title":"5.4.2 AFU Error Handling","text":"<p>In this OFS design, the AFU Interface Handler handles error logging for all VFs in the AFU. Errors handled are as follows</p> <p>Table 5-4 AFU Error Descriptions</p> Checker Field Description AFU protocol checker (PCIe TLP) Malformed TLP AFU PCIe TLP contains unsupported format type AFU protocol checker (PCIe TLP) MaxPayloadError AFU memory write payload size exceeds max_payload_length limit AFU protocol checker (PCIe TLP) MaxReadReqSizeError AFU memory read payload size exceeds max_read_request_size limit AFU protocol checker (PCIe TLP) MaxTagError AFU memory read request tag value exceeds the maximum supported tag count AFU protocol checker (PCIe TLP) UnalignedAddrErr The address field in AFU memory write/read request TLP is not DW-aligned. AFU protocol checker (PCIe TLP) UnexpMMIOResp AFU is sending a MMIO read response with no matching MMIO read request. AFU protocol checker (PCIe TLP) MMIOTimedOut AFU is not responding to a MMIO read request within the pre-defined response timeout period. AFU protocol checker (PCIe TLP) MMIODataPayloadOverrun The number of data payload sent by AFU for a MMIO response (cplD) is more than the data length specified in the response. AFU protocol checker (PCIe TLP) MMIOInsufficientData The number of data payload sent by AFU for a memory write request is more than the data length specified in the request. AFU protocol checker (PCIe TLP) TxMWrDataPayloadOverrun The number of data payload sent by AFU for a memory write request is less than the data length specified in the request. AFU protocol checker (PCIe TLP) TxMWrInsufficientData The number of data payload sent by AFU for a memory write request is less than the data length specified in the request. AFU Protocol Checker (Arm\u00ae AMBA\u00ae 4 AXI4) TxValidViolation Three checkers are implemented in the FIM to catch errors and protocol violations."},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#55-tlp-to-axi4-lite-memory-mapped-bridge-st2mm","title":"5.5 TLP to AXI4-Lite Memory Mapped Bridge (ST2MM)","text":"<p>ST2MM implements the following key features:</p> <ul> <li>Host MMIO bridge     * Maps MMIO TLP packets received from the PCIe Subsystem over streaming interface to AXI4-Lite memory-mapped request. The memory-mapped request is sent to AFU or Board peripherals over APF and BPF.     * Maps AXI4-lite MM response received from AFU or Board peripherals to TLP packets and send the packets over ST streaming channel to host HIA subsystem.</li> <li>Sends MMIO response of all 0\u2019s for MMIO read to unused BAR region.</li> <li>Interrupt     * Sends interrupt packets to the PCIe subsystem when interrupt requests are received from the peripherals. Interrupts can be requested by a peripheral through a memory write to interrupt CSR registers in the ST2MM.</li> </ul> <p>Figure 5-3 ST2MM Module</p> <p></p> <p>ST2MM implements both AXI4-lite master and slave interfaces that are connected to the designated slave and master port on APF. Host memory requests are sent on the ST2MM master interface to AFP where the requests are routed to the targeted peripherals. </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#6-mmio-regions","title":"6 MMIO Regions","text":"<p>The FIM and AFU expose their functionalities to the host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO). An MMIO region is an address space within a base address register (BAR) region to which features are memory mapped.  </p> <p>For example, when a feature is mapped to an MMIO region, the CSR registers of that feature are located within the address range of that region. There can be multiple MMIO regions within a BAR region. </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#61-feature-region","title":"6.1 Feature Region","text":"<p>A group of related CSRs can be categorized as a feature region. For example, a DMA engine has queue management function and quality of service (QoS) function; these are two different features of the DMA engine. A feature region is contained within a single PCIe BAR and cannot span across two BAR region boundaries. </p> <p>A Device Feature Header (DFH) is a block of registers that mark the start of the feature region and sub-feature region, and you must place it at the first address of the region. Each DFH starts at 4KB boundary. A DFH register contains information that OPAE software requires to enumerate the feature. It also has an offset field that points to the next DFH in a feature list. OPAE software traverses the linked list of DFHs in each BAR region to discover all the features implemented on the platform. </p> <p>The <code>EOL</code> field in a DFH Start marks the end of a DFH list and is only set in the DFH of the last feature in the feature list. The feature type field in the DFH is used to differentiate between the different types of feature region. Basic building blocks (BBB) and private features are always a child of an AFU or FPGA Interface Unit (FIU) and must be contained within an AFU or FIU, respectively.  </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#611-device-feature-header-dfh-structure","title":"6.1.1 Device Feature Header (DFH) Structure","text":"<p>All DFHs must follow a specific structure to be compatible with OPAE software.  Note that only features you want to be exposed to the OPAE software must have a DFH.  For the latest information on DFH structure, please refer to https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev/Documentation/fpga/dfl.rst#device-feature-list-dfl-overview.</p> <p>6.2 Control and Status Registers</p> <p>All the Control and Status Registers (CSRs) in the FIM are 64-bit registers with the following MMIO write, and MMIO read support.</p> <p>Table 6-5: CSR MMIO Read and Write Support</p> Request Memory Attribute Payload size Memory Ordering MMIO Write UC 4B or 8B Strongly ordered MMIO Read UC 4B or 8B Strongly ordered <p>The FIM does not reorder the MMIO requests or responses. For MMIO writes, there is no reordering of requests in FIM, and uncacheable (UC) ordering rules are followed. Similarly, for MMIO reads, there is no re-ordering of requests or responses in the FIM. An AFU may opt to re-order the MMIO read responses but the FIM does not enforce read response ordering. </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#621-software-access-to-registers","title":"6.2.1 Software Access to Registers","text":"<ul> <li>Software accesses 64-bit registers as aligned quadwords. For example, to modify a field (bit or byte) in a 64-bit register, the entire quadword is read, the appropriate field(s) are modified, and the entire quadword is written back.</li> <li>When updating registers through multiple accesses (whether in software or due to hardware disassembly), certain registers may have specific requirements on how the accesses must be ordered for proper behavior. These are documented as part of the respective register descriptions.</li> <li>For compatibility with future extensions or enhancements, software must assign the last read value to all \u201cReserved and Preserved\u201d (RsvdP) fields when written. In other words, any updates to a register must be read so that the appropriate merge between the RsvdP and updated fields occurs. Also, software must assign a value of zero for \u201cReserved and Zero\u201d (RsvdZ) fields when written.</li> <li>PCIe locked operations to FPGA hardware registers are not supported. Software must not issue locked operations to access FPGA hardware registers.</li> </ul> <p>In the following two cases, the FIM terminates MMIO Read requests by sending a completion with the data (CplD) specified below: * MMIO Timeout:  This occurs when the AFU does not respond within a set timeout. The timeout value is currently configured to 512 pclks (clk_2x). In this case, the FIM returns all 1s.</p> <ul> <li>Illegal MMIO Accesses: This occurs when the read is accessing undefined registers in the FIM or if an AFU access violation.  An example of an access violation is when a PF attempts to access the AFU when it is set to VF mode, or when a VF attempts to access the AFU when it is set to PF mode. In this case, the FME will returns all 0s.</li> </ul>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#622-register-attribute-definition","title":"6.2.2    Register Attribute Definition","text":"<p>Table 6-6: OFS Register Attribute Definitions</p> Attribute Expansion Description RW Read/Write This bit can be read or written by software. RO Read Only The bit is set by hardware only. Software can only read this bit. Writes do not have any effect. RW1C Read/ Write 1 to Clear Software can read or clear this bit. The software must write 1 to clear this bit. Writing zero to RW1C bit has no effect. Note that a multi-bit RW1C field may exist. In this case, all bits in the field are cleared if a 1 is written to any of the bits. RW1S Read/ Write 1 to Set Software can read this bit. Writing a 1 to the bit sets it to 1. Writing a 0 has no effect. It is not possible for software to set this bit to 0. The 1 to 0 transition can only be performed by HW. RW1CS Read/Write 1 to Clear Sticky Software can read and clear this bit. Writing a 1 to a bit clears it, while writing a 0 to a bit has no effect. This bit is only reinitialized to its default value by a power-on reset. RWD Read/Write Sticky across Hard Reset The bit can be read or written by SW. This bit is sticky or unchanged by any reset type, including Hard Reset. The bit gets cleared only with power on. *S Sticky across Soft Reset The bit will be sticky or unchanged by soft reset. These bits are only re-initialized to their default value by a power-on reset. *D Sticky across Hard Reset The bit is sticky or unchanged by or unchanged by any reset type, including hard reset. The bit gets cleared only with power on. Rsvd Reserved Reserved for future definitions. Currently don\u2019t care bits. RsvdP Reserved and Protected Reserved for future RW implementations. The software must preserve the value of this bit by read modify write. RsvdZ Reserved and Zero Reserved for future RW1C implementations. The software must write zero to this bit."},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#623-csr-offset-in-bars","title":"6.2.3 CSR Offset in BARs","text":"<p>The table below captures the FIM and AFU features in the supported BAR regions. The highlighted offset indicates the first DFH in the DFH list of a BAR region where device driver starts the DFH traversal.</p> <p>Table 6-7: PF0 BAR0 Features</p> Offset Feature CSR set 0x00000 FME 0x01000 Thermal Management 0x03000 Global Performance 0x04000 Global Error 0x10000 PCIe 0x12000 QSFP0 0x13000 QSFP1 0x20000 PMCI 0x40000 ST2MM 0x60000 Transceiver CSR Interface 0x61000 Virtual UART 0x62000 EMIF 0x70000 Port Gasket PR logic 0x71000 Port Gasket Port interface 0x73000 Port Gasket Remote Signal Tap 0x80000 AFU Interface Handler- AFU Errors <p>Table 6-8: PF0 BAR4 Features</p> Offset Feature CSR set 0x03000 MSI-X Vector Tables"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#7-clocks","title":"7 Clocks","text":"<p>The following table provides external clock sources which correspond to pins on the FPGA that drive blocks of internal logic or are used as a reference clock for internal PLLs.  The names in the table are used in the top.sv or are the logical clock names used by their respective functional blocks.  </p> <p>Table 7-1: External Clock Source</p> Clock Frequency Description SYS_RefClk 100 MHz Reference clock to system IOPLL (sys_pll) which provides FIM system clocks. PCIE_REFCLK 100MHz PCIe reference clock 0 PCIE_REFCLK 100MHz PCIe reference clock 1 qsfp_ref_clk 156.25 MHz Ethernet Reference Clock ddr4_x32[0].ref_clk 150MHz Refclk for 32-bit EMIF channel 0 ddr4_x32[1].ref_clk 150 MHz Refclk for 32-bit EMIF channel 1 ddr4_x40[0].ref_clk 150 MHz Refclk for 40-bit EMIF channel 0 ddr4_x40[1].ref_clk 150 MHz Refclk for 40-bit EMIF channel 1 ddr4_hps.ref_clk 150 MHz Refclk for HPS EMIF sdm_config_clk 125 MHz Refclk for HPS EMIF hps_refclk 25 MHz Refclk for HPS EMIF altera_reserved_tck 10 MHz Refclk for HPS EMIF <p>Table 7-2: Internal Clocks</p> <p>Internal clock generated by the IOPLL as <code>outclk</code> outputs.</p> outclk# Clock Frequency Description outclk0 clk_sys 470 MHz System clock. Primary clock for PCIe Datapath outclk1 clk_100m 100 MHz For RemoteSTP and user clock, or any logic that requires a 100 MHz clock. outclk2 clk_100m 175 MHz Drives AFU in PR slot outclk3 clk_ptp_slv 155.56 MHz Unused outclk4 clk_50m 50 MHz Drives Virtual UART"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#8-reset","title":"8 Reset","text":""},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#81-reset-signals","title":"8.1   Reset Signals","text":"<p>The FIM system reset signals are driven according to their respective requirements derived from their use cases.  The behavioral code defining the reset operation is located in the file <code>rst_ctrl.sv</code>. The FIM System Reset Drivers table below provides a list of the input and feedback signals that compose the various resets.</p> <p>Table 8-1: FIM System Reset Drivers</p> Reset Description <code>nPERST</code> pin Active low PCIe reset pin from the PCIe card edge that may be set by the host machine for cold or warm resets. <code>nCONFIG</code> pin Active low input to the FPGA that causes the FPGA to lose its configuration data, enter a reset state, and tri-state all I/O pins. Host software must reload the FPGA FIM after nCONFIG is activated. <code>ninit_done</code> Active low signal indicating FPGA core configuration is complete and FPGA has entered usermode.  This signal is provided by the configuration monitor block in rst_ctrl.sv. <code>pcie_reset_status</code> Active high reset status from PCIe hard IP. When driven high, this signal indicates that the PCIe IP core is not ready for usermode. <code>pll_locked</code> Active high SYS IOPLL locked signal <code>pcie_cold_rst_ack_n</code> Reset Acknowledge signal from the PCIe subsystem that lets the Reset Controller know that the Cold Reset sequence has been completed. <code>pcie_warm_rst_ack_n</code> Reset Acknowledge signal from the PCIe subsystem that lets the Reset Controller know that the Warm Reset sequence has been completed. <p>Upon power-on, the reset module in the FIM holds the FIM in reset until all the reset conditions are de-activated:</p> <ul> <li><code>nPERST</code> signal is asserted.</li> <li>The <code>INIT_DONE</code> pin is driven high to indicate core configuration is complete.</li> <li>The SYS IOPLL is locked.</li> <li>The reset status from PCIe hard IP is de-asserted indicating the IP is ready for transfer. </li> </ul> <p>The reset module places the FIM back into reset if any of these conditions becomes active again. The only way to invoke a system reset to the FIM after power-up is to de-assert the <code>nPERST</code> pin either by performing a warm reboot or through PCIe driver intervention. There are soft reset signals set aside to allow software to reset the Port, AFU and partial reconfiguration IP. </p> <p>THe following table lists the reset outputs from the <code>rst_ctrl.sv</code> block.</p> <p>\u200b                                                      Table 8-2: FIM System Reset Outputs</p> Reset Description <code>rst_n_sys</code> pin System general reset synchronous to <code>clk_sys</code>.  This is a warm reset of the FPGA logic.  Sticky bits in the FME and other CSR registers will not be reset by this signal. <code>rst_n_100m</code> pin System general reset synchronous to clk_100m. <code>ninit_done</code> Active low signal indicating FPGA core configuration is complete and FPGA has entered usermode.  This signal is provided by the configuration monitor block in rst_ctrl.sv. <code>pwr_good_n</code> Hardware reset conditioned by <code>ninit_done</code> and the <code>pll_locked</code> signal.  The signal is generally set when power has been cycled or a physical hardware fault has occurred, requiring a reset of the FPGA logic.   This signal is synchronous to <code>clk_sys</code>. <code>pcie_cold_rst_ack_n</code> Hardware reset conditioned by the <code>pcie_reset_status</code> which is a summary reset driven by the PCIe Hard IP logic tile on the FPGA die.  This signal is synchronous to <code>clk_sy</code>s. <code>pcie_warm_rst_ack_n</code> Soft reset conditioned by <code>nPERST</code> when the pcie_reset_status is not asserted, meaning a warm reset is desired.  Cold reset sticky bits in the PCIe subsystem will not be reset by this signal."},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#9-interrupts","title":"9 Interrupts","text":"<p>The OFS platform supports interrupts through MSI-X feature. The MSI-X Interrupt feature handles FME and AFU interrupts. FME interrupts are primarily used to notify the host of error events happened in the FIM. When any of the bit in the FME error status registers is set, an interrupt request is sent to the MSI-X module. There are FME error status registers for OFS for Agilex FPGA features.  An AFU sends interrupt to the MSI-X module in the PCIE SS on the AXI interrupt request channel. The MSI-X table entries and PBA vectors are implemented in the PCIE SS. The PCIE SS supports upto 4096 vectors in \"Static MSI-X mode.</p> <p>Please refer to the Intel FPGA IP Subsystem for PCI Express IP User Guide for more information.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#10-external-memory-interface-emif","title":"10 External Memory Interface (EMIF)","text":"<p>There are 5 EMIF channels (5 DDR4 banks) on the Intel\u00ae FPGA SmartNIC N6001-PL.  Banks 3D and 2A are dedicated for HPS use, and Banks 3B, 3A, and 2B are connected to the HE-MEM exerciser module in AFU. The provided FIM reference design implements ECC for the HPS external memory bank while ECC is not implemented for the fabric external memory interfaces. The Intel\u00ae FPGA SmartNIC N6001-PL that this design targets supports ECC on all banks except 2B and the user may create a FIM design with ECC support.  Both memory subsystem and HE-MEM implement AXI-MM interface.</p> <p>Table 10-1 Memory Subsystem Configuration on the Intel\u00ae FPGA SmartNIC N6001-PL</p> <p>This table shows the capabilities of the memory populated on the Intel\u00ae FPGA SmartNIC N6001-PL for reference.</p> FPGA I/O Bank Width ECC Width ECC Supported Speed Size 3D, HPS x32 x8 1GB 2400 Three 256Mx16 3B x32 x8 4GB 2400 Three 1024Mx16 3A x32 x8 4GB 2400 Three 1024Mx16 2B x32 No ECC 4GB 2400 Two 1024Mx16 2A, HPS x32 x8 1GB 2400 Two 1024Mx16 <p>Figure 10-1: EMIF Interfaces</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#101-emif-csr","title":"10.1 EMIF CSR","text":"<p>The CSR for the EMIF feature is memory mapped to the FME BAR region. The following table captures the EMIF CSR registers.</p> <p>Table 10-2: EMIF CSR Registers</p> EMIF_DFH 0x62000 0x300000001000100F EMIF Management DFH FIELD NAME RANGE ACCESS DEFAULT DESCRIPTION FeatureType [63:60] RO 0x3 Feature Type = Private Feature Reserved40 [59:40] RsvdZ 0x0 Reserved NextDfhByteOffset [39:16] RO 0x1000 Next DFH Byte offset FeatureRev [15:12] RO 0x0 Feature Revision FeatureID [11:0] RO 0x9 Feature Id EMIF_STAT 0x62008 0x0000000000000000 EMIF Status FIELD NAME RANGE ACCESS DEFAULT DESCRIPTION Reserved [63:8] RsvdZ 0x0 Reserved CalFailure [7:4] RO 0x0 EMIF PHY Calibration Failure (1 bit per interface) CalSuccess [3:0] RO 0x0 EMIF PHY Calibration Successful (1 bit per interface) EMIF_CAPABILITY 0x62010 0x000000000000000F EMIF Capability Register FIELD NAME RANGE ACCESS DEFAULT DESCRIPTION Reserved [63:4] RsvdZ 0x0 Reserved EMIFCap [3:0] RO 0xF Attached Memory Capability (1 bit per interface) <p>\u200b           </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#11-ethernet-subsystem","title":"11 Ethernet Subsystem","text":""},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#111-ethernet-subsystem-overview","title":"11.1 Ethernet Subsystem Overview","text":"<p>The Ethernet Subsystem (hssi_ss) provides portability to different Ethernet configurations across platforms and generations and reusability of the hardware framework and software stack. This reference FIM implements an E-tile Ethernet Subsystem IP in a 2x4x25GbE configuration and provides a Linux driver that can be leveraged for customization. Each group of 4x25GbE routes to a QSFP.</p> <p>For more information about how to reconfigure the Ethernet Subsystem please refer to the Ethernet Subsystem Intel FPGA IP.</p> <p>Table 11-1: Ethernet Configurations for example OFS FIMs for Agilex FPGAs</p> Parameter Configuration for PCIe Attach Intel Agilex OFS (2x4x25GbE) IP file name hssi_ss_8x25g Number of ports enabled 8 Enabled ports Port 0-7 Port{x} profile 25GbE Port{x} subprofile MAC+PCS Port{x} RSFEC True Port{x} PTP False Enable AN/LT False Enable NPDME True Enable JTAG to Avalon master bridge False Enable Tx packet classifier NA PTP accuracy mode NA Enable iCAL and pCAL recipe at power True TX/RX maximum frame size 1518 Enforce maximum frame size False Link fault generation mode Bidirectional Stop TX traffic when link partner sends PAUSE Yes Bytes to remove from RX frames Remove CRC bytes Forward RX PAUSE requests False Use source address insertion False Enable TX/RX VLAN detection True Enable asynchronous adapter clocks False Enable preamble Passthrough False Enable asynchronous adapter clocks False Enable preamble Passthrough False Enable strict preamble check False Enable strict SFD check False Average IPG 12 Enable adaptation load soft IP True Additional IPG removed as per AM period 0 <p>To determine which Transceiver Subsystem port maps to the QSFP A and B lanes, please refer to the following table:</p> <p>Table 11-2: Transceiver Subsystem Port Mapping </p> Port number Configuration for PCIe Attach Intel Agilex OFS (2x4x25GbE) 1 QSFP-A Lane-0 2 QSFP-A Lane-1 3 QSFP-A Lane-2 4 QSFP-A Lane-3 5 QSFP-B Lane-0 6 QSFP-B Lane-1 7 QSFP-B Lane-2 8 QSFP-B Lane-3 9 NA 10 NA 11 NA 12 NA 13 NA 14 NA 15 NA 16 NA <p>Figure 11-1: Transceiver Subsystem Block Diagram</p> <p></p> <p>A host exerciser, named he-hssi, is provided in the pr_slot of the AFU partition. The Ethernet Subsystem interface to the AFU has an Arm\u00ae AMBA\u00ae 4 AXI4 data and sideband interface.  </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#112-parameterization-options","title":"11.2 Parameterization Options","text":"<p>The Ethernet Subsystem features are highly parameterized to provide the various features/configurations required for the different FIMs. The macro defines can be added to the <code>ofs_top.qsf</code> file and are as follows:</p> <ul> <li>ETH_100G: includes 100G related logic. Used to generate 2x1x100G.</li> <li>ETH_10G:  includes 10G related logic. Used to generate 2x4x10G</li> <li>ETH_25G: includes 25G related logic (Default behaviour even with no `DEFINES). Used to generate 2x4x25G</li> </ul> <p>Parameterization is also included in the ofs_fim_eth_plat_defines.svh package file:</p> <p>\u2022   INCLUDE_HSSI_PORT_{n}: These are available for every port. If defined for a particular port, that indicates that port is enabled. \u2022  Based on which INCLUDE_HSSI_PORT_{n} is defined in ofs_fim_eth_plat_defines_pkg.svh file, hssi_ss IP needs to be configured manually to have only those ports enabled. </p> <p>Following are parameters defined in ofs_fim_eth_plat_if_pkg.sv: </p> <p>\u2022   MAX_NUM_ETH_CHANNELS: This indicates how many maximum ethernet channels are supported for platfrom \u2022   NUM_QSFP_PORTS: Indicates number of QSFP cages are available on a platform \u2022   NUM_ETH_CHANNELS: Indicates number of channels present for a FIM, i.e. number for ports for Transceiver SS IP  \u2022   NUM_QSFP_LANES: Number of lanes per QSFP port \u2022   NUM_LANES: Number of lanes per HSSI port \u2022   ETH_PACKET_WIDTH: Datawidth of client side AXI-ST interface coming from HSSI SS IP. This is not an user configurabale parameter. User need update this value to reflect HSSI SS IP client side data width for selected configuration.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#113-ofs-ethernet-subsystem-interface-module","title":"11.3 OFS Ethernet Subsystem Interface Module","text":"<p>A wrapper around the Transceiver Subsystem integrates the following features: * DFH registers  * Control &amp; status registers  * Indirect access to Transceiver SS CSR registers via CSR mailbox in the HSSI SS interface </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1131-ethernet-subsystem-control-and-status-register-csr-map","title":"11.3.1   Ethernet Subsystem Control and Status Register (CSR) Map","text":"<p>The Ethernet Subsystem connects to the APF which is memory mapped to PF0 BAR0. The Ethernet Subsystem CSR space in the FIM consists of two parts:</p> <ul> <li>Ethernet Subsystem CSRs assigned from offset 0x000 to 0x7FF</li> <li>Additional CSRs are added to FIM at offset 0x800 to 0xFFF</li> </ul> <p>The PCIe subsystem uses AXI Memory Mapped accesses to read and write Ethernet Subsystem Control and Status Registers in the FIM. The Ethernet Subsystem CSR Map structure is designed to scale according to IP capabilities.</p> <p>The Ethernet Subsystem CSR Map can be found <code>ipss/hssi/HSSI_SS_CSR.xls</code>.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#114-ethernet-subsytem-software","title":"11.4 Ethernet Subsytem Software","text":"<p>There are two pieces of software related to running the Ethernet Subsystem: The Linux* dfl network driver and the user space OPAE Tools.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1141-ethernet-subsystem-linux-driver","title":"11.4.1 Ethernet Subsystem Linux Driver","text":"<p>The Ethernet subystem is exposed as a feature in the PCIe PF BAR0 region.  It has a Device Feature Header (DFH) specifying the interface. </p> <p>The primary functionality of the driver is to interact with the ethernet MAC and PHY through an indirect register access mailbox implemented by the HSSI_RCFG_CMD0, HSSI_RCFG_DATA0 registers described above. To aid in RTL bringup, the driver provides a debugfs interface directly to the indirect register access mailbox. For each HSSI interface in the system there would be a directory with the following form containing two files, regaddr and regval: /sys/kernel/debug/dfl-fme.X.Y</p> <p>To read a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then read the value as string out of regval file. To write a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then write the value as a C hex string to regval file.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1142-ethernet-subsystem-opae-user-space-tool","title":"11.4.2   Ethernet Subsystem OPAE User Space Tool","text":"<p>User space OPAE Tools that are part of OPAE SDK provide support for the Ethernet Subsystem.  You can use the --help option to print more information about each of these commands: * hssi: Provides a means of interacting with the 10G and 100G HSSI AFUs through the host exerciser. * hssiloopback: Enables and disables Ethernet loopback. * hssistats: Provides MAC statistics.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#12-partial-reconfiguration","title":"12 Partial Reconfiguration","text":"<p>Partial Reconfiguration (PR) is an Intel FPGA technology that allows users to reconfigure parts of the FPGA device dynamically, while the remainder of the device continues to operate. In a non-partial reconfiguration flow, any change to the design requires full reprogramming of the entire configuration RAM (CRAM) arrays in the device. With partial reconfiguration, you can dynamically reprogram one or more CRAM frames. A partial reconfiguration design has a static region, and a PR regions, which can be modified to implement new logic. The portion of the CRAM on the chip to be reconfigured is contained within a PR region. For the PR flow, your design must be partitioned into static region and reconfigurable region. The static region is the area of your FPGA that is not reconfigured without reprogramming the entire FPGA. An area of the chip that you plan to partially reconfigure is a PR region. </p> <p>The Port Gasket contains all the PR specific modules and logic, such as PR slot reset/freeze control, user clock, remote STP etc. For this reference example only one PR slot is supported.</p> <p>The Figure below shows the fundamental concepts required to support PR in OFS platform. There are 4 OFS management DFH \u2013 PR, Port, User Clock and Remote STP in Port Gasket that is exposed to OFS software. These platform capabilities are generally used in conjunction to Partial Reconfiguration. The Figure below also demonstrates the concepts of adding a new interface to the PR region. </p> <p>Figure 12-1 Partial Reconfiguration Gasket</p> <p></p> <p>The isolation logic is provided on the output signals of the PR region to ensure they don\u2019t glitch and affect the interfacing logic in the Static Region (SR). The isolation logic is controlled by the PR Freeze logic during PR operation.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#user-clock-support","title":"User Clock Support","text":"<p>The reference platform provides two user configurable clock (uclk_usr, uclk_usr_div2) for use by the AFU. These clocks are generated by a reconfigurable IOPLL. The control and status of these clocks is expose through two pairs of command and status registers (USR_CLK_FREQ_CMD0 / USR_CLK_FREQ_STS0 &amp; USR_CLK_FREQ_CMD1 / USR_CLK_FREQ_STS1). The first pair controls the fPLL reconfiguration functionality. The second pair controls a clock frequency measurement block. </p> <p>The following are the default values of the userclk. </p> <p>uclk_usr: 312.5 MHz </p> <p>uclk_usr_div2: 156.2 MHz </p> <p>Table 12-1 usr_clk_* Acceptable Programming Range</p> Fabric Frequency Range uclk_usr (H) uclk_usr_div2 (L) Details 0-400 MHz 0-800 MHz 0-400 MHz Clocks set on 2x relationship for L&lt;400 MHz 400-800 MHz 400-800 MHz 400-800 MHz Clks are equal for L&gt;400 MHz <p>PLL Reconfiguration </p> <p>The blue bit stream hardware exposes the low level IOPLL reconfiguration interfaces directly to software control. Through the USR_CLK_FREQ_CMD0 register software can select the reference clock, assert the PLL power down pin and issue reads and writes on the IOPLL Avalon-mm reconfiguration bus. Through the USR_CLK_FREQ_STS0 register software can query the IOPLL active reference clock, locked status and readdata returned from the IOPLL AVMM interface for read requests. </p> <p>Clock Frequency Counter </p> <p>The user clocks, generated by the reconfigurable IOPLL, are connected to a frequency measurement circuit. Software selects which of the two clocks to measure by setting the clock select bit in the USER_CLK_FREQ_CMD1 register. After 10ms software can read the frequency, in 10 KHz units, from the USER_CLK_FREQ_STS1 register. Reading this register before 10ms has passed will return undefined data but otherwise has no effect. </p> <p>Configuring User Clocks </p> <p>To program the user clock to the desired frequency, user will set the clock-frequency-low and clock-frequency-high fields in the PR AFU GBS .json file to the desired frequency value. During PR, SW will try to provide the closest possible frequency to the value specified in the .json file. </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#13-host-exercisers","title":"13 Host Exercisers","text":"<p>The Host Exerciser (HE) modules are responsible for generating traffic with the intent of exercising the specific interface they are designed to connect to. They are intended to test the interface in simulation and hardware, enable measurement of bandwidth and other performance KPIs and, in come cases, provide an example of data movement between interfaces (PCIe to DDR for e.g.) for adoption into a customer application. </p> <p>### 13.1 HE-LB and HE-MEM Host Exerciser</p> <p>The Host Exerciser Loopback module is a traffic generator that can be attached both to host memory, over PCIe (HE-LB), and to local memory, such as board-attached DDR (HE-MEM). The Host Exerciser (HE) is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth as well as demonstrating data path correctness. The FIM picks up the HE-LB module behind the PIM (Platform Interface Manager).  The PIM converts the AXI with TLP out of the PCIe SS to standard Arm\u00ae AMBA\u00ae 4 AXI4 (MM for completions and Lite for CSR) interfaces. The figure below shows how the HE-LB is instantiated in the FIM.</p> <p>Figure 13-1 HE-LB Dataflow Diagram </p> <p>The exerciser has two primary modes: loopback, in which read data is fed back as writes, and read/write mode, in which reads and writes are generated independently. Furthermore, the host_exerciser software provided with OPAE that drives the RTL has two major modes: \"lpbk\" and \"mem\". These modes only select the UUID of the HE AFU, with lpbk selecting a version configured with no local memory (56e203e9-864f-49a7-b94b-12284c31e02b) and mem seeking a version with local memory (8568ab4e-6ba5-4616-bb65-2a578330a8eb). The behavior of each engine with and without local memory is described below.</p> <p>Figure 13-2 HE Engine Heirarchy </p> <p>For more details of HE-LB and HE-MEM IP, please refer to ofs-fim-common/src/common/he_lb/README.md</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#132-hssi-host-exerciser-he-hssi","title":"13.2 HSSI Host Exerciser (HE-HSSI)","text":"<p>HE-HSSI is an Ethernet AFU that handles client side ethernet traffic. The reference HE-HSSI has following features:</p> <ul> <li>HE-HSSI provides an E-tile compatible interface with the Transceiver Subsystem.</li> <li>Includes a traffic generator and checker or monitor</li> <li>Provides pause signals to the Transceiver Subsystem for XON and XOFF generation</li> <li>Generates traffic or incoming traffic that can be looped back into transmit path by enabling loopback mode, which will bypass traffic generator</li> <li>At the HE-HSSI interface boundary the Ethernet data interface is AXI4-Stream with 64-bit data at eth_clk clock</li> </ul> <ul> <li>The Traffic generator and checker modules have a 64-bit data interface at eth_clk clock.</li> <li>The traffic generator supports the following modes:     * Fixed length or Random Length     * Incremental pattern or Random pattern</li> <li>Traffic checker does a 32-bit crc check in 10/25G. In the 100G configuration, there is no data integrity check, only a packet counter. </li> <li>The CSR of this AFU is accessible through AXI4-Stream PCIe TLP interface</li> <li>The PCIe TLP to CSR Interface Conversion module converts PCIe TLPs into simple CSR interface</li> <li>The CSR space of the traffic generator and checker modules are accessed in an indirect way using mailbox registers</li> <li>If used for more than one channel, each channel has a separate traffic generator and traffic checker with separate CSR space.</li> <li>Reads and Writes to individual traffic controller CSR spaces can be done by selecting that particular channel using channel select register.</li> </ul> <p>The HE-HSSI Ethernet block diagram is below. </p> <p>Figure 13-3: HE-HSSI Block Diagram Block Diagram</p> <p></p> <p>The diagram below shows the path followed depending on if you enable loopback mode in HE-HSSI or not.  In loopback mode, traffic is looped back into the transmit path which will bypass traffic.  Alternatively, the traffic generates traffic.</p> <p>Figure 13-4: HE-HSSI Operation Mode Traffic Patterns</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1322-he-hssi-csr-map","title":"13.2.2 HE-HSSI CSR Map","text":"<p>The reference HSSI AFU contains the following registers and a similar arrangement of register space can be implemented for other usecase specific HSSI AFUs. * AFU DFH Register: Device feature header for the AFU (AFU_DFH) * AFU ID Registers: 128-bit UUID for the AFU which occupies two 64-bit registers (AFU_ID_L, AFU_ID_H) * Mailbox Registers: Command and Data register for traffic controller register access. It follows the standard access method defined for OFS. Access method and implementation is same as Reconfiguration Interface defined for the HSSI FIM. (TRAFFIC_CTRL_CMD, TRAFFIC_CTRL_DATA) * Channel Select Register: Channel select register for traffic controller mailbox access. It is used in cases where more than one channel is in the AFU, else it defaults to zero, meaning channel-0 is selected. (TRAFFIC_CTRL_PORT_SEL) * Scratchpad Register: Scratchpad register for CSR access checking. (AFU_SCRATCHPAD) </p> <p>The CSR excel for HE-HSSI module can be found at ofs-common/src/common/he_hssi/HE_HSSI_CSR.xls.</p> <p>13.3 HE-Null Overview</p> <p>This module is a simple stub that is used to replace various HE and other blocks in the FIM whenever they are bypassed using the qsf compiler directive such as null_he_lb, null_he_hssi, null_he_mem and null_he_mem_tg.  To find out more about these compiler directives, refer to the Intel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</p> <p>Table 13-1  HE-Null DFH</p> REGISTER NAME ADDRESS ACCESS DEFAULT DESCRIPTION DFH 0x0000 RO 0x0000_0000_1000_0000 DFH register GUID_L 0x0008 RO 0xaa31f54a3e403501 Lower 64b of GUID GUID_H 0x0010 RO 0x3e7b60a0df2d4850 Upper 64b of GUID SCRATCHPAD 0x0018 RW 0x0 Scratchpad <p>Figure 13-5: HE-Null Block Diagram</p> <p></p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#14-reliability-accessibility-serviceability-ras-and-error-handling","title":"14 Reliability, Accessibility, Serviceability (RAS) and Error Handling","text":"<ol> <li>Downstream AFU checker: Identifies AFU violations.  For example, these checker flags violations of the interface specification. </li> <li>Upstream software or PCIe link checker: Identifies invalid traffic from PCIe that violates FIM or PCIe specifications. For example, this checker flags an application sending traffic if it violates the FIM specification or creates a PCIe link issue by causing completion timeout or malformed TLP. </li> <li>FIM - Checks for bugs in the FIM fabric.</li> </ol> <p>Errors reported by the checker are logged in either the FME error registers or Port error registers, or both, as shown in the table below.  For more details on each of the registers, please refer to ofs-fim-common/src/common/fme/xls/n6000/FME_CSR.xls or the SystemVerilog file: ofs-common/src/common/fme/fme_csr.sv.</p> <p>Table 14-1: Error Registers</p> MMIO Region Area Register Description FME CoreFIM FME_ERROR FME Error Status Register 0.  Registers parity errors, underflow or overflow errors and access mismatches. FME CoreFIM FME_ERROR0_MASK FME Error Mask Register 0.  Write a 0 to mask errors in the FME Error Status Register 0. FME External PCIE0_ERROR PCIe0 Error Status Register. FME External PCIE0_ERROR_MASK PCIe0 Error Mask Register 0.  Write a 0 to mask errors in the PCIe0 Error Status Register 0. FME CoreFIM FME_FIRST_ERROR First FME Error Register. FME CoreFIM FME_NEXT_ERROR FME Next Error Register. FME CoreFIM RAS_NOFAT_ERR_STAT Reliability/Accessibility/Serviceability (RAS) Non-Fatal Error Status Register. FME CoreFIM RAS_NOFAT_ERR_MASK RAS Non-Fatal Error Mask Register. Write 0 to mask error fields in RAS_NOFAT_ERR_STAT Register. FME CoreFIM RAS_CATFAT_ERR_STAT RAS Catastrophic and Fatal Errors Status Register. FME CoreFIM RAS_CATFAT_ERR_MASK RAS Catastrophic and Fatal Errors Mask Register. Write 0 to mask error fields in the RAS_CATFAT_ERR_STAT Register. FME CoreFIM RAS_ERROR_INJ RAS error Injection Register. PORT CoreFIM PORT_ERROR Port Error Status Register. PORT CoreFIM PORT_FIRST_ERROR Port First Error Register . PORT CoreFIM PORT_MALFORMED_REQ0 Port Malformed Request Register 0.  Provides malformed request header LSBs. PORT CoreFIM PORT_MALFORMED_REQ1 Port Malformed Request Register 1.  Provides malformed request header MSBs."},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#141-fme-errors","title":"14.1 FME Errors","text":""},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1411-fme_error0","title":"14.1.1   FME_ERROR0","text":"<p>The FME_ERROR0 register flags CoreFIM FME errors in the Global Error (GLBL_ERROR) private feature. The error bits in this register are sticky bits. You can only clear these bits through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in FME_ERROR0_MASK register masks the error.</p> <p>Table 14-2: FME Error Types</p> Error Type Description Fabric errors FIFO underflow/overflow condition in CoreFIM. These errors only occur if you have introduced bugs into the FIM or during very rare single event upset (SEU) or SEU-like events. Invalid port access A port can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the Port. If it finds a PF is trying to access a port that is mapped to a VF or vice-versa, an error will be reported. Invalid AFU access An AFU can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the AFU associated with the Port. If it finds a PF is trying to access an AFU that is mapped to a VF or vice-versa, an error is reported and a fake response is sent back to the requester to avoid a completion timeout on the host."},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1412-pcie0_error","title":"14.1.2 PCIE0_ERROR","text":"<p>The PCIe Avalon-ST to AXI4-Stream bridge monitors the PCIe link for errors and logs any such errors in the PCIE0_ERROR register (in PCIE0 feature region) and PCIE0_ERROR register in the GLBL_ERR private feature.    The error bits in the PCIE0_ERROR register are sticky bits that you can only clear through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in PCIE0_ERROR0_MASK masks the error.  </p> <p>If you have other external FME features, you can add similar _ERROR registers to this space. Please refer to the following spreadsheet in the release branch found at: /ipss/pcie/rtl/PCIE_CSR.xls or the SystemVerilog file: ipss/pcie/rtl/pcie_csr.sv for more details on this register.  <p>NOTE</p> <p>The PCIE0_ERROR register is located in both the Global Error external feature memory space and a separate PCIe external feature memory space.  OPAE software supports the PCIe external feature memory space beginning at offset 0x40000 for OFS EA and going forward.  PCIe registers beginning at 0x4000 in the Global Error external feature memory space is there for backward compatibility to the Intel FPGA PAC D5005 v2.0.1 Acceleration Stack.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1413-fme_first_error-fme_next_error","title":"14.1.3   FME_FIRST_ERROR, FME_NEXT_ERROR","text":"<p>The FME_FIRST_ERROR register flags which of the FME error reporting registers, such as FME_ERROR0, PCIE0_ERROR0, has reported the first error occurrence. The error fields of the first error register are then continuously logged into the FME_FIRST_ERROR register until a system reset or software clears all the errors in that first error register. Likewise, the FME_NEXT_ERROR indicates which of the FME error reporting registers (except the first error register) has reported the next occurrence of error after the first error register. The error fields of the next error register are continuously logged into the FME_NEXT_ERROR register until a system reset or software clears all the errors in the second error register.</p> <p>Please refer to the file in the ofs-fim-common repository folder: src/common/fme/fme_csr.sv for individual register field descriptions or the SystemVerilog file src/common/fme/fme_csr.sv.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1414-reliability-accessibility-serviceability-ras-error-status","title":"14.1.4   Reliability, Accessibility, Serviceability (RAS) Error Status","text":"<p>The RAS feature in CoreFIM labels errors as non-fatal, fatal or catastrophic based on their impact to the system.  * A non-fatal error usually originates from software or an AFU.  With a non-fatal error, the user application may still be able to recover from the error by performing a soft reset on the AFU, fixing the user application software if necessary, and clearing the error. On the other hand, a fatal or catastrophic error is non-recoverable and requires the platform to be reset. * Non-fatal errors are logged in the RAS_NOFAT_ERR_STAT register and fatal or catastrophic errors are logged in the RAS_CATFAT_ERR_STAT register.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#14141-non-fatal-errors","title":"14.1.4.1    Non-Fatal Errors","text":"<p>The RAS_NOFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It logs the high-level status of non-fatal errors in the hardware.  Unlike the error bits in the PCIE0_ERROR and FME_ERROR0 registers which are RW1C (software can write a 1 to clear the error), the error bits in this register are read-only and can only be cleared by system reset. Software has an option to mask the error using RAS_NOFAT_ERR_MASK. Please refer to the following file in the ofs-fim-common resository: src/common/fme/xls/n6000/FME_CSR.xls for individual register field descriptions or the SystemVerilog file: src/common/fme/fme_csr.sv.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#14142-catastrophic-fatal-errors","title":"14.1.4.2    Catastrophic &amp; Fatal Errors","text":"<p>The RAS_CATFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It captures the high-level status of errors that can only be recovered with a system reset. Therefore, the error bits in the RAS_CATFAT_ERR_STAT register are read-only and can only be cleared by system reset or masked through RAS_CATFAT_ERR_MASK. Please refer to the following file in the ofs-fim-common resository: src/common/fme/xls/n6000/FME_CSR.xls for individual register field descriptions or the SystemVerilog file: src/common/fme/fme_csr.sv.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1415-ras-error-injection","title":"14.1.5   RAS Error Injection","text":"<p>For software testing purposes, you can inject non-fatal, fatal and catastrophic errors into the platform through the RAS_ERROR_INJ register.  These errors are reported in the RAS_CATFAT_ERR_STAT and RAS_NOFAT_ERR_STAT registers. Please refer to the following file in the ofs-fim-common resository: src/common/fme/xls/n6000/FME_CSR.xls for individual register field descriptions or the SystemVerilog file: src/common/fme/fme_csr.sv.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1416-fme-error-interrupts","title":"14.1.6   FME Error Interrupts","text":"<p>In an event of an FME error, the MSI-X module in the FIM generates an interrupt so the host can decide on the next course of action. The FIM does not stall upstream and downstream traffic after the FME error. However, a port error triggered by invalid request from a user AFU stalls all the traffic going from AFU to PCIe. The interrupt capability is discoverable by querying the <code>NumbSuppInterrupt</code> field of the PORT_CAPABILITY register in the Port private feature.  The MSI-X vector number is recorded in the <code>InterruptVectorNumber</code> field of the GLBL_ERROR_CAPABILITY register of the Global Error external feature.</p> <p>An FME error interrupt is generated in response to the FME_ERROR0, PCIE0_ERROR0, RAS_NOFAT_ERR_STAT or RAS_CATFAT_ERR_STAT registers recording a new, unmasked, error per the rules defined by CoreFIM interrupt feature.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1417-fme-error-handling","title":"14.1.7   FME Error Handling","text":"<p>When the host receives an FME error interrupt, it must take the recommended actions described below to bring the system back to its normal operation.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#14171-catastrophicfatal-error","title":"14.1.7.1    Catastrophic/Fatal Error","text":"<p>A system reset is mandatory for any catastrophic or fatal error.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#14172-non-fatal-error","title":"14.1.7.2    Non-Fatal Error","text":"<p>When software receives a non-fatal error interrupt which does not require a system reset, it can take the following steps to clear the error after software handles the error: 1.  Set the *_ERROR_MASK register to all 1\u2019s to mask all errors 2. Clear the *_FIRST_ERROR register 3. Clear the *_ERROR register 4. Set *_ERROR_MASK register to all 0\u2019s to enable all errors</p> <ul> <li>Result: The *_ERROR &amp; *_FIRST_ERROR registers begin capturing new errors.</li> </ul> <p>NOTE</p> <p>A system reset can only clear RAS Error status registers.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#142-mmio-requests","title":"14.2 MMIO Requests","text":"<p>The FIM is designed to gracefully handle MMIO request scenarios.  </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1421-unsupported-functions-and-bars","title":"14.2.1 Unsupported Functions and BARs","text":"<p>The PCIe hard IP in the FIM guarantees that only TLP packets for the functions and BARs supported by the FIM (as configured in PCIe HIP IP instantiation) are sent to the FIM.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1422-mmio-request-decoding","title":"14.2.2 MMIO Request Decoding","text":"<p>The packet router and memory decoder in the FIM ensure that only legal MMIO requests are forwarded to the targeted MMIO region. Full address and BAR decoding is done both in the packet router and the memory decoder to ensure the requests are forwarded to the designated CSR region as defined in the MMIO Regions chapter.  Any unsolicited/illegal MMIO request is dropped, and an error is reported back to host through the FME error register.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1423-unused-fmeport-csr-regions","title":"14.2.3 Unused FME/Port CSR Regions","text":"<p>All the CSR slaves in FIM which are mapped to the FME or Port CSR regions must always respond to MMIO read requests targeting its associated CSR region. A CSR slave must return all 0s for MMIO reads to its unused CSR region such as a reserved space or a region where no CSR register is implemented for the address. The FIM ensures MMIO reads to FME or Port CSR regions that are not mapped to any CSR slave always gets a response of all 0s. The memory decoder module and fake responder module in the FIM provide this guaranteed response.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1424-unsupported-mmio-request","title":"14.2.4 Unsupported MMIO Request","text":"<p>Any MMIO request targeting FME or Port CSR regions with a length or address alignment that are not  supported by the FIM is dropped, and an error is logged in PCIE0_ERROR register. The MMIO checker module in the FIM guarantees this response. When an unsupported MMIO read request to the FIM CSR region is detected, the FIM sends back a CPL (completion without data) with error status (UR) back to host.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1425-afu-access-violation","title":"14.2.5 AFU Access Violation","text":"<p>AFU access violations refer to the scenarios where a PF is attempting to access the MMIO region of an AFU bound to a VF (virtualization enabled), or when a VF is trying to access the MMIO region of an AFU bound to a PF (virtualization disabled). When such a violation is detected, the FIM drops the request and logs the error in the FME_ERROR0 register. If the request is an MMIO read request, the FIM returns a fake response to the host.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#1426-afu-mmio-response-timeout","title":"14.2.6    AFU MMIO Response Timeout","text":"<p>An AFU MMIO Response timeout functions in the same manner described in the MMIO Response Timeout section.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#15-ofs-design-hierarchy","title":"15 OFS Design Hierarchy","text":"<p>Files for design, build and unit test simulation are found at https://github.com/OFS/ofs-n6001, release branch ${{ N6001_Release }}.</p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#151-design-guidance","title":"15.1 Design Guidance","text":"<p>The OFS FIM is designed with configurability and scalability in mind.  At a high level, these are the necessary steps for a user to customize the design.  Please refer to the FIntel\u00ae FPGA Interface Manager Developer Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs for detaaled design guidance. </p>"},{"location":"hw/n6001/reference_manuals/ofs_fim/mnl_fim_ofs_n6001/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  \u00a0</p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/","title":"Platform Evaluation Script: Open FPGA Stack for Intel Agilex FPGA","text":""},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#1-overview","title":"1 Overview","text":""},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a set-up and user guide for the checkout and evaluation of an Intel\u00ae FPGA SmartNIC N6001-PL development platform using Open FPGA Stack (OFS). After reviewing the document, you will be able to:</p> <ul> <li>Set-up and modify the script to the your environment</li> </ul> <ul> <li>Compile and simulate an OFS reference design</li> </ul> <ul> <li>Run hardware and software tests to evaluate the complete OFS flow</li> </ul>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#table-1-2-software-version-summary","title":"Table 1-2: Software Version Summary","text":"Component Version Description FPGA Platform Intel\u00ae FPGA SmartNIC N6001-PL Intel platform you can use for your custom board development OFS FIM Source Code Branch: https://github.com/OFS/ofs-n6001, Tag: ofs-2023.1-1 OFS Shell RTL for Intel Agilex FPGA (targeting Intel\u00ae FPGA SmartNIC N6001-PL) OFS FIM Common Branch: https://github.com/OFS/ofs-fim-common/2023.1, Tag: https://github.com/OFS/ofs-fim-common/2023.1 Common RTL across all OFS-based platforms AFU Examples Branch: examples-afu , Tag:ofs-examples-https://github.com/OFS/examples-afu/releases/tag/ofs-2023.1-1 Tutorials and simple examples for the Accelerator Functional Unit region (workload region) OPAE SDK Branch: 2.5.0-3, Tag: 2.5.0-3 Open Programmable Acceleration Engine Software Development Kit Kernel Drivers Branch: ofs-2023.1-6.1-1, Tag: ofs-2023.1-6.1-1 OFS specific kernel drivers OPAE Simulation Branch: opae-sim, Tag: 2.5.0-3 Accelerator Simulation Environment for hardware/software co-simulation of your AFU (workload) Intel Quartus Prime Pro Edition Design Software 23.1 [Intel\u00ae Quartus\u00ae Prime Pro Edition Linux] Software tool for Intel FPGA Development Operating System RHEL 8.6 Operating system on which this script has been tested <p>A download page containing the release and already-compiled FIM binary artifacts that you can use for immediate evaluation on the Intel\u00ae FPGA SmartNIC N6001-PL can be found on the OFS ofs-2023.1-1 official release drop on GitHub.</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#2-introduction-to-ofs-evaluation-script","title":"2 Introduction to OFS Evaluation Script","text":"<p>By following the setup steps and using the OFS evaluation script you can quickly evaluate many features that the OFS framework provides and also leverage this script for your own development.  </p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#21-pre-requisites","title":"2.1 Pre-Requisites","text":"<p>This script uses the following set of software tools which should be installed using the directory structure below. Tool versions can vary.</p> <ul> <li>Intel Quartus\u00ae Prime Pro Software</li> <li>Synopsys\u00ae VCS Simulator</li> <li>Siemens\u00ae Questa\u00ae Simulator</li> </ul> <p>Figure 2-1 Folder Hierarchy for Software Tools</p> <p></p> <ol> <li> <p>You must create a directory named \"ofs-X.X.X\" where the X represents the current release number, for example ofs-2023.1-1. </p> </li> <li> <p>You must clone the required OFS repositories as per Figure 2-2.  Please refer to the BKC table for locations. Please go [OFS Getting Started User Guide] for the instructions for the BKC installation.</p> </li> <li> <p>Once the repositories are cloned, copy the evaluation script (ofs_n6001_eval.sh) which is located at [eval_scripts] beneath the $IOFS_BUILD_ROOT directory location as shown in the example below:</p> </li> </ol> <p>Figure 2-2 Directory Structure for OFS Project</p> <pre><code>## ofs-2023.1-1\n##  -&gt; examples-afu\n##  -&gt; linux-dfl\n##  -&gt; ofs-n6001\n##  -&gt; oneapi-asp\n##  -&gt; oneAPI-samples\n##  -&gt; opae-sdk\n##  -&gt; opae-sim\n##  -&gt; ofs_n6001_eval.sh\n</code></pre> <ol> <li>Open the README file named (README_ofs_n6001_eval.txt) which is located at [eval_scripts] which informs the user which sections to modify in the script prior to building the FIM and running hardware, software and simulation tests.</li> </ol>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#22-n6001-evaluation-script-modification","title":"2.2 n6001 Evaluation Script modification","text":"<p>To adapt this script to the user environment please follow the instructions below which explains which line numbers to change in the ofs_n6001_eval.sh script </p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#user-directory-creation","title":"User Directory Creation","text":"<p>The user must create the top-level source directory and then clone the OFS repositories</p> <pre><code>mkdir ofs-2023.1-1\n</code></pre> <p>In the example above we have used ofs-2023.1-1 as the directory name</p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#set-up-proxy-server-lines-65-67","title":"Set-Up Proxy Server (lines 65-67)","text":"<p>Please enter the location of your proxy server to allow access to external internet to build software packages.</p> <p>Note: Failing to add proxy server will prevent cloning of repositories and the user will be unable to build the OFS framework.</p> <pre><code>export http_proxy=&lt;user_proxy&gt;\nexport https_proxy=&lt;user_proxy&gt;\nexport no_proxy=&lt;user_proxy&gt;\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#license-files-lines-70-72","title":"License Files (lines 70-72)","text":"<p>Please enter the the license file locations for the following tool variables</p> <pre><code>export LM_LICENSE_FILE=&lt;user_license&gt;\nexport DW_LICENSE_FILE=&lt;user_license&gt;\nexport SNPSLMD_LICENSE_FILE=&lt;user_license&gt;\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#tools-location-line-85-86-87-88","title":"Tools Location (line 85, 86, 87, 88)","text":"<p>Set Location of Quartus, Synopsys, Questasim and oneAPI Tools</p> <pre><code>export QUARTUS_TOOLS_LOCATION=/home\nexport SYNOPSYS_TOOLS_LOCATION=/home\nexport QUESTASIM_TOOLS_LOCATION=/home\nexport ONEAPI_TOOLS_LOCATION=/opt\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#quartus-tools-version-line-93","title":"Quartus Tools Version (line 93)","text":"<p>Set version of Quartus</p> <pre><code>export QUARTUS_VERSION=23.1\n</code></pre> <p>In the example above \"23.1\" is used as the Quartus tools version</p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#opae-tools-line-106","title":"OPAE Tools (line 106)","text":"<p>change OPAE SDK VERSION</p> <pre><code>export OPAE_SDK_VERSION=2.5.0-3\n</code></pre> <p>In the example above \"2.5.0-3\" is used as the OPAE SDK tools version</p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#pcie-bus-number-lines-231-and-238","title":"PCIe (Bus Number) (lines 231 and 238)","text":"<p>The Bus number must be entered by the user after installing the hardware in the chosen server, in the example below \"b1\" is the Bus Number for a single card as defined in the evaluation script.</p> <pre><code>export ADP_CARD0_BUS_NUMBER=b1\n</code></pre> <p>The evaluation script uses the bus number as an identifier to interrogate the card. The command below will identify the accelerater card plugged into a server. </p> <pre><code>lspci | grep acc\n\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)&lt;br&gt;\nb1:00.1 Processing accelerators: Intel Corporation Device bcce&lt;br&gt;\nb1:00.2 Processing accelerators: Intel Corporation Device bcce&lt;br&gt;\nb1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device&lt;br&gt;\nb1:00.4 Processing accelerators: Intel Corporation Device bcce&lt;br&gt;\n</code></pre> <p>The result identifies the card as being assigned \"b1\" as the bus number so the entry in the script changes to</p> <pre><code>export ADP_CARD0_BUS_NUMBER=b1\n</code></pre> <p>The user can also run the following command on the ofs_n6001_eval.sh script to automatically change the bus number to b1 in the ofs_n6001_eval.sh script.</p> <p>grep -rli 'b1' * | xargs -i@ sed -i 'b1' @</p> <p>if the bus number is 85 for example </p> <pre><code>85:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)&lt;br&gt;\n85:00.1 Processing accelerators: Intel Corporation Device bcce&lt;br&gt;\n85:00.2 Processing accelerators: Intel Corporation Device bcce&lt;br&gt;\n85:00.3 Processing accelerators: Red Hat, Inc. Virtio network device&lt;br&gt;\n85:00.4 Processing accelerators: Intel Corporation Device bcce&lt;br&gt;\n</code></pre> <p>the command to change to 85 in the evaluation script would be</p> <p>grep -rli 'b1' * | xargs -i@ sed -i '85' @</p> <p>The ofs_n6001_eval.sh script has now been modified to the server set-up and the user can proceed to build, compile and simulate the OFS stack</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#3-n6001-evaluation-script","title":"3 n6001 Evaluation Script","text":""},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#31-overview","title":"3.1 Overview","text":"<p>The figure below shows a snapshot of the full evaluation script menu showing all 62 options and each one one of 11 sub-menus which focus on different areas of evaluation. Each of these menu options are described in the next section.</p> <p>Figure 3-1 ofs_n6001_eval.sh Evaluation Menu</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#311-adp-tools-menu","title":"3.1.1 ADP TOOLS MENU","text":"<p>By selecting \"List of Documentation for ADP n6001 Project,\" a list of links to the latest OFS documentation appears. Note that these links will take you to documentation for the most recent release which may not correspond to the release version you are evaluating. To find the documentation specific to your release, ensure you clone the intel-ofs-docs tag that corresponds to your OFS version.</p> <p>By selecting \"Check Versions of Operating System and Quartus Premier Design Suite\", the tool verifies correct Operating System, Quartus version, kernel parameters, license files and paths to installed software tools.</p> <p></p> Menu Option Example Output 1 - List of Documentation for ADP n6001 Project  Open FPGA Stack Overview                  Guides you through the setup and build steps to evaluate the OFS solution                 https://ofs.github.io 2 - Check versions of Operating System and Quartus Premier Design Suite (QPDS) Checking Linux release                 Linux version 5.15.52-dfl (guest@hw-rae-svr4-l) (gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-4), GNU ld version 2.30-79.el8) #1 SMP Fri Sep 23 17:19:37 BST 2022                  Checking RedHat release                 CentOS Linux release 8.3.2011                  Checking Ubuntu release                 cat: /etc/lsb-release: No such file or directory                  Checking Kernel parameters                 BOOT_IMAGE=(hd0,gpt2)/vmlinuz-5.15.52-dfl root=/dev/mapper/cl-root ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200                  Checking Licenses                 LM_LICENSE_FILE is set to port@socket number:port@socket number                 DW_LICENSE_FILE is set to port@socket number:port@socket number                 SNPSLMD_LICENSE_FILE is set to port@socket number:port@socket number                  Checking Tool versions                 QUARTUS_HOME is set to /home/intelFPGA_pro/23.1/quartus                 QUARTUS_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus                 IMPORT_IP_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus/../ip                 QSYS_ROOTDIR is set to /home/intelFPGA_pro/23.1/quartus/../qsys/bin                  Checking QPDS Patches                 Quartus Prime Shell                 Version 23.1 Build XXX XX/XX/XXXX Patches X.XX SC Pro Edition                 Copyright (C) XXXX  Intel Corporation. All rights reserved."},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#312-adp-hardware-menu","title":"3.1.2 ADP HARDWARE MENU","text":"<p>Identifies card by PCIe number, checks power, temperature and current firmware configuration. </p> <p></p> Menu Option Example Output 3 - Identify Acceleration Development Platform (ADP) n6001 Hardware via PCIe PCIe card detected as                 b1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)                 b1:00.1 Processing accelerators: Intel Corporation Device bcce                 b1:00.2 Processing accelerators: Intel Corporation Device bcce                 b1:00.4 Processing accelerators: Intel Corporation Device bcce                 Host Server is connected to SINGLE card configuration 4 - Identify the Board Management Controller (BMC) Version and check BMC sensors Intel Acceleration Development Platform N6001                 Board Management Controller NIOS FW version: 3.2.0                 Board Management Controller Build version: 3.2.0                 //****** BMC SENSORS ******//                 Object Id                        : 0xEE00000                 PCIe s:b:d.f                     : 0000:B1:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x1771                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x50102027135A894                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 7dbb989d-5eb9-54f4-8a74-40ddff52e0e2 5 - Identify the FPGA Management Engine (FME) Version Intel Acceleration Development Platform N6001                 Board Management Controller NIOS FW version: 3.2.0                 Management Controller Build version: 3.2.0                 //****** FME ******//                 Object Id                        : 0xEE00000                 PCIe s:b:d.f                     : 0000:B1:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x1771                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x50102027135A894                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 7dbb989d-5eb9-54f4-8a74-40ddff52e0e2                 Boot Page                        : user1                 Factory Image Info               : a7c6879683182ce61084c420e51f50b6                 User1 Image Info                 : 8a7440ddff52e0e27dbb989d5eb954f4                 User2 Image Info                 : a7c6879683182ce61084c420e51f50b6 6 - Check Board Power and Temperature Intel Acceleration Development Platform N6001                 Board Management Controller NIOS FW version: 3.2.0                 Board Management Controller Build version: 3.2.0                 //****** POWER ******//                 Object Id                        : 0xEE00000                 PCIe s:b:d.f                     : 0000:B1:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x1771                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x50102027135A894                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 7dbb989d-5eb9-54f4-8a74-40ddff52e0e2                 ( 1) VCCRT_GXER_0V9 Voltage      : 0.91 Volts                 etc ......................                  Intel Acceleration Development Platform N6001                 Board Management Controller NIOS FW version: 3.2.0                 Board Management Controller Build version: 3.2.0                 //****** TEMP ******//                 Object Id                        : 0xEE00000                 PCIe s:b:d.f                     : 0000:B1:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x1771                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x50102027135A894                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 7dbb989d-5eb9-54f4-8a74-40ddff52e0e2                 ( 1) FPGA E-Tile Temperature [Remote] : 33.50 Celsius                 etc ...................... 7 - Check Accelerator Port status //****** PORT ******//                 Object Id                        : 0xED00000                 PCIe s:b:d.f                     : 0000:B1:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x1771                 Socket Id                        : 0x00 8 - Check MAC and PHY status Intel Acceleration Development Platform N6001                 Board Management Controller NIOS FW version: 3.2.0                 Board Management Controller Build version: 3.2.0                 //****** MAC ******//                 Object Id                        : 0xEE00000                 PCIe s:b:d.f                     : 0000:B1:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x1771                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x50102027135A894                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 7dbb989d-5eb9-54f4-8a74-40ddff52e0e2                 Number of MACs                   : 255                 mac info is not supported                  Intel Acceleration Development Platform N6001                 Board Management Controller NIOS FW version: 3.2.0                 Board Management Controller Build version: 3.2.0                 //****** PHY ******//                 Object Id                        : 0xEE00000                 PCIe s:b:d.f                     : 0000:B1:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x1771                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x50102027135A894                 Bitstream Version                : 5.0.1                 Pr Interface Id                  : 7dbb989d-5eb9-54f4-8a74-40ddff52e0e2                  //****** HSSI information ******//                 HSSI version                     : 1.0                 Number of ports                  : 8                 Port0                            :25GbE        DOWN                 Port1                            :25GbE        DOWN                 Port2                            :25GbE        DOWN                 Port3                            :25GbE        DOWN                 Port4                            :25GbE        DOWN                 Port5                            :25GbE        DOWN                 Port6                            :25GbE        DOWN                 Port7                            :25GbE        DOWN"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#313-adp-pfvf-mux-menu","title":"3.1.3 ADP PF/VF MUX MENU","text":"<p>This menu reports the number of PF/VF functions in the reference example and also allows you to reduce the number to 1PF and 1VF to reduce resource utilisation and create a larger area for your workload development. This selection is optional and if the user wants to implement the default number of PF's and VF's then option 9, 10 and 11 should not be used.  Additionally the code used to make the PF/VF modification can be leveraged to increase or modify the number of PF/VFs in the existing design within the limits that the PCIe Subsystem supports (8PF/2K VFs)</p> <p></p> Menu Option Description 9 - Check PF/VF Mux Configuration  This menu selection displays the current configuration of the pcie_host.ofss file which is located at the following directory $OFS_ROOTDIR/tools/pfvf_config_tool                  [ProjectSettings]                 platform = n6001                 family = Agilex                 fim = base_x16                 Part = AGFB014R24A2E2V                 IpDeployFile = pcie_ss.sh                 IpFile = pcie_ss.ip                 OutputName = pcie_ss                 ComponentName = pcie_ss                 is_host = True                  [pf0]                 num_vfs = 3                 pg_enable = True                  [pf1]                  [pf2]                  [pf3]                  [pf4] 10 - Modify PF/VF Mux Configuration As an example this menu selection modifies the pcie_host.ofss file to 1 PF located in the following directory $OFS_ROOTDIR/tools/pfvf_config_tool             This option also displays the the modified pcie_host.ofss file 11 - Build PF/VF Mux Configuration If option 10 is not used then then the default number of PF's and VF's is used to build the FIM, if option 10 is selected then only 1 VF is built to reduce logic utilisation"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#314-adp-fimpr-build-menu","title":"3.1.4 ADP FIM/PR BUILD MENU","text":"<p>Builds FIM, Partial Reconfiguration Region and Remote Signal Tap</p> <p></p> Menu Option Description 12 - Check ADP software versions for ADP n6001 Project OFS_ROOTDIR is set to /home/user_area/ofs-X.X.X/ofs-n6001                 OPAE_SDK_REPO_BRANCH is set to release/X.X.X                 OPAE_SDK_ROOT is set to /home/user_area/ofs-X.X.X/ofs-n6001/../opae-sdk                 LD_LIBRARY_PATH is set to /home/user_area/ofs-X.X.X/ofs-n6001/../opae-sdk/lib64: 13 - Build FIM for n6001 Hardware This option builds the FIM based on the setting for the $ADP_PLATFORM, $FIM_SHELL environment variable. Check this variable in the following file ofs_n6001_eval.sh 14 - Check FIM Identification of FIM for n6001 Hardware The FIM is identified by the following file fme-ifc-id.txt located at $OFS_ROOTDIR/$FIM_WORKDIR/syn/syn_top/ 15 - Build Partial Reconfiguration Tree for n6001 Hardware This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development and also for the oneAPI build flow  16 - Build Base FIM Identification(ID) into PR Build Tree template This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU and oneAPI workloads 17 - Build Partial Reconfiguration Tree for n6001 Hardware with Remote Signal Tap This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development and also for the oneAPI build flow for the Remote Signal Tap flow 18 - Build Base FIM Identification(ID) into PR Build Tree template with Remote Signal Tap This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree for Remote Signal Tap to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU and oneAPI workloads"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#315-adp-hardware-programmingdiagnostic-menu","title":"3.1.5 ADP HARDWARE PROGRAMMING/DIAGNOSTIC MENU","text":"<p>The following submenu allows you to: * Program and check flash  * Perform a remote system update (RSU) of the FPGA image into the FPGA * Bind virtual functions to VFIO PCIe driver  * Run host exerciser (HE) commands such as loopback to test interfaces VFIO PCI driver binding * Read the control and status registers (CSRs) for bound modules that are part of the OFS reference design.</p> <p></p> Menu Option Description 19 - Program BMC Image into n6001 Hardware The user must place a new BMC flash file in the following directory $OFS_ROOTDIR/bmc_flash_files. Once the user executes this option a new BMC image will be programmed. A remote system upgrade command is initiated to store the new BMC image 20 - Check Boot Area Flash Image from n6001 Hardware This option checks which location area in FLASH the image will boot from, the default is user1              Boot Page : user1 21 - Program FIM Image into user1 area for n6001 Hardware This option programs the FIM image \"ofs_top_page1_unsigned_user1.bin\" into user1 area in flash 22 - Initiate Remote System Upgrade (RSU) from user1 Flash Image into n6001 Hardware This option initiates a Remote System Upgrade and soft reboots the server and re-scans the PCIe bus for the new image to be loaded              2022-11-10 11:26:24,307 - [[pci_address(0000:b1:00.0), pci_id(0x8086, 0xbcce)]] performing RSU operation             2022-11-10 11:26:24,310 - [[pci_address(0000:b0:02.0), pci_id(0x8086, 0x347a)]] removing device from PCIe bus             2022-11-10 11:26:24,357 - waiting 10 seconds for boot             2022-11-10 11:26:34,368 - rescanning PCIe bus: /sys/devices/pci0000:b0/pci_bus/0000:b0             2022-11-10 11:26:35,965 - RSU operation complete 23 - Check PF/VF Mapping Table, vfio-pci driver binding and accelerator port status This option checks the current vfio-pci driver binding for the PF's and VF's 24 - Unbind vfio-pci driver This option unbinds the vfio-pci driver for the PF's and VF's 25 - Create Virtual Functions (VF) and bind driver to vfio-pci n6001 Hardware This option creates vfio-pci driver binding for the PF's and VF's             Once the VF's have been bound to the driver the user can select menu option 23 to check that the new drivers are bound 26 - Verify FME Interrupts with hello_events The hello_events utility is used to verify FME interrupts. This tool injects FME errors and waits for error interrupts, then clears the errors 27 - Run HE-LB Test This option runs 5 tests              1) checks and generates traffic with the intention of exercising the path from the AFU to the Host at full bandwidth             2) run a loopback throughput test using one cacheline per request             3) run a loopback read test using four cachelines per request             4) run a loopback write test using four cachelines per request             5) run a loopback throughput test using four cachelines per request 28 - Run HE-MEM Test This option runs 2 tests              1) Checking and generating traffic with the intention of exercising the path from FPGA connected DDR; data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host             2) run a loopback throughput test using one cacheline per request 29 - Run HE-HSSI Test This option runs 1 test              HE-HSSI is responsible for handling client-side ethernet traffic. It wraps the 10G and 100G HSSI AFUs, and includes a traffic generator and checker. The user-space tool hssi exports a control interface to the HE-HSSI's AFU's packet generator logic              1) Send traffic through the 10G AFU              30 - Run Traffic Generator AFU Test This option runs 3 tests              TG AFU has an OPAE application to access &amp; exercise traffic, targeting a specific bank              1) Run the preconfigured write/read traffic test on channel 0             2) Target channel 1 with a 1MB single-word write only test for 1000 iterations             3) Target channel 2 with 4MB write/read test of max burst length for 10 iterations 31 - Read from CSR (Command and Status Registers) for n6001 Hardware This option reads from the following CSR's             HE-LB Command and Status Register Default Definitions             HE-MEM Command and Status Register Default Definitions             HE-HSSI Command and Status Register Default Definitions"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#316-adp-hardware-afu-testing-menu","title":"3.1.6  ADP HARDWARE AFU TESTING MENU","text":"<p>This submenu tests partial reconfiguration by building and loading an memory-mapped I/O example AFU/workload, executes software from host, and tests remote signal tap.</p> <p></p> Menu Option Description 32 - Build and Compile host_chan_mmio example This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS (Green Bit Stream) ready for hardware programming 33 - Execute host_chan_mmio example This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test 34 - Modify host_chan_mmio example to insert Remote Signal Tap This option inserts a pre-defined host_chan_mmio.stp Signal Tap file into the OFS code to allow a user to debug the host_chan_mmio AFU example 35 - Build and Compile host_chan_mmio example with Remote Signal Tap This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS(Green Bit Stream) ready for hardware programming with Remote Signal tap enabled 36 - Execute host_chan_mmio example with Remote Signal Tap This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test. The user must open the Signal Tap window when running the host code to see the transactions in the Signal Tap window"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#317-adp-hardware-afu-bbb-testing-menu","title":"3.1.7 ADP HARDWARE AFU BBB TESTING MENU","text":"<p>This submenu tests partial reconfiguration using a hello_world example AFU/workload, executes sw from host</p> <p></p> Menu Option Description 37 - Build and Compile hello_world example This option builds the hello_ world example from the following repo $FPGA_BBB_CCI_SRC/samples/tutorial/afu_types/01_pim_ifc/$AFU_BBB_TEST_NAME, where AFU_BBB_NAME=hello_world. This produces a GBS(Green Bit Stream) ready for hardware programming 38 - Execute hello_world example This option builds the host code for hello_world example and programs the GBS file and then executes the test"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#318-adp-oneapi-project-menu","title":"3.1.8 ADP ONEAPI PROJECT MENU","text":"<p>Builds oneAPI kernel, executes sw from host and runs diagnostic tests</p> <p></p> Menu Option Result 39 - Check oneAPI software versions for n6001 Project This option checks the setup of the oneAPI software and adds the relevant oneAPI environment variables to the terminal. This option also informs the user to match the oneAPI software version to the oneAPI-samples version 40 - Build and clone shim libraries required by oneAPI host This option builds the oneAPI directory structure 41 - Install oneAPI Host Driver This option Installs the oneAPI Host driver at the following location /opt/Intel/OpenCLFPGA/oneAPI/Boards/, and requires sudo permission 42 - Uninstall oneAPI Host Driver This option Uninstall's the oneAPI Host driver, and requires sudo permissions 43 - Diagnose oneAPI Hardware This option Checks ICD (Intel Client Driver) and FCD (FPGA Client Driver), oneAPI library locations and detects whether oneAPI BSP is loaded into the FPGA 44 - Build oneAPI BSP ofs_n6001 Default Kernel (hello_world) This option Builds the oneAPI BSP using hello_world kernel 45 - Build oneAPI MakeFile Environment This option Builds the oneAPI environment using a Makefile for kernel insertion  46 - Compile oneAPI Sample Application (board_test) for Emulation This option compiles the board_test kernel for Emulation 47 - Run oneAPI Sample Application (board_test) for Emulation This option executes the board_test kernel for Emulation 48 - Generate oneAPI Optimization report for (board_test) This option generates an optimization report for the board_test kernel 49 - Check PF/VF Mapping Table, vfio-pci driver binding and accelerator port status This option checks the current vfio-pci driver binding for the PF's and VF's 50 - Unbind vfio-pci driver This option unbinds the vfio-pci driver for the PF's and VF's 51 - Create Virtual Function (VF) and bind driver to vfio-pci n6001 Hardware This option creates vfio-pci driver binding for the PF's and VF's             Once the VF's have been bound to the driver the user can select menu option 45 to check that the new drivers are bound 52 - Program OpenCL BSP ofs_n6001 Default Kernel (hello_world) This option programs the FPGA with a aocf file based on the hello_world kernel 53 - Compile oneAPI Sample Application (board_test) for Hardware This option compiles the board_test kernel for Hardware 54 - Run oneAPI Sample Application (board_test) for Hardware This option builds the host code for board_test kernel and executes the program running through kernel and host bandwidth tests"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#319-adp-unit-test-project-menu","title":"3.1.9 ADP UNIT TEST PROJECT MENU","text":"<p>Builds, compiles and runs standalone simulation block tests.  More unit test examples are found at the following location ofs_n6001/sim/unit_test </p> <p></p> Menu Option Result 55 - Generate Simulation files for Unit Test This option builds the simulation file set for running a unit test simulation 56 - Simulate Unit Test dfh_walker and log waveform This option runs the dfh_walker based on the environment variable \"UNIT_TEST_NAME=dfh_walker\" in the evaluation script. A user can change the test being run by modifying this variable"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#3110-adp-uvm-project-menu","title":"3.1.10 ADP UVM PROJECT MENU","text":"<p>Builds, compiles and runs full chip simulation tests.  The user should execute the options sequentially ie 68,69, 70 and 71</p> <p></p> Menu Option Description 57 - Check UVM software versions for n6001 Project DESIGNWARE_HOME is set to /home/synopsys/vip_common/vip_Q-2020.03A                 UVM_HOME  is set to /home/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm                 VCS_HOME is set to /home/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel                 VERDIR is set to /home/user_area/ofs-X.X.X/ofs-n6001/verification                 VIPDIR is set to /home/user_area/ofs-X.X.X/ofs-n6001/verification 58 - Compile UVM IP This option cmpiles the UVM IP  59 - Compile UVM RTL and Testbench This option compiles the UVM RTL and Testbench 60 - Simulate UVM dfh_walking_test and log waveform This option runs the dfh_walking test based on the environment variable \"UVM_TEST_NAME=dfh_walking_test\" in the evaluation script. A user can change the test being run by modifying this variable 61 - Simulate all UVM test cases (Regression Mode) This option runs the n6001 regression mode, cycling through all UVM tests defined in verification/tests/test_pkg.svh file"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#3111-adp-build-all-project-menu","title":"3.1.11 ADP BUILD ALL PROJECT MENU","text":"<p>Builds the complete OFS flow, good for regression testing and overnight builds</p> <p>For this menu a user can run a sequence of tests (compilation, build and simulation) and executes them sequentially. After the script is successfully executed, a set of binary files is produced which a you can use to evaluate your hardware. Log files are also produced which checks whether the tests passed.</p> <p>A user can run a sequence of tests and execute them sequentially. In the example below when the user selects option 62 from the main menu the script will execute 24 tests ie (main menu options 2, 9, 12, 13, 14, 15, 16, 17, 18, 32, 34, 35, 37, 39, 40, 44, 45, 53, 55, 56, 57, 58, 59 and 60. These 24 menu options are chosen to build the complete OFS flow covering build, compile and simulation.</p> <p></p> Menu Option Result 62 - Build and Simulate Complete n6001 Project Generating Log File with date and timestamp                 Log file written to /home/guest/ofs-2.3.1/log_files/n6001_log_2022_11_10-093649/ofs_n6001_eval.log"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#definition-of-multi-test-set-up","title":"Definition of Multi-Test Set-up","text":"<p>Menu Option 62 above in the evaluation script can be refined to tailor it to the users need and is principally defined by the variable below</p> <p>MULTI_TEST[A,B]=C</p> <p>where</p> <p>A= Total Number of menu options in script B= Can be changed to a number to select the test order C= Menu Option in Script</p> <p>Example 1 MULTI_TEST[62,0]=2</p> <p>A= 62 is the total number of options in the script B= 0 indicates that this is the first test to be run in the script C= Menu option in Script ie 2- List of Documentation for ADP n6001 Project</p> <p>Example 2 MULTI_TEST[62,0]=2 MULTI_TEST[62,1]=9</p> <p>In the example above two tests are run in order ie 0, and 1 and the following menu options are executed ie 2- List of Documentation for ADP n6001 Project and 9 - Check ADP software versions for ADP n6001 Project</p> <p>The user can also modify the build time by de-selecting options they do not wish to use, see below for a couple of use-case scenarios.</p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#default-user-case","title":"Default User Case","text":"<p>A user can run a sequence of tests and execute them sequentially. In the example below when the user selects option 62 from the main menu the script will execute 24 tests ie (main menu options 2, 9, 12, 13, 14, 15, 16, 17, 18, 32, 34, 35, 37, 39, 40, 44, 45, 53, 55, 56, 57, 58, 59 and 60. All other tests with an \"X\" indicates do not run that test.</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#user-case-for-adp-fimpr-build-menu","title":"User Case for ADP FIM/PR BUILD MENU","text":"<p>In the example below when the user selects option 62 from the main menu the script will only run options from the ADP FIM/PR BUILD MENU (7 options, main menu options 12, 13, 14, 15, 16, 17 and 18). All other tests with an \"X\" indicates do not run that test.</p> <p></p> <p></p>"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#4-n6001-common-test-scenarios","title":"4 n6001 Common Test Scenarios","text":"<p>This section will describe the most common compile build scenarios if a user wanted to evaluate an acceleration card on their server. The Pre-requisite column indcates the menu comamnds that must be run befere executing the test eg To run Test 5 then a user needs to have run option 13, 15 and 16 before running options 23, 24, 25, 32 and 33.</p> Test Test Scenario Pre-Requisite Menu Option Menu Option Test 1 FIM Build - 13 Test 2 Partial Reconfiguration Build 13 15, 16 Test 3 Program FIM and perform Remote System Upgrade 13 21, 22 Test 4 Bind PF and VF to vfio-pci drivers - 23, 24, 25 Test 5 Build, compile and test AFU on hardware 13, 15, 16 23, 24, 25, 32, 33 Test 6 Build, compile and test AFU Basic Building Blocks on hardware 13, 15, 16 23, 24, 25, 37, 38 Test 7 Build, compile and test oneAPI on hardware 13, 15, 16 39, 40, 41, 44, 45, 49, 50, 51, 52, 53, 54 Test 8 Build and Simulate Unit Tests - 55, 56 Test 9 Build and Simulate UVM Tests - 57, 58, 59, 60"},{"location":"hw/n6001/user_guides/ug_eval_ofs_n6001/ug_eval_script_ofs_n6001/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/","title":"Getting Started Guide: Open FPGA Stack for Intel\u00ae Agilex FPGAs Targeting the Intel\u00ae FPGA SmartNIC N6001-PL","text":""},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#10-introduction","title":"1.0 Introduction","text":""},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#11-about-this-document","title":"1.1 About This Document","text":"<p>The purpose of this document is to help users get started in evaluating the 2023.1  version of the Open FPGA Stack (OFS) for the Intel Agilex FPGA targeting the Intel N6001-PL FPGA SmartNIC Platform. After reviewing the document a user shall be able to:</p> <ul> <li>Set up their server environment according to the Best Known Configuration (BKC)</li> <li>Build and install the OFS Linux Kernel drivers</li> <li>Build and install the Open Programmable Acceleration Engine Software Development Kit (OPAE SDK) software on top of the OFS Linux kernel drivers</li> <li>Load and Verify the Firmware and FIM versions loaded on their boards</li> <li>Verify the full stack functionality offered by the OFS solution</li> <li>Know where to find additional information on other OFS ingredients</li> </ul> <p>The following flow charts show a high level overview of the initial bring up process, split into three sequential diagrams. Detailed instructions for each installation process are shown in their respective sections.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#diagram-1-installing-the-opae-sdk","title":"Diagram 1: Installing the OPAE SDK","text":""},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#diagram-2-installing-the-linux-dfl-drivers","title":"Diagram 2: Installing the Linux DFL Drivers","text":""},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#diagram-3-bringing-up-the-intel-fpga-smartnic-n6001-pl","title":"Diagram 3: Bringing up the Intel\u00ae FPGA SmartNIC N6001-PL","text":""},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#12-introduction-to-ofs","title":"1.2 Introduction to OFS","text":"<p>Each OFS FIM targets a specific platform, but the modular hardware, software, simulation and test infrastructure allow users to modify each part of the design and test environment for their own custom acceleration platform card. This OFS release targets the Intel\u00ae FPGA SmartNIC N6001-PL.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#13-intended-audience","title":"1.3 Intended Audience","text":"<p>The information in this document is intended for customers evaluating the Intel\u00ae FPGA SmartNIC N6001-PL . The card is an acceleration development platform (ADP) intended to be used as a starting point for evaluation and development. This document will cover key topics related to initial bring up and development, with links for deeper dives on the topics discussed therein.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#14-reference-documents","title":"1.4 Reference Documents","text":"<p>Documentation for N6001 is collected  on GitHub. The document list is as follows:</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-2-reference-documents","title":"Table 2: Reference Documents","text":"Document Purpose Getting Started Guide: Intel Open FPGA Stack for Intel Agilex FPGA Guides you through the setup and build steps to evaluate the OFS solution targeting an Intel N6001-PL FPGA SmartNIC Platform FPGA Interface Manager Technical Reference Manual: Intel Open FPGA Stack for Intel Agilex FPGA Describes the OFS FIM architecture and features. Software Reference Manual: Intel Open FPGA Stack Describes the Open Programmable Acceleration Engine (OPAE) Software Development Kit, the OPAE C++ and Python API and management interfaces.  This document also covers building the OPAE SDK, how to add a new PCIe device, and debugging the software stack. FPGA Interface Manager Developer Guide: Intel Open Stack for Intel Agilex FPGA Provides guidance on developing an FPGA Interface Manager (FIM) for a custom FPGA acceleration board. Hard Processor System Software Developer Guide: Intel OFS for Intel Agilex FPGAs Describes the HPS configuration and software package for the Intel OFS release targeting Intel Agilex OFS and guides you through the steps to build your own Yocto application image for HPS. Accelerator Functional Unit Developer Guide: Intel Open FPGA Stack Provides guidance on how to build and test an AFU when designing to an OFS-based FPGA Interface Manager Simulation User Guide: Intel Open FPGA Stack for Intel Agilex FPGA Provides steps for setting up the UVM verification tool suite and running UVM unit tests Security User Guide: Intel Open FPGA Stack Describes how to create keys and sign bitstreams for your custom design; includes new VAB feature oneAPI Accelerator Support Package (ASP): Getting Started User Guide Describes how to get started using OneAPI with the OFS FIM BSP. oneAPI Accelerator Support Package(ASP) Reference Manual: Open FPGA Stack Describes how to use the provided shim for OFS for creating your custom OneAPI board support package. Platform Evaluation Script: Open FPGA Stack for Intel Agilex FPGA Serves as a set-up and user guide for the checkout and evaluation of an Intel FPGA SmartNIC N6001 Platform using Open FPGA Stack (OFS)."},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#15-component-version-summary","title":"1.5 Component Version Summary","text":"<p>The OFS 2023.1 Release targeting the Intel\u00ae FPGA SmartNIC N6001-PL is built upon tightly coupled software and firmware versions. Use this section as a general reference for the versions which compose this release.</p> <p>The following table highlights the hardware which makes up the Best Known Configuration (BKC) for the OFS 2023.1 release.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-3-hardware-bkc","title":"Table 3: Hardware BKC","text":"Component Version 1 x Intel\u00ae FPGA SmartNIC N6001-PL, SKU2 1 x Supermicro Server SYS-220HE 1 x Intel FPGA Download Cable II (Only Required for manual flashing) 1 x 2x5 Extension header - Samtech Part No: ESQ-105-13-L-D (Only Required for manual flashing) <p>The following table highlights the versions of the software which compose the OFS stack. The installation of the OPAE SDK on top of the Linux DFL drivers will be discussed in their relevant sections in this document.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-4-software-version-summary","title":"Table 4: Software Version Summary","text":"Component Version FPGA Platform Intel\u00ae FPGA SmartNIC N6001-PL, release notes: https://github.com/OFS/ofs-n6001/releases/tag/ofs-2023.1-1 under \"Known Issues\" OPAE SDK 2.5.0-3 Kernel Drivers ofs-2023.1-6.1-1 OneAPI-ASP ofs-2023.1-1 OFS FIM Source Code for N6001 ofs-2023.1-1 OFS FIM Common Resources Tag: ofs-fim-common-1.1.0-rc2 OFS Platform AFU BBB ofs-2023.1-1 Intel Quartus Prime Pro Edition Design Software* Quartus Prime Pro Version 23.1 for Linux Operating System RedHat\u00ae Enterprise Linux\u00ae (RHEL) 8.6 <p>The following table highlights the differences between N6000/1 PL FPGA SmartNIC platforms (SKU1/SKU2). Use this table to identify which version of the N6000/1-PL FPGA SmartNIC platform you have. The board identification printed by the <code>fpgainfo fme</code> commands depends on both the OPAE SDK and Linux DFL drivers from sections 3.0 OFS DFL Kernel Drivers through 4.0 OPAE Software Development Kit to be installed before it can be run.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-5-intel-n60001-pl-fpga-smartnic-platform-sku-mapping","title":"Table 5: Intel N6000/1-PL FPGA SmartNIC Platform SKU Mapping","text":"SKU Mapping SKU Value Primary Difference <code>fpgainfo</code> Identification N6000 Q1613314XXXXX PCIe Gen 4 1x16 mechanical bifurcated 2x8 logical to host, with one PCIe Gen 4x8 endpoint reserved for Intel E810-C-CAM2 NIC, the other reserved for FIM \"Intel Acceleration Development Platform N6000\" N6001 Q0216514XXXXX PCIe Gen 4 1x16 mechanical and logical connection between host and FIM \"Intel Acceleration Development Platform N6001\" <p>The following table highlights the programmable firmware versions that are supported on the Intel N6001-PL FPGA SmartNIC Platform in the OFS 2023.1 release. Programming and verifying these components is discussed in their respective sections.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-6-intel-fpga-smartnic-n6001-pl-programmable-component-version-summary","title":"Table 6: Intel\u00ae FPGA SmartNIC N6001-PL Programmable Component Version Summary","text":"Component Version PR Interface ID 4514ee67-ca01-5def-9fa5-a1ef30d0c76c Bitstream ID 360571655976424377 BMC RTL 3.11.0 BMC NIOS FW 3.11.0"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#16-initial-server-setup","title":"1.6 Initial Server Setup","text":""},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#161-server-bmc-and-bios-updates","title":"1.6.1 Server BMC and BIOS Updates","text":"<p>Both the server BIOS and BMC need to match the versions listed below in Table 7: Supermicro Server BMC BKC. These updates only apply for this specific Best Known Configuration (BKC) - other server manufacturers may require different BIOS updates. Please consult your server's user guide and release notes for update information.</p> <p>Information about the server\u2019s currently loaded firmware can be found on the BMC web portal dashboard. Accessing this page requires an Ethernet cable to be attached to an open port on the server labelled \u201cIPMI\u201d. During boot the BMC\u2019s login IP will be presented on the screen.</p> <p>Open this IP address in a browser and enter your login credentials. The default username is ADMIN, and the default password has been printed on the service tag that pulls out from the front of the server case. It is recommended the user change their BMC\u2019s default username as soon as they are able</p> <p>After logging in you should be able to review information about the BMC and BIOS by referring to the System box, visible upon initial loading of the page. Double check that the values match those in Table 7 Supermicro Server BMC BKC. If they do not, you may download the appropriate versions from the Supermicro product page by selecting the BIOS option and downloading the most recent \u201cBundled Software File Name\u201d. Follow the BMC and BIOS update instructions included in the Supermicro manuals page in the document X12/H12 BMC Manual in Appendix A.2 Updating Firmware Using BMC Web GUI.</p> <p>If using a different server model, refer to that server\u2019s user guide for instructions on remote system management.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-7-supermicro-server-bmc-bkc","title":"Table 7: Supermicro Server BMC BKC","text":"Component Version BIOS Version American Megatrends International, LLC(1.4)"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#162-server-fan-speed","title":"1.6.2 Server Fan Speed","text":"<p>The recommended fan speed setting is to use the 100% preset. If using a different server model, refer to that server\u2019s user guide for instructions on changing fan speed. The following steps will help users on the Supermicro platform.</p> <ol> <li>Log in to the Supermicro server BMC. (This requires an Ethernet cable to be attached to an open port on the server labelled \u201cIPMI\u201d.)</li> <li>During boot the BMC\u2019s login IP will be presented on the screen. Open this IP address in a browser and enter your login credentials. The default username is ADMIN, and the default password has been printed on the service tag that pulls out from the front of the server case.</li> <li>On the left menu select System -&gt; Component Info, select the Fan tab, under Advanced Settings click the circle next to Full Speed.</li> </ol>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#163-server-bios-configuration-changes","title":"1.6.3 Server BIOS Configuration Changes","text":"<p>To enter the Supermicro server\u2019s BIOS setup page, reboot, and press \\&lt;Delete&gt; when prompted. You can browse the tabs / options with a combination of arrow keys along with \\&lt;Escape&gt; and \\&lt;Enter&gt;.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#1631-enabling-intel-vt-d-technology","title":"1.6.3.1 Enabling Intel VT-d Technology","text":"<p>Navigate right to the Advanced tab, then select the following menu options: Chipset Configuration -&gt; North Bridge -&gt; IIO Configuration -&gt; Intel VT for Directed I/O (VT-d). If not already, enable the option Intel VT for Directed I/O (VT-d).</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#1632-pcie-slot-mapping","title":"1.6.3.2 PCie Slot Mapping","text":"<p>The Intel N6001-PL FPGA SmartNIC Platform is officially verified in the upper middle PCIe x16 slot (Slot 3). If using a different slot, refer to the information in Table 8 PCIe Slot Mapping for which port to manually change in the server BIOS.</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-8-pcie-slot-mapping","title":"Table 8: PCIe Slot Mapping","text":"CPU Number Port Number (in BIOS) PCIe Slot CPU1 Port 2 5 and 6 CPU1 Port 4 7 and 8 CPU2 Port 2 1 and 2 CPU2 Port 4 3 and 4"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#164-intel-fpga-smartnic-n6001-pl-installation-procedure","title":"1.6.4 Intel\u00ae FPGA SmartNIC N6001-PL Installation Procedure","text":"<p>The following instructions will help to ensure safe installation of the Intel\u00ae FPGA SmartNIC N6001-PL into a supported server. Refer to Table 8 PCIe Slot Mapping for a breakdown of the available PCIe slots on a SuperMicro SYS-220HE.</p> <ol> <li>Position the board over the selected connector on the motherboard.</li> <li>Press down gently and firmly to seat the card in the PCIe slot, and then secure the bracket to the system chassis with the retention screw.</li> </ol> <p></p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-9-intel-fpga-smartnic-n6001-pl-installation-procedure","title":"Table 9: Intel\u00ae FPGA SmartNIC N6001-PL Installation Procedure","text":"Callout Description 1 Retention screw 2 Press down here gently 3 Press down here gently 4 Motherboard <p>Do not bend the card while inserting into a slot. Do not apply much pressure in regions 2 or 3 while inserting.</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#165-intel-fpga-smartnic-n6001-pl-removal-procedure","title":"1.6.5 Intel\u00ae FPGA SmartNIC N6001-PL Removal Procedure","text":"<p>The following instructions will help to ensure safe removal of the platform from a supported server.</p> <ol> <li>Disconnect all power cords from the server power supply(s).</li> <li>Remove the retention bracket screw.</li> <li>Carefully lift the card out of the PCIe slot.</li> </ol> <p></p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-10-intel-fpga-smartnic-n6001-pl-removal-procedure","title":"Table 10: Intel\u00ae FPGA SmartNIC N6001-PL Removal Procedure","text":"Callout Description 1 Retention screw 2 Pull up here gently 3 Motherboard <p>Do not bend the card while removing it from the slot.</p> <p></p> <p> </p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#20-ofs-stack-architecture-overview-for-reference-platform","title":"2.0 OFS Stack Architecture Overview for Reference Platform","text":""},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#21-hardware-components","title":"2.1 Hardware Components","text":"<p>The OFS hardware architecture decomposes all designs into a standard set of modules, interfaces, and capabilities. Although the OFS infrastructure provides a standard set of functionality and capability, the user is responsible for making the customizations to their specific design in compliance with the specifications outlined in the FPGA Interface Manager Technical Reference Manual: Intel Open FPGA Stack for Intel Agilex FPGA.</p> <p>OFS is a hardware and software infrastructure that provides an efficient approach to developing a customer FPGA-based platform or workload using an Intel, 3rd party, or custom board.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#211-fpga-interface-manager","title":"2.1.1 FPGA Interface Manager","text":"<p>The FPGA Interface Manager (FIM), or shell of the FPGA provides platform management functionality, clocks, resets, and interface access to the host and peripheral features on the acceleration platform. The OFS architecture for Intel Agilex FPGA provides modularity, configurability and scalability.  The primary components of the FPGA Interface Manager or shell of the reference design are:</p> <ul> <li>PCIe Subsystem - a hierarchical design that targets the P-tile PCIe hard IP and is configured to support Gen4 speeds and Arm AXI4-Stream Data Mover functional mode.</li> <li>Ethernet Subsystem - provides portability to different Ethernet configurations across platforms and generations and reusability of the hardware framework and software stack.</li> <li>Memory Subsystem - composed of 5 DDR4 channels; two HPS DDR4 banks, x40 (x32 Data and x8 ECC), 1200 MHz, 1GB each, and four Fabric DDR4 banks, x32 (no ECC), 1200 MHz, 4GB</li> <li>Hard Processor System - 64-bit quad core ARM\u00ae Cortex*-A53 MPCore with integrated peripherals.</li> <li>Reset Controller</li> <li>FPGA Management Engine - Provides a way to manage the platform and enable acceleration functions on the platform.</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from Host or AFU</li> <li>Platform Management Controller Interface (PMCI) to the board management controller</li> </ul> <p>The FPGA Management Engine (FME) provides management features for the platform and the loading/unloading of accelerators through partial reconfiguration. Each feature of the FME exposes itself to the kernel-level OFS drivers on the host through a Device Feature Header (DFH) register that is placed at the beginning of Control Status Register (CSR) space. Only one PCIe link can access the FME register space in a multi-host channel design architecture at a time.</p> <p>Note: For more information on the FIM and its external connections, refer to the FPGA Interface Manager Technical Reference Manual: Intel Open FPGA Stack for Intel Agilex FPGA.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#12-afu","title":"*.1.2 AFU","text":"<p>An AFU is an acceleration workload that interfaces to the FIM. The AFU boundary in this reference design comprises both static and partial reconfiguration (PR) regions.  You can decide how you want to partition these two areas or if you want your AFU region to only be a partial reconfiguration region. A port gasket within the design provides all the PR specific modules and logic required to support partial reconfiguration. Only one partial reconfiguration region is supported in this design.</p> <p>Similar to the FME, the port gasket exposes its capability to the host software driver through a DFH register placed at the beginning of the port gasket CSR space. In addition, only one PCIe link can access the port register space.  </p> <p>You can compile your design in one of the following ways:</p> <ul> <li>Your entire AFU resides in a partial reconfiguration region of the FPGA.</li> <li>The AFU is part of the static region and is compiled as a flat design.</li> <li>Your AFU contains both static and PR regions.</li> </ul> <p>In this design, the AFU region is comprised of:</p> <ul> <li>AFU Interface handler to verify transactions coming from AFU region.</li> <li>PF/VF Mux to route transactions to and from corresponding AFU components: ST2MM module, Virtio LB stub, PCIe loopback host exerciser (HE-LB), HSSI host exerciser (HE-HSSI), Memory Host Exerciser (HE-MEM), Traffic Generator to memory (HE-MEM-TG), Port Gasket (PRG) and HPS Copy Engine.</li> <li>AXI4 Streaming to Memory Map (ST2MM) Module that routes MMIO CSR accesses to FME and board peripherals.</li> <li>Host exercisers to test PCIe, memory and HSSI interfaces (these can be removed from the AFU region after your FIM design is complete to provide more resource area for workloads)</li> <li>Basic HPS Copy Engine to copy second-stage bootloader and Linux OS image from Host DDR to HPS DDR.  </li> <li>Port gasket and partial reconfiguration support.</li> <li>Component for handling PLDM over MCTP over PCIe Vendor Defined Messages (VDM)</li> </ul> <p>The AFU has the option to consume native packets from the host or interface channels or to instantiate a shim provided by the Platform Interface Manager (PIM) to translate between protocols.</p> <p>Note: For more information on the Platform Interface Manager and AFU development and testing, refer to the AFU Development Guide: OFS for Intel\u00ae Agilex\u00ae PCIe Attach FPGAs.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#22-ofs-software-overview","title":"2.2 OFS Software Overview","text":"<p>The responsibility of the OFS kernel drivers is to act as the lowest software layer in the FPGA software stack, providing a minimalist driver implementation between the host software and functionality that has been implemented on the development platform. This leaves the implementation of IP-specific software in user-land, not the kernel. The OFS software stack also provides a mechanism for interface and feature discovery of FPGA platforms.</p> <p>The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space, and can be found on the OPAE SDK Github.</p> <p>The OFS drivers decompose implemented functionality, including external FIM features such as HSSI, EMIF and SPI, into sets of individual Device Features. Each Device Feature has its associated Device Feature Header (DFH), which enables a uniform discovery mechanism by software. A set of Device Features are exposed through the host interface in a Device Feature List (DFL). The OFS drivers discover and \"walk\" the Device Features in a Device Feature List and associate each Device Feature with its matching kernel driver.</p> <p>In this way the OFS software provides a clean and extensible framework for the creation and integration of additional functionalities and their features.</p> <p>*Note: A deeper dive on available SW APIs and programming model is available in the Software Reference Manual: Intel\u00ae Open FPGA Stack and on kernel.org.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#30-ofs-dfl-kernel-drivers","title":"3.0 OFS DFL Kernel Drivers","text":"<p>OFS DFL driver software provides the bottom-most API to FPGA platforms. Libraries such as OPAE and frameworks like DPDK are consumers of the APIs provided by OFS. Applications may be built on top of these frameworks and libraries. The OFS software does not cover any out-of-band management interfaces. OFS driver software is designed to be extendable, flexible, and provide for bare-metal and virtualized functionality. An in depth look at the various aspects of the driver architecture such as the API, an explanation of the DFL framework, and instructions on how to port DFL driver patches to other kernel distributions can be found on https://github.com/OPAE/linux-dfl/wiki.</p> <p>An in-depth review of the Linux device driver architecture can be found on opae.github.io.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#31-ofs-dfl-kernel-driver-environment-setup","title":"3.1 OFS DFL Kernel Driver Environment Setup","text":"<p>All OFS DFL kernel driver code resides in the Linux DFL GitHub repository. This repository is open source and should not require any permissions to access. It includes a snapshot of the Linux kernel with the OFS driver included in /drivers/fpga/*. Downloading, configuration, and compilation will be discussed in this section. The only operating systems supported out of the box by the Linux DFL kernel drivers is RHEL 8.6.</p> <p>This installation process assumes the user has access to an internet connection in order to clone specific GitHub repositories, and to satisfy package dependencies.</p> <p>1. Make the following changes on your installation machine to satisfy all dependencies:</p> <pre><code>subscription-manager release --set=8.6\nsudo dnf update\n</code></pre> <p>If you wish to install the pre-built linux-dfl package available on the OFS 2023.1 Release Page skip to section 3.3 Installing the OFS DFL Kernel Drivers from Pre-Built Packages.</p> <p>2. You must satisfy the following package dependencies if building and installing the drivers from source. Double check that all packages have been found and installed. The following section assumes you require use of a proxy to download from remote repositories. If you do not, then you may safely ignore all references to proxies in the following code block.</p> <pre><code># If you require the use of a proxy, add it to DNF using by editing the following file\nsudo nano /etc/dnf/dnf.conf\n# Include your proxy by adding the following line, replacing the URL with your proxy's URL\n# proxy=http://proxy.server.com:port\nsudo dnf update\nsubscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\nsudo dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n\nsudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libuuid-devel rpm-build systemd-devel nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\npython3-pyyaml hwloc-devel libedit-devel git kernel-headers kernel-devel elfutils-libelf-devel ncurses-devel openssl-devel bison flex cli11-devel spdlog-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install Pybind11==2.10.0 --proxy http://yourproxy:xxx\n\nsudo pip3 install setuptools==59.6.0 --prefix=/usr --proxy http://yourproxy:xxx\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm -y\n</code></pre> <p>It is recommended you create an empty top level directory for their OFS related repositories to keep the working environment clean. All steps in this installation will use a generic top-level directory at <code>/home/OFS/</code>. If you have created a different top-level directory, replace this path with your custom path.</p> <p>3. Initialize an empty git repository and clone the LTS tagged DFL driver source code:</p> <pre><code>mkdir /home/OFS/\ncd /home/OFS/\ngit init\ngit clone https://github.com/OFS/linux-dfl\ncd /home/OFS/linux-dfl\ngit checkout tags/ofs-2023.1-6.1-1\n</code></pre> <p>4. Verify that the correct tag/branch have been checkout out.</p> <pre><code>git describe --tags\nofs-2023.1-6.1-1\n</code></pre> <p>Note: If two different tagged releases are tied to the same commit, running git describe tags may report the other release's tag. This is why the match is made explicit.</p> <p>Note: The linux-dfl repository is roughly 5 GB in size.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#32-building-and-installing-the-ofs-dfl-kernel-drivers-from-source","title":"3.2 Building and Installing the OFS DFL Kernel Drivers from Source","text":"<p>1. The following set of instructions walk you through copying an existing kernel configuration file on your machine and changing the minimal required configuration settings.:</p> <pre><code>cd /home/OFS/linux-dfl\ncp /boot/config-`uname -r` .config\ncat configs/dfl-config &gt;&gt; .config\necho 'CONFIG_LOCALVERSION=\"-dfl\"' &gt;&gt; .config\necho 'CONFIG_LOCALVERSION_AUTO=y' &gt;&gt; .config\nsed -i -r 's/CONFIG_SYSTEM_TRUSTED_KEYS=.*/CONFIG_SYSTEM_TRUSTED_KEYS=\"\"/' .config\nsed -i '/^CONFIG_DEBUG_INFO_BTF/ s/./#&amp;/' .config\necho 'CONFIG_DEBUG_ATOMIC_SLEEP=y' &gt;&gt; .config\nexport LOCALVERSION=\nmake olddefconfig\n</code></pre> <p>1.1. The above command may report errors resembling <code>symbol value 'm' invalid for CHELSIO_IPSEC_INLINE</code>. These errors indicate that the nature of the config has changed between the currently executing kernel and the kernel being built. The option \"m\" for a particular kernel module is no longer a valid option, and the default behavior is to simply turn the option off. However the option can likely be turned back on by setting it to 'y'. If the user wants to turn the option back on, change it to 'y' and re-run \"make olddefconfig\":</p> <pre><code>cd /home/OFS/linux-dfl\necho 'CONFIG_CHELSIO_IPSEC_INLINE=y' &gt;&gt; .config\nmake olddefconfig\n</code></pre> <p>(Optional) To use the built-in GUI menu for editing kernel configuration parameters, you can opt to run <code>make menuconfig</code>.</p> <p>2. Linux kernel builds take advantage of multiple processors to parallelize the build process. Display how many processors are available with the <code>nproc</code> command, and then specify how many make threads to utilize with the -j option. Note that number of threads can exceed the number of processors. In this case, the number of threads are set to the number of processors in the system.</p> <pre><code>cd /home/OFS/linux-dfl\nmake -j $(nproc)\n</code></pre> <p>3. The user has two options for installation from source:</p> <ul> <li>Using the built-in install option from the kernel Makefile.</li> <li>Locally building a set of RPM/DEP packages.</li> </ul> <p>3.1 (Option 1) This first flow will directly install the kernel and kernel module files without the need to create a package first:</p> <pre><code>cd /home/OFS/linux-dfl\nsudo make modules_install -j $(nproc)\nsudo make install\n</code></pre> <p>3.2 (Option 2) This second flow will locally build a set of packages. The package options for this flow as as follows:</p> <ul> <li>rpm-pkg: Build both source and binary RPM kernel packages</li> <li>binrpm-pkg: Build only the binary kernel RPM package</li> <li>deb-pkg: Build both source and binary deb kernel packages</li> <li>bindeb-pkg: Build only the binary kernel deb package</li> </ul> <p>If you are concerned about the size of the resulting package and binaries, they can significantly reduce the size of the package and object files by using the make variable INSTALL_MOD_STRIP. If this is not a concern, feel free to skip this step. The below instructions will build a set of binary RPM packages:</p> <pre><code>cd /home/OFS/linux-dfl\nmake INSTALL_MOD_STRIP=1 binrpm-pkg\n</code></pre> <p>3.2.1 By default a directory is created in your <code>home</code> directory called <code>rpmbuild</code>. This directory will house all of the kernel packages which have been built. You need to navigate to the newly built kernel packages and install them. The following files were generated using the build command executed in the previous step:</p> <pre><code>cd ~/rpmbuild/RPMS/x86_64\nls\nkernel-6.1.22_dfl.x86_64.rpm  kernel-headers-6.1.22_dfl.x86_64.rpm\nsudo dnf localinstall kernel*.rpm\n</code></pre> <p>4. The system will need to be rebooted in order for changes to take affect. After a reboot, select the newly built kernel as the boot target. This can be done pre-boot using the command <code>grub2-reboot</code>, which removes the requirement for user intervention. After boot, verify that the currently running kernel matches expectation.</p> <pre><code>uname -r\n6.1.22-dfl\n</code></pre> <p>5. Verify the DFL drivers have been successfully installed by reading version information directly from <code>/lib/modules</code>. Recall that the name of the kernel built as apart of this section is <code>6.1.22-dfl</code>. If the user set a different name for their kernel, change this path as needed:</p> <pre><code>cd /usr/lib/modules/6.1.22-dfl/kernel/drivers/fpga\nls\ndfl-afu.ko     dfl-fme.ko      dfl-fme-region.ko  dfl.ko             dfl-pci.ko      fpga-mgr.ko     intel-m10-bmc-sec-update.ko\ndfl-fme-br.ko  dfl-fme-mgr.ko  dfl-hssi.ko        dfl-n3000-nios.ko  fpga-bridge.ko  fpga-region.ko\n</code></pre> <p>If an N6000/1-PL FPGA SmartNIC Platform is present on the server, you can also double check driver versions using the <code>lsmod</code> command:</p> <pre><code>lsmod | grep dfl\nuio_dfl                20480  0\ndfl_emif               16384  0\nuio                    20480  1 uio_dfl\nptp_dfl_tod            16384  0\ndfl_intel_s10_iopll    20480  0\n8250_dfl               20480  0\ndfl_fme_region         20480  0\ndfl_fme_br             16384  0\ndfl_fme_mgr            20480  2\ndfl_fme                49152  0\ndfl_afu                36864  0\ndfl_pci                20480  0\ndfl                    40960  11 dfl_pci,uio_dfl,dfl_fme,intel_m10_bmc_pmci,dfl_fme_br,8250_dfl,qsfp_mem,ptp_dfl_tod,dfl_afu,dfl_intel_s10_iopll,dfl_emif\nfpga_region            20480  3 dfl_fme_region,dfl_fme,dfl\nfpga_bridge            20480  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br\nfpga_mgr               20480  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme\n</code></pre> <p>Refer to the following table for a brief description of each driver:</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-11-dfl-driver-modules","title":"Table 11: DFL Driver Modules","text":"Module Name Short Description uio_dfl Generic DFL driver for Userspace I/O devices dfl_intel_s10_iopll DFL Intel S10 IOPLL driver uio UIO Driver dfl_fme_region FPGA Region for DFL FPGA Management Engine ptp_dfl_tod DFL ToD driver dfl_emif DFL EMIF driver dfl_fme_br FPGA Bridge for DFL FPGA Management Engine 8250_dfl DFL Intel UART driver dfl_fme_mgr FPGA Manager for DFL FPGA Management Engine dfl_fme FPGA Management Engine driver dfl_afu FPGA Accelerated Function Unit driver dfl_pci FPGA DFL PCIe Device Driver dfl FPGA Device Feature List (DFL) Support fpga_region FPGA Region Driver fpga_bridge FPGA Bridge Driver fpga_mgr FPGA manager framework <p>6. Two kernel parameters must be added to the boot commandline for the newly installed kernel. First, open the file <code>grub</code>:</p> <pre><code>sudo vim /etc/default/grub\n</code></pre> <p>7. In the variable GRUB_CMDLINE_LINUX add the following parameters in bold: GRUB_CMDLINE_LINUX=\"crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200\"</p> <p>Note: If you wish to instead set hugepages on a per session bassis, you can perform the following steps. These settings will be lost on reboot.</p> <pre><code>mkdir -p /mnt/huge mount -t hugetlbfs nodev /mnt/huge echo 2048 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages echo 2048 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages </code></pre> <p>8. Save your edits, then apply them to the GRUB2 configuration file.</p> <pre><code>sudo grub2-mkconfig\n</code></pre> <p>9. Warm reboot. Your kernel parameter changes should have taken affect.</p> <pre><code>cat /proc/cmdline\nBOOT_IMAGE=(hd1,gpt2)/vmlinuz-6.1.22-dfl root=/dev/mapper/cl-root ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200 rhgb quiet\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#33-installing-the-ofs-dfl-kernel-drivers-from-pre-built-packages","title":"3.3 Installing the OFS DFL Kernel Drivers from Pre-Built Packages","text":"<p>1. Make the following changes on your installation machine to satisfy all dependencies:</p> <pre><code>subscription-manager release --set=8.6\nsudo dnf update\n</code></pre> <p>2. To use the pre-built Linux DFL packages, the user will need to download the files from the OFS 2023.1 Release Page. You can choose to either install using the SRC RPMs, or to use the pre-built RPM packages targeting the official supported release platform.</p> <pre><code>tar xf kernel-6.1.22_dfl-1.x86_64-&lt;&lt;version&gt;&gt;.tar.gz\nsudo dnf localinstall kernel-6.1.22_dfl_&lt;&lt;version&gt;&gt;.x86_64.rpm \\\nkernel-devel-6.1.22_dfl_&lt;&lt;version&gt;&gt;.x86_64.rpm \\\nkernel-headers-6.1.22_dfl_&lt;&lt;version&gt;&gt;.x86_64.rpm\n### OR\nsudo dnf localinstall kernel-6.1.22_dfl_&lt;&lt;version&gt;&gt;.src.rpm\n</code></pre> <p>3. After installation has completed you should continue with steps 4-9 in previous section 3.2 Building and Installing the OFS DFL Kernel Drivers from Source.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#40-opae-software-development-kit","title":"4.0 OPAE Software Development Kit","text":"<p>The OPAE SDK software stack sits in user space on top of the OFS kernel drivers. It is a common software infrastructure layer that simplifies and streamlines integration of programmable accelerators such as FPGAs into software applications and environments. OPAE consists of a set of drivers, user-space libraries, and tools to discover, enumerate, share, query, access, manipulate, and reconfigure programmable accelerators. OPAE is designed to support a layered, common programming model across different platforms and devices. To learn more about OPAE, its documentation, code samples, an explanation of the available tools, and an overview of the software architecture, visit the opae reference page.</p> <p>The OPAE SDK source code is contained within a single GitHub repository hosted at the OPAE Github. This repository is open source and does not require any permissions to access.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#41-opae-sdk-build-environment-setup","title":"4.1 OPAE SDK Build Environment Setup","text":"<p>This installation process assumes the you have access to an internet connection in order to pull specific GitHub repositories, and to satisfy package dependencies.</p> <p>1. Before OPAE SDK installation you must remove any prior OPAE frameworks.  To remove these packages:</p> <pre><code>sudo dnf remove opae*\n</code></pre> <p>2. The following repository changes must be enabled in order to install all dependencies:</p> <pre><code>subscription-manager release --set=8.6\nsudo dnf update\n</code></pre> <p>3. The following package dependencies must be satisfied by the user. Double check that all packages have been found and installed. The following section assumes you require use of a proxy to download from remote repositories. If you do not, then you may safely ignore all references to proxies in the following code block.</p> <pre><code># If you require the use of a proxy, add it to DNF using by editing the following file\nsudo nano /etc/dnf/dnf.conf\n# Include your proxy by adding the following line, replacing the URL with your proxy's URL\n# proxy=http://proxy.server.com:port\nsudo dnf update\nsubscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\nsudo dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n\nsudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libuuid-devel rpm-build systemd-devel nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\npython3-pyyaml hwloc-devel libedit-devel git kernel-headers kernel-devel elfutils-libelf-devel ncurses-devel openssl-devel bison flex cli11-devel spdlog-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install Pybind11==2.10.0 --proxy http://yourproxy:xxx\n\nsudo pip3 install setuptools==59.6.0 --prefix=/usr --proxy http://yourproxy:xxx\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm -y\n</code></pre> <p>It is recommended you create an empty top level directory for their OFS related repositories to keep the working environment clean. All steps in this installation will use a generic top-level directory at <code>/home/OFS/</code>. If the you have created a different top-level directory, replace this path with your custom path.</p> <p>4. Initialize an empty git repository and clone the tagged OPAE SDK source code:</p> <pre><code>cd /home/OFS/\ngit init\ngit clone https://github.com/OFS/opae-sdk\ncd /home/OFS/opae-sdk\ngit checkout tags/2.5.0-3\n</code></pre> <p>5. Verify that the correct tag/branch have been checkout out.</p> <pre><code>git describe --tags\n2.5.0-3\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#42-building-and-installing-the-opae-sdk-by-script","title":"4.2 Building and Installing the OPAE SDK by Script","text":"<p>1. Build the OPAE SDK source code, and pack it into several local RPM packages. Building the code into packages allows for easier installation and removal. This build script can take advantage of multiple processors to parallelize the build process. Display how many processors are available with the <code>$(nproc)</code> command, and then specify how many make threads to utilize with the -j option. Note that number of threads can exceed the number of processors. In this case, the number of threads are set to the number of processors in the system.</p> <pre><code>cd /home/OFS/opae-sdk/packaging/opae/rpm\n./create fedora\n</code></pre> <p>2. After a successful compile there should be packages generated:</p> <p>The below table lists a short description for each package:</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-12-opae-package-description","title":"Table 12: OPAE Package Description","text":"Package Name Description opae OPAE SDK is a collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. It provides a library implementing the OPAE C API for presenting a streamlined and easy-to-use interface for software applications to discover, access, and manage FPGA devices and accelerators using the OPAE software stack. opae-debuginfo This package provides debug information for package opae. Debug information is useful when developing applications that use this package or when debugging this package. opae-debugsource This package provides debug sources for package opae. Debug sources are useful when developing applications that use this package or when debugging this package. opae-devel OPAE headers, tools, sample source, and documentation opae-devel-debuginfo This package provides debug information for package opae-devel. Debug information is useful when developing applications that use this package or when debugging this package. opae-tools This package contains OPAE base tools binaries opae-extra-tools Additional OPAE tools opae-extra-tools-debuginfo This package provides debug information for package opae-extra-tools. Debug information is useful when developing applications that use this package or when debugging this package. <p>3. Install the OPAE SDK packages:</p> <pre><code>cd /home/OFS/opae-sdk/packaging/opae/rpm\nrm -rf opae-2.5.0-3.el8.src.rpm sudo dnf localinstall -y opae*.rpm\n</code></pre> <p>4. Check that all packages have been installed:</p> <pre><code>[user@localhost opae-sdk]# rpm -qa | grep opae\nopae-packager-2.5.0-3.x86_64\nopae-devel-2.5.0-3.x86_64\nopae-PACSign-2.5.0-3.x86_64\nopae-tools-extra-2.5.0-3.x86_64\nopae-2.5.0-3.x86_64\nopae-tools-2.5.0-3.x86_64\nopae-libs-2.5.0-3.x86_64\nopae-opae.admin-2.5.0-3.x86_64\nopae-tests-2.5.0-3.x86_64\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#43-building-and-installing-the-opae-sdk-by-opae-source-code","title":"4.3 Building and Installing the OPAE SDK by OPAE source code","text":"<ol> <li>Build the OPAE SDK source code, and pack it into several local RPM packages. Building the code into packages allows for easier installation and removal. This build script can take advantage of multiple processors to parallelize the build process. Display how many processors are available with the nproc command, and then specify how many make threads to utilize with the -j option. Note that number of threads can exceed the number of processors. In this case, the number of threads are set to the number of processors in the system.</li> </ol> <pre><code>cd /home/OFS/opae-sdk\nmkdir build\ncd /home/OFS/opae-sdk/build\ncmake .. -DCPACK_GENERATOR=RPM -DOPAE_BUILD_FPGABIST=ON -DOPAE_BUILD_PYTHON_DIST=ON -DCMAKE_BUILD_PREFIX=/usr\nmake -j `nproc`\nmake -j `nproc` package_rpm\n</code></pre> <p>The build directory location was selected for ease of use. If the user wishes to build the OPAE SDK in a different location, they will need to replace the '..' in the above command with the direct or relative path to the opae-sdk repository.</p> <ol> <li>After a successful compile there should be 9 packages present:</li> </ol> <pre><code>cd /home/OFS/opae-sdk/build\nls | grep rpm\nopae-2.5.0-3.x86_64.rpm             opae-PACSign-2.5.0-3.x86_64.rpm\nopae-devel-2.5.0-3.x86_64.rpm       opae-tests-2.5.0-3.x86_64.rpm\nopae-libs-2.5.0-3.x86_64.rpm        opae-tools-2.5.0-3.x86_64.rpm\nopae-opae.admin-2.5.0-3.x86_64.rpm  opae-tools-extra-2.5.0-3.x86_64.rpm\nopae-packager-2.5.0-3.x86_64.rpm    opae-packager-2.5.0-3.x86_64.rpm\n</code></pre> <ol> <li>Install the OPAE SDK packages:</li> </ol> <pre><code>cd /home/OFS/opae-sdk/build\nsudo dnf localinstall -y opae*.rpm\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#44-opae-tools-overview","title":"4.4 OPAE Tools Overview","text":"<p>The following section offers a brief introduction including expected output values for the utilities included with OPAE. A full explanation of each command with a description of its syntax is available in the opae-sdk GitHUb repo.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#441-board-management-with-fpgainfo","title":"4.4.1 Board Management with fpgainfo","text":"<p>The fpgainfo utility displays FPGA information derived from sysfs files.</p> <p>Displays FPGA information derived from sysfs files. The command argument is one of the following: errors, power, temp, port, fme, bmc, phy or mac, security. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p> <p>Note: Your BItstream ID and PR Interface Id may not match the below examples.</p> <p>The following examples walk through sample outputs generated by <code>fpgainfo</code>.</p> <pre><code>sudo fpgainfo fme\n\nIntel Acceleration Development Platform N6001\nBoard Management Controller NIOS FW version: 3.11.0\nBoard Management Controller Build version: 3.11.0\n//****** FME ******//\nObject Id                        : 0xED00001\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 360571655976424377\nBitstream Version                : 5.0.1\nPr Interface Id                  : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\nBoot Page                        : user1\nFactory Image Info               : a2b5fd0e7afca4ee6d7048f926e75ac2\nUser1 Image Info                 : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\nUser2 Image Info                 : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\n</code></pre> <pre><code>sudo fpgainfo bmc\n\nIntel Acceleration Development Platform N6001\nBoard Management Controller NIOS FW version: 3.11.0\nBoard Management Controller Build version: 3.11.0\n//****** FME ******//\nObject Id                        : 0xED00001\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 360571655976424377\nBitstream Version                : 5.0.1\nPr Interface Id                  : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\n( 1) VCCRT_GXER_0V9 Voltage                             : 0.91 Volts\n( 2) FPGA VCCIO_1V2 Voltage                             : 1.21 Volts\n( 3) Inlet 12V Aux Rail Current                         : 0.87 Amps\n( 4) FPGA E-Tile Temperature [Remote]                   : 47.00 Celsius\n( 5) AVDD_ETH_0V9_CVL Voltage                           : 1.48 Volts\n( 6) FPGA E-TILE Temperature #3                         : 51.00 Celsius\n...\n(77) FPGA FABRIC Remote Digital Temperature#3           : 47.00 Celsius\n(78) MAX10 &amp; Board CLK PWR 3V3 Inlet Current            : 0.97 Amps\n(79) CVL Non Core Rails Inlet Current                   : 0.01 Amps\n(80) FPGA Core Voltage Phase 0 VR Temperature           : 49.50 Celsius\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#432-sensor-monitoring-with-fpgad","title":"4.3.2 Sensor Monitoring with fpgad","text":"<p>The fpgad is a service that can help you protect the server from crashing when the hardware reaches an upper non-recoverable or lower non-recoverable sensor threshold (also called as fatal threshold). The fpgad is capable of monitoring each of the 80 sensors reported by the Board Management Controller. This service is only available once the installation instructions in sections 3.2 Building and Installing the OFS DFL Kernel Drivers and 4.1 OPAE SDK Build Environment Setup have been completed . Note: Qualified OEM server systems should provide the required cooling for your workloads. Therefore, using fpgad may be optional.</p> <p>When the opae-tools-extra-2.5.0-3.x86_64  package is installed, fpgad is placed in the OPAE binaries directory (default: /usr/bin). The configuration file fpgad.cfg is located at /etc/opae. The log file fpgad.log which monitors fpgad actions is located at /var/lib/opae/. The fpgad periodically reads the sensor values and if the values exceed the warning threshold stated in the fpgad.conf or the hardware defined warning threshold, it masks the PCIe Advanced Error Reporting (AER) registers for the Intel N6000/1-PL FPGA SmartNIC Platform to avoid system reset. Use the following command to start the fpgad service:</p> <p>Use the following command to start the fpgad service:</p> <p><pre><code>sudo systemctl start fpgad\n</code></pre> The configuration file only includes the threshold setting for critical sensor 12V Aux Rail Voltage (sensor 29). This sensor does not have a hardware defined warning threshold and hence fpgad relies on the configuration file. The fpgad uses information contained within this file to mask the PCIe AER register when the sensor reaches the warning threshold.</p> <p>You may create another entry below the 12V Aux Voltage entry for any other sensors on the board. The updated configuration file includes a new entry for (18) Board Front Side Temperature with arbitrary values:</p> <pre><code>{\n\"configurations\": {\n\"fpgad-xfpga\": {\n\"configuration\": {\n},\n\"enabled\": true,\n\"plugin\": \"libfpgad-xfpga.so\",\n\"devices\": [\n[ \"0x8086\", \"0xbcc0\" ],\n[ \"0x8086\", \"0xbcc1\" ]\n]\n},\n\"fpgad-vc\": {\n\"configuration\": {\n\"cool-down\": 30,\n\"get-aer\": [\n\"setpci -s %s ECAP_AER+0x08.L\",\n\"setpci -s %s ECAP_AER+0x14.L\"\n],\n\"disable-aer\": [\n\"setpci -s %s ECAP_AER+0x08.L=0xffffffff\",\n\"setpci -s %s ECAP_AER+0x14.L=0xffffffff\"\n],\n\"set-aer\": [\n\"setpci -s %s ECAP_AER+0x08.L=0x%08x\",\n\"setpci -s %s ECAP_AER+0x14.L=0x%08x\"\n],\n\"config-sensors-enabled\": true,\n\"sensors\": [\n{\n\"name\": \"12V AUX Voltage\",\n\"low-warn\": 11.40,\n\"low-fatal\": 10.56\n},\n{\n\u201cname\u201d: \u201c3V3 VR Temperature\u201d,\n\u201clow-warn\u201d: 50.00,\n\u201clow-fatal\u201d: 100.00\n}\n]\n},\n\"enabled\": true,\n\"plugin\": \"libfpgad-vc.so\",\n\"devices\": [\n[ \"0x8086\", \"0x0b30\" ],\n[ \"0x8086\", \"0x0b31\" ],\n[ \"0x8086\", \"0xaf00\" ],\n[ \"0x8086\", \"0xbcce\" ]\n]\n}\n},\n\"plugins\": [\n\"fpgad-xfpga\",\n\"fpgad-vc\"\n]\n}\n</code></pre> <p>You can monitor the log file to see if upper or lower warning threshold levels are hit. For example:</p> <pre><code>tail -f /var/lib/opae/fpgad.log | grep \u201csensor.*warning\u201d\nfpgad-vc: sensor ' Columbiaville Die Temperature ' warning\n</code></pre> <p>You must take appropriate action to recover from this warning before the sensor value reaches upper or lower fatal limits. On reaching the warning threshold limit, the daemon masks the AER registers and the log file will indicate that the sensor is tripped. Sample output: Warning message when the 'CVL Core0 Voltage VR Temperature' exceeds the upper warning threshold limit</p> <pre><code>tail -f /var/lib/opae/fpgad.log fpgad-vc: sensor 'CVL Core Voltage VR Temperature' warning.\nfpgad-vc: saving previous ECAP_AER+0x08 value 0x057ff030 for 0000:b0:02.0\nfpgad-vc: saving previous ECAP_AER+0x14 value 0x0000f1c1 for 0000:b0:02.0\nfpgad-vc: sensor 'CVL Core Voltage VR Temperature' still tripped.\n</code></pre> <p>If the upper or lower fatal threshold limit is reached, then a power cycle of server is required to recover the Intel N6001-PL SmartNIC FPGA Platform. AER is unmasked by the fpgad after the sensor values are within the normal range which is above the lower warning or below the upper warning threshold.</p> <p>To stop fpgad:</p> <pre><code>sudo systemctl stop fpgad.service\n</code></pre> <p>To check status of fpgad:</p> <pre><code>sudo systemctl status fpgad.service\n</code></pre> <p>Optional: To enable fpgad to re-start on boot, execute</p> <pre><code>sudo systemctl enable fpgad.service\n</code></pre> <p>For a full list of systemctl commands, run the following command:</p> <pre><code>systemctl -h\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#433-updating-with-fpgasupdate","title":"4.3.3 Updating with fpgasupdate","text":"<p>The fpgasupdate tool updates the Intel Max10 Board Management Controller (BMC) image and firmware (FW), root entry hash, and FPGA Static Region (SR) and user image (PR). The fpgasupdate tool only accepts images that have been formatted using PACsign. If a root entry hash has been programmed onto the board, then you must also sign the image using the correct keys. Refer to the Security User Guide: Intel Open FPGA Stack for information on created signed images and on programming and managing the root entry hash.  </p> <p>The Intel\u00ae FPGA SmartNIC N6001-PL ships with a factory, user1, and user2 programmed image for both the FIM and BMC FW and RTL on all cards. The platform ships with a single FIM image that can be programmed into either user1 or user2, depending in the image selected.</p> <p>Use the following chart for information on the Bitstream ID and Pr Interface ID, two unique values reported by <code>fpgainfo</code> which can be used to identify the loaded FIM.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-13-fim-version-summary-for-ofs-20231-release","title":"Table 13: FIM Version Summary for OFS 2023.1 Release","text":"FIM Version Bitstream ID Pr Interface ID File Name Download Location ofs-2023.1 360571655976424377 4514ee67-ca01-5def-9fa5-a1ef30d0c76c ofs_top_page[\u00bd]_unsigned_user[\u00bd].bin ofs-2023.1 Release Page ofs-n6001-0.9.0-rc2 0x50102025AD3DD11 92ec8960-2f2f-5544-9804-075d2e8a71a1 ofs_top_page[\u00bd]_unsigned_user[\u00bd].bin ofs-2.3.0 Release Page OFS-2.3.0 0x50102022267A9ED f59830f7-e716-5369-a8b0-e7ea897cbf82 ofs_top_page[\u00bd]_unsigned_user[\u00bd].bin ofs-2.3.0 Release Page OFS-2.2.0 0x501020295B081F0 8c157a52-1cf2-5d37-9514-944af0a060da ofs_top_page[\u00bd]_unsigned_user[\u00bd].bin ofs-2.2.0-beta Release Page"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-14-bmc-version-summary-for-ofs-20231-release","title":"Table 14: BMC Version Summary for OFS 2023.1 Release","text":"BMC FW and RTL Version File Name Download Location 3.11.0 AC_BMC_RSU_user_retail_3.11.0_unsigned.rsu n/a <ol> <li>Example loading a new version of the BMC RTL and FW.</li> </ol> <pre><code>sudo fpgasupdate AC_BMC_RSU_user_retail_3.11.0_unsigned.rsu &lt;PCI ADDRESS&gt;\n[2022-04-14 16:32:47.93] [WARNING ] Update starting. Please do not interrupt.                                           [2022-04-14 16:32:47.93] [INFO    ] updating from file /home/user/AC_BMC_RSU_user_retail_3.11.0_unsigned.rsu with size 904064                                   [2022-04-14 16:32:47.94] [INFO    ] waiting for idle                                                                    [2022-04-14 16:32:47.94] [INFO    ] preparing image file                                                                [2022-04-14 16:33:26.98] [INFO    ] writing image file                                                                  (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] [904064/904064 bytes][Elapsed Time: 0:00:00.00]                                           [2022-04-14 16:33:26.98] [INFO    ] programming image file                                                              (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] [Elapsed Time: 0:00:26.02]                                                                 [2022-04-14 16:33:53.01] [INFO    ] update of 0000:b1:00.0 complete                                                     [2022-04-14 16:33:53.01] [INFO    ] Secure update OK                                                                    [2022-04-14 16:33:53.01] [INFO    ] Total time: 0:01:05.07\nsudo rsu bmcimg\n</code></pre> <ol> <li>Example for loading a Static Region (SR) update image. This process will take up to 20 minutes.</li> </ol> <pre><code>sudo fpgasupdate ofs_top_page1_unsigned_user1.bin &lt;PCI ADDRESS&gt;\n[2022-04-14 16:42:31.58] [WARNING ] Update starting. Please do not interrupt.                                           [2022-04-14 16:42:31.58] [INFO    ] updating from file ofs_top_page1_pacsign_user1.bin with size 19928064               [2022-04-14 16:42:31.60] [INFO    ] waiting for idle                                                                    [2022-04-14 16:42:31.60] [INFO    ] preparing image file                                                                [2022-04-14 16:42:38.61] [INFO    ] writing image file                                                                  (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] [19928064/19928064 bytes][Elapsed Time: 0:00:16.01]                                       [2022-04-14 16:42:54.63] [INFO    ] programming image file                                                              (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588][Elapsed Time: 0:06:16.40]                                                                 [2022-04-14 16:49:11.03] [INFO    ] update of 0000:b1:00.0 complete                                                     [2022-04-14 16:49:11.03] [INFO    ] Secure update OK                                                                    [2022-04-14 16:49:11.03] [INFO    ] Total time: 0:06:39.45\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#434-signing-images-with-pacsign","title":"4.3.4 Signing Images with PACSign","text":"<p>PACSign is an OPAE utility which allows users to insert authentication markers into bitstreams targeted for the Intel\u00ae FPGA SmartNIC N6001-PL. PACSign also allows users updating their Static Region (SR) to designate which partition of flash (user1, user2, factory) to overwrite given a specific FIM binary image. All binary images must be signed using PACSign before fpgasupdate can use them for an update. Assuming no Root Entry Hash (REH) has been programmed on the device, the following examples demonstrate how to prepend the required secury authentication data, and specifiy which region of flash to update. More information, including charts detailing the different certification types and their required options, are fully described in the PACsign README on GitHub.</p> <p>For more information on PACSign and on general security practices surrounding the Intel N6001-PL FPGA SmartNIC device, visit the Security User Guide: Intel Open FPGA Stack.</p> <p>PACSign can be run on images that have previously been signed. It will overwrite any existing authentication data.</p> <p>The following example creates an unsigned SR image from an existing signed SR binary update image, targeting the user1 partition in flash.</p> <pre><code>PACSign SR -t UPDATE -s 0 -H openssl_manager -i ofs_top_page1_pacsign_user1.bin -o new_image.bin\nNo root key specified.  Generate unsigned bitstream? Y = yes, N = no: y\nNo CSK specified.  Generate unsigned bitstream? Y = yes, N = no: y\nNo root entry hash bitstream specified.  Verification will not be done.  Continue? Y = yes, N = no: y\n2021-10-18 14:42:54,490 - PACSign.log - WARNING - Bitstream is already signed - removing signature blocks\n</code></pre> <p>---&gt;</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#435-loading-images-with-rsu","title":"4.3.5 Loading Images with rsu","text":"<p>The rsu performs a Remote System Update operation on a N6000/1-PL device, given its PCIe address. An rsu operation sends an instruction to the device to trigger a power cycle of the card and forces reconfiguration from flash for either the BMC or FPGA image.</p> <p>The Intel\u00ae FPGA SmartNIC N6001-PL contains two regions of flash you may store FIM images. These locations are referred to as user1 and user2. After an image has been programmed with fpgasupdate in either of these regions you may choose to perform an rsu to switch. This operation indicates to the BMC which region to configure the FPGA device from after power-on.</p> <p>If the factory image has been updated, Intel strongly recommends the user to immediately RSU to the factory image to ensure the image is functional.</p> <p>The user can determine which region of flash was used to configure their FPGA device using the command <code>fpgainfo fme</code> and referring to the row labelled Boot Page.</p> <pre><code>sudo fpgainfo fme | grep Boot\nBoot Page                        : user1\n</code></pre> <p>Swapping between user1 and user2 skips load times that are created when using <code>fpgasupdate</code> to flash a new FIM image.</p> <p><code>rsu</code> Overview</p> <p>Mode 1: RSU</p> <p>Perform RSU (remote system update) operation on a development platform given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.</p> <p>Mode 2: Default FPGA Image</p> <p>Set the default FPGA boot sequence. The --page option determines the primary FPGA boot image. The --fallback option allows a comma-separated list of values to specify fallback images.</p> <p>The following example will load an image stored in user2.</p> <pre><code>sudo rsu fpga --page=user2 0000:b1:00.0\n2022-04-15 09:25:22,951 - [[pci_address(0000:b1:00.0), pci_id(0x8086, 0xbcce)]] performing RSU operation\n2022-04-15 09:25:22,955 - [[pci_address(0000:b0:02.0), pci_id(0x8086, 0x347a)]] removing device from PCIe bus\n2022-04-15 09:25:22,998 - waiting 10 seconds for boot\n2022-04-15 09:25:33,009 - rescanning PCIe bus: /sys/devices/pci0000:b0/pci_bus/0000:b0\n2022-04-15 09:25:34,630 - RSU operation complete\n</code></pre> <p>Note: As a result of using the rsu command, the host rescans the PCI bus and may assign a different Bus/Device/Function (B/D/F) value than the originally assigned value.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#436-verify-fme-interrupts-with-hello_events","title":"4.3.6 Verify FME Interrupts with hello_events","text":"<p>The hello_events utility is used to verify FME interrupts. This tool injects FME errors and waits for error interrupts, then clears the errors.</p> <p>Sample output from <code>sudo hello_events</code>.</p> <pre><code>sudo hello_events\nWaiting for interrupts now...\ninjecting error\nFME Interrupt occurred\nSuccessfully tested Register/Unregister for FME events!\nclearing error\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#437-host-exercisor-modules","title":"4.3.7 Host Exercisor Modules","text":"<p>The reference FIM and unchanged FIM compilations contain Host Exerciser Modules (HEMs). These are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. There are three HEMs present in the Intel OFS Reference FIM - HE-LPBK, HE-MEM, and HE-HSSI. These exercisers are tied to three different VFs that must be enabled before they can be used. Execution of these exercisers requires you bind specific VF endpoint to vfio-pci. The host-side software looks for these endpoints to grab the correct FPGA resource.</p> <p>Refer to the Intel FPGA Interface Manager Technical Reference Manual: Intel Open FPGA Stack for Intel Agilex FPGA for a full description of these modules.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-15-module-pfvf-mappings","title":"Table 15: Module PF/VF Mappings","text":"Module PF/VF ST2MM PF0 HE-MEM PF0-VF0 HE-HSSI PF0-VF1 HE-MEM_TG PF0-VF2 HE-LB Stub PF1-VF0 HE-LB PF2 VirtIO LB Stub PF3 HPS Copy Engine PF4"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#4371-he-mem-he-lb","title":"4.3.7.1 HE-MEM / HE-LB","text":"<p>The host exerciser used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc. Host Exerciser Loopback (HE-LBK) AFU can move data between host memory and FPGA.</p> <p>HE-LBK supports: - Latency (AFU to Host memory read) - MMIO latency (Write+Read) - MMIO BW (64B MMIO writes) - BW (Read/Write, Read only, Wr only)</p> <p>Host Exerciser Loopback Memory (HE-MEM) AFU is used to exercise use of FPGA connected DDR, data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host.</p> <p>HE-LB is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth. HE-MEM is used to exercise use of FPGA connected DDR; data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller. Both exercisers rely on the user-space tool host_exerciser. When using the Intel N6001-PL FPGA SmartNIC Platform, optimal performance requires the exercisers be run at 400 MHz.</p> <p>Execution of these exercisers requires you to bind specific VF endpoint to vfio-pci. The following commands will bind the correct endpoint for a device with B/D/F 0000:b1:00.0 and run through a basic loopback test.</p> <p>Note: While running the <code>opae.io init</code> command listed below, if no output is present after completion then the command has failed. Double check that Intel VT-D and IOMMU have been enabled in the kernel as discussed in step 12 in section 3.1 Intel OFS DFL Kernel Driver Environment Setup.</p> <pre><code>sudo pci_device  0000:b1:00.0 vf 3\nsudo opae.io init -d 0000:b1:00.2 user:user\nUnbinding (0x8086,0xbcce) at 0000:b1:00.2 from dfl-pci                                                                  Binding (0x8086,0xbcce) at 0000:b1:00.2 to vfio-pci iommu group for (0x8086,0xbcce) at 0000:b1:00.2 is 188                                                                  Assigning /dev/vfio/188 to DCPsupport                                                                                  Changing permissions for /dev/vfio/188 to rw-rw----\nsudo host_exerciser --clock-mhz 400 lpbk\n    starting test run, count of 1\nAPI version: 1\nAFU clock from command line: 400 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\nHost Exerciser numWrites: 1025\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nNumber of clocks: 5224\nTotal number of Reads sent: 1024\nTotal number of Writes sent: 1022\nBandwidth: 5.018 GB/s\n    Test lpbk(1): PASS\n</code></pre> <p>The following example will run a loopback throughput test using one cacheline per request.</p> <pre><code>sudo pci_device  0000:b1:00.0 vf 3\nsudo opae.io init -d 0000:b1:00.2 user:user\nsudo host_exerciser --clock-mhz 400 --mode trput --cls cl_1 lpbk\n    starting test run, count of 1\nAPI version: 1\nAFU clock from command line: 400 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 512\nHost Exerciser numWrites: 513\nHost Exerciser numPendReads: 0\nHost Exerciser numPendWrites: 0\nNumber of clocks: 3517\nTotal number of Reads sent: 512\nTotal number of Writes sent: 512\nBandwidth: 7.454 GB/s\n    Test lpbk(1): PASS\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#4372-traffic-generator-afu-test-application","title":"4.3.7.2 Traffic Generator AFU Test Application","text":"<p>Beginning in OPAE version 2.0.11-1+ the TG AFU has an OPAE application to access &amp; exercise traffic, targeting a specific bank. The supported arguments for test configuration are:</p> <ul> <li>Number of test loops: --loops</li> <li>Number of read transfers per test loop: -r,--read</li> <li>Number of write transfers per test loop: -w,--write</li> <li>Burst size of each transfer: -b,--bls</li> <li>Address stride between each transfer: --stride</li> <li>Target memory TG: -m,--mem-channel</li> </ul> <p>Below are some example commands for how to execute the test application. To run the preconfigured write/read traffic test on channel 0:</p> <pre><code>mem_tg tg_test\n</code></pre> <p>Target channel 1 with a 1MB single-word write only test for 1000 iterations</p> <pre><code>mem_tg --loops 1000 -r 0 -w 2000 -m 1 tg_test\n</code></pre> <p>Target channel 2 with 4MB write/read test of max burst length for 10 iterations</p> <pre><code>mem_tg --loops 10 -r 8 -w 8 --bls 255 -m 2 tg_test\n</code></pre> <pre><code>sudo mem_tg --loops 1000 -r 2000 -w 2000 --stride 2 --bls 2  -m 1 tg_test\n[2022-07-15 00:13:16.349] [tg_test] [info] starting test run, count of 1\nMemory channel clock frequency unknown. Assuming 300 MHz.\nTG PASS\nMem Clock Cycles: 17565035\nWrite BW: 4.37232 GB/s\nRead BW: 4.37232 GB/s\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#4373-he-hssi","title":"4.3.7.3 HE-HSSI","text":"<p>HE-HSSI is responsible for handling client-side ethernet traffic. It wraps the 10G and 100G HSSI AFUs, and includes a traffic generator and checker. The user-space tool hssi exports a control interface to the HE-HSSI's AFU's packet generator logic.</p> <p>The hssi application provides a means of interacting with the 10G and with the 100G HSSI AFUs. In both 10G and 100G operating modes, the application initializes the AFU, completes the desired transfer as described by the mode- specific options, and displays the ethernet statistics by invoking ethtool --statistics INTERFACE.</p> <p>The following example walks through the process of binding the VF corresponding with the HE-HSSI exerciser to vfio-pci, sending traffic, and verifying that traffic was received.</p> <p>1. Create 3 VFs in the PR region.</p> <pre><code>sudo pci_device b1:00.0 vf 3 </code></pre> <p>1.1 Verify all 3 VFs were created.</p> <pre><code>lspci -s b1:00 b1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01) b1:00.1 Processing accelerators: Intel Corporation Device bcce b1:00.2 Processing accelerators: Intel Corporation Device bcce b1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device b1:00.4 Processing accelerators: Intel Corporation Device bcce b1:00.5 Processing accelerators: Intel Corporation Device bccf b1:00.6 Processing accelerators: Intel Corporation Device bccf b1:00.7 Processing accelerators: Intel Corporation Device bccf </code></pre> <p>2. Bind all of the PF/VF endpoints to the <code>vfio-pci</code> driver.</p> <pre><code>sudo opae.io init -d 0000:b1:00.1 user:user\nUnbinding (0x8086,0xbcce) at 0000:b1:00.1 from dfl-pci\nBinding (0x8086,0xbcce) at 0000:b1:00.1 to vfio-pci\niommu group for (0x8086,0xbcce) at 0000:b1:00.1 is 187\nAssigning /dev/vfio/187 to DCPsupport\nChanging permissions for /dev/vfio/187 to rw-rw----\n\nsudo opae.io init -d 0000:b1:00.2 user:user\nUnbinding (0x8086,0xbcce) at 0000:b1:00.2 from dfl-pci\nBinding (0x8086,0xbcce) at 0000:b1:00.2 to vfio-pci\niommu group for (0x8086,0xbcce) at 0000:b1:00.2 is 188\nAssigning /dev/vfio/188 to DCPsupport\nChanging permissions for /dev/vfio/188 to rw-rw----\n\n...\n\nsudo opae.io init -d 0000:b1:00.7 user:user\nBinding (0x8086,0xbccf) at 0000:b1:00.7 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:b1:00.7 is 319\nAssigning /dev/vfio/319 to DCPsupport\nChanging permissions for /dev/vfio/319 to rw-rw----\n</code></pre> <p>3. Check that the accelerators are present using <code>fpgainfo</code>. Note your port configuration may differ from the below.</p> <pre><code>sudo fpgainfo port //****** PORT ******//\nObject Id                        : 0xEC00000\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0xE0B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.7\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 4dadea34-2c78-48cb-a3dc-5b831f5cecbb\n//****** PORT ******//\nObject Id                        : 0xC0B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.6\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 823c334c-98bf-11ea-bb37-0242ac130002\n//****** PORT ******//\nObject Id                        : 0xA0B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.5\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 8568ab4e-6ba5-4616-bb65-2a578330a8eb\n//****** PORT ******//\nObject Id                        : 0x80B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.4\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 44bfc10d-b42a-44e5-bd42-57dc93ea7f91\n//****** PORT ******//\nObject Id                        : 0x40B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n//****** PORT ******//\nObject Id                        : 0x20B1000000000000\nPCIe s:b:d.f                     : 0000:B1:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x01\nAccelerator GUID                 : 3e7b60a0-df2d-4850-aa31-f54a3e403501\n</code></pre> <p>The following table contains a mapping between each VF, Accelerator GUID, and component.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-16-accelerator-pfvf-and-guid-mappings","title":"Table 16: Accelerator PF/VF and GUID Mappings","text":"Component VF Accelerator GUID Intel N6001-PL FPGA SmartNIC Platform base PF XXXX:XX:XX.0 N/A VirtIO Stub XXXX:XX:XX.1 3e7b60a0-df2d-4850-aa31-f54a3e403501 HE-MEM Stub XXXX:XX:XX.2 56e203e9-864f-49a7-b94b-12284c31e02b Copy Engine XXXX:XX:XX.4 44bfc10d-b42a-44e5-bd42-57dc93ea7f91 HE-MEM XXXX:XX:XX.5 8568ab4e-6ba5-4616-bb65-2a578330a8eb HE-HSSI XXXX:XX:XX.6 823c334c-98bf-11ea-bb37-0242ac130002 MEM-TG XXXX:XX:XX.7 4dadea34-2c78-48cb-a3dc-5b831f5cecbb <p>4. Check Ethernet PHY settings with <code>fpgainfo</code>.</p> <pre><code>sudo fpgainfo phy -B 0xb1 IIntel Acceleration Development Platform N6001\nBoard Management Controller NIOS FW version: 3.11.0\nBoard Management Controller Build version: 3.11.0\n//****** FME ******//\nObject Id                        : 0xED00001\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 360571655976424377\nBitstream Version                : 5.0.1\nPr Interface Id                  : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\n//****** HSSI information ******//\nHSSI version                     : 1.0\nNumber of ports                  : 8\nPort0                            :25GbE        DOWN\nPort1                            :25GbE        DOWN\nPort2                            :25GbE        DOWN\nPort3                            :25GbE        DOWN\nPort4                            :25GbE        DOWN\nPort5                            :25GbE        DOWN\nPort6                            :25GbE        DOWN\nPort7                            :25GbE        DOWN\n</code></pre> <p>5. Set loopback mode.</p> <pre><code>sudo hssiloopback --loopback enable  --pcie-address 0000:b1:00.0 args Namespace(loopback='enable', pcie_address='0000:b1:00.0', port=0)\nsbdf: 0000:b1:00.0\nFPGA dev: {'segment': 0, 'bus': 177, 'dev': 0, 'func': 0, 'path': '/sys/class/fpga_region/region0', 'pcie_address': '0000:b1:00.0'}\nargs.hssi_grps{0: ['dfl_dev.6', ['/sys/bus/pci/devices/0000:b1:00.0/fpga_region/region0/dfl-fme.0/dfl_dev.6/uio/uio0']]}\nfpga uio dev:dfl_dev.6\n\n--------HSSI INFO START-------\nDFH                     :0x3000000010002015\nHSSI ID                 :0x15\nDFHv                    :0.5\nguidl                   :0x99a078ad18418b9d\nguidh                   :0x4118a7cbd9db4a9b\nHSSI version            :1.0\nFirmware Version        :1\nHSSI num ports          :8\nPort0                   :25GbE\nPort1                   :25GbE\nPort2                   :25GbE\nPort3                   :25GbE\nPort4                   :25GbE\nPort5                   :25GbE\nPort6                   :25GbE\nPort7                   :25GbE\n--------HSSI INFO END-------\n\nhssi loopback enabled to port0\n</code></pre> <p>6. Send traffic through the 10G AFU.</p> <pre><code>sudo hssi --pci-address b1:00.6 hssi_10g --num-packets 100       10G loopback test\nport: 0\neth_loopback: on\n  he_loopback: none\n  num_packets: 100\npacket_length: 64\nsrc_address: 11:22:33:44:55:66\n    (bits): 0x665544332211\n  dest_address: 77:88:99:aa:bb:cc\n    (bits): 0xccbbaa998877\n  random_length: fixed\n  random_payload: incremental\n  rnd_seed0: 5eed0000\n  rnd_seed1: 5eed0001\n  rnd_seed2: 25eed\n  eth:\n\nNo eth interface, so not honoring --eth-loopback.\n0x40000           ETH_AFU_DFH: 0x1000010000001000\n0x40008          ETH_AFU_ID_L: 0xbb370242ac130002\n0x40010          ETH_AFU_ID_H: 0x823c334c98bf11ea\n0x40030      TRAFFIC_CTRL_CMD: 0x0000000000000000\n0x40038     TRAFFIC_CTRL_DATA: 0x0000000100000000\n0x40040 TRAFFIC_CTRL_PORT_SEL: 0x0000000000000000\n0x40048        AFU_SCRATCHPAD: 0x0000000045324511\n\n0x3c00         number_packets: 0x00000064\n0x3c01          random_length: 0x00000000\n0x3c02         random_payload: 0x00000000\n0x3c03                  start: 0x00000000\n0x3c04                   stop: 0x00000000\n0x3c05           source_addr0: 0x44332211\n0x3c06           source_addr1: 0x00006655\n0x3c07             dest_addr0: 0xaa998877\n0x3c08             dest_addr1: 0x0000ccbb\n0x3c09        packet_tx_count: 0x00000064\n0x3c0a              rnd_seed0: 0x5eed0000\n0x3c0b              rnd_seed1: 0x5eed0001\n0x3c0c              rnd_seed2: 0x00025eed\n0x3c0d             pkt_length: 0x00000040\n0x3cf4          tx_end_tstamp: 0x000003d2\n0x3d00                num_pkt: 0xffffffff\n0x3d01               pkt_good: 0x00000064\n0x3d02                pkt_bad: 0x00000000\n0x3d07            avst_rx_err: 0x00000000\n0x3d0b          rx_sta_tstamp: 0x00000103\n0x3d0c          rx_end_tstamp: 0x0000053b\n0x3e00               mac_loop: 0x00000000\n\nHSSI performance:\n        Selected clock frequency : 402.832 MHz\n        Latency minimum : 642.948 ns\n        Latency maximum : 896.155 ns\n        Achieved Tx throughput : 18.4528 GB/s\n        Achieved Rx throughput : 16.7101 GB/s\n\nNo eth interface, so not showing stats.\n</code></pre> <p>The <code>hssi_loopback</code> utility works in conjunction with a packet generator accelerator function unit (AFU) to test high-speed serial interface (HSSI) cards. The hssi_loopback utility tests both external and internal loopbacks.</p> <p>The <code>hssistats</code> tool provides the MAC statistics.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#50-upgrading-the-intel-fpga-smartnic-n6001-pl-with-20231-version-of-the-bmc-and-fim","title":"5.0 Upgrading the Intel\u00ae FPGA SmartNIC N6001-PL with 2023.1 Version of the BMC and FIM","text":"<p>If your Intel\u00ae FPGA SmartNIC N6001-PL does not have the 2022.3.1 version of the FIM and BMC, use this section to begin your upgrade process. The upgrade process depends on both the OPAE SDK and kernel drivers, which were installed in sections 3.0 Intel OFS DFL Kernel Drivers and 4.0 OPAE Software Development Kit. Use the output of fpgainfo and compare against the table below to determine if an upgade is necessary.</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-17-fim-version-summary-for-intel-ofs-20231-release","title":"Table 17: FIM Version Summary for Intel OFS 2023.1 Release","text":"FIM Version Bitstream ID Pr Interface ID File Name Download Location 1 360571655976424377 4514ee67-ca01-5def-9fa5-a1ef30d0c76c ofs_top_page[\u00bd]_unsigned_user[\u00bd].bin ofs-2023.1 Release Page"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#table-18-bmc-version-summary-for-intel-ofs-20231-release","title":"Table 18: BMC Version Summary for Intel OFS 2023.1 Release","text":"BMC FW and RTL Version File Name Download Location 3.11.0 AC_BMC_RSU_user_retail_3.11.0_unsigned.rsu n/a <p>Sample output of <code>fpgainfo</code> with matching values:</p> <pre><code>Intel Acceleration Development Platform N6001\nBoard Management Controller NIOS FW version: 3.11.0\nBoard Management Controller Build version: 3.11.0\n//****** FME ******//\nObject Id                        : 0xED00001\nPCIe s:b:d.f                     : 0000:B1:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x1771\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 360571655976424377\nBitstream Version                : 5.0.1\nPr Interface Id                  : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\nBoot Page                        : user1\nFactory Image Info               : a2b5fd0e7afca4ee6d7048f926e75ac2\nUser1 Image Info                 : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\nUser2 Image Info                 : 4514ee67-ca01-5def-9fa5-a1ef30d0c76c\n</code></pre> <ol> <li>If your output does not match the table above, download the appropriate FIM image from the Intel OFS 2023.1 (Intel Agilex) release page. Once downloaded transfer the file over to the server and use the fpgasupdate utility to perform an upgrade of the BMC.</li> </ol> <p><pre><code>sudo fpgasupdate AC_BMC_RSU_user_retail_3.11.0_unsigned.rsu\n[2022-04-14 16:32:47.93] [WARNING ] Update starting. Please do not interrupt.                                           [2022-04-14 16:32:47.93] [INFO    ] updating from file /home/user/AC_BMC_RSU_user_retail_3.11.0_unsigned.rsu with size 904064                                   [2022-04-14 16:32:47.94] [INFO    ] waiting for idle                                                                    [2022-04-14 16:32:47.94] [INFO    ] preparing image file                                                                [2022-04-14 16:33:26.98] [INFO    ] writing image file                                                                  (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] [904064/904064 bytes][Elapsed Time: 0:00:00.00]                                           [2022-04-14 16:33:26.98] [INFO    ] programming image file                                                              (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] [Elapsed Time: 0:00:26.02]                                                                 [2022-04-14 16:33:53.01] [INFO    ] update of 0000:b1:00.0 complete                                                     [2022-04-14 16:33:53.01] [INFO    ] Secure update OK                                                                    [2022-04-14 16:33:53.01] [INFO    ] Total time: 0:01:05.07\nsudo rsu bmcimg\n</code></pre> 2. Load the new FIM image.</p> <pre><code>sudo fpgasupdate ofs_top_page1_unsigned_user1.bin &lt;PCI ADDRESS&gt;\n[2022-04-14 16:42:31.58] [WARNING ] Update starting. Please do not interrupt.                                           [2022-04-14 16:42:31.58] [INFO    ] updating from file ofs_top_page1_pacsign_user1.bin with size 19928064               [2022-04-14 16:42:31.60] [INFO    ] waiting for idle                                                                    [2022-04-14 16:42:31.60] [INFO    ] preparing image file                                                                [2022-04-14 16:42:38.61] [INFO    ] writing image file                                                                  (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] [19928064/19928064 bytes][Elapsed Time: 0:00:16.01]                                       [2022-04-14 16:42:54.63] [INFO    ] programming image file                                                              (100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588][Elapsed Time: 0:06:16.40]                                                                 [2022-04-14 16:49:11.03] [INFO    ] update of 0000:b1:00.0 complete                                                     [2022-04-14 16:49:11.03] [INFO    ] Secure update OK                                                                    [2022-04-14 16:49:11.03] [INFO    ] Total time: 0:06:39.45\nsudo rsu fpga --page=user1 &lt;PCI ADDRESS&gt;\n</code></pre> <ol> <li>Verify the output of fpgainfo matches the table above.</li> </ol> <p>---&gt;</p>"},{"location":"hw/n6001/user_guides/ug_qs_ofs_n6001/ug_qs_ofs_n6001/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/","title":"Simulation User Guide: Open FPGA Stack for Intel Intel\u00ae Agilex\u00ae FPGA","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#1-overview","title":"1 Overview","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a set-up and user guide for the UVM simulation tool using OFS. After reviewing the document, you will be able to:</p> <ul> <li>Set-up the UVM verification tool suite</li> </ul> <ul> <li>Run pre-existing UVM unit tests and also create new UVM tests for your design</li> </ul> <p></p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#2-introduction-to-uvm","title":"2 Introduction to UVM","text":"<p>The Functional Verification Environment for OFS is UVM (Universal Verification Methodology) compliant and provides configurable setup for verifying various FIM features in simulation.</p> <p>The purpose of this document is to demonstrate a full chip level and unit level UVM based verification environment for the current base shell FIM architecture as well as providing examples to extend the setup for different OFS variants by reusing the existing architecture and infrastructure for UVM based verification.</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#3-universal-testbench-architecture","title":"3 Universal Testbench Architecture","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#31-overview","title":"3.1 Overview","text":"<p>The main idea behind UVM is to develop modular, reusable, and a scalable testbench structure by providing an API framework that can be deployed across multiple projects.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#32-core-verification-concepts","title":"3.2 Core Verification Concepts","text":"<p>The following is the list of verification components that will be used to design a UVM testbench architecture:</p> <p>\u2022   Sequencer \u2022   Driver \u2022   Monitor \u2022   Scoreboard \u2022   Virtual Sequencer \u2022   Interface \u2022   Verification Environment \u2022   TOP Testbench</p> <p>Figure 1 provides the general UVM Testbench and the verification components involved in the top-level architecture.</p> <p></p> <p>Figure 1 Typical UVM Testbench</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4-ofs-testbench-architecture","title":"4 OFS Testbench Architecture","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#41-overview","title":"4.1 Overview","text":"<p>OFS (Open FPGA Stack) provides a UVM (Universal Verification Methodology) environment for the FIM with a modular, reusable, and scalable testbench structure via an API framework.</p> <p>The framework consists of a FIM Testbench which is UVM compliant and integrates third party VIPs from Synopsys for PCI Express, Arm\u00ae AMBA\u00ae 4 AXI4Arm\u00ae AMBA\u00ae 4 AXI4-Streaming interface and Arm\u00ae AMBA\u00ae 4 AXI4-Memory Mapped interface for comprehensive verification. The user will need to acquire licenses for these VIPs to use this Testbench. UVM RAL(Register Abstraction Level) is used for CSR (Command and Status Registers) verification. </p> <p>The qualified verification IPs will help to detect incorrect protocol behavior, help to focus on FIM features and accelerate the verification process.</p> <p>Verification components include:</p> <pre><code>\u2022 FIM monitor to detect correct design behavior\n\u2022 FIM assertions for signal level integrity testing\n\u2022 Arm AMBA Arm\u00ae AMBA\u00ae 4 AXI4 scoreboards to check data integrity\n\u2022 FIM coverage to collect functional data\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#42-base-fim-dut","title":"4.2 Base FIM DUT","text":"<p>The hardware architecture of an Agilex FIM is based on the OFS hardware architecture. The following is the list of features and subsystems supported in the base shell.</p> <pre><code>\u2022   PCIe Subsystem\n\u2022   HSSI Subsystem\n\u2022   Memory Subsystem\n\u2022   HPS Subsystem\n\u2022   FME\n\u2022   AFU with PR support\n\u2022   QSFP Controllers\n\u2022   PMCI Controller, MCTP\n</code></pre> <p></p> <p>Figure 2 DUT Base Shell Diagram</p> <p>Figure 2 shows the high level architecture of an Agilex Base Shell. It has a Gen4x16, 100G Ethernet Datapath in a 2x4x25G configuration. The Agilex Base Shell is a shell that will enable a user to build other shell variants for a custom configuration. For the N6001 board there is one shell variant</p> <p>base_x16</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#43-full-chip-level-verification-archiecture-for-fim","title":"4.3 Full Chip Level Verification Archiecture for FIM","text":"<p>Figure 3 shows a graphical representation a full chip testbench that includes major RTL blocks depicted in a OFS Agilex based UVM environment </p> <p></p> <p>Figure 3 OFS FIM Testbench</p> <p>The major connection is the interface between the Xeon CPU and the FPGA where the PCIe Verification IP is connected to PCIe Subsystem. Therefore, as a full chip simulation environment, PCIe host VIP is the sole VIP/BFM used. PCIe host VIP connects to PCIe device which resides in FPGA in serial mode.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#431-testbench-components","title":"4.3.1 Testbench components","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4311-tb-top","title":"4.3.1.1 TB TOP","text":"<p>TOP is the top level testbench and consists of a FIM DUT instance and top-level UVM Verification Environment instance. It binds RTL inputs with the verification environmnet interfaces to drive stimulus. It also has clock generation and reset driving logic.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4312-fim-verification-environment","title":"4.3.1.2 FIM Verification Environment","text":"<p>This is the top most verification environment class and consists of the protocol specific PCI Express and AXI UVM environment VIP instances, Monitors, Scoreboards, Assertions, Functional coverage Modules and other verification components. It instantiates Virtual sequencers to control stimuli for FIM traffic from different sequencers of the VIPs.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4313-synopsys-vips","title":"4.3.1.3 Synopsys VIPs","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#43131-pci-vip-as-host","title":"4.3.1.3.1 PCI VIP as Host","text":"<p>This is Synopsys Licensed PCI Express Gen4 VIP and acts as Root Port. The PCI Express link is connected to the DUT using TX-RX lanes. Agent is an active component and includes a sequencer to generate TLPs, Driver to drive it on a PCI Express link and Monitor to check the protocol correctness.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#43132-axi-streaming-vip-monitors","title":"4.3.1.3.2 AXI-Streaming VIP Monitors","text":"<p>This is Synopsys Licensed AXI streaming interface Verification IP used as a Passive Agent to monitor AXI-ST links at various points. Please refer to Figure 3 to see all the AXI-ST monitors connected to different modules.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#43133-axi4-memory-mapped-vip-monitors","title":"4.3.1.3.3 AXI4-Memory Mapped VIP Monitors","text":"<p>This is Synopsys Licensed Arm\u00ae AMBA\u00ae 4 AXI4 memory mapped interface Verification IP used in passive mode to observe memory requests. For each master-slave pair, the verification environment has a VIP instantiated in passive mode for monitoring protocol violations and performing data integrity checks.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#43134-axi4-lite-vip-monitors","title":"4.3.1.3.4 AXI4-Lite VIP Monitors","text":"<p>This is Synopsys Licensed Arm\u00ae AMBA\u00ae 4 AXI4 Lite interface Verification IP used in passive mode to observe MMIO requests. For each master-slave pair, the verification environment has a VIP instantiated in passive mode for monitoring protocol violations and perfoming data integrity checks. Please refer to Figure 3 to see all the Arm\u00ae AMBA\u00ae 4 AXI4-Lite monitors connected to different modules.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#43135-axi4-lite-vip-as-pmci-master","title":"4.3.1.3.5 AXI4-Lite VIP as PMCI Master","text":"<p>This is Synopsys Licensed Arm\u00ae AMBA\u00ae 4 AXI4 Lite interface Verification IP used to drive and observe MMIO requests as PMCI master. For each master-slave pair, the verification environment has a VIP instantiated in active mode and includes a sequencer to generate MMIO requests, driver to drive these requests on AXI-4 Lite interface to BPF and a monitor for observing protocol violations and data integrity checks. </p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4314-axi4-s-scoreboard","title":"4.3.1.4 AXI4-S Scoreboard","text":"<p>The Arm\u00ae AMBA\u00ae 4 AXI4-S scoreboard checks data integrity of source and sink components. It has input transactions from VIP monitors and a TLP to AXI converter for PCIe TLP packets. It makes sure the valid TLPs or AXI transactions are not missed while traversing from Host to AFU and reverse. The scoreboard will be disabled for error testing especially for invalid TLP requests and UR responses.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4315-virtual-sequencer","title":"4.3.1.5 Virtual Sequencer","text":"<p>The virtual sequencer is the top-level sequencer which controls Enumeration, MMIO Requests, downstream and Upstream traffic as well as HSSI and Memory transactions. It makes sure that the transactions are ordered correctly as per the design specification while running a UVM test simulation.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4316-fim-monitor","title":"4.3.1.6 FIM Monitor","text":"<p>The FIM monitor is used for checking the correctness of a specific FIM feature. As an example, a user can add interrupt related checks, error generation and clearing checks, Protocol checker impacts etc. in this component. </p> <p>This would be an independent plug-n-play component and can be reused with any user developed UVM FIM TB.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4317-fim-assertions","title":"4.3.1.7 FIM Assertions","text":"<p>The assertion component is used for checking the signal level integrity of a specific FIM feature or behavior. As an example, we can add interrupt signal triggering and clear assertions, Error detection to error register bit assertions, protocol checker and clearing logic, FLR behavior assertion etc. in this top-level module. There are alos assertions to make sure the inputs are driven correctly to catch errors in a users simulation. </p> <p>This would be an independent plug-n-play component and can be reused with any user developed UVM FIM TB.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#4318-fim-functional-coverage","title":"4.3.1.8 FIM Functional Coverage","text":"<p>The FIM functional coverage component will have the functional coverage of each feature like interrupts, CSR's, MMIO requests, Byte align transactions, error reporting etc. to demonstrate a variety of FIM features. This will help us to find holes in the design as well as wide verification coverage to make sure thorough testing of a design. It will also provide a user what the FIM is capable of and how much code coverage they are testing.</p> <p>This would be an independent plug-n-play component and can be reused with any user developed UVM FIM TB.</p> <p></p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#5-uvm-verification-set-up","title":"5 UVM Verification set-up","text":"<p>To run the tutorial steps in this guide requires the following development environment:</p> Item Version Intel Quartus Prime Pro Intel Quartus Prime Pro 23.1 Simulator Synopsys VCS P-2019.06-SP2-5 or newer for UVM simulation of top level FIM Simulator (Questasim) Questasim 2021.4 or newer for UVM simulation of top level FIM"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#51-uvm-prerequisite","title":"5.1 UVM Prerequisite","text":"<p>Retrieve OFS repositories.</p> <p>The OFS FIM source code is included in the OTCShare GitHub repository. Create a new directory to use as a clean starting point to store the retrieved files.  The following is a short description of each repository, followed by the git commands for cloning.  The instructions section uses the HTTPS git method for cloning repositories.  Cloning the repo using the HTTPS method requires a personal access token.  Please see this blog post for information about obtaining a personal access token Token authentication requirements for Git operations.</p> <p>Navigate to location for storage of OFS source, create the top-level source directory and clone OFS repositories.</p> <pre><code>$ mkdir ofs-2023.1-1\n$ cd ofs-2023.1-1\n$ export OFS_BUILD_ROOT=$PWD\n$ git clone --branch --recurse-submodules https://github.com/ofs-n6001.git\n\nCloning into 'ofs-n6001'...'\nUsername for 'https://github.com': &lt;&lt;Enter your git hub username&gt;&gt;\nPassword for 'https://&lt;&lt;Your username&gt;&gt;': &lt;&lt;Enter your personal access token&gt;&gt;\nremote: Enumerating objects:  ....\n...\n...\nResolving deltas  ..., done.\n\n$ cd ofs-n6001\n$ git checkout tags/ofs-2023.1-1\n</code></pre> <p>Verify that the correct tag/branch have been checked out        </p> <pre><code>$ git describe --tags\n\n$ ofs-2023.1-1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#52-license-requirements","title":"5.2 License Requirements","text":"<p>The FIM Testbench is UVM compliant and integrates third party VIP's from Synopsys for PCI Express, Arm\u00ae AMBA\u00ae 4 AXI4Arm\u00ae AMBA\u00ae 4 AXI4-Streaming interface and Arm\u00ae AMBA\u00ae 4 AXI4-Memory Mapped interface for comprehensive verification. The user will need to acquire licenses for these VIPs to use this TB. UVM RAL (Register Abstraction Layer) is used for CSR Verification.</p> <p>The Qualified Verification IPs will help to detect incorrect protocol behavior easily, help to focus on FIM features and accelerate the verification process.</p> <pre><code>\u2022 VCS &amp; DVE\n\u2022 SNPS-Assertions\n\u2022 Verdi\n\u2022 VerdiCoverage\n\u2022 VerdiSimDB\n\u2022 VerdiTransactionDebugUltra\n\u2022 VIP-AMBA-AXI-SVT\n\u2022 VIP-AMBA-STREAM-SVT\n\u2022 VIP-PCIE-SVT\n\u2022 VIP-PCIE-TS-SVT\n\u2022 VIP-PCIE-G3-OPT-SVT\n\u2022 VIP-Ethernet-SVT\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#53-software-tools-requirements","title":"5.3 Software Tools Requirements","text":"<p>The following tools are required for successful UVM set-up</p> <ul> <li>Python 3.7.7</li> <li>Synopsys PCIE and AMBA AXI UVM VIP Q-2020.03A License</li> <li>Synopsys Verdi R-2020.12-SP2 License      Note: Makefile can be modified to use DVE instead of Verdi</li> </ul> <ul> <li>VCS R-2020.12-SP2 License </li> </ul>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#54-creating-a-software-tools-script","title":"5.4 Creating a Software Tools Script","text":"<p>The UVM tool set-up is best done by creating a simple set-up script so all applicable tools are sourced before running the tests.</p> <p>The following environment variables can be pasted into a script and used prior to running the UVM verification environment</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#license-files","title":"License Files","text":"<pre><code>export LM_LICENSE_FILE=\nexport SNPSLMD_LICENSE_FILE=\n</code></pre> <p>The license environment variables LM_LICENSE_FILE and SNPSLMD_LICENSE_FILE can point to a server license on your system.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#general-environment-variables","title":"General Environment Variables","text":"<pre><code>export IOFS_BUILD_ROOT=$PWD\nexport OFS_ROOTDIR=&lt;user_path&gt;/ofs-n6001\nexport WORKDIR=$OFS_ROOTDIR\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#quartus-tools","title":"Quartus Tools","text":"<pre><code>export QUARTUS_HOME=&lt;user_path&gt;/intelFPGA_pro/23.1/quartus\nexport QUARTUS_ROOTDIR=$QUARTUS_HOME\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport QSYS_ROOTDIR=$QUARTUS_ROOTDIR/../qsys/bin\nexport PATH=$QUARTUS_HOME/bin:$QUARTUS_HOME/qsys/bin:$QUARTUS_HOME/sopc_builder/bin/:$PATH\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#synopsys-verification-tools","title":"Synopsys Verification Tools","text":"<pre><code>export DESIGNWARE_HOME=&lt;user_path&gt;/synopsys/vip_common/vip_Q-2020.03A\nexport PATH=$DESIGNWARE_HOME/bin:$PATH\nexport UVM_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel/etc/uvm\nexport VCS_HOME=&lt;user_path&gt;/synopsys/vcsmx/S-2021.09-SP1/linux64/rhel\nexport PATH=$VCS_HOME/bin:$PATH\nexport VERDIR=$OFS_ROOTDIR/verification\nexport VIPDIR=$VERDIR\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#questasim-verification-tools","title":"QuestaSIM Verification Tools","text":"<pre><code>export MTI_HOME=&lt;user_path&gt;/mentor/questasim/2021.4/linux64\nexport PATH=$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$PATH\nexport QUESTA_HOME=$MTI_HOME\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#6-running-a-uvm-simulation-test-and-analysing-results","title":"6 Running a UVM Simulation Test and Analysing Results","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#61-simulation","title":"6.1 Simulation","text":"<p>The default simulator used in the simulation script is Synopsys VCS-MX. Users can refer to the options and adopt the options for other simulators. The script is a makefile that calls vlogan, vcs and simv for compilation, elaboration and simulation, respectively.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#62-file-structure","title":"6.2 File Structure","text":"<p>After cloning the repo, the verification and ofs-common directories contain all UVM verification related files. The directory structure is shown in Figure 4 below.</p> <p></p> <p>Figure 4 UVM Verification Directory File Structure</p> <p>ofs-n6001/verification/testbench has a testbench, uvm env, virtual sequencer, RAL etc. </p> <p>ofs-n6001/tests contains all uvm tests and sequences. </p> <p>Users can run the simulation under \"ofs-n6001/verification/scripts\" directory and the simulation result is outputted to a \"sim\" directory for Synopsys VCS or sim_msim for Questasim.</p> <p>The simulation result folder is named after the test name with increasing suffix number. If user runs the same test multiple times, the suffix is incremented by 1 each time.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#63-uvm-test-suite","title":"6.3 UVM Test Suite","text":"<p>The UVM environment contains a variety of tests that have been developed to test out the FIM portion of OFS.</p> <p>The table below has four columns which describe the \"Test Name\", \"DUT Scope\", \"Test Scenario\" and the \"Checking Criteria\".</p> <p>Tests are located at ofs-n6001/ofs-common/verification/fpga_family/agilex/tests</p> Test Name DUT Scope Test Scenario Checking Criteria afu_mmio_flr_pf0_test PF0 FLR Reset Apply FLR Reset for PF0 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF0 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf0_vf0_test PF0_VF0_FLR Reset Apply FLR Reset for PF0_VF0 and deassert Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR       access are working fine afu_mmio_flr_pf0_vf1_test PF0_VF1_FLR Reset Apply FLR Reset for PF0_VF1 and deassert Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf0_vf2_test PF0_VF2_FLR Reset Apply FLR Reset for PF0_VF2 and deassert Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf2_test PF2 FLR Reset Apply FLR Reset for PF2 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF2 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf3_test PF3 FLR Reset Apply FLR Reset for PF3 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF3 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_mmio_flr_pf4_test PF4 FLR Reset Apply FLR Reset for PF4 and deassert.                 Initiate MMIO transactions for all PFs. Make sure all completions are sent/received and no pending transactions are seen. Apply FLR Reset for PF4 and deassert. Initiate mmio access and ensure all PFs CSR access are working fine Initiate mmio access before and after FLR Reset and ensure all PF/VFs CSR access are working fine afu_stress_5bit_tag_test AFU-Stress To check the AFU Stress by sending traffic from all PF/VF. i.e Send traffic on HE-LPK/HE-MEM and initiating MMIO access to other PF/VFs Data checking afu_stress_8bit_tag_test AFU-Stress To check the AFU Stress by sending traffic from all PF/VF. i.e Send traffic on HE-LPK/HE-MEM and initiating MMIO access to other PF/VFs Data checking afu_stress_test AFU-Stress 1. Initiate transactions to all the supported PF/VF from PCIE VIP and ensure that traffic is sent to all blocks of the AFU.                 2. Ensure that CE/HE-LB/HE-MEM/HSSI/BPF/FME are seeing traffic.                 3. Ensure that HE-LB/HE-MEM/CE sends DMWR/DMRD requests to PCIE VIP.                 4. Ensure the Mux/DeMux blocks is able to handle the traffic based on the PF's/VF's and proper muxing/demuxing happens. Data checking bar_32b_test PCIe MMIO Path Set the BAR values to 32bit and test mmio access BAR address, Register Base Offset bar_64b_test PCIe MMIO Path Set the BAR values to 64bit and test mmio access BAR address, Register Base Offset dfh_walking_test DFH DFH walking offset checking, eol checking -&gt; tb emif_csr_test EMIF CSR access data checking fme_csr_test FME CSR CSR accesses data checking fme_err_intr_test Interrupt FME Interrupt request using FME ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read fme_intr_test Interrupt FME interrupt request using RAS ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read fme_multi_err_intr_test Interrupt FME interrupt request using RAS ERROR and FME ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read plus verifying interrupt requests generated from FME and RAS ERROR bits he_hssi_csr_test HE-HSSI CSR accesses data checking he_hssi_rx_lpbk_25G_10G_test HE-HSSI Sending back to back ethernet data traffic with 25G speed on HSSI RX Port0-7 lanes using Ethernet VIPs Enable the loopback mode in HE-HSSI and compare the pkts recived on HSSI TX Port(DATA CHECKING) he_hssi_tx_lpbk_P0_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port0  lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P1_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port1 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P2_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port2 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P3_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port3 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P4_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port4 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P5_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port5 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P6_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port6 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_hssi_tx_lpbk_P7_test HE-HSSI Send back to back traffic with 25G speed on HSSI TX Port7 lanes using Traffic generator registers Check the CRC errors on loopback packets on Traffic Monitor Registers he_lpbk_cont_test HE-LPBK Continuous mode/LPBK mode, random num_lines, addresses, req_len data checking he_lpbk_csr_test HE-LPBK CSR accesses data checking he_lpbk_flr_rst_test HE-LPBK Set HE_LPK in  all the modes randomly and iterate the transactions in loop. At the end of every loop assert the Soft reset in the middle of the transactions data checking, counter checking he_lpbk_long_rst_test HE-LPBK Multiple iterations of he_lpb_seq with soft reset HE-LB in middle data checking, counter checking he_lpbk_long_test HE-LPBK Multiple iterations of he_lpb_seq with STOP HE-LB in middle data checking, counter checking he_lpbk_multi_user_intr_test HE-LPBK generate user HE_LB interrupt interrupt checking he_lpbk_rd_cont_test HE-LPBK Read only mode/ Continuous mode. Randomize num_lines, addresses, req_len data checking he_lpbk_rd_test HE-LPBK Read only mode. Randomize num_lines, addresses, req_len counter checking he_lpbk_reqlen16_test HE-LPBK To check the behavior of HE_LPK block when req_length 16 and num_lines set to 1024 Cache lines in Loopback mode data checking, counter checking he_lpbk_reqlen1_test HE-LPBK Loopback mode. 128 CLs, req_len = 1CL, random addresses data checking, counter checking he_lpbk_reqlen2_test HE-LPBK Loopback mode. 128 CLs, req_len = 2CL, random addresses data checking, counter checking he_lpbk_reqlen4_test HE-LPBK Loopback mode. 128 CLs, req_len = 4CL, random addresses data checking, counter checking he_lpbk_reqlen8_test HE-LPBK Loopback mode. 128 CLs, req_len = 8CL, random addresses data checking, counter checking he_lpbk_rst_in_middle_test PCIe MMIO Path Set HE_LPK in  all the modes randomly and iterate the transactions in loop. At the end of every loop assert the Soft reset in the middle of the transactions Register Base Offset he_lpbk_test HE-LPBK Loopback mode.  Randomize num_lines, addresses, req_len data checking, counter checking he_lpbk_thruput_contmode_test HE-LPBK Continuous mode, Read/Write mode. 50/50. Randomize num_lines, addresses, req_len data checking he_lpbk_thruput_test HE-LPBK generate user HE_LB interrupt counter checking he_lpbk_user_intr_test HE-LPBK Read/Write mode. 50/50. Randomize num_lines, addresses, req_len counter checking he_lpbk_wr_cont_test HE-LPBK Write only mode/Continuous mode. Randomize num_lines, addresses, req_len data checking he_lpbk_wr_test HE-LPBK Write only mode. Randomize num_lines, addresses, req_len counter checking he_mem_cont_test HE-MEM Continuous mode/LPBK mode, random num_lines, addresses, req_len data checking, counter checking he_mem_csr_test HE-MEM CSR accesses data checking he_mem_lpbk_long_rst_test HE-MEM Multiple iterations of he_lpb_seq with soft reset HE-LB in middle data checking, counter checking he_mem_lpbk_long_test HE-MEM Multiple iterations of he_lpb_seq with STOP HE-LB in middle data checking, counter checking he_mem_lpbk_reqlen16_test HE-MEM To check the behavior of HE_MEM block when req_length 16 and num_lines set to 1024 Cache lines in Loopback mode data checking, counter checking he_mem_lpbk_reqlen1_test HE-MEM Loopback mode. 128 CLs, req_len = 1CL, random addresses data checking, counter checking he_mem_lpbk_reqlen2_test HE-MEM Loopback mode. 128 CLs, req_len = 2CL, random addresses data checking, counter checking he_mem_lpbk_reqlen4_test HE-MEM Loopback mode. 128 CLs, req_len = 4CL, random addresses data checking, counter checking he_mem_lpbk_reqlen8_test HE-MEM Loopback mode. 128 CLs, req_len = 8CL, random addresses data checking, counter checking he_mem_lpbk_test HE-MEM Loopback mode.  Randomize num_lines, addresses, req_len data checking, counter checking he_mem_multi_user_intr_test Interrupt Back to back multiple User interrupt request from HE MEM Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read for multiple back to back request he_mem_rd_cont_test HE-MEM Read only mode/Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_rd_test HE-MEM Read only mode. Randomize num_lines, addresses, req_len counter checking he_mem_thruput_contmode_directed_test HE-MEM Set HE_LPK in thruput mode and send traffic with req len 1 and num_lines set to 40 data checking, counter checking he_mem_thruput_contmode_test HE-MEM Continuous mode, Read/Write mode. 50/50. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_thruput_test HE-MEM Read/Write mode. 50/50. Randomize num_lines, addresses, req_len counter checking he_mem_user_intr_test Interrupt FME interrupt request using RAS ERROR and FME ERROR assertion Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read plus verifying interrupt requests generated from FME and RAS ERROR bits he_mem_wr_cont_test HE-MEM Write only mode/Continuous mode. Randomize num_lines, addresses, req_len data checking, counter checking he_mem_wr_test HE-MEM Write only mode. Randomize num_lines, addresses, req_len counter checkingt he_random_test All HEs Enable all HEs and randomize modes data checking if in lpbk mode, counter checking helb_rd_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Read only mode Measure the performance helb_rd_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Read only mode Measure the performance helb_rd_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Read only mode Measure the performance helb_thruput_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Thruput mode Measure the performance helb_thruput_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Thruput mode Measure the performance helb_thruput_4cl_5bit_tag_test Performance Set HE_LPK in thruput mode and send traffic with req len 4 and num_lines set to 1024. Measure the Read/Write performance Measure the performance helb_thruput_4cl_8bit_tag_test Performance Set HE_LPK in thruput mode and send traffic with req len 4 and num_lines set to 1024. Measure the Read/Write performance Measure the performance helb_thruput_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Thruput mode Measure the performance helb_wr_1cl_test Performance HE-LB; ReqLen = 1CL; 1024 CLs; Write only mode Measure the performance helb_wr_2cl_test Performance HE-LB; ReqLen = 2CL; 1024 CLs; Write only mode Measure the performance helb_wr_4cl_test Performance HE-LB; ReqLen = 4CL; 1024 CLs; Write only mode Measure the performance hssi_ss_test HSSI CSR accesses data checking malformedtlp_pcie_rst_test Protocol Checker generate malformed TLP protocol error and initiate pcie reset to clear the error Check for error malformedtlp_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. MaxTagError_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transactions are completing. mem_tg_csr_test MEM-TG CSR access data checking mem_tg_traffic_gen_test MEM-TG This test checks the MEM_TG traffic generator flow for 1 bank data checking mini_smoke_test All HEs shorter simpler version of random test for turn-in sanity check data checking if in lpbk mode, counter checking mix_intr_test Interrupt Mix interrupt testcase to send multiple FME and User interrupt request simultaneously Test checks for interrupt assertion, deassertion, mask feature, PBA bits and MSIX host memory data integrity through backdoor memory read plus verifying interrupt requests through different sources - FME and HE-MEM modules mmio_pcie_mrrs_128B_mps_128B_test PCIe - Max Payload/Max Read Req Size Random length mmio Write Checking valid possible combination of MPS &amp; MRRS mmio_pcie_mrrs_128B_mps_256B_test PCIe - Max Payload/Max Read Req Size Random length mmio Write Checking valid possible combination of MPS &amp; MRRS mmio_pcie_mrrs_256B_mps_128B_test PCIe - Max Payload/Max Read Req Size Random length mmio Write Checking valid possible combination of MPS &amp; MRRS mmio_pcie_mrrs_256B_mps_256B_test PCIe - Max Payload/Max Read Req Size Random length mmio Read Checking valid possible combination of MPS &amp; MRRS mmio_stress_nonblocking_test PF/VF Mux/Demux Stressing MMIO on PF/VF Mux/Demux with non-blocking MMIO reads data checking mmio_stress_test PF/VF Mux/Demux Stressing MMIO on PF/VF Mux/Demux data checking mmio_test PCIe MMIO Path MMIO targeting PF0(ST2MM, FME, PMCI, QSFP, HSSI SS), PF1, PF2,PF3, PF4, PF1.VF1, PF1.VF2 data checking mmio_unimp_test PCIe MMIO Path MMIO acccess to unimplemented addresses data checking MMIODataPayloadOverrun_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. MMIOInsufficientData_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. MMIOTimedout_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR  CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. pcie_csr_test PCIESS Earlier msix registers were in fme block but now it has moved from fme to pciess. Hence coded a seperate test for msix data checking pcie_pmci_mctp_multi_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM multiple packets received from PMCI controller over APF and BPF to PCIe HIA subsystem pcie_pmci_mctp_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM (Vendor Defined Message) single packet received from PCIe HIA subsystem to PMCI controller over APF and BPF via AXI4-lite memory write request pmci_csr_test PMCI CSR CSR accesses data checking pmci_fme_csr_test PMCI FME CSR CSR accesses data checking pmci_pcie_mctp_multi_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM multiple packets received from PMCI controller over APF and BPF to PCIe HIA subsystem pmci_pcie_mctp_vdm_test MCTP Vendor specific messaging capability MCTP PCIe VDM single packet received from PMCI controller over APF and BPF to PCIe HIA subsystem pmci_pciess_csr_test PMCI PCIESS CSR CSR accesses data checking pmci_qsfp_csr_test PMCI QSFP CSR CSR accesses data checking port_gasket_csr_test PORT GASKET CSR accesses data checking qsfp_csr_test QSFP CSR accesses data checking TxMWrDataPayloadOverrun_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. TxMWrInsufficientData_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. uart_intr_test UART Checking Generates UART interrupt Check interrupt UnexpMMIORspErr_test Protocol Checker Checks for different PCIe Protocol error generation (upstram/downstream) and check the clear mechanism of AFU for these detected protocol errors.                 1. Apply the error.                 2. Wait 5us 1us                 3. Set the port reset bit true and then false again (within 1us) (You will not be able to perform a read-modify-write because F's will be returned on reads. Write a 0x5 to set and a 0x4 to clear).                 4. Wait 124us 135us (or 7.5us 28us if MMIO_TIMEOUT_CYCLES is 512.)                 5. Read bit 31 of the AFU_INTF_ERROR, BlockingTraffic. If it is set it means that we did not wait long enough in step 4.                 6. Read the AFU_INTF_ERROR  register, Be sure only the expected error(s) are set.                 7. Read the AFU_INTF_FIRST_ERROR CSR. Be sure only one error bit is set and it is the expected one.                 8. Clear the errors in the AFU_INTF_ERROR CSR by writing one to the bits that are set.                 9. Read the AFU_INTF_FIRST_ERROR CSR. Be sure all bits are cleared 1.Check AFU_INTF_ERROR and AFU_INTF_FIRST_ERROR register is getting set with correct error vector.                 2.After clearing the error register ,check if normal transcation are completing. vdm_err_vid_test Vendor ID check generate a packet with undefined Vendor-ID from Host to PMCI_SS ID check <p></p> <p>The next section describes how to compile and build the UVM environment prior to running each UVM test and analyinsg the results in the log files </p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#64-ip-compile","title":"6.4 IP Compile","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#synopsys-vcs","title":"Synopsys VCS","text":"<p>To compile all IPs for the Synopsys VCS simulater:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk cmplib_adp\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#questasim-tbd","title":"Questasim (TBD)","text":"<p>To compile all IPs for the Questasim simulater:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk cmplib_adp\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#65-rtl-test-bench-compile","title":"6.5 RTL &amp; Test Bench Compile","text":"<p>The RTL file list for compilation is located here: verification/scripts/rtl_comb.f</p> <p>The TB file list for compilation is located here: verification/scripts/ver_list.f</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#synopsys-vcs_1","title":"Synopsys VCS","text":"<p>To compile RTL and Testbench for the Synopsys VCS simulater</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk build_adp DUMP=1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#questasim-tbd_1","title":"Questasim (TBD)","text":"<p>To compile RTL and Testbench for the Questasim simulater</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk build_adp DUMP=1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#66-ip-and-rtl-test-bench-compile","title":"6.6 IP and RTL &amp; Test Bench Compile","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#synopsys-vcs_2","title":"Synopsys VCS","text":"<p>If the user wants to compile all IPs and RTL Testbench in one command for Synopsys VCS then follow the procedure below</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk build_all DUMP=1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#questasim-tbd_2","title":"Questasim (TBD)","text":"<p>If the user wants to compile all IPs and RTL Testbench in one command for Questasim then follow the procedure below</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk build_all DUMP=1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#synopsys-vcs_3","title":"Synopsys VCS","text":"<p>To run a simulation for Synopsys VCS:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_VCS.mk run TESTNAME=ofs_mmio_test DUMP=1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#questasim-tbd_3","title":"Questasim (TBD)","text":"<p>To run a simulation for Questasim:</p> <pre><code>    cd $VERDIR/scripts\n\n    gmake -f Makefile_MSIM.mk run TESTNAME=ofs_mmio_test DUMP=1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#synopsys-vcs_4","title":"Synopsys VCS","text":"<p>To dump the waveform, \"DUMP=1\" must be added into the command line for Synopsys VCS build and simulation. </p> <pre><code>    gmake -f Makefile_VCS.mk build_adp DUMP=1\n\n    gmake -f Makefile_VCS.mk run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> <p>Or</p> <pre><code>    gmake -f Makefile_VCS.mk build_run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#questasim-tbd_4","title":"Questasim (TBD)","text":"<p>To dump the waveform, \"DUMP=1\" must be added into the command line for Questasim build and simulation. </p> <pre><code>    gmake -f Makefile_MSIM.mk build_adp DUMP=1\n\n    gmake -f Makefile_MSIM.mk run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> <p>Or</p> <pre><code>    gmake -f Makefile_MSIM.mk build_run TESTNAME=&lt;test_case_name&gt; DUMP=1\n</code></pre> <p>There are some optimizations in the Table below for convenience if you want to bypass some commands for both Synopsys VCS and Questasim:</p> Command (Synopsys VCS) Command (Questasim) Details gmake -f Makefile_VCS.mk build_all DUMP=1 gmake -f Makefile_MSIM.mk build_all DUMP=1 compile IP + compile RTL gmake -f Makefile_VCS.mk build_run TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk build_run TESTNAME= DUMP=1 compile RTL + run test gmake -f Makefile_VCS.mk do_it_all TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk do_it_all TESTNAME= DUMP=1 compile IP, RTL and run test gmake -f Makefile_VCS.mk rundb TESTNAME= DUMP=1 gmake -f Makefile_MSIM.mk rundb TESTNAME= DUMP=1 run test in sim dir + over-writes content"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#67-uvm-regression-test","title":"6.7 UVM Regression Test","text":"<pre><code>cd $VERDIR/scripts\n\npython uvm_regress.py -l -n 8 -p adp -k top_pkg -s vcs -c none\n\nFor Regression in VCS with top/test package, execute the following command \n    python uvm_regress.py -l -n 8 -p adp -k top_pkg -s vcs -c none\n\nResults are created in a sim directory ($VERDIR/sim) with individual testcase log dir\n\nFor Regression in MSIM with top/test package, execute the following command \n    python uvm_regress.py -l -n 8 -p adp -k top_pkg -s msim -c none\n</code></pre> <p>Results are created in a sim directory ($VERDIR/sim_msim) with individual testcase log dir</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#68-uvm-waveform-and-transcript-analysis","title":"6.8 UVM Waveform and Transcript Analysis","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#synopsys-vcs_5","title":"Synopsys VCS","text":"<p>Running Synopsys VCS UVM tests will generate a ofs-n6001/verification/sim directory</p> <pre><code>\u2022 All build time logs are located at ofs-n6001/verification/sim\n\n\u2022 Each testcase will have separate directory inside sim ofs-n6001/verification/sim/&lt;test_case_name&gt;\n</code></pre> <p>There are two tracker or log files that are available: runsim.log and trans.log. </p> <p>runsim.log is the simulation log file generated from Synopsys VCS. The test sequence prints useful information for debugging purpose, such as the base address for each function or block. For HE-LB and HE-MEM, key information such as SRC_ADDR, DST_ADDR, NUM_LINES, mode, req_len etc is printed out as shown in Figure 5</p> <p></p> <p>Figure 5 runsim.log</p> <p>trans.log is generated from PCIe host VIP. trans.log records all transaction information coming in or going out of the VIP. Users can find traffic direction(DIR), TLP type, Tag, Address or BDF, 3 or 4 dword header of the TLP as shown in Figure 6</p> <p></p> <p>Figure 6 trans.log</p> <p>The waveform generated is named as \"inter.vpd\". To open the waveform, go to simulation result directory and run </p> <pre><code>    dve -full64 -vpd inter.vpd &amp;\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#questasim-tbd_5","title":"Questasim (TBD)","text":"<p>Running Questasim UVM tests will generate a ofs-n6001/verification/sim_msim directory</p> <pre><code>\u2022 All build time logs are at ofs-n6001/verification/sim_msim\n\n\u2022 Each testcase will have separate directory inside sim ofs-n6001/verification/sim_msim/&lt;test_case_name&gt;\n</code></pre> <p>There are two tracker or log files that are available: runsim.log and trans.log. </p> <p>runsim.log is the simulation log file generated from Questasim. The test sequence prints useful information for debugging purpose, such as the base address for each function or block. For HE-LB and HE-MEM, key information such as SRC_ADDR, DST_ADDR, NUM_LINES, mode, req_len etc is printed out as shown in Figure 7</p> <p></p> <p>Figure 7 runsim.log</p> <p>trans.log is generated from PCIe host VIP. trans.log records all transaction information coming in or going out of the VIP. Users can find traffic direction(DIR), TLP type, Tag, Address or BDF, 3 or 4 dword header of the TLP as shown in Figure 8</p> <p></p> <p>Figure 8 trans.log</p> <p>The waveform generated is named as \"vsim.wlf\". To open the waveform, go to simulation result directory and run </p> <pre><code>    vsim -view vsim.wlf &amp;\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#69-uvm-coverage-analysis","title":"6.9 UVM Coverage Analysis","text":"<p>The following command allows to run a single testcase with coverage enabled</p> <pre><code>    gmake -f Makefile_VCS.mk cmplib_adp &amp;&amp; gmake -f Makefile_VCS.mk build_adp DUMP=1 DEBUG=1 COV_FUNCTIONAL=1&amp;&amp; gmake -f Makefile_VCS.mk run TESTNAME=&lt;TESTCASE-NAME&gt; DUMP=1 DEBUG=1 COV_FUNCTIONAL=1 &amp;\n</code></pre> <p>The following command shows how to merge and generate the coverage report</p> <pre><code>    urg -dir &lt;$VERDIR/sim/simv.vdb&gt; &lt;$VERDIR/sim/regression.vdb&gt; -format both -dbname &lt;regression_database_name&gt;\n</code></pre> <p>This will generate both urgreport directory and .vdb file Multiple regression.vdb from different regressions can be merged with the same command. <pre><code>    e.g \"urg -dir &lt;path1_till_simv.vdb&gt; &lt;path1_till_regression.vdb&gt; &lt;path2_till_regression.vdb&gt; -report &lt;dir&gt; -format both -dbname &lt;dirname&gt;\"\n</code></pre> <p>The following commands shows how to launch DVE and check the coverage reports</p> <pre><code>To open DVE of a single regression or testcase, execute:\n\n    dve -full64 -cov -covdir simv.vdb regression.vdb &amp;\n\nTo open DVE of a merged regression test, execute:\n\n    dve -full64 -cov -covdir &lt;dirname.vdb&gt; &amp;\n</code></pre> <p></p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#7-csr-verification-using-uvm-ral","title":"7 CSR Verification using UVM RAL","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#71-overview","title":"7.1 Overview","text":"<p>The UVM Register Layer provides a standard base class library that enable users to implement the object-oriented model to access the DUT registers and memories. The UVM Register Layer is also referred to as UVM Register Abstraction Layer (UVM RAL). Design registers can be accessed independently of the physical bus interface. i.e. by calling read/write methods. This is shown in Figure 9 below.</p> <p></p> <p>Figure 9 RAL UVM Testbench</p> <p>The RAL register models for different CSR's mimics the design registers. All RAL files are located here.</p> <pre><code>    ofs-n6001/verification/testbench/ral\n</code></pre> <p>The RAL model is generated through the Synopsys RALGEN tool and is used for CSR verification.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#72-ral-integration","title":"7.2 RAL Integration","text":"<p>For UVM RAL model integration to the environment, adapters for each CSR is implemented and integrated into the Testbench Environment. It is used to convert the PCIe bus sequence items into uvm_reg_bus_op and vice versa. The CSR test cases pick up all the registers from the respective CSR blocks and perform a default value, wr/rd check on them. </p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#73-ral-model-generation","title":"7.3 RAL Model Generation","text":"<p>Steps for RAL model generation</p> <p>Excel(xls) file containing the registers is required. Make sure there are separate xls files for each CSR and the worksheet name must contain the name \"reg_fields\".  </p> <p>Excel sheet snapshot example below for EMIF_CSR.xls located at /ipss/mem/rtl/adp</p> <p></p> <pre><code>\u2022 Navigate to ofs-n6001/ofs-common/verification/common/scripts/ral\n\u2022 Copy the excel file (xls) to the above area\n\u2022 In the bash terminal run mk_ral.sh &lt;Excel sheet name without extension &gt; &lt;output *.sv file name without ral_  prepended &gt;\n\u2022 The above steps generate two ral *.sv files. File with _cov suffix is a coverage enabled ral model. \n\u2022 Copy *.sv files to ofs-n6001/verification/testbench/ral\n</code></pre> <p></p> <pre><code>\u2022 As an example to generate ral_ac_ce.sv from AC_CE_CSR.xls file the command is\n\n    mk_ral.sh AC_CE_CSR ac_ce\n</code></pre> <p>This generates two ral models (ral_ac_ce.sv and ral_ac_ce_cov.sv)</p> <p>To add new registers</p> <pre><code>\u2022 To create new registers, copy existing ones and modify the cells in the xls. Make sure the last line is also a copied blank line\n\u2022 Follow all the steps of RAL model generation\n</code></pre> <p>To Generate a RAL model when a new xls sheet is created for a new component</p> <pre><code>\u2022 Copy the relevant xls sheet to ofs-n6001/ofs-common/verification/common/scripts/ral\n\u2022 Follow all the steps of RAL model generation\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#74-top-level-verification-architecture-for-csr-testing","title":"7.4 Top Level Verification Architecture for CSR testing","text":""},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#741-testbench-components","title":"7.4.1 Testbench components","text":"<p>The testbench components for RAL are defined below</p> <pre><code>\u2022 ral_reg_iofs_* (uvm_reg) generated by the steps as mentioned in section 5.3\n</code></pre> <p>The uvm register class is written by extending the uvm_reg. A register represents a set of fields that are accessible as a single entity Each register contains any number of fields, which mirror the values of the corresponding elements in hardware</p> <pre><code>\u2022 ral_block_iofs_* (uvm_block) generated in the same register file\n</code></pre> <p>A register model is an instance of a register block, which may contain any number of registers, register files, memories, and other blocks</p> <pre><code>\u2022 ral_block_ofs (uvm_block) \u2013 Contains all the CSR block instantiations\n\u2022 Reg2vip_*_adapter (uvm_reg_adapter) \u2013 This class defines an interface for converting between uvm_reg_bus_op and a specific bus transaction. For each CSR a respective adapter is present\n</code></pre> <p>All the components are defined in ofs-n6001/ofs-common/verification/testbench</p> <p>Integration of components in testbench</p> <pre><code>\u2022 The RAL blocks and adapters for each CSR is instantiated in tb_env\n\u2022 The bar range for each CSR is also set in the tb_env\n</code></pre> <p>Sample Environment Integration snippets </p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#8-modifying-uvm-testbench","title":"8 Modifying UVM Testbench","text":"<p>The next sections describe what needs to be considered when modifying the UVM, adding a new interface to the testbench and creating a new UVM test for a customised OFS Accelerator platform.</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#81-modifying-uvm-environment-for-new-shell-variant","title":"8.1 Modifying UVM environment for new Shell Variant","text":"<p>OFS n6001 comprises a shell based on PCIe Gen4x16 and is named base_x16</p> <p>This base_x16 shell is described by an RTL file list, IP File lists and setup scripts to complete the build flow</p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#82-modifying-uvm-environment-and-setting-up-compile-and-run-flow","title":"8.2 Modifying UVM environment and setting up Compile and Run flow","text":"<p>All the variants can mostly reuse the existing UVM infrastructure to setup the build and run flow</p> <pre><code>\u2022 Create directory under $OFS_BUILD_ROOT new variant e.g ofs-n9000\n\u2022 Change directory to $OFS_BUILD_ROOT/ofs-n9000/verification/scripts\n\u2022 modify Makefile it to point to the new RTL, IP and script files.\n</code></pre> <p>Following these three steps above will enable the build and sim flow to run the existing UVM TB and tests with new IOFS n9000 variant.</p> <p>Adding a new interface requires signal connections in the testbench. An additional BFM or verification IP is needed to drive the new interface. The main testbench file tb_top.sv is found at the following location</p> <pre><code>    ofs-n6001/verification/testbench\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#83-adding-a-new-ral-directory","title":"8.3 Adding a new RAL directory","text":"<p>In case the design has many register changes and the user decides to generate all the new RAL models instead of reusing from existing base RAL models, the following steps will help to create and integrate a new RALDIR in the UVM environment.</p> <pre><code>\u2022 Generate the new RAL files in desired directory. Preferably under the \"ofs-n6001/verification/common/testbench\" \n\u2022 By default, the Makefile points to base FIM RAL so set the RALDIR path in the Makefile to the new generated RAL file directory\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#84-modifying-tbtest-files-for-new-variant","title":"8.4 Modifying TB/Test files for new Variant","text":"<p>Create a define for the new variant. e.g 'define FIM_NEW. If you are modifying common files then add new logic under this define so other projects will not get affected with variant specific change.</p> <p>If there are more changes, please create separate \"testbench\" and \"test\" folders under this new variant. </p> <pre><code>\u2022 Extend variant specific env file from base env file to add variant specific changes.\n\u2022 Create new test/seq lib files in \"tests\" folder.\n\u2022 Create new variant package, add new TB/Tests/Sequence lib files and also import the base package files.\n</code></pre> <p>If you are adding new files then make sure it's included in Makefile for the build+run flow. </p>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#85-uvm-pcie-drivers","title":"8.5 UVM PCIe Drivers","text":"<p>The \"svt_pcie_driver_app_transaction_base_sequence\" is part of Synopsys PCIe VIP library. You can find the sequence definition in the following two directories</p> <pre><code>\u2022 Navigate to \"$DESIGNWARE_HOME/vip/svt/pcie_svt/Q-2020.03/sverilog/src/vcs/svt_pcie_driver_app_transaction_sequence_collection.svp\" file. All the base and PCIe sequences are defined in this file.\n\n\u2022 When the OFS UVM build command is executed, it creates \"vip\" directory under \"$OFS_BUILD_ROOT/ofs-n6001/verification\". You can also find the same sequence file at \"$IOFS_BUILD_ROOT/ofs-n6001/verification/vip/pcie_vip/src/sverilog/vcs/svt_pcie_driver_app_transaction_sequence_collection.sv\"\n</code></pre>"},{"location":"hw/n6001/user_guides/ug_sim_ofs_n6001/ug_sim_ofs_n6001/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"sw/build_chain/fpga_api/api_build/","title":"Building OPAE SDK Artifacts","text":""},{"location":"sw/build_chain/fpga_api/api_build/#steps","title":"Steps","text":"<ol> <li>Fetch the OPAE SDK source tree</li> <li>Configure the OPAE SDK CMake project</li> <li>Build OPAE SDK targets</li> </ol> <p>The example below lists commands that can be used to fetch and build OPAE SDK.</p> <pre><code># fetch the source\ngit clone https://github.com/OPAE/opae-sdk.git\ncd opae-sdk\n# configure CMake\ncmake ..\n# build\nmake\n</code></pre> <p>For a list of targets that can be built, type <code>make help</code> from the build directory.</p> <p>CMake options that may be set during the configuration include the following:</p> <pre><code>|----------------------------|-----------------------|-------------------------------------|---------------------------------------|----------------|\n| cmake flag                 | Optional or Mandatory | Purpose                             | Valid values                          | Default value  |\n|----------------------------|-----------------------|-------------------------------------|---------------------------------------|----------------|\n| -DCMAKE_BUILD_TYPE         | Optional              | Set compiler flags                  | Debug/Release/Coverage/RelWithDebInfo | RelWithDebInfo |\n| -DOPAE_BUILD_LEGACY        | Optional              | Enable/disable opae-legacy.git      | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_SPHINX_DOC    | Optional              | Enable/disable documentation build  | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_TESTS         | Optional              | Enable/disable building unit tests  | ON/OFF                                | OFF            |\n| -DOPAE_INSTALL_RPATH       | Optional              | Enable/disable rpath for install    | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_LIBOPAE_CXX   | Optional              | Enable/disable OPAE C++ bindings    | ON/OFF                                | ON             | \n| -DOPAE_WITH_PYBIND11       | Optional              | Enable/disable pybind11 binaries    | ON/OFF                                | ON             |\n| -DOPAE_BUILD_PYTHON_DIST   | Optional              | Enable/disable Python Distribution  | ON/OFF                                | OFF            |\n| -DOPAE_ENABLE_MOCK         | Optional              | Enable/disable mocks for unit tests | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_SIM           | Optional              | Enable/disable opae-sim.git         | ON/OFF                                | OFF            |\n</code></pre>"},{"location":"sw/build_chain/fpga_driver/driver_build/","title":"Building the OPAE Intel FPGA driver (out-of-tree)","text":"<p>The Intel FPGA driver included with OPAE SDK releases is packaged as an RPM or DEB package as well as a source tarball. Starting with OPAE SDK release of 1.4, the driver can be built from source out-of-tree but requires the following packages:</p> <p>For RPM package managers (Red Hat, CentOS, Fedora, etc.) * kernel-headers * kernel-devel * gcc * make</p> <p>For DEB package managers (Debian, Ubuntu, etc.) * kernel-headers-generic * gcc * make</p> <p>After installation of necessary distribution packages, follow the steps in the example below to build the Intel Kernel driver. NOTE The example below references Intel FPGA Kernel driver version 2.0.2. but can be applied to later versions.</p> <pre><code>tar zxf opae-intel-fpga-driver-2.0.2-1.tar.gz\ncd opae-intel-fpga-driver-2.0.2\nmake\n</code></pre>"},{"location":"sw/drv_arch/drv_arch/","title":"Open Programmable Accelerator Engine (OPAE) Linux Device Driver Architecture","text":"<p>The OPAE FPGA Linux Device Driver provides interfaces for user-space applications to configure, enumerate, open, and access FPGA accelerators on platforms equipped with Intel FPGA solutions. The OPAE FPGA driver also enables system-level management functions such as FPGA reconfiguration and virtualization.</p>"},{"location":"sw/drv_arch/drv_arch/#hardware-architecture","title":"Hardware Architecture","text":"<p>The Linux Operating System treats the FPGA hardware as a PCIe* device. A predefined data structure, Device Feature List (DFL), allows for dynamic feature discovery in an Intel FPGA solution.</p> <p></p> <p>The Linux Device Driver implements PCIe Single Root I/O Virtualization (SR-IOV) for the creation of Virtual Functions (VFs). The device driver can release individual accelerators for assignment to virtual machines (VMs).</p> <p></p>"},{"location":"sw/drv_arch/drv_arch/#fpga-management-engine-fme","title":"FPGA Management Engine (FME)","text":"<p>The FPGA Management Engine provides error reporting, reconfiguration, performance reporting, and other infrastructure functions. Each FPGA has one FME which is always accessed through the Physical Function (PF). The Intel Xeon\u00ae Processor with Integrated FPGA also performs power and thermal management. These functions are not available on the Intel Programmable Acceleration Card (PAC).</p> <p>User-space applications can acquire exclusive access to the FME using <code>open()</code>, and release it using <code>close()</code>. Device access may be managed by standard Linux interfaces and tools.</p> <p>If an application terminates without freeing the FME or Port resources, Linux closes all file descriptors owned by the terminating process, freeing those resources.</p>"},{"location":"sw/drv_arch/drv_arch/#port","title":"Port","text":"<p>A Port represents the interface between two components: * The FPGA Interface Manager (FIM) which is part of the static FPGA fabric * The Accelerator Function Unit (AFU) which is the partially reconfigurable region</p> <p>The Port controls the communication from software to the AFU and makes features such as reset and debug available.</p>"},{"location":"sw/drv_arch/drv_arch/#accelerator-function-unit-afu","title":"Accelerator Function Unit (AFU)","text":"<p>An AFU attaches to a Port. The AFU provides a 256 KB memory mapped I/O (MMIO) region for accelerator-specific control registers.</p> <ul> <li>Use <code>open()</code> on the Port device to acquire access to an AFU associated with the Port device.</li> <li>Use <code>close()</code>on the Port device to release the AFU associated with the Port device.</li> <li>Use <code>mmap()</code> on the Port device to map accelerator MMIO regions.</li> </ul>"},{"location":"sw/drv_arch/drv_arch/#partial-reconfiguration-pr","title":"Partial Reconfiguration (PR)","text":"<p>Use PR to reconfigure an AFU from a bitstream file. Successful reconfiguration has the following requirement:</p> <ul> <li>You must generate the reconfiguration AFU for the exact FIM. The AFU and FIM are compatible if their interface IDs match. You can verify this match by comparing the interface ID in the bitstream header against the interface ID that is exported by the driver in sysfs.</li> </ul> <p>In all other cases PR fails and may cause system instability.</p> <p>Platforms that support 512-bit Partial Reconfiguration require binutils &gt;= version 2.25.</p> <p>Close any software programs accessing the FPGA, including those running in a virtualized host before initiating PR. For virtualized environments, the recommended sequence is as follows:</p> <ol> <li>Unload the driver from the guest</li> <li>Release the VF from the guest</li> </ol> <p>Releasing the VF from the guest while an application on the guest is still accessing its resources may lead to VM instabilities. We recommend closing all applications accessing the VF in the guest before releasing the VF.</p> <ol> <li>Disable SR-IOV</li> <li>Perform PR</li> <li>Enable SR-IOV</li> <li>Assign the VF to the guest</li> <li>Load the driver in the guest</li> </ol>"},{"location":"sw/drv_arch/drv_arch/#fpga-virtualization","title":"FPGA Virtualization","text":"<p>To enable accelerator access from applications running on a VM, create a VF for the port using the following process:</p> <ol> <li> <p>Release the Port from the PF using the associated ioctl on the FME device.</p> </li> <li> <p>Use the following command to enable SR-IOV and VFs. Each VF can own a single Port with an AFU. In the following command, N is the number of Port released from the PF.</p> </li> </ol> <pre><code>    echo N &gt; $PCI_DEVICE_PATH/sriov_numvfs\n</code></pre> <p>The number, 'N', cannot be greater than the number of supported VFs. This can be read from $PCI_DEVICE_PATH/sriov_totalvfs.</p> <ol> <li> <p>Pass the VFs through to VMs using hypervisor interfaces.</p> </li> <li> <p>Access the AFU on a VF from applications running on the VM using the same driver inside the VM.</p> </li> </ol> <p>Creating VFs is only supported for port devices. Consequently, PR and other management functions are only available through the PF.    </p> <p></p> <p>If assigning multiple devices to the same VM on a guest IOMMU, you may need to increase the hard_limit option in order to avoid hitting a limit of pinned memory. The hard limit should be more than (VM memory size x Number of PCIe devices).</p>"},{"location":"sw/drv_arch/drv_arch/#driver-organization","title":"Driver Organization","text":""},{"location":"sw/drv_arch/drv_arch/#pcie-module-device-driver","title":"PCIe Module Device Driver","text":"<p>FPGA devices appear as a PCIe devices. Once enumeration detects a PCIe PF or VF, the Linux OS loads the FPGA PCIe device driver. The device driver performs the following functions:</p> <ol> <li>Walks through the Device Feature List in PCIe device base address register (BAR) memory to discover features and their sub-features and creates necessary platform devices.</li> <li>Enables SR-IOV.</li> <li>Introduces the feature device infrastructure, which abstracts operations for sub-features and provides common functions to feature device drivers.</li> </ol>"},{"location":"sw/drv_arch/drv_arch/#pcie-module-device-driver-functions","title":"PCIe Module Device Driver Functions","text":"<p>The PCIe Module Device Driver performs the following functions:</p> <ol> <li>PCIe discovery, device enumeration, and feature discovery.</li> <li>Creates sysfs directories for the device, FME, and Port.</li> <li>Creates the platform driver instances, causing the Linux kernel to load their respective drivers.</li> </ol>"},{"location":"sw/drv_arch/drv_arch/#fme-platform-module-device-driver","title":"FME Platform Module Device Driver","text":"<p>The FME Platform Module Device Driver loads automatically after the PCIe driver creates the FME Platform Module. It provides the following features for FPGA management:</p> <ol> <li> <p>Power and thermal management, error reporting, performance reporting, and other infrastructure functions. You can access these functions via sysfs interfaces the FME driver provides.</p> </li> <li> <p>Partial Reconfiguration. During PR sub-feature initialization, the FME driver registers the FPGA Manager framework to support PR. When the FME receives the relevant ioctl request from user-space, it invokes the common interface function from the FPGA Manager to reconfigure the AFU using PR.</p> </li> <li> <p>Port management for virtualization (releasing/assigning port device).</p> </li> </ol> <p>After a port device is released, you can use the PCIe driver SR-IOV interfaces to create/destroy VFs.</p> <p>For more information, refer to \"FPGA Virtualization\".</p>"},{"location":"sw/drv_arch/drv_arch/#fme-platform-module-device-driver-functions","title":"FME Platform Module Device Driver Functions","text":"<p>The FME Platform Module Device Driver performs the the following functions:</p> <ul> <li>Creates the FME character device node.</li> <li>Creates the FME sysfs files and implements the FME sysfs file accessors.</li> <li>Implements the FME private feature sub-drivers.</li> <li>FME private feature sub-drivers:     * FME Header     * Partial Reconfiguration     * Global Error     * Global Performance</li> </ul>"},{"location":"sw/drv_arch/drv_arch/#port-platform-module-device-driver","title":"Port Platform Module Device Driver","text":"<p>After the PCIe Module Device Driver creates the Port Platform Module device, the FPGA Port and AFU driver are loaded.  This module provides an interface for user-space applications to access the individual accelerators, including basic reset control on the Port, AFU MMIO region export, DMA buffer mapping service, and remote debug functions.</p>"},{"location":"sw/drv_arch/drv_arch/#port-platform-module-device-driver-functions","title":"Port Platform Module Device Driver Functions","text":"<p>The Port Platform Module Device Driver performs the the following functions:</p> <ul> <li>Creates the Port character device node.</li> <li>Creates the Port sysfs files and implements the Port sysfs file accessors.</li> <li>Implements the following Port private feature sub-drivers.     * Port Header     * AFU     * Port Error     * Signal Tap</li> </ul>"},{"location":"sw/drv_arch/drv_arch/#opae-fpga-driver-interface","title":"OPAE FPGA Driver Interface","text":"<p>The user-space interface consists of a sysfs hierarchy and ioctl requests. Most kernel attributes can be accessed/modified via sysfs nodes in this hierarchy. More complex I/O operations are controlled via ioctl requests. The OPAE API implementation, libopae-c, has been designed to use this interface to interact with the OPAE FPGA kernel drivers.</p>"},{"location":"sw/fpga_api/fpga_api/","title":"OPAE C API Reference","text":"<p>The reference documentation for the OPAE C API is grouped into the following sections:</p> <ul> <li>Types<ul> <li>types.h</li> <li>types_enum.h</li> </ul> </li> <li>Enumeration API<ul> <li>enum.h</li> <li>properties.h</li> </ul> </li> <li>Access API<ul> <li>access.h</li> </ul> </li> <li>Event API<ul> <li>event.h</li> </ul> </li> <li>MMIO and Shared Memory APIs<ul> <li>mmio.h</li> <li>buffer.h</li> <li>umsg.h</li> </ul> </li> <li>Management API<ul> <li>manage.h</li> </ul> </li> <li>Metrics API<ul> <li>metrics.h</li> </ul> </li> <li>SysObject<ul> <li>sysobject.h</li> </ul> </li> <li>Utilities<ul> <li>utils.h</li> </ul> </li> <li>Samples<ul> <li>hello_fpga.c</li> <li>hello_events.c</li> </ul> </li> </ul>"},{"location":"sw/fpga_api/fpga_api/#types","title":"Types","text":"<p>The OPAE C API defines a number of types; most prominent are the types fpga_token, fpga_handle, and fpga_properties. All regular types are defined in types.h, while the values of enumeration types are defined in types_enum.h.</p>"},{"location":"sw/fpga_api/fpga_api/#typesh","title":"types.h","text":"<p>types.h</p>"},{"location":"sw/fpga_api/fpga_api/#types_enumh","title":"types_enum.h","text":"<p>types_enum.h</p>"},{"location":"sw/fpga_api/fpga_api/#enumeration-api","title":"Enumeration API","text":"<p>The OPAE enumeration API allows selective discovery of FPGA resources. When enumerating resources, a list of filter criteria can be passed to the respective function to select a subset of all resources in the system. The fpgaEnumerate() function itself then returns a list of fpga_tokens denoting resources, which can be used in subsequent API calls.</p> <p>Filter criteria are specified using one or more fpga_properties object. These objects need to be created using fpgaGetProperties() (defined in ) before being passed to fpgaEnumerate(). Individual attributes of an fpga_properties object are set using specific accessors, which are also defined in ."},{"location":"sw/fpga_api/fpga_api/#enumh","title":"enum.h","text":"<p>enum.h</p>"},{"location":"sw/fpga_api/fpga_api/#propertiesh","title":"properties.h","text":"<p>properties.h</p>"},{"location":"sw/fpga_api/fpga_api/#access-api","title":"Access API","text":"<p>The access API provides functions for opening and closing FPGA resources. Opening a resource yields an fpga_handle, which denotes ownership and can be used in subsequent API calls to interact with a specific resource. Ownership can be exclusive or shared.</p>"},{"location":"sw/fpga_api/fpga_api/#accessh","title":"access.h","text":"<p>access.h</p>"},{"location":"sw/fpga_api/fpga_api/#event-api","title":"Event API","text":"<p>The event API provides functions and types for handling asynchronous events such as errors or accelerator interrupts.</p> <p>To natively support asynchronous event, the driver for the FPGA platform needs to support events natively (in which case the OPAE C library will register the event directly with the driver). For some platforms that do not support interrupt-driven event delivery, you need to run the FPGA Daemon (fpgad) to enable asynchronous OPAE events. fpgad will act as a proxy for the application and deliver asynchronous notifications for registered events.</p>"},{"location":"sw/fpga_api/fpga_api/#eventh","title":"event.h","text":"<p>event.h</p>"},{"location":"sw/fpga_api/fpga_api/#mmio-and-shared-memory-apis","title":"MMIO and Shared Memory APIs","text":"<p>These APIs feature functions for mapping and accessing control registers through memory-mapped IO (mmio.h), allocating and sharing system memory buffers with an accelerator (buffer.h), and using low-latency notifications (umsg.h).</p>"},{"location":"sw/fpga_api/fpga_api/#mmioh","title":"mmio.h","text":"<p>mmio.h</p>"},{"location":"sw/fpga_api/fpga_api/#bufferh","title":"buffer.h","text":"<p>buffer.h</p>"},{"location":"sw/fpga_api/fpga_api/#umsgh","title":"umsg.h","text":"<p>umsg.h</p>"},{"location":"sw/fpga_api/fpga_api/#management-api","title":"Management API","text":"<p>The management APIs define functions for reconfiguring an FPGA (writing new partial bitstreams) as well as assigning accelerators to host interfaces.</p>"},{"location":"sw/fpga_api/fpga_api/#manageh","title":"manage.h","text":"<p>manage.h</p>"},{"location":"sw/fpga_api/fpga_api/#metrics-api","title":"Metrics API","text":"<p>The metrics APIs define functions for discovery/enumeration of metrics information and reading metrics values.</p>"},{"location":"sw/fpga_api/fpga_api/#metricsh","title":"metrics.h","text":"<p>metrics.h</p>"},{"location":"sw/fpga_api/fpga_api/#sysobject","title":"SysObject","text":"<p>The SysObject API can be used to get system objects by name. Names used with the SysObject API are driver-specific and may not be compatible across plugins and/or drivers. For example, SysObject names used with the xfpga plugin will apply to the OPAE Linux Kernel driver and refer to sysfs nodes under the sysfs tree for the resource used with the SysObject API.</p>"},{"location":"sw/fpga_api/fpga_api/#sysobjecth","title":"sysobject.h","text":"<p>sysobject.h</p>"},{"location":"sw/fpga_api/fpga_api/#utilities","title":"Utilities","text":"<p>Functions for mapping fpga_result values to meaningful error strings are provided by the utilities API.</p>"},{"location":"sw/fpga_api/fpga_api/#utilsh","title":"utils.h","text":"<p>utils.h</p>"},{"location":"sw/fpga_api/fpga_api/#samples","title":"Samples","text":"<p>Code samples demonstrate how to use OPAE C API.</p>"},{"location":"sw/fpga_api/fpga_api/#hello_fpgac","title":"hello_fpga.c","text":"<p>hello_fpga.c</p>"},{"location":"sw/fpga_api/fpga_api/#hello_eventsc","title":"hello_events.c","text":"<p>hello_events.c</p>"},{"location":"sw/fpga_api/fpga_cxx_api/","title":"OPAE C++ Core API Reference","text":"<p>The reference documentation for the OPAE C++ Core API is grouped into the following sections:</p> <ul> <li>Overview</li> <li>Goals<ul> <li>Simplicity</li> <li>Extensibility and Interoperability</li> <li>Modern C++ Coding Practices</li> <li>Error Handling</li> <li>Coding Style</li> </ul> </li> <li>Fundamental Types<ul> <li>Properties</li> <li>pvalue.h</li> <li>properties.h</li> <li>Resource Classes</li> <li>token.h</li> <li>handle.h</li> <li>shared_buffer.h</li> <li>errors.h</li> <li>events.h</li> <li>sysobject.h</li> <li>Exceptions</li> <li>except.h</li> <li>Misc</li> <li>version.h</li> </ul> </li> </ul>"},{"location":"sw/fpga_api/fpga_cxx_api/#overview","title":"Overview","text":"<p>The OPAE C++ API enables C++ developers with the means to use FPGA resources by integrating the OPAE software stack into C++ applications.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#goals","title":"Goals","text":""},{"location":"sw/fpga_api/fpga_cxx_api/#simplicity","title":"Simplicity","text":"<p>Keep the API as small and lightweight as possible. Although features such as system validation and orchestration are beyond the scope of this API, using this API for their development should be relatively easy.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#extensibility-and-interoperability","title":"Extensibility and Interoperability","text":"<p>While keeping to the goal of simplicity, the OPAE C++ API is designed to allow for better reuse by either extending the API or by integrating with other languages.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#modern-c-coding-practices","title":"Modern C++ Coding Practices","text":"<p>The OPAE C++ API uses the C++ 11 standard library and makes use of its features whenever practical. The OPAE C++ API is also designed to require the minimum number of third-party libraries/dependencies.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#error-handling","title":"Error Handling","text":"<p>The OPAE C++ API is designed to throw exceptions when appropriate. The structure of OPAE C++ exceptions is similar to the error codes in the OPAE C API. This gives users of the API more freedom on error handling while providing better debug information in cases of failure.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#coding-style","title":"Coding Style","text":"<p>For formatting of the OPAE C++ API complies with most of the recommendations of the Google C++ style. For example, the OPAE C++ API uses:</p> <ul> <li>opening braces on the same line as their scope definition</li> <li>spaces instead of tabs for indentation</li> <li>indentation of two spaces</li> </ul>"},{"location":"sw/fpga_api/fpga_cxx_api/#fundamental-types","title":"Fundamental Types","text":"<p>Basic types for the OPAE C++ API are found in the opae::fpga::types namespace. They serve as an adapter layer between the OPAE C API and the OPAE C++ layer. Aside from providing a C++ binding to the C fundamental types, these types also:</p> <ul> <li>manage the lifetime and scope of the corresponding C struct.</li> </ul> <ul> <li>For example a C++ destructor will take care of calling the appropriate C function to release the data structure being wrapped.</li> </ul> <ul> <li>provide a friendly syntax for using the OPAE C type.</li> </ul> <p>Most classes in this namespace have a c_type() method that returns the C data structure being wrapped, making it easy to use the OPAE C++ type with the OPAE C API. Alternatively, most classes in this namespace have implicit conversion operators that enable interoperability with the OPAE C API.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#properties","title":"Properties","text":"<p>C++ class properties wraps fpga_properties and uses pvalue and guid_t to get and set properties stored in an instance of an fpga_properties. pvalue and guid_t are designed to call an accessor method in the OPAE C API to either read property values or write them. Most accessor methods in the OPAE C API share a similar signature, so pvalue generalizes them into common operations that translate into calling the corresponding C API function. guid_t follows similar patterns when reading or assigning values.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#pvalueh","title":"pvalue.h","text":"<p>pvalue.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#propertiesh","title":"properties.h","text":"<p>properties.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#resource-classes","title":"Resource Classes","text":"<p>The token, handle, and shared_buffer classes are used to enumerate and access FPGA resources. properties are used to narrow the search space for token's. Before enumerating the accelerator resources in the system, applications can produce one or more properties objects whose values are set to the desired characteristics for the resource. For example, an application may search for an accelerator resource based on its guid.</p> <p>Once one or more token's have been enumerated, the application must choose which token's to request. The token is then converted to a handle by requesting that a handle object be allocated and opened for it.</p> <p>Once a handle has been successfully opened, the application can read and write the associated configuration and status space. Additionally, the application may use the handle to allocate shared_buffer's or to register event's. The shared_buffer and event objects retain a reference to their owning handle so that the handle does not lose scope before freeing the shared_buffer and event objects.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#tokenh","title":"token.h","text":"<p>token.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#handleh","title":"handle.h","text":"<p>handle.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#shared_bufferh","title":"shared_buffer.h","text":"<p>shared_buffer.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#errorsh","title":"errors.h","text":"<p>errors.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#eventsh","title":"events.h","text":"<p>events.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#sysobjecth","title":"sysobject.h","text":"<p>sysobject.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#exceptions","title":"Exceptions","text":"<p>When the OPAE C++ API encounters an error from the OPAE C API, it captures the current source code location and the error code into an object of type except, then throws the except. Applications should implement the appropriate catch blocks required to respond to runtime exceptions.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#excepth","title":"except.h","text":"<p>except.h</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#misc","title":"Misc","text":"<p>The version class wraps the OPAE C version API.</p>"},{"location":"sw/fpga_api/fpga_cxx_api/#versionh","title":"version.h","text":"<p>version.h</p>"},{"location":"sw/fpga_api/fpga_python_api/","title":"OPAE Python API Reference","text":"<p>The reference documentation for the OPAE Python API and is grouped into the following sections:</p> <ul> <li>Module Types, Methods, and Constants</li> <li>Fundamental Types<ul> <li>Properties</li> <li>Token</li> <li>Handle</li> <li>Event</li> <li>Shared Buffer</li> <li>Error</li> <li>SysObject</li> </ul> </li> </ul>"},{"location":"sw/fpga_api/fpga_python_api/#module-types-methods-and-constants","title":"Module Types, Methods, and Constants","text":""},{"location":"sw/fpga_api/fpga_python_api/#fundamental-types","title":"Fundamental Types","text":""},{"location":"sw/fpga_api/fpga_python_api/#properties","title":"Properties","text":""},{"location":"sw/fpga_api/fpga_python_api/#token","title":"Token","text":""},{"location":"sw/fpga_api/fpga_python_api/#handle","title":"Handle","text":""},{"location":"sw/fpga_api/fpga_python_api/#event","title":"Event","text":""},{"location":"sw/fpga_api/fpga_python_api/#shared-buffer","title":"Shared Buffer","text":""},{"location":"sw/fpga_api/fpga_python_api/#error","title":"Error","text":""},{"location":"sw/fpga_api/fpga_python_api/#sysobject","title":"SysObject","text":""},{"location":"sw/fpga_api/plug_guide/readme/","title":"Plugin Developer's Guide","text":""},{"location":"sw/fpga_api/plug_guide/readme/#overview","title":"Overview","text":"<p>Beginning with OPAE C library version 1.2.0, OPAE implements a plugin-centric model. This guide serves as a reference to define the makeup of an OPAE C API plugin and to describe a sequence of steps that one may follow when constructing an OPAE C API plugin.</p>"},{"location":"sw/fpga_api/plug_guide/readme/#plugin-required-functions","title":"Plugin Required Functions","text":"<p>An OPAE C API plugin is a runtime-loadable shared object library, also known as a module. On Linux systems, the dl family of APIs from libdl are used to interact with shared objects. Refer to \"man dlopen\" and \"man dlsym\" for examples of using the libdl API.</p> <p>An OPAE C API plugin implements one required function. This function is required to have C linkage, so that its name is not mangled.</p> <pre><code>    int opae_plugin_configure(opae_api_adapter_table *table, const char *config);\n</code></pre> <p>During initialization, the OPAE plugin manager component loads each plugin, searching for its <code>opae_plugin_configure</code> function. If none is found, then the plugin manager rejects that plugin. When it is found, <code>opae_plugin_configure</code> is called passing a pointer to a freshly-created <code>opae_api_adapter_table</code> and a buffer consisting of configuration data for the plugin.</p> <p>The job of the <code>opae_plugin_configure</code> function is to populate the given adapter table with each of the plugin's API entry points and to consume and comprehend the given configuration data in preparation for initialization.</p>"},{"location":"sw/fpga_api/plug_guide/readme/#opae-api-adapter-table","title":"OPAE API Adapter Table","text":"<p>The adapter table is a data structure that contains function pointer entry points for each of the OPAE APIs implemented by a plugin. In this way, it adapts the plugin-specific behavior to the more general case of a flat C API. Note that OPAE applications are only required to link with opae-c. In other words, the name of the plugin library should not appear on the linker command line. In this way, plugins are truly decoupled from the OPAE C API, and they are required to adapt to the strict API specification by populating the adapter table only. No other linkage is required nor recommended.</p> <p><code>adapter.h</code> contains the definition of the <code>opae_api_adapter_table</code>. An abbreviated version is depicted below, along with supporting type <code>opae_plugin</code>:</p> <pre><code>    typedef struct _opae_plugin {\nchar *path;\nvoid *dl_handle;\n} opae_plugin;\ntypedef struct _opae_api_adapter_table {\nstruct _opae_api_adapater_table *next;\nopae_plugin plugin;\nfpga_result (*fpgaOpen)(fpga_token token, fpga_handle *handle,\nint flags);\nfpga_result (*fpgaClose)(fpga_handle handle);\n...\nfpga_result (*fpgaEnumerate)(const fpga_properties *filters,\nuint32_t num_filters, fpga_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n...\n// configuration functions\nint (*initialize)(void);\nint (*finalize)(void);\n// first-level query\nbool (*supports_device)(const char *device_type);\nbool (*supports_host)(const char *hostname);\n} opae_api_adapter_table;\n</code></pre> <p>Some points worth noting are that the adapter tables are organized in memory by adding them to a linked list data structure. This is the use of the <code>next</code> structure member. (The list management is handled by the plugin manager.) The <code>plugin</code> structure member contains the handle to the shared object instance, as created by <code>dlopen</code>. This handle is used in the plugin's <code>opae_plugin_configure</code> to load plugin entry points. A plugin need only implement the portion of the OPAE C API that a target application needs. Any API entry points that are not supported should be left as NULL pointers (the default) in the adapter table. When an OPAE API that has no associated entry point in the adapter table is called, the result for objects associated with that plugin will be <code>FPGA_NOT_SUPPORTED</code>.</p> <p>The following code illustrates a portion of the <code>opae_plugin_configure</code> for a theoretical OPAE C API plugin libfoo.so:</p> <pre><code>    /* foo_plugin.c */\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\nadapter-&gt;fpgaOpen = dlsym(adapter-&gt;plugin.dl_handle, \"foo_fpgaOpen\");\nadapter-&gt;fpgaClose =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_fpgaClose\");\n...\nadapter-&gt;fpgaEnumerate =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_fpgaEnumerate\");\n...\nreturn 0;\n}\n</code></pre> <p>Notice that the implementations of the API entry points for plugin libfoo.so are prefixed with <code>foo_</code>. This is the recommended practice to avoid name collisions and to enhance the debugability of the application. Upon successful configuration, <code>opae_plugin_configure</code> returns 0 to indicate success. A non-zero return value indicates failure and causes the plugin manager to reject the plugin from futher consideration.</p>"},{"location":"sw/fpga_api/plug_guide/readme/#plugin-optional-functions","title":"Plugin Optional Functions","text":"<p>Once the plugin manager loads and configures each plugin, it uses the adapter table to call back into the plugin so that it can be made ready for runtime. This is the job of the <code>opae_plugin_initialize</code> entry point, whose signature is defined as:</p> <pre><code>    int opae_plugin_initialize(void);\n</code></pre> <p>The function takes no parameters, as the configuration data was already given to the plugin by <code>opae_plugin_configure</code>. <code>opae_plugin_initialize</code> returns 0 if no errors were encountered during initialization. A non-zero return code indicates that plugin initialization failed. A plugin makes its <code>opae_plugin_initialize</code> available to the plugin manager by populating the adapter table's <code>initialize</code> entry point as shown:</p> <pre><code>    /* foo_plugin.c */\nint foo_plugin_initialize(void)\n{\n...\nreturn 0; /* success */\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;initialize =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_initialize\");\n...\nreturn 0;\n}\n</code></pre> <p>If a plugin does not implement an <code>opae_plugin_initialize</code> entry point, then the <code>initialize</code> member of the adapter table should be left uninitialized. During plugin initialization, if a plugin has no <code>opae_plugin_initialize</code> entry in its adapter table, the plugin initialization step will be skipped, and the plugin will be considered to have initialized successfully.</p> <p>Once plugin initialization is complete for all loaded plugins, the system is considered to be running and fully functional.</p> <p>During teardown, the plugin manager uses the adapter table to call into each plugin's <code>opae_plugin_finalize</code> entry point, whose signature is defined as:</p> <pre><code>    int opae_plugin_finalize(void);\n</code></pre> <p><code>opae_plugin_finalize</code> returns 0 if no errors were encountered during teardown. A non-zero return code indicates that plugin teardown failed. A plugin makes its <code>opae_plugin_finalize</code> available to the plugin manager by populating the adapter table's <code>finalize</code> entry point as shown:</p> <pre><code>    /* foo_plugin.c */\nint foo_plugin_finalize(void)\n{\n...\nreturn 0; /* success */\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;finalize =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_finalize\");\n...\nreturn 0;\n}\n</code></pre> <p>If a plugin does not implement an <code>opae_plugin_finalize</code> entry point, then the <code>finalize</code> member of the adapter table should be left uninitialized. During plugin cleanup, if a plugin has no <code>opae_plugin_finalize</code> entry point in its adapter table, the plugin finalize step will be skipped, and the plugin will be considered to have finalized successfully.</p> <p>In addition to <code>initialize</code> and <code>finalize</code>, an OPAE C API plugin has two further optional entry points that relate to device enumeration. During enumeration, when a plugin is being considered for a type of device, the plugin may provide input on that decision by exporting an <code>opae_plugin_supports_device</code> entry point in the adapter table:</p> <pre><code>    bool opae_plugin_supports_device(const char *device_type);\n</code></pre> <p><code>opae_plugin_supports_device</code> returns true if the given device type is supported and false if it is not. A false return value from <code>opae_plugin_supports_device</code> causes device enumeration to skip the plugin.</p> <p>Populating the <code>opae_plugin_supports_device</code> is done as:</p> <pre><code>    /* foo_plugin.c */\nbool foo_plugin_supports_device(const char *device_type)\n{\nif (/* device_type is supported */)\nreturn true;\n...\nreturn false;\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;supports_device =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_supports_device\");\n...\nreturn 0;\n}\n</code></pre> <pre><code>.. note::\n    The `opae_plugin_supports_device` mechanism serves as a placeholder only.\n    It is not implemented in the current version of the OPAE C API.\n</code></pre> <p>Similarly to determining whether a plugin supports a type of device, a plugin may also answer questions about network host support by populating an <code>opae_plugin_supports_host</code> entry point in the adapter table:</p> <pre><code>    bool opae_plugin_supports_host(const char *hostname);\n</code></pre> <p><code>opae_plugin_supports_host</code> returns true if the given hostname is supported and false if it is not. A false return value from <code>opae_plugin_supports_host</code> causes device enumeration to skip the plugin.</p> <p>Populating the <code>opae_plugin_supports_host</code> is done as:</p> <pre><code>    /* foo_plugin.c */\nbool foo_plugin_supports_host(const char *hostname)\n{\nif (/* hostname is supported */)\nreturn true;\n...\nreturn false;\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;supports_host =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_supports_host\");\n...\nreturn 0;\n}\n</code></pre> <pre><code>.. note::\n    The `opae_plugin_supports_host` mechanism serves as a placeholder only.\n    It is not implemented in the current version of the OPAE C API.\n</code></pre>"},{"location":"sw/fpga_api/plug_guide/readme/#plugin-construction","title":"Plugin Construction","text":"<p>The steps required to implement an OPAE C API plugin, libfoo.so, are:</p> <ul> <li>Create foo_plugin.c: implements <code>opae_plugin_configure</code>, <code>opae_plugin_initialize</code>, <code>opae_plugin_finalize</code>, <code>opae_plugin_supports_device</code>, and <code>opae_plugin_supports_host</code> as described in the previous sections.</li> <li>Create foo_plugin.h: implements function prototypes for each of the plugin-specific OPAE C APIs.</li> </ul> <pre><code>    /* foo_plugin.h */\nfpga_result foo_fpgaOpen(fpga_token token, fpga_handle *handle,\nint flags);\nfpga_result foo_fpgaClose(fpga_handle handle);\n...\nfpga_result foo_fpgaEnumerate(const fpga_properties *filters,\nuint32_t num_filters, fpga_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n...\n</code></pre> <ul> <li>Create foo_types.h: implements plugin-specific types for opaque data structures.</li> </ul> <pre><code>    /* foo_types.h */\nstruct _foo_token {\n...\n};\nstruct _foo_handle {\n...\n};\nstruct _foo_event_handle {\n...\n};\nstruct _foo_object {\n...\n};\n</code></pre> <ul> <li>Create foo_enum.c: implements <code>foo_fpgaEnumerate</code>, <code>foo_fpgaCloneToken</code>, and <code>foo_fpgaDestroyToken</code>.</li> <li>Create foo_open.c: implements <code>foo_fpgaOpen</code>.</li> <li>Create foo_close.c: implements <code>foo_fpgaClose</code>.</li> <li>Create foo_props.c: implements <code>foo_fpgaGetProperties</code>, <code>foo_fpgaGetPropertiesFromHandle</code>, <code>foo_fpgaUpdateProperties</code></li> <li>Create foo_mmio.c: implements <code>foo_fpgaMapMMIO</code>, <code>foo_fpgaUnmapMMIO</code> <code>foo_fpgaWriteMMIO64</code>, <code>foo_fpgaReadMMIO64</code>, <code>foo_fpgaWriteMMIO32</code>, <code>foo_fpgaReadMMIO32</code>.</li> <li>Create foo_buff.c: implements <code>foo_fpgaPrepareBuffer</code>, <code>foo_fpgaReleaseBuffer</code>, <code>foo_fpgaGetIOAddress</code>.</li> <li>Create foo_error.c: implements <code>foo_fpgaReadError</code>, <code>foo_fpgaClearError</code>, <code>foo_fpgaClearAllErrors</code>, <code>foo_fpgaGetErrorInfo</code>.</li> <li>Create foo_event.c: implements <code>foo_fpgaCreateEventHandle</code>, <code>foo_fpgaDestroyEventHandle</code>, <code>foo_fpgaGetOSObjectFromEventHandle</code>, <code>foo_fpgaRegisterEvent</code>, <code>foo_fpgaUnregisterEvent</code>.</li> <li>Create foo_reconf.c: implements <code>foo_fpgaReconfigureSlot</code>.</li> <li>Create foo_obj.c: implements <code>foo_fpgaTokenGetObject</code>, <code>foo_fpgaHandleGetObject</code>, <code>foo_fpgaObjectGetObject</code>, <code>foo_fpgaDestroyObject</code>, <code>foo_fpgaObjectGetSize</code>, <code>foo_fpgaObjectRead</code>, <code>foo_fpgaObjectRead64</code>, <code>foo_fpgaObjectWrite64</code>.</li> <li>Create foo_clk.c: implements <code>foo_fpgaSetUserClock</code>, <code>foo_fpgaGetUserClock</code>.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/","title":"OPAE C API Programming Guide","text":""},{"location":"sw/fpga_api/prog_guide/readme/#overview","title":"Overview","text":"<p>The OPAE C library (libopae-c) is a lightweight user-space library that provides abstractions for FPGA resources in a compute environment. The OPAE C library  builds on the driver stack that supports the FPGA device, abstracting  hardware- and OS-specific details. It provides access to the underlying FPGA resources as a set of features available to software programs running on the host. These features include the acceleration logic preconfigured on the FPGA and functions to manage and reconfigure the FPGA. The library enables your applications to transparently and seamlessly benefit from FPGA-based acceleration.</p> <p></p> <p>By providing a unified C API, the library supports different FPGA integration and deployment models, ranging from single-node systems with one or a few FPGA devices to large-scale FPGA deployments in a data center. At one end of the spectrum, the API supports a simple application using a PCIe link to reconfigure  the FPGA with different accelerator functions. At the other end of the spectrum, resource management and orchestration services in a data center can use this API to discover and select FPGA resources and then allocate them for use by acceleration workloads.</p>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-role","title":"OPAE Role","text":"<p>The OPAE provides a common base layer for a wide range of applications without sacrificing performance or efficiency. The abstraction layer limits  the details of the FPGA hardware that software applications must handle. </p> <p>The OPAE provides consistent interfaces to crucial components of the platform. The  OPAE does not constrain frameworks and applications by making optimizations with limited applicability. When the OPAE does provide convenience functions or optimizations, they are optional.</p> <p>For example, the OPAE provides an interface to allocate physically contiguous buffers in system memory that user-space software and an accelerator can share.  This interface enables the most basic feature set of allocating and sharing a large page of memory in one API call. However, it  does not provide a malloc()-like interface backed by a memory pool or slab allocator. Higher layers of the software stack can make such domain-specific optimizations.</p>"},{"location":"sw/fpga_api/prog_guide/readme/#intel-accelerator-stack-hardware-terminology","title":"Intel Accelerator Stack Hardware Terminology","text":"<p>The following terms define the hardware and hardware processes involved in creating an accelerator function. </p> <ul> <li>FPGA: Field Programmable Gate Array  is a discrete or integrated device connecting to a host CPU via PCIe or other type of interconnects.</li> <li>Accelerator Function Unit (AFU): The AFU is the supplied implementation of an accelerator, typically in HDL. AFUs implement a function such as compression, encryption, or mathematical operations. The Quartus Prime Pro software synthesizes the RTL logic into a bitstream. </li> <li>Accelerator Function (AF): The AF is the compiled binary for an AFU. An AF is a raw binary file (.rbf) bitstream. A tool (fpgaconf) reconfigures the FPGA using an AF bitstream.</li> <li>Reconfiguration: The process of reprogramming the FPGA with a different AF.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-software-concepts-reflected-in-the-c-api","title":"OPAE Software Concepts Reflected in the C API","text":"<p>The following OPAE data structures and functions integrate AFUs into the OPAE environment.  The OPAE C API models these data structures and functions. For more information on the object  models refer to the Object model section.</p> <ul> <li>Accelerator: An accelerator is an allocable accelerator function implemented in an FPGA.  An accelerator tracks the  ownership of an AFU (or part of it) for a process that uses it. Multiple processes can share an accelerator.</li> <li>Device: The OPAE enumerates and models two device types: the FPGA and the AFU.</li> <li>Events: Events are asynchronous notifications. The FPGA driver triggers particular events to indicate error conditions. Accelerator logic can also define its own events. User applications can choose to be notified when particular events occur and respond appropriately.</li> <li>Shared memory buffers: Software allocates shared memory buffers in user process memory on the host. Shared memory buffers facilitate data transfers between the user process and the  accelerator that it owns.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-library","title":"OPAE Library","text":"<p>Linking with this library is straightforward. Code using the  OPAE library should include the header file <code>fpga.h</code>. Taking the GCC compiler on Linux as an example, here is the simplest compile and link command:</p> <p><code>gcc myprog.c -I&lt;/path/to/fpga.h&gt; -L&lt;/path/to/libopae-c.so&gt; -lopae-c -luuid -ljson-c -lpthread</code></p> <p>.. note::</p> <pre><code>The OPAE library uses the third-party `libuuid` and `libjson-c` libraries that are not distributed with \nthe OPAE library. Make sure to install these libraries.\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#sample-code","title":"Sample Code","text":"<p>The library source includes two code samples. Use these samples to learn how to call functions in the library. Build and run these samples to determine if your installation and environment are set up properly. </p> <p>Refer to the Running the Hello FPGA Example chapter in the Intel\u00ae Acceleration Stack Quick Start Guide for for Intel Programmable Acceleration Card with Intel Arria\u00ae 10 GX FPGA for more information about using the sample code.  </p>"},{"location":"sw/fpga_api/prog_guide/readme/#high-level-directory-structure","title":"High-Level Directory Structure","text":"<p>Building and installing the OPAE library results in the following directory structure on the Linux OS. Windows and MacOS have similar directories and files.</p> Directory &amp; Files Contents include/opae Directory containing all header files include/opae/fpga.h Top-level header for user code to include include/opae/access.h Header file for accelerator acquire/release, MMIO, memory management, event handling, and so on include/opae/bitstream.h Header file for bitstream manipulation functions include/opae/common.h Header file for error reporting functions include/opae/enum.h Header file for AFU enumeration functions include/opae/manage.h Header file for FPGA management functions include/opae/types.h Various type definitions lib Directory containing shared library files lib/libopae-c.so The shared dynamic library for linking with the user application doc Directory containing API documentation doc/html Directory for documentation of HTML format doc/latex Directory for documentation of LaTex format doc/man Directory for documentation of Unix man page format"},{"location":"sw/fpga_api/prog_guide/readme/#basic-application-flow","title":"Basic Application Flow","text":"<p>The figure below shows the basic application flow from the viewpoint of a user-process. </p> <p></p>"},{"location":"sw/fpga_api/prog_guide/readme/#api-components","title":"API Components","text":"<p>The API object model abstracts the physical FPGA device and available functions. It is a generalized model and extends to  describe any FPGA type. </p>"},{"location":"sw/fpga_api/prog_guide/readme/#object-models","title":"Object Models","text":"<ul> <li><code>fpga_objtype</code>: An enum type that represents the type of an FPGA resource, either <code>FPGA_DEVICE</code> or <code>FPGA_ACCELERATOR</code>.  An <code>FPGA_DEVICE</code> object corresponds to a physical FPGA device. Only <code>FPGA_DEVICE</code> objects can invoke management functions. The <code>FPGA_ACCELERATOR</code> represents an instance of an AFU. </li> <li><code>fpga_token</code>: An opaque type that represents a resource known to, but not necessarily owned by, the calling process. The calling process must own a resource before it can invoke functions of the resource.</li> <li><code>fpga_handle</code>: An opaque type that represents a resource owned by the calling process. The API functions <code>fpgaOpen()</code> and <code>fpgaClose()</code> acquire and release ownership of a resource that an <code>fpga_handle</code> represents. (Refer to the Functions section for more information.)</li> <li><code>fpga_properties</code>: An opaque type for a properties object. Your applications use these properties to query and search for appropriate resources. The  FPGA Resource Properties section documents properties visible to your applications.</li> <li><code>fpga_event_handle</code>: An opaque handle the FPGA driver uses to notify your application about an event. </li> <li><code>fpga_event_type</code>: An enum type that represents the types of events. The following are valid values:  <code>FPGA_EVENT_INTERRUPT</code>, <code>FPGA_EVENT_ERROR</code>, and <code>FPGA_EVENT_POWER_THERMAL</code>. (The Intel Programmable Acceleration Card (PAC) with Intel Arria 10 GX FPGA does not handle thermal and power events.)</li> <li><code>fpga_result</code>: An enum type to represent the result of an API function. If the function returns successfully the result is <code>FPGA_OK</code>. Otherwise, the result is the appropriate error codes. Function <code>fpgaErrStr()</code> translates an error code into human-readable strings.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/#functions","title":"Functions","text":"<p>The table below groups important API calls by their functionality. For more information about each of the functions, refer to the  OPAE C API reference manual.</p> Functionality API Call FPGA Accelerator Description Enumeration <code>fpgaEnumerate()</code> Yes Yes Query FPGA resources that match certain properties Enumeration: Properties <code>fpga[Get, Update, Clear, Clone, Destroy Properties]()</code> Yes Yes Manage <code>fpga_properties</code> life cycle <code>fpgaPropertiesGet[Prop]()</code> Yes Yes Get the specified property Prop, from the FPGA Resource Properties table <code>fpgaPropertiesSet[Prop]()</code> Yes Yes Set the specified property Prop, from the FPGA Resource Properties table Access: Ownership <code>fpga[Open, Close]()</code> Yes Yes Acquire/release ownership Access: Reset <code>fpgaReset()</code> Yes Yes Reset an accelerator Access: Event handling <code>fpga[Register, Unregister]Event()</code> Yes Yes Register/unregister an event to be notified about <code>fpga[Create, Destroy]EventHandle()</code> Yes Yes Manage <code>fpga_event_handle</code> life cycle Access: MMIO <code>fpgaMapMMIO()</code>, <code>fpgaUnMapMMIO()</code> Yes Yes Map/unmap MMIO space <code>fpgaGetMMIOInfo()</code> Yes Yes Get information about the specified MMIO space <code>fpgaReadMMIO[32, 64]()</code> Yes Yes Read a 32-bit or 64-bit value from MMIO space <code>fpgaWriteMMIO[32, 64]()</code> Yes Yes Write a 32-bit or 64-bit value to MMIO space Memory management: Shared memory <code>fpga[Prepare, Release]Buffer()</code> Yes Yes Manage memory buffer shared between the calling process and an accelerator <code>fpgaGetIOAddress()</code> Yes Yes Return the device I/O address of a shared memory buffer Management: Reconfiguration <code>fpgaReconfigureSlot()</code> Yes No Replace an existing AFU with a new one Error report <code>fpgaErrStr()</code> Yes Yes Map an error code to a human readable string <p>.. note::</p> <pre><code>The UMsg APIs are not supported for the Intel(R) PAC cards. They will be deprecated in a future release.\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#fpga-resource-properties","title":"FPGA Resource Properties","text":"<p>Applications query resource properties by specifying the property name for <code>Prop</code> in the  <code>fpgaPropertiesGet[Prop]()</code> and <code>fpgaPropertiesSet[Prop]()</code> functions. The FPGA and Accelerator columns state whether or not the Property is available for the FPGA or Accelerator objects.</p> Property FPGA Accelerator Description Parent No Yes <code>fpga_token</code> of the parent object ObjectType Yes Yes The type of the resource: either <code>FPGA_DEVICE</code> or <code>FPGA_ACCELERATOR</code> Bus Yes Yes The bus number Device Yes Yes The PCI device number Function Yes Yes The PCI function number SocketId Yes Yes The socket ID DeviceId Yes Yes The device ID NumSlots Yes No Number of AFU slots available on an <code>FPGA_DEVICE</code> resource BBSID Yes No The FPGA Interface Manager (FIM) ID of an <code>FPGA_DEVICE</code> resource BBSVersion Yes No The FIM version of an <code>FPGA_DEVICE</code> resource VendorId Yes No The vendor ID of an <code>FPGA_DEVICE</code> resource GUID Yes Yes The GUID of an <code>FPGA_DEVICE</code> or <code>FPGA_ACCELERATOR</code> resource NumMMIO No Yes The number of MMIO space of an <code>FPGA_ACCELERATOR</code> resource NumInterrupts No Yes The number of interrupts of an <code>FPGA_ACCELERATOR</code> resource AcceleratorState No Yes The state of an <code>FPGA_ACCELERATOR</code> resource: either <code>FPGA_ACCELERATOR_ASSIGNED</code> or <code>FPGA_ACCELERATOR_UNASSIGNED</code>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-c-api-return-codes","title":"OPAE C API Return Codes","text":"<p>The OPAE C library returns a code for every exported public API function.  <code>FPGA_OK</code> indicates successful completion of the requested operation. Any return code other than <code>FPGA_OK</code> indicates an error or unexpected behavior. When using the OPAE C API, always check the API return codes. </p> Error Code Description <code>FPGA_OK</code> Operation completed successfully <code>FPGA_INVALID_PARAM</code> Invalid parameter supplied <code>FPGA_BUSY</code> Resource is busy <code>FPGA_EXCEPTION</code> An exception occurred <code>FPGA_NOT_FOUND</code> A required resource was not found <code>FPGA_NO_MEMORY</code> Not enough memory to complete operation <code>FPGA_NOT_SUPPORTED</code> Requested operation is not supported <code>FPGA_NO_DRIVER</code> Driver is not loaded <code>FPGA_NO_DAEMON</code> FPGA Daemon (<code>fpgad</code>) is not running <code>FPGA_NO_ACCESS</code> Insufficient privileges or permissions <code>FPGA_RECONF_ERROR</code> Error while reconfiguring FPGA"},{"location":"sw/fpga_api/prog_guide/readme/#usage-models","title":"Usage Models","text":""},{"location":"sw/fpga_api/prog_guide/readme/#query-and-search-for-a-resource","title":"Query and Search for a Resource","text":"<p>The user-code first populates an <code>fpga_properties</code> object with the required properties. Then, <code>fpgaEnumerate()</code> searches for matching resources. <code>fpgaEnumerate()</code> may return more than one matching resource.</p> <pre><code>#include \"fpga/fpga.h\"\n\nfpga_guid               guid;\nfpga_properties         filter = NULL;\nfpga_result             res;\nfpga_token              tokens[MAX_NUM_TOKENS];\nuint32_t                num_matches = 0;\n\n/* Start with an empty properties object */\nres = fpgaGetProperties(NULL, &amp;filter);\n\n/* Populate the properties object with required values.\n   In this case, search for accelerators that matches \n   the specified GUID.\n*/\nuuid_parse(GUID, guid);\nres = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\nres = fpgaPropertiesSetGuid(filter, guid);\n\n/* Query the number of matching resources */\nres = fpgaEnumerate(&amp;filter, 1, NULL, 1, &amp;num_matches);\n\n/* Return tokens for all matching resources */\nres = fpgaEnumerate(&amp;filter, 1, tokens, num_matches, &amp;num_matches);\n\n/* Destroy the properties object */\nres = fpgaDestroyProperties(&amp;filter);\n\n/* More code */\n......\n\n/* Destroy tokens */\nfor (uint32_t i = 0; i &lt; num_matches; ++i) {\n    res = fpgaDestroyToken(tokens[i]);\n}\n</code></pre> <p>The <code>fpgaEnumerate()</code> function can take multiple <code>fpga_properties</code>objects in an array. In such cases, the function performs a logical OR of  the properties object and returns resources that match any of  the multiple properties. The  <code>fpga_token</code> objects that <code>fpgaEnumerate()</code> returns, do not signify ownership. To acquire ownership of a resource represented by a token, pass the token to <code>fpgaOpen()</code>.</p>"},{"location":"sw/fpga_api/prog_guide/readme/#acquire-and-release-a-resource","title":"Acquire and Release a Resource","text":"<p>Use <code>fpgaOpen()</code> and <code>fpgaClose()</code> to acquire and release ownership of a resource.  The calling process must own the resource before it can initiate MMIO, access share memory buffers,  and use functions offered by the resource.</p> <pre><code>    #include \"fpga/fpga.h\"\nfpga_handle             handle;\nfpga_result             res;\n/* Acquire ownership of a resource that \n    `fpgaEnumerate()` previously returned as a token */\nres = fpgaOpen(token, &amp;handle);\n/* More code */\n......\n/* Release the ownership */\nres = fpgaClose(handle);\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#shared-memory-buffer","title":"Shared Memory Buffer","text":"<p>This code snippet shows how to prepare a memory buffer to be shared between the calling process and an accelerator.</p> <pre><code>    #include \"fpga/fpga.h\"\nfpga_handle             handle;\nfpga_result             res;\n/* Hint for the virtual address of the buffer */\nvolatile uint64_t       *addr_hint;\n/* An ID we can use to reference the buffer later */\nuint32_t                bufid;\n/* Flag to indicate whether or not the buffer is preallocated */\nint                     flag = 0;\n/* Allocate (if necessary), pin, and map a buffer to be accessible\n       by an accelerator\n    */\nres = fpgaPrepareBuffer(handle, BUF_SIZE, (void **) &amp;addr_hint,\n&amp;bufid, flag);\n/* The actual address mapped to the buffer */\nuint64_t                iova;\n/* Get the IO virtual address for the buffer */\nres = fpgaGetIOAddress(handle, bufid, &amp;iova);\n/* Inform the accelerator about the virtual address by writing to its mapped\n       register file\n    */\n......\n/* More code */\n......\n/* Release the shared buffer */\nres = fpgaReleaseBuffer(handle, bufid);\n</code></pre> <p>.. note::</p> <pre><code>The `flag` variable can take a constant `FPGA_BUF_PREALLOCATED` to\nindicate that the calling process has already allocated the address space\nthat `addr_hint` points to.\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#mmio","title":"MMIO","text":"<p>This code snippet shows how to map and unmap the register file of an accelerator into the calling process's virtual memory space.</p> <pre><code>    #include \"fpga/fpga.h\"\nfpga_handle             handle;\nfpga_result             res;\n/* Index of the MMIO space. There might be multiple spaces on an accelerator */\nuint32_t                mmio_num = 0;\n/* Mapped address */\nuint64_t                mmio_addr;\n/* Map MMIO */\nres = fpgaMapMMIO(handle, mmio_num, &amp;mmio_addr);\n/* Write to a 32-bit value to the mapped register file at a certain byte\n       offset.\n       CSR_CTL is the offset in the mapped space to where the value will be\n       written. It's defined elsewhere.\n    */\nres = fpgaWriteMMIO32(handle, mmio_num, CSR_CTL, value);\n/* More code */\n......\n/* Unmap MMIO */\nres = fpgaUnmapMMIO(handle, mmio_num);\n</code></pre> <p>.. Note::</p> <pre><code>Every AFU has its own register adress space and its own protocol to control operation through \nthe registers. \n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/","title":"Quick Start Guide","text":""},{"location":"sw/fpga_api/quick_start/readme/#overview","title":"Overview","text":"<p>The OPAE C library is a lightweight user-space library that provides an abstraction for FPGA resources in a compute environment. Built on top of the OPAE Intel\u00ae FPGA driver stack that supports Intel\u00ae FPGA platforms, the library abstracts away hardware-specific and OS-specific details and exposes the underlying FPGA resources as a set of features accessible from within software programs running on the host.</p> <p>These features include the acceleration logic preconfigured on the device, as well as functions to manage and reconfigure the device. Hence, the library can enable user applications to transparently and seamlessly leverage FPGA-based acceleration.</p> <p>In this document, we will explore the initial steps on how to set up the required libraries and utilities to use the FPGA devices.</p> <p>If you do not have access to an Intel\u00ae Xeon\u00ae processor with integrated FPGA, or a programmable FPGA acceleration card for Intel\u00ae Xeon\u00ae processors, you will not be able to run the examples below. However, you can still make use of the AFU simulation environment (ASE) to develop and test accelerator RTL with OPAE applications.</p> <p>The source for the OPAE SDK Linux device drivers is available at the OPAE Linux DFL drivers repository.</p>"},{"location":"sw/fpga_api/quick_start/readme/#build-the-opae-linux-device-drivers-from-the-source","title":"Build the OPAE Linux device drivers from the source","text":"<p>For building the OPAE kernel and kernel driver, the kernel development environment is required. So before you build the kernel, you must install the required packages. Run the following commands (we are using Fedora 32 as an example):</p> <pre><code>sudo yum install gcc gcc-c++ make kernel-headers kernel-devel elfutils-libelf-devel ncurses-devel openssl-devel bison flex\n</code></pre> <p>Download the OPAE upstream kernel tree from GitHub:</p> <pre><code>git clone https://github.com/OPAE/linux-dfl.git -b fpga-upstream-dev-5.8.0\n</code></pre> <p>Configure the kernel:</p> <pre><code>cd linux-dfl\ncp /boot/config-`uname -r` .config\ncat configs/n3000_d5005_defconfig &gt;&gt; .config echo 'CONFIG_LOCALVERSION=\"-dfl\"' &gt;&gt; .config\necho 'CONFIG_LOCALVERSION_AUTO=y' &gt;&gt; .config\nmake olddefconfig\n</code></pre> <p>Compile and install the new kernel:</p> <pre><code>make -j\nsudo make modules_install\nsudo make install\n</code></pre> <p>After the installation finishes, reboot your system. Log back into the system, and confirm the correct version for the kernel:</p> <pre><code>$ uname -a\nLinux localhost.localdomain 5.8.0-rc1-dfl-g73e16386cda0 #6 SMP Wed Aug 19 08:38:32 EDT 2020 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/#building-and-installing-the-opae-sdk-from-the-source","title":"Building and installing the OPAE SDK from the source","text":"<p>Download the OPAE SDK source package:</p> <ol> <li>Go to the section corresponding to the desired release on GitHub:</li> <li>Click the <code>Source code (tar.gz)</code> link under the section's <code>Assets</code>.</li> <li> <p>On the command line, go through the following steps to install it:</p> <pre><code># Unpack\ntar xfvz opae-sdk-&lt;release&gt;.tar.gz\n# Configure\ncd opae-sdk-&lt;release&gt;\nmkdir build\ncd build\n# The default installation prefix is `/usr/local`;\n# You have the option to configure for a different location\ncmake [-DCMAKE_INSTALL_PREFIX=&lt;prefix&gt;] ..\n# Compile\nmake\n# Install: you need system administration privileges (`sudo`)\n# if you have elected to install in the default location\n[sudo] make install\n</code></pre> </li> </ol> <p>The remainder of this guide assumes you installed into <code>/usr/local</code>.</p>"},{"location":"sw/fpga_api/quick_start/readme/#configuring-the-fpga-loading-an-fpga-afu","title":"Configuring the FPGA (loading an FPGA AFU)","text":"<p>The <code>fpgaconf</code> tool exercises the AFU reconfiguration functionality. It shows how to read a bitstream from a disk file, check its validity and compatibility, and then injects it into FPGA to be configured as a new AFU, which can then be discovered and used by user applications.</p> <p>For this step, you require a valid green bitstream (GBS) file. To reconfigure the FPGA slot, you can issue the following command as system administrator:</p> <pre><code>sudo fpgaconf -b 0x5e &lt;filename&gt;.gbs\n</code></pre> <p>The <code>-b</code> option to <code>fpgaconf</code> indicates the target bus number of the FPGA slot to be reconfigured. Alternatively, you can also specify the target socket number of the FPGA using the <code>-s</code> option.</p> <pre><code>$ sudo fpgaconf --help\nUsage:\n        fpgaconf [-hvn] [-b &lt;bus&gt;] [-d &lt;device&gt;] [-f &lt;function&gt;] [-s &lt;socket&gt;] &lt;gbs&gt;\n\n-h,--help           Print this help\n-v,--verbose        Increase verbosity\n                -n,--dry-run        Don't actually perform actions\n                -b,--bus            Set target bus number\n                -d,--device         Set target device number\n                -f,--function       Set target function number\n                -s,--socket         Set target socket number\n</code></pre> <pre><code>The sample application on the Building a Sample Application\nsection requires loading of an AFU called \"Native Loopback\nAdapter\" (NLB) on the FPGA. Please refer to the NLB documentation\nfor the location of the NLB's green bitstream. You also can verify\nif the NLB green bitstream has already been loaded into the FPGA\nslot by typing the following command and checking the output\nmatches the following:\n\n```bash\n$ cat /sys/class/fpga_region/region0/dfl-port.0/afu_id\nd8424dc4a4a3c413f89e433683f9040b\n```\n</code></pre> <pre><code>The fpgaconf tool is not available for the Intel PAC N3000. The NLB is\nalready included in the AFU.\n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/#building-a-sample-application","title":"Building a sample application","text":"<p>The library source includes code samples. Use these samples to learn how to call functions in the library. Build and run these samples as quick sanity checks to determine if your installation and environment are set up properly.</p> <p>In this guide, we will build <code>hello_fpga.c</code>. This is the \"Hello World!\" example of using the library.  This code searches for a predefined and known AFU called \"Native Loopback Adapter\" on the FPGA. If found, it acquires ownership and then interacts with the AFU by sending it a 2MB message and waiting for the message to be echoed back. This code exercises all major components of the API except for AFU reconfiguration: AFU search, enumeration, access, MMIO, and memory management.</p> <p>You can also find the source for <code>hello_fpga</code> in the <code>samples</code> directory of the OPAE SDK repository on GitHub.</p> <pre><code>    int main(int argc, char *argv[])\n{\nfpga_properties    filter = NULL;\nfpga_token         afu_token;\nfpga_handle        afu_handle;\nfpga_guid          guid;\nuint32_t           num_matches;\nvolatile uint64_t *dsm_ptr    = NULL;\nvolatile uint64_t *status_ptr = NULL;\nvolatile uint64_t *input_ptr  = NULL;\nvolatile uint64_t *output_ptr = NULL;\nuint64_t        dsm_wsid;\nuint64_t        input_wsid;\nuint64_t        output_wsid;\nfpga_result     res = FPGA_OK;\nif (uuid_parse(NLB0_AFUID, guid) &lt; 0) {\nfprintf(stderr, \"Error parsing guid '%s'\\n\", NLB0_AFUID);\ngoto out_exit;\n}\n/* Look for accelerator by its \"afu_id\" */\nres = fpgaGetProperties(NULL, &amp;filter);\nON_ERR_GOTO(res, out_exit, \"creating properties object\");\nres = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\nON_ERR_GOTO(res, out_destroy_prop, \"setting object type\");\nres = fpgaPropertiesSetGuid(filter, guid);\nON_ERR_GOTO(res, out_destroy_prop, \"setting GUID\");\n/* TODO: Add selection via BDF / device ID */\nres = fpgaEnumerate(&amp;filter, 1, &amp;afu_token, 1, &amp;num_matches);\nON_ERR_GOTO(res, out_destroy_prop, \"enumerating accelerators\");\nif (num_matches &lt; 1) {\nfprintf(stderr, \"accelerator not found.\\n\");\nres = fpgaDestroyProperties(&amp;filter);\nreturn FPGA_INVALID_PARAM;\n}\n/* Open accelerator and map MMIO */\nres = fpgaOpen(afu_token, &amp;afu_handle, 0);\nON_ERR_GOTO(res, out_destroy_tok, \"opening accelerator\");\nres = fpgaMapMMIO(afu_handle, 0, NULL);\nON_ERR_GOTO(res, out_close, \"mapping MMIO space\");\n/* Allocate buffers */\nres = fpgaPrepareBuffer(afu_handle, LPBK1_DSM_SIZE,\n(void **)&amp;dsm_ptr, &amp;dsm_wsid, 0);\nON_ERR_GOTO(res, out_close, \"allocating DSM buffer\");\nres = fpgaPrepareBuffer(afu_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n(void **)&amp;input_ptr, &amp;input_wsid, 0);\nON_ERR_GOTO(res, out_free_dsm, \"allocating input buffer\");\nres = fpgaPrepareBuffer(afu_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n(void **)&amp;output_ptr, &amp;output_wsid, 0);\nON_ERR_GOTO(res, out_free_input, \"allocating output buffer\");\nprintf(\"Running Test\\n\");\n/* Initialize buffers */\nmemset((void *)dsm_ptr,    0,    LPBK1_DSM_SIZE);\nmemset((void *)input_ptr,  0xAF, LPBK1_BUFFER_SIZE);\nmemset((void *)output_ptr, 0xBE, LPBK1_BUFFER_SIZE);\ncache_line *cl_ptr = (cache_line *)input_ptr;\nfor (uint32_t i = 0; i &lt; LPBK1_BUFFER_SIZE / CL(1); ++i) {\ncl_ptr[i].uint[15] = i+1; /* set the last uint in every cacheline */\n}\n/* Reset accelerator */\nres = fpgaReset(afu_handle);\nON_ERR_GOTO(res, out_free_output, \"resetting accelerator\");\n/* Program DMA addresses */\nuint64_t iova;\nres = fpgaGetIOAddress(afu_handle, dsm_wsid, &amp;iova);\nON_ERR_GOTO(res, out_free_output, \"getting DSM IOVA\");\nres = fpgaWriteMMIO64(afu_handle, 0, CSR_AFU_DSM_BASEL, iova);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_AFU_DSM_BASEL\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 0);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 1);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\nres = fpgaGetIOAddress(afu_handle, input_wsid, &amp;iova);\nON_ERR_GOTO(res, out_free_output, \"getting input IOVA\");\nres = fpgaWriteMMIO64(afu_handle, 0, CSR_SRC_ADDR, CACHELINE_ALIGNED_ADDR(iova));\nON_ERR_GOTO(res, out_free_output, \"writing CSR_SRC_ADDR\");\nres = fpgaGetIOAddress(afu_handle, output_wsid, &amp;iova);\nON_ERR_GOTO(res, out_free_output, \"getting output IOVA\");\nres = fpgaWriteMMIO64(afu_handle, 0, CSR_DST_ADDR, CACHELINE_ALIGNED_ADDR(iova));\nON_ERR_GOTO(res, out_free_output, \"writing CSR_DST_ADDR\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_NUM_LINES, LPBK1_BUFFER_SIZE / CL(1));\nON_ERR_GOTO(res, out_free_output, \"writing CSR_NUM_LINES\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CFG, 0x42000);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\nstatus_ptr = dsm_ptr + DSM_STATUS_TEST_COMPLETE/8;\n/* Start the test */\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 3);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n/* Wait for test completion */\nwhile (0 == ((*status_ptr) &amp; 0x1)) {\nusleep(100);\n}\n/* Stop the device */\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 7);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n/* Check output buffer contents */\nfor (uint32_t i = 0; i &lt; LPBK1_BUFFER_SIZE; i++) {\nif (((uint8_t*)output_ptr)[i] != ((uint8_t*)input_ptr)[i]) {\nfprintf(stderr, \"Output does NOT match input \"\n\"at offset %i!\\n\", i);\nbreak;\n}\n}\nprintf(\"Done Running Test\\n\");\n/* Release buffers */\nout_free_output:\nres = fpgaReleaseBuffer(afu_handle, output_wsid);\nON_ERR_GOTO(res, out_free_input, \"releasing output buffer\");\nout_free_input:\nres = fpgaReleaseBuffer(afu_handle, input_wsid);\nON_ERR_GOTO(res, out_free_dsm, \"releasing input buffer\");\nout_free_dsm:\nres = fpgaReleaseBuffer(afu_handle, dsm_wsid);\nON_ERR_GOTO(res, out_unmap, \"releasing DSM buffer\");\n/* Unmap MMIO space */\nout_unmap:\nres = fpgaUnmapMMIO(afu_handle, 0);\nON_ERR_GOTO(res, out_close, \"unmapping MMIO space\");\n/* Release accelerator */\nout_close:\nres = fpgaClose(afu_handle);\nON_ERR_GOTO(res, out_destroy_tok, \"closing accelerator\");\n/* Destroy token */\nout_destroy_tok:\nres = fpgaDestroyToken(&amp;afu_token);\nON_ERR_GOTO(res, out_destroy_prop, \"destroying token\");\n/* Destroy properties object */\nout_destroy_prop:\nres = fpgaDestroyProperties(&amp;filter);\nON_ERR_GOTO(res, out_exit, \"destroying properties object\");\nout_exit:\nreturn res;\n}\n</code></pre> <p>Linking with the OPAE library is straightforward.  Code using this library should include the header file <code>fpga.h</code>. Taking the GCC compiler on Linux as an example, the minimalist compile and link line should look like:</p> <pre><code>gcc -std=c99 hello_fpga.c -I/usr/local/include -L/usr/local/lib -lopae-c -luuid -ljson-c -lpthread -o hello_fpga\n</code></pre> <pre><code>The API uses some features from the C99 language standard. The\n`-std=c99` switch is required if the compiler does not support C99 by\ndefault.\n</code></pre> <pre><code>Third-party library dependency: The library internally uses\n`libuuid` and `libjson-c`. But they are not distributed as part of the\nlibrary. Make sure you have these libraries properly installed.\n</code></pre> <pre><code>The layout of AFU is different between the N3000 card and Rush Creek/Darby Creek.\nIn the N3000 card, the NLB and DMA are contained in the AFU, so we need to do\nenumeration again in AFU to discover the NLB.\nTo run the hello_fpga application on the N3000 card, it should use the `-c`\noption to support the N3000 card:\n\n```bash\n$ sudo ./hello_fpga -c\nRunning Test\nRunning on bus 0x08.\nAFU NLB0 found @ 28000\nDone Running Test\n```\n</code></pre> <p>To run the <code>hello_fpga</code> application; just issue:</p> <pre><code>$ sudo ./hello_fpga\nRunning Test\nDone\n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/#setup-iofs-release1-bitstream-on-fpga-pcie-card","title":"Setup IOFS Release1 Bitstream on FPGA PCIe card","text":"<p>Program IOFS Release1 bitstream on the FPGA D5005 or N6000 cards and reboot the system.</p> <p>Run this command:</p> <pre><code>$ lspci | grep acc\n3b:00.0 Processing accelerators: Intel Corporation Device af00 (rev 01)\n</code></pre> <p>Number of virtual functions supported by bitstream:</p> <pre><code>$ cat /sys/bus/pci/devices/0000:3b:00.0/sriov_totalvfs output: 3\n</code></pre> <p>Enable FPGA virtual functions:</p> <pre><code>sudo sh -c \"echo 3 &gt; /sys/bus/pci/devices/0000:3b:00.0/sriov_numvfs\"\n</code></pre> <p>List of FPGA PF and VF's:</p> <pre><code>Physical Functions (PFs):\n  3b:00.0 Processing accelerators: Intel Corporation Device af00 (rev 01)\n\nVirtual Functions (VFs).\n  3b:00.1 Processing accelerators: Intel Corporation Device af01 (rev 01)\n  3b:00.2 Processing accelerators: Intel Corporation Device af01 (rev 01)\n  3b:00.3 Processing accelerators: Intel Corporation Device af01 (rev 01)\n</code></pre> <p>Bind vfio-pcie driver to FPGA virtual functions:</p> <pre><code>sudo opaevfio  -i 0000:3b:00.1 -u userid -g groupid\nsudo opaevfio  -i 0000:3b:00.2 -u userid -g groupid\nsudo opaevfio  -i 0000:3b:00.3 -u userid -g groupid\n</code></pre> <p>List of fpga accelerators:</p> <pre><code>$ fpgainfo port\n\n//****** PORT ******//\n  Object Id                        : 0x600D000000000000\n  PCIe s:b:d.f                     : 0000:3b:00.3\n  Device Id                        : 0xAF00\n  Socket Id                        : 0xFF\n  Accelerator Id                   : 43425ee6-92b2-4742-b03a-bd8d4a533812\n  Accelerator GUID                 : 43425ee6-92b2-4742-b03a-bd8d4a533812\n  //****** PORT ******//\n  Object Id                        : 0x400D000000000000\n  PCIe s:b:d.f                     : 0000:3b:00.2\n  Device Id                        : 0xAF00\n  Socket Id                        : 0xFF\n  Accelerator Id                   : 8568AB4E-6bA5-4616-BB65-2A578330A8EB\n  Accelerator GUID                 : 8568AB4E-6bA5-4616-BB65-2A578330A8EB\n  //****** PORT ******//\n  Object Id                        : 0x200D000000000000\n  PCIe s:b:d.f                     : 0000:3b:00.1\n  Device Id                        : 0xAF00\n  Socket Id                        : 0xFF\n  Accelerator Id                   : 56e203e9-864f-49a7-b94b-12284c31e02b\n  Accelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n\nFPGA VF1/3b:00.1/Host Exerciser Loopback Accelerator GUID: 56E203E9-864F-49A7-B94B-12284C31E02B\nFPGA VF2/3b:00.2/Host Exerciser Memory Accelerator GUID: 8568AB4E-6bA5-4616-BB65-2A578330A8EB\nFPGA VF3/3b:00.3/Host Exerciser HSSI Accelerator GUID: 43425ee6-92b2-4742-b03a-bd8d4a533812\n</code></pre> <p>Unbind pcie-vfio dirver to FPGA virtual functions:</p> <pre><code>sudo opaevfio  -r 0000:3b:00.1\n</code></pre> <p>Host Exerciser Loopback (HE-LBK) AFU can move data between host memory and FPGA:</p> <pre><code>$ host_exerciser lpbk\n\n[lpbk] [info] starting test run, count of 1\nInput Config:0\n  Allocate SRC Buffer\n  Allocate DST Buffer\n  Allocate DSM Buffer\n  Start Test\n  Test Completed\n  Host Exerciser swtest msg:0\n  Host Exerciser numReads:32\n  Host Exerciser numWrites:32\n  Host Exerciser numPendReads:0\n  Host Exerciser numPendWrites:0\n  [lpbk] [info] Test lpbk(1): PASS\n</code></pre> <pre><code>  In order to successfully run hello\\_fpga, the user needs to configure\n  system hugepage to reserve 2M-hugepages.\n  For example, the command below reserves 20 2M-hugepages:\n\n  ```bash\n  echo 20 | sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages\n  ```\n\n  For x86_64 architecture CPU, user can use the following command to find out available huge page sizes:\n\n  ```bash\n  $ grep pse /proc/cpuinfo | uniq\n  flags : ... pse ...\n  ```\n\n  If this command returns a non-empty string, 2MB pages are supported:\n\n  ```bash\n  $ grep pse /proc/cpuinfo | uniq\n  flags : ... pdpe1gb ...\n  ```\n\n  If this commands returns a non-empty string, 1GB pages are supported.\n  ````\n\n````{note}\nThe default configuration for many Linux distributions currently sets a\nrelatively low limit for pinned memory allocations per process \n(RLIMIT_MEMLOCK, often set to a default of 64kiB).\n\nTo run an OPAE application that attempts to share more memory than specified\nby this limit between software and an accelerator, you can either:\n\n* Run the application as root, or\n* Increase the limit for locked memory via `ulimit`:\n\n```bash\nulimit -l unlimited\n```\n\nSee the Installation Guide for how to permanently adjust the memlock limit.\n</code></pre>"},{"location":"sw/fpga_dfl_drv/fpga_dfl_drv/","title":"Enable OPAE on FPGA PCIe drivers","text":"<pre><code>.. toctree::\n.. highlight:: c\n.. highlight:: console\n</code></pre> <p>FPGA PCIe driver for PCIe-based Field-Programmable Gate Array (FPGA) solutions which implement the Device Feature List (DFL). This driver provides interfaces for user space applications to configure, enumerate, open and access FPGA accelerators on the FPGA DFL devices. additionally, it also enables system level management functions such as FPGA partial reconfiguration, power management, virtualization with DFL framework and DFL feature device drivers.</p> <p>OPAE 1.4.0 release supports both FPGA Intel Linux driver as well as Linux FPGA DFL driver patch set2. Linux PCIe FPGA DFL driver supports Intel FPGA devices.</p> <p>FPGA DFL Linux driver source code patchset2 available  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers?h=linux-5.4.y</p> <p>FPGA DFL Linux driver source code patchset1 available  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/fpga?h=v4.19.14</p> <p></p>"},{"location":"sw/fpga_tools/readme/","title":"fpga_tools","text":""},{"location":"sw/fpga_tools/readme/#fpgainfo","title":"fpgainfo","text":""},{"location":"sw/fpga_tools/readme/#name","title":"NAME","text":"<p>fpgainfo - FPGA information tool</p>"},{"location":"sw/fpga_tools/readme/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgainfo [-h | --help] [-s | --socket-id] &lt;command&gt; [&lt;args&gt;]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#description","title":"DESCRIPTION","text":"<p>fpgainfo is a tool to show FPGA information derived from sysfs files. The command argument is one of the following: errors, power, temp and is used to specify what type of information to report. Some commands may also have other arguments/options that can be used to control the behavior of that command.</p>"},{"location":"sw/fpga_tools/readme/#common-options","title":"COMMON OPTIONS","text":"<p><code>--help, -h</code></p> <pre><code>Print help information and exit.\n</code></pre> <p><code>--socket-id, -s</code></p> <pre><code>Socket ID encoded in BBS. Default=0\n</code></pre>"},{"location":"sw/fpga_tools/readme/#fpgainfo-commands","title":"FPGAINFO COMMANDS","text":"<p><code>errors</code></p> <pre><code>Show/clear errors of an FPGA resource as specified by the first argument.\nError information is parsed to display in human readable form.\n</code></pre> <p><code>power</code></p> <pre><code>Show total power consumed by the FPGA hardware in watts\n</code></pre> <p><code>temp</code></p> <pre><code>Show FPGA temperature values in degrees Farenheit\n</code></pre>"},{"location":"sw/fpga_tools/readme/#errors-options","title":"ERRORS OPTIONS","text":"<p><code>--clear, -c</code></p> <pre><code>Clear errors for the given FPGA resource\n</code></pre>"},{"location":"sw/fpga_tools/readme/#errors-arguments","title":"ERRORS ARGUMENTS","text":"<p>The first argument to the <code>errors</code> command is used to specify what kind of resource to act on. It must be one of the following: <code>fme</code>,<code>port</code>,<code>first_error</code>,<code>pcie0</code>,<code>pcie1</code>,<code>bbs</code>,<code>gbs</code>,<code>all</code> More details on the errors reported for the resource can be found below:</p>"},{"location":"sw/fpga_tools/readme/#errors-resources","title":"ERRORS RESOURCES","text":"<p><code>fme</code></p> <pre><code>Show/clear errors pertaining to the FME\n</code></pre> <p><code>port</code></p> <pre><code>Show/clear errors pertaining to the PORT\n</code></pre> <p><code>first_error</code></p> <pre><code>Show/clear first errors encountered by the FPGA\n</code></pre> <p><code>pcie0</code></p> <pre><code>Show/clear errors pertaining to the PCIE0 lane\n</code></pre> <p><code>pcie1</code></p> <pre><code>Show/clear errors pertaining to the PCIE1 lane\n</code></pre> <p><code>bbs</code></p> <pre><code>Show/clear errors pertaining to the BBS (blue bitstream)\n</code></pre> <p><code>gbs</code></p> <pre><code>Show/clear errors pertaining to the GBS (green bitstream)\n</code></pre> <p><code>all</code></p> <pre><code>Show/clear errors for all resources\n</code></pre>"},{"location":"sw/fpga_tools/readme/#examples","title":"EXAMPLES","text":"<p>This command shows the current power consumtion: <pre><code>./fpgainfo power\n</code></pre></p> <p>This command shows the current temperature reading: <pre><code>./fpgainfo temp\n</code></pre></p> <p>This command shows the errors for the FME resource: <pre><code>./fpgainfo errors fme\n</code></pre> This command clears all the errors on all resources: <pre><code>./fpgainfo errors all -c\n</code></pre></p>"},{"location":"sw/fpga_tools/readme/#fpgaconf","title":"fpgaconf","text":""},{"location":"sw/fpga_tools/readme/#name_1","title":"NAME","text":"<p>fpgadiag - Configure a green bitstream to an FPGA</p>"},{"location":"sw/fpga_tools/readme/#synopsis_1","title":"SYNOPSIS","text":"<p><code>fpgaconf [-hvn] [-b &lt;bus&gt;] [-d &lt;device&gt;] [-f &lt;function&gt;] [-s &lt;socket&gt;] &lt;gbs&gt;</code></p>"},{"location":"sw/fpga_tools/readme/#description_1","title":"DESCRIPTION","text":"<p>fpgaconf writes accelerator configuration bitstreams (also referred to as \"green bitstreams\" to an FPGA device recognized by OPAE. In the process, it also checks the green bitstream file for compatibility with the targeted FPGA and its current infrastructure bitstream (the \"blue bistream\"). fpgaconf takes the following arguments:</p> <p><code>-h, --help</code></p> <pre><code>Print usage information\n</code></pre> <p><code>-v, --verbose</code></p> <pre><code>Print more verbose messages while enumerating and configuring. Can be\ngiven more than once\n</code></pre> <p><code>-n, --dry-run</code></p> <pre><code>Perform enumeration, but skip any operations with side-effects (like the\nactual configuration of the bitstream\n</code></pre> <p><code>-b, --bus</code></p> <pre><code>PCI bus number of the FPGA to target\n</code></pre> <p><code>-d, --device</code></p> <pre><code>PCI device number of the FPGA to target\n</code></pre> <p><code>-f, --function</code></p> <pre><code>PCI function number of the FPGA to target\n</code></pre> <p><code>-s, --socket</code></p> <pre><code>Socket number of the FPGA to target\n</code></pre> <p>fpgaconf will enumerate available FPGA devices in the system and select compatible FPGAs for configuration. If there are more than one candidate FPGAs that are compatible with the given green bitstream, fpgaconf will exit and ask you to be more specific in selecting the target FPGAs (e.g. by specifying a socket number, or a PCIe bus/device/function).</p>"},{"location":"sw/fpga_tools/readme/#examples_1","title":"EXAMPLES","text":"<p><code>fpgaconf my_green_bitstream.gbs</code></p> <pre><code>Program \"my_green_bitstream.gbs\" to a compatible FPGA\n</code></pre> <p><code>fpgaconf -v -s 0 my_green_bitstream.gbs</code></p> <pre><code>Program \"my_green_bitstream.gbs\" to the FPGA in socket 0, if compatible,\nwhile printing out slightly more verbose information\n</code></pre>"},{"location":"sw/fpga_tools/readme/#fpgad","title":"fpgad","text":""},{"location":"sw/fpga_tools/readme/#name_2","title":"NAME","text":"<p>fpgad - log errors and generate events</p>"},{"location":"sw/fpga_tools/readme/#synopsis_2","title":"SYNOPSIS","text":"<p><code>fpgad --daemon [--directory=&lt;dir&gt;] [--logfile=&lt;file&gt;] [--pidfile=&lt;file&gt;] [--umask=&lt;mode&gt;] [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code> <code>fpgad [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_2","title":"DESCRIPTION","text":"<p>Periodically monitors/reports the error status reflected in the device driver's error status sysfs files. Establishes the channel by which events are communicated to the OPAE application. Programs a NULL bitstream in response to AP6 event.</p> <p>fpgad is required to be running before API calls <code>fpgaRegisterEvent</code> and <code>fpgaUnregisterEvent</code> will succeed.</p> <p>Use SIGINT to stop fpgad.</p> <p><code>-d, --daemon</code></p> <pre><code>When given, fpgad executes as a system demon process.\n</code></pre> <p><code>-D, --directory &lt;dir&gt;</code></p> <pre><code>When running in daemon mode, execute from the given directory.\nIf omitted when daemonizing, /tmp is used.\n</code></pre> <p><code>-l, --logfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, send output to file. When not in daemon mode, the output is sent to stdout.\nIf omitted when daemonizaing, /tmp/fpgad.log is used.\n</code></pre> <p><code>-p, --pidfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, write the daemon's process id to file.\nIf omitted when daemonizing, /tmp/fpgad.pid is used.\n</code></pre> <p><code>-m, --umask &lt;mode&gt;</code></p> <pre><code>When running in daemon mode, use the mode value as the file mode creation mask passed to umask.\nIf omitted when daemonizing, 0 is used.\n</code></pre> <p><code>-s, --socket &lt;sock&gt;</code></p> <pre><code>Listen for event API registration requests on sock. The default socket value used by the API is\n/tmp/fpga_event_socket.\n</code></pre> <p><code>-n, --null-bitstream &lt;file&gt;</code></p> <pre><code>Specify the NULL bitstream to program when an AP6 event occurs. This option may be given multiple\ntimes. The bitstream, if any, that matches the FPGA's PR interface id will be programmed when AP6\nis detected.\n</code></pre>"},{"location":"sw/fpga_tools/readme/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>If any issues are encountered, try the following for additional debug information:</p> <ol> <li>Examine the log file when in daemon mode.</li> <li>Run in non-daemon mode and view stdout.</li> </ol>"},{"location":"sw/fpga_tools/readme/#examples_2","title":"EXAMPLES","text":"<p><code>fpgad --daemon --null-bitstream=my_null_bits.gbs</code></p>"},{"location":"sw/fpga_tools/readme/#see-also","title":"SEE ALSO","text":"<p>umask</p>"},{"location":"sw/fpga_tools/readme/#fpgadiag","title":"fpgadiag","text":""},{"location":"sw/fpga_tools/readme/#name_3","title":"NAME","text":"<p>fpgadiag - FPGA diagnosis and testing tool.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_3","title":"SYNOPSIS","text":"<pre><code>fpgadiag [-m | --mode=] &lt;mode&gt; [-t | --target=] &lt;target&gt; [options]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#description_3","title":"DESCRIPTION","text":"<p>fpgadiag includes several tests to diagnose, test and report on the FPGA hardware.</p> <p><code>&lt;mode&gt;</code> chooses which test to run. <code>&lt;target&gt;</code> specifies on what platform to run the test. <code>&lt;target&gt;</code> can be either <code>fpga</code> or <code>ase</code>, where <code>ase</code> stands for \"AFU Simulation Environment\".</p> <p>The tests that can be selected by <code>&lt;mode&gt;</code> include:</p> <p>lpbk1</p> <pre><code>The test performs loopback test on the number of cachelines specified with \nthe `BEGIN` option. _fpgadiag_ sets up source and  destination buffers in \nmain memory. The FPGA then performs a memcpy from a source buffer to the \ndestination buffer, one cacheline at a time.\n\nA cacheline is 64 bytes. When `BEGIN = END`, you perform one iteration. When \n`BEGIN = END + x`, you perform `x` iterations. The first iteration consists \nof copying `BEGIN` cachelines; the second iteration consists of copying \n`BEGIN+1` cache lines; the third iteration consists of copying `BEGIN+3` \ncache lines, etc.\n\nThe latency is shown as the number of clock ticks.\n\nWhen you specify `MULTI-CL`, you copy `MULTI-CL` cache lines at a time.\nThere is always a WrFence. `WR-FENCE` chooses what virtual channel the \nWrFence occurs on.\n\nIf you specify continuous mode with `--cont`, the program runs an iteration\nuntil the timeout specified in `TIMEOUT` completes.\n</code></pre> <p>read</p> <pre><code>This test performs only a read, not a memcpy. It is used to measure read \nbandwidth.\n</code></pre> <p>write </p> <pre><code>This test is used to measure write bandwidth.\n</code></pre> <p>trput</p> <pre><code>This test measures both read and write bandwidth by performing 50% read and \n50% write tests.\n</code></pre> <p>sw</p> <pre><code>This is a send-and-respond (ping-pong) test where one side sends data and \nwaits for answer.\n</code></pre> <p>Each test requires presence of one of these bitstreams, as documented below. Before running a test, make sure its required bitstream is properly configured on the platform.</p> <ul> <li>nlb mode 0 for the <code>lpbk1</code> test.</li> <li>nlb mode 3 for the <code>trput</code>, <code>read</code>, and <code>write</code> tests.</li> <li>nlb mode 7 for the <code>sw</code> test.</li> </ul>"},{"location":"sw/fpga_tools/readme/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/readme/#common-options_1","title":"Common options","text":"<p><code>--help, -h</code></p> <pre><code>Print help information and exit.\n</code></pre> <p><code>--target=, -t</code></p> <pre><code>Values accepted for this switch are fpga or ase. Default=fpga\n</code></pre> <p><code>--mode=, -m</code></p> <pre><code>The test to run. Values accepted for this switch are `lpbk1`, `read`,\n`write`, `trput`, `sw`\n</code></pre> <p><code>--config=, -c</code></p> <pre><code>A configuration file in the JSON format that specifies options for a test.\nIf an option is specified both in the configuration file and on the command \nline, the value in the configuration file prevails\n</code></pre> <p><code>--socket-id=, -s</code></p> <pre><code>Socket ID encoded in BBS. Default=0\n</code></pre> <p><code>--bus-number=, -B</code></p> <pre><code>Bus number of the PCIe device. Default=0\n</code></pre> <p><code>--device=, -D</code></p> <pre><code>Device number of the PCIe device. Default=0\n</code></pre> <p><code>--function=, -F</code></p> <pre><code>Function number of the PCIe device. Default=0\n</code></pre> <p><code>--freq=, -T</code></p> <pre><code>Clock frequency in Hz. Default=400 MHz\n</code></pre> <p><code>--suppress-hdr, -S</code></p> <pre><code>Suppress column headers for text output. Default=off\n</code></pre> <p><code>--csv, -V</code></p> <pre><code>Comma separated value format. Default=off\n</code></pre>"},{"location":"sw/fpga_tools/readme/#lpbk1-test-options","title":"lpbk1 test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=D8424DC4-A4A3-C413-F89E-433683F9040B\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -U</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I Default=wrline-M\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. Default=auto\n</code></pre>"},{"location":"sw/fpga_tools/readme/#read-test-options","title":"read test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Attempt to prime the cache with hits. Default=off, Attempt to prime the \ncache with misses. Default=off\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Attempt to prime the cpu cache with misses. Default=off\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre>"},{"location":"sw/fpga_tools/readme/#write-test-options","title":"write test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I Default=wrline-M\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Attempt to prime the cache with hits. Default=off, Attempt to prime the \ncache with misses. Default=off\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Attempt to prime the cpu cache with misses. Default=off\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=`WRITE-VC`\n</code></pre> <p><code>--alt-wr-pattern, -l</code></p> <pre><code>Alternate Write Pattern. Default=off\n</code></pre>"},{"location":"sw/fpga_tools/readme/#trput-test-options","title":"trput test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I Default=wrline-M\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be  auto, vl0, vh0, vh1. Default=`WRITE-VC`\n</code></pre>"},{"location":"sw/fpga_tools/readme/#sw-test-options","title":"sw test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=7BAF4DEA-A57C-E91E-168A-455D9BDA88A3\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I. Default=wrline-M\n</code></pre> <p><code>--cache-hint= -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random Default=auto\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. Default=`WRITE-VC`\n</code></pre> <p><code>--notice=, -N</code></p> <pre><code>Can be poll, csr-write, umsg-data, or umsg-hint. Default=poll\n</code></pre>"},{"location":"sw/fpga_tools/readme/#examples_3","title":"EXAMPLES","text":"<p>This command starts an <code>lpbk1</code> test on the FPGA on bus <code>0x5e</code>. The test  copies 57535, 57536, 57537, ..., up to 65535 cache lines, one line at a time. The test output is printed in the CSV format with header suppressed. <pre><code>./fpgadiag --mode=lpbk1 --target=fpga -SV --bus-number=0x5e --begin=57535\n--end=65535 --cache-hint=rdline-I --cache-policy=wrpush-I --multi-cl=1\n--write-vc=vl0 --read-vc=vh1 --wrfence-vc=auto\n</code></pre></p> <p>This command starts a <code>read</code> test on the FPGA located on bus <code>0xbe</code>. The test reads 2045 cache lines in the continuous mode with a 15-second timeout period.  Data is accessed with a strided pattern with a 10-byte stride length. <pre><code>./fpgadiag --mode=read --target=fpga -SV --bus-number=0xbe --begin=2045 --cont\n--timeout-sec=15   --cache-hint=rdline-I --multi-cl=1 -a=10 --write-vc=vh1\n--read-vc=auto --wrfence-vc=auto\n</code></pre></p> <p>This command starts an <code>sw</code> test on the FPGA located on bus <code>0xbe</code>. The test notifies completion using a CSR write. <pre><code>./fpgadiag --mode=sw --target=fpga -SV --bus-number=0xbe --begin=4 --end=8192\n--cache-hint=rdline-I --cache-policy=wrline-I --notice=csr-write --write-vc=vl0\n--wrfence-vc=auto --read-vc=random \n</code></pre></p>"},{"location":"sw/fpga_tools/readme/#troubleshooting_1","title":"TROUBLESHOOTING","text":"<p>When a test fails to run or gives errors, check the following:</p> <ul> <li>Is Intel FPGA driver properly installed?  See Installation Guide  for driver installation instructions.</li> <li>Are FPGA port permissions set properly? Check the permission bits of the port, for example, <code>/dev/intel-fpga-port-0</code>. Users need READ and WRITE permissions to run <code>fpgadiag</code> tests.</li> <li>Is hugepage properly configured on the system?  See Installation Guide for hugepage configuration steps.</li> <li>Is the required bitstream loaded? See DESCRIPTION for information about what bitstream is required by which test.</li> <li>Are <code>--begin</code> and <code>--end</code> values set properly? <code>--end</code> must be no smaller than the <code>--begin</code>. Also, <code>--begin</code> must be a multiple of the <code>--multi-cl</code> value.</li> <li>The <code>--warm-fpga-cache</code> and <code>--cool-fpga-cache</code> options in the <code>read</code> and <code>write</code> tests are mutually exclusive.</li> <li>The timeout options are only meaningful for the continuous mode  (with the <code>--cont</code> option).</li> </ul>"},{"location":"sw/fpga_tools/readme/#mmlink","title":"mmlink","text":""},{"location":"sw/fpga_tools/readme/#name_4","title":"NAME","text":"<p>MMLink - Debugging RTL.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_4","title":"SYNOPSIS","text":"<p><code>mmlink [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;TCP port&gt;] [-I &lt;IP Address&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_4","title":"DESCRIPTION","text":"<p>Remote signaltap is software  tool used for debug RTL (AFU), effectively a signal trace capability that Quartus places into a green bitstream. Remote Signal Tap provides  access the RST part of the Port MMIO space, and then runs the remote protocol on top.</p>"},{"location":"sw/fpga_tools/readme/#examples_4","title":"EXAMPLES","text":"<p><code>./mmlink  -B 0x5e -P 3333</code></p> <p>MMLink app starts and listens for connection.</p>"},{"location":"sw/fpga_tools/readme/#options_1","title":"OPTIONS","text":"<p><code>-B,--bus</code> FPGA Bus number.</p> <p><code>-D,--device</code> FPGA Device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-P,--port</code> TCP port number.</p> <p><code>-I,--ip</code> IP address of FPGA system. </p>"},{"location":"sw/fpga_tools/readme/#notes","title":"NOTES","text":"<p>Driver privilege:</p> <p>Change AFU driver privilege to user .</p> <p>command: chmod 777 /dev/intel-fpga-port.0</p> <p>set memlock:    </p> <p>command: ulimit -l 10000</p>"},{"location":"sw/fpga_tools/readme/#coreidle","title":"coreidle","text":""},{"location":"sw/fpga_tools/readme/#name_5","title":"NAME","text":"<p>coreidle - idles cores for shared TDP sockets to run online cores at maximum capacity.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_5","title":"SYNOPSIS","text":"<p><code>coreidle [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-G &lt;GBS path&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_5","title":"DESCRIPTION","text":"<p>This tools parses input GBS, extracts power from metadata ,calculates fpga power, number of online and idle cores. It moves threads from idle cores to online cores.</p>"},{"location":"sw/fpga_tools/readme/#examples_5","title":"EXAMPLES","text":"<p><code>./coreidle  -B 0x5e -G /home/lab/gbs/mode0.gbs</code></p> <p>Idle cores to run online cores at maximum capacity.</p>"},{"location":"sw/fpga_tools/readme/#options_2","title":"OPTIONS","text":"<p><code>-B,--bus</code> FPGA Bus number.</p> <p><code>-D,--device</code> FPGA Device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-G,--gbs</code> Green bitstream file path.</p>"},{"location":"sw/fpga_tools/readme/#fpgamux","title":"fpgamux","text":""},{"location":"sw/fpga_tools/readme/#name_6","title":"NAME","text":"<pre><code>fpgamux - Software MUX for running multiple AFU (accelerator functional unit) tests in one GBS (green bitsream)\n</code></pre>"},{"location":"sw/fpga_tools/readme/#synopsis_6","title":"SYNOPSIS","text":"<pre><code>fpgamux [-h] [-S|--socket-id SOCKET_ID] [-B|--bus-number BUS] [-D|--device DEVICE] [-F|--function FUNCTION]\n          [-G|--guid GUID] -m|--muxfile MUXFILE.json\n</code></pre>"},{"location":"sw/fpga_tools/readme/#description_6","title":"DESCRIPTION","text":"<p>fpgamux is a testing tool to interact with multiple AFUs that have been synthesized into one GBS along with the CCIP-MUX BBB (basic building block). The CCIP-MUX uses upper bits in the MMIO addresses to route MMIO reads/writes to the AFU running on the corresponding CCIP-MUX port. fpgamux uses a configuration file that lists the software components and configuration to use.</p> <p>.. note::</p> <pre><code>  Only one (the first) AFU is discoverable by the OPAE driver. Enumerating acceleration on an FPGA will find\n  the accelerator associated with the first AFU only. The first software component in the configuration will\n  be used to determine the GUID to use for enumeration. This can be overridden with the -G|--guid option.\n</code></pre>"},{"location":"sw/fpga_tools/readme/#options_3","title":"OPTIONS","text":"<pre><code>-S SOCKET_ID, --socket-id SOCKET_ID\n   socket id of FPGA resource\n\n-B BUS, --bus BUS\n   bus id of FPGA resource\n\n-D DEVICE, --device DEVICE\n   device id of FPGA resource\n\n\n-F FUNCTION, --function FUNCTION\n   function id of FPGA resource\n\n-G, --guid\n   specify what guid to use for the accelerator enumeration\n</code></pre>"},{"location":"sw/fpga_tools/readme/#configuration","title":"CONFIGURATION","text":"<p>fpgamux uses a configuration file (in JSON format) to determine what software components to instantiate and how to configure them for interacting with the AFUs in the GBS. This schema for this is listed below:</p> <pre><code>[\n    {\n        \"app\" : \"fpga_app\",\n        \"name\" : \"String\",\n        \"config\" : \"Object\"\n    }\n]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#examples_6","title":"EXAMPLES","text":"<p>An example configuration with two components is listed below:</p> <pre><code>[\n    {\n        \"app\" : \"nlb0\",\n        \"name\" : \"nlb0\",\n        \"config\" :\n        {\n            \"begin\" : 1,\n            \"end\" : 1,\n            \"multi-cl\" : 1,\n            \"cont\" : false,\n            \"cache-policy\" : \"wrline-M\",\n            \"cache-hint\" : \"rdline-I\",\n            \"read-vc\" : \"vh0\",\n            \"write-vc\" : \"vh1\",\n            \"wrfence-vc\" : \"write-vc\",\n            \"timeout-usec\" : 0,\n            \"timeout-msec\" : 0,\n            \"timeout-sec\" : 1,\n            \"timeout-min\" : 0,\n            \"timeout-hour\" : 0,\n            \"freq\" : 400000000\n        }\n    },\n    {\n        \"app\" : \"nlb3\",\n        \"name\" : \"nlb3\",\n        \"config\" :\n        {\n            \"mode\" : \"read\",\n            \"begin\" : 1,\n            \"end\" : 1,\n            \"multi-cl\" : 1,\n            \"strided-access\" : 1,\n            \"cont\" : false,\n            \"warm-fpga-cache\" : false,\n            \"cool-fpga-cache\" : false,\n            \"cool-cpu-cache\" : false,\n            \"cache-policy\" : \"wrline-M\",\n            \"cache-hint\" : \"rdline-I\",\n            \"read-vc\" : \"vh0\",\n            \"write-vc\" : \"vh1\",\n            \"wrfence-vc\" : \"write-vc\",\n            \"alt-wr-pattern\" : false,\n            \"timeout-usec\" : 0,\n            \"timeout-msec\" : 0,\n            \"timeout-sec\" : 1,\n            \"timeout-min\" : 0,\n            \"timeout-hour\" : 0,\n            \"freq\" : 400000000\n        }\n    }\n]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#userclk","title":"userclk","text":""},{"location":"sw/fpga_tools/readme/#name_7","title":"NAME","text":"<p>userclk - to set afu high and low clock frequency.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_7","title":"SYNOPSIS","text":"<p><code>userclk [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;Port id&gt;] [-H &lt;User clock high frequency&gt;] -L &lt;User clock low frequency&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_7","title":"DESCRIPTION","text":"<p>userclk tool used to set high and low clock frequency to acceleration function unit.</p>"},{"location":"sw/fpga_tools/readme/#examples_7","title":"EXAMPLES","text":"<p><code>./userclk  -B 0x5e -H 400 -L 200</code></p> <p>Sets AFU frequency.</p>"},{"location":"sw/fpga_tools/readme/#options_4","title":"OPTIONS","text":"<p><code>-B,--bus</code> FPGA Bus number.</p> <p><code>-D,--device</code> FPGA Device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-P,--port</code> Port id.</p> <p><code>-H,--freq-high</code> User clock high frequency. </p> <p><code>-L,--freq-low</code> User clock low frequency. </p>"},{"location":"sw/fpga_tools/coreidle/coreidle/","title":"coreidle","text":""},{"location":"sw/fpga_tools/coreidle/coreidle/#synopsis","title":"SYNOPSIS","text":"<p><code>coreidle [-v] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-G &lt;GBS path&gt;]</code></p>"},{"location":"sw/fpga_tools/coreidle/coreidle/#description","title":"DESCRIPTION","text":"<p><code>coreidle</code> parses the Accelerator Function Unit (AFU) metadata and extracts power information. <code>coreidle</code> calculates the FPGA power and calculates the number of online and idle cores. It moves threads from idle cores to online cores.  <code>coreidle</code> is only available the Integrated FPGA Platform. You cannot run <code>coreidle</code> on the PCIe Accelerator Card (PAC).</p>"},{"location":"sw/fpga_tools/coreidle/coreidle/#examples","title":"EXAMPLES","text":"<p><code>./coreidle  -B 0x5e -G /home/lab/gbs/mode0.gbs</code></p> <p>Idle cores to run online cores at maximum capacity.</p>"},{"location":"sw/fpga_tools/coreidle/coreidle/#options","title":"OPTIONS","text":"<p><code>-v,--version</code> Prints version information and exit.</p> <p><code>-B,--bus</code> FPGA bus number.</p> <p><code>-D,--device</code> FPGA device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-G,--gbs</code> Green bitstream file path.</p>"},{"location":"sw/fpga_tools/fecmode/fecmode/","title":"fecmode (N3000 specific tool)","text":""},{"location":"sw/fpga_tools/fecmode/fecmode/#synopsis","title":"SYNOPSIS","text":"<pre><code>fecmode [&lt;mode&gt;][&lt;args&gt;]\n</code></pre>"},{"location":"sw/fpga_tools/fecmode/fecmode/#description","title":"DESCRIPTION","text":"<p>Fecmode changes FEC mode of external ethernet PHY, this tool only support on N3000 Card.</p>"},{"location":"sw/fpga_tools/fecmode/fecmode/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>--segment, -S</code></p> <p>segment number of the PCIe device.</p> <p><code>--bus, -B</code> </p> <p>bus number of the PCIe device. </p> <p><code>--device, -D</code> </p> <p>device number of the PCIe device.</p> <p><code>--function, -F</code> function number of the PCIe device</p> <p><code>--rsu, -r</code> reboot card only if mode is not configured</p> <p><code>--debug, -d</code> output debug information </p>"},{"location":"sw/fpga_tools/fecmode/fecmode/#fec-mode","title":"FEC Mode","text":"<p><code>no</code> no FEC.</p> <p><code>kr</code> BaseR FEC (Fire-Code) correction \u2013 4 orders</p> <p><code>rs</code> Reed-Solomon FEC correction \u2013 7 orders</p>"},{"location":"sw/fpga_tools/fecmode/fecmode/#example","title":"EXAMPLE","text":"<p>This command change FEC mode to \u201ckr\u201d: <pre><code># fecmode -B 0x25 kr\n</code></pre></p> <p>This command reboot card (no need to specify bus number if there is only one card): <pre><code># fecmode -r\n</code></pre></p> <p>This command display the current FEC mode: <pre><code># fecmode\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/","title":"fpgabist","text":""},{"location":"sw/fpga_tools/fpgabist/fpgabist/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgabist [-h] [-i device_id] [-b bus] [-d device] [-f function] [path_to_gbs1 path_to_gbs2 ...]\n</code></pre>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#description","title":"DESCRIPTION","text":"<p>The <code>fpgabist</code> tool performs self-diagnostic tests on supported FPGA platforms.</p> <p>The tool accepts one or more Accelerator Function (AF) binaries from a predetermined set of AFs. Depending on the available binaries,  the tool runs appropriate tests and reports hardware issues.</p> <p><code>fpgabist</code> always uses <code>fpgainfo</code> to report system information before running any hardware tests.</p> <p>Currently, <code>fpgabist</code> accepts the following AFs:    1. nlb_mode_3: The native loopback (NLB) test implements a loopback from TX to RX. Use it to verify basic functionality    and to measure bandwidth.    2. dma_afu: The direct memory access (DMA) AFU test transfers data from host memory to FPGA-attached local memory. </p> <p>The installation includes the AF files, but you can also compile the AFs from the source. </p> <p>If there are multiple PCIe\u00ae devices, use -b, -d, -f to specify the BDF for the specific PCIe\u00ae device.</p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>[path_to_gbs1 path_to_gbs2 ...]</code></p> <p>Paths to Accelerator Function (AF) files.</p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p>You can use the single letter or the full parameter name for the command line arguments.</p> <p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>-i device_id, --device-id device_id</code></p> <p>Device ID for Intel FPGA. Default is: 0x09c4</p> <p><code>-B bus, --bus bus</code></p> <p>Bus number for specific FPGA</p> <p><code>-D device, --device device</code></p> <p>Device number for specific FPGA</p> <p><code>-F function, --function function</code></p> <p>Function number for specific FPGA</p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#examples","title":"EXAMPLES","text":"<p><code>fpgabist &lt;path_to_gbs_files&gt;/dma_afu.gbs &lt;path_to_gbs_files&gt;/nlb_3.gbs</code></p> <p>Runs <code>fpgabist</code> on any platform in the system that matches the default device ID. This command runs both the DMA and   NLB_MODE_3 tests.</p> <p><code>fpgabist -i 09c4 -b 5 &lt;path to gbs&gt;/dma_afu.gbs</code></p> <p>Runs <code>fpgabist</code> the DMA test on the PCIe\u00ae  Endpoint with <code>device_id</code> 09c4 on bus 5. </p>"},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/","title":"fpgaconf","text":""},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgaconf [-hvVn] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] &lt;gbs&gt;</code></p>"},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/#description","title":"DESCRIPTION","text":"<p><code>fpgaconf</code> configures the FPGA with the accelerator function (AF). It also checks the AF for compatibility with  the targeted FPGA and the FPGA Interface Manager (FIM). <code>fpgaconf</code> takes the following arguments: </p> <p><code>-h, --help</code></p> <pre><code>Prints usage information.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-V, --verbose</code></p> <pre><code>Prints more verbose messages while enumerating and configuring. Can be\nrequested more than once.\n</code></pre> <p><code>-n, --dry-run</code></p> <pre><code>Performs enumeration. Skips any operations with side-effects such as the\nactual AF configuration.\n</code></pre> <p><code>-S, --segment</code></p> <pre><code>PCIe segment number of the target FPGA.\n</code></pre> <p><code>-B, --bus</code></p> <pre><code>PCIe bus number of the target FPGA.\n</code></pre> <p><code>-D, --device</code></p> <pre><code>PCIe device number of the target FPGA.\n</code></pre> <p><code>-F, --function</code></p> <pre><code>PCIe function number of the target FPGA.\n</code></pre> <p><code>--force</code></p> <pre><code>Reconfigure the AFU even if it is in use.\n</code></pre> <p><code>fpgaconf</code> enumerates available FPGA devices in the system and selects compatible FPGAs for configuration. If more than one FPGA is compatible with the AF, <code>fpgaconf</code> exits and asks you to be more specific in selecting the target FPGAs by specifying a a PCIe BDF.</p>"},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/#examples","title":"EXAMPLES","text":"<p><code>fpgaconf my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to a compatible FPGA.\n</code></pre> <p><code>fpgaconf -V -B 0x3b my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA in bus 0x3b, if compatible,\nwhile printing out slightly more verbose information.\n</code></pre> <p><code>fpgaconf 0000:3b:00.0 my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA at address 0000:3b:00.0.\n</code></pre>"},{"location":"sw/fpga_tools/fpgad/fpgad/","title":"fpgad","text":""},{"location":"sw/fpga_tools/fpgad/fpgad/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgad --daemon [--version] [--directory=&lt;dir&gt;] [--logfile=&lt;file&gt;] [--pidfile=&lt;file&gt;] [--umask=&lt;mode&gt;] [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code> <code>fpgad [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code></p>"},{"location":"sw/fpga_tools/fpgad/fpgad/#description","title":"DESCRIPTION","text":"<p>fpgad monitors the device sensors, checking for sensor values that are out of the prescribed range. </p> <p>When any of the sensors is detected to be out of bounds, fpgad will focus on keeping the server from rebooting by masking PCIE AER, and send a message to system administrator. System administrator can take further actions like stop the application and stop the FPGA, but fpgad just focus on monitor the sensors and will not take any cooling actions. </p> <p>Note: fpgad must be running (as root) and actively monitoring devices when a sensor anomaly occurs in order to initiate Graceful Shutdown.  If fpgad is not loaded during such a sensor anomaly, the out-of-bounds scenario will not be detected, and the resulting effect on the hardware is undefined.</p>"},{"location":"sw/fpga_tools/fpgad/fpgad/#arguments","title":"ARGUMENTS","text":"<p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-d, --daemon</code></p> <pre><code>When specified, fpgad executes as a system daemon process.\n</code></pre> <p><code>-D, --directory &lt;dir&gt;</code></p> <pre><code>When running in daemon mode, run from the specified directory.\nIf omitted when daemonizing, `fpgad` uses /tmp.\n</code></pre> <p><code>-l, --logfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, send output to file. When not in daemon mode, the output goes to stdout.\nIf omitted when daemonizaing, fpgad uses /tmp/fpgad.log.\n</code></pre> <p><code>-p, --pidfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, write the daemon's process id to a file.\nIf omitted when daemonizing, fpgad uses /tmp/fpgad.pid.\n</code></pre> <p><code>-m, --umask &lt;mode&gt;</code></p> <pre><code>When running in daemon mode, use the mode value as the file mode creation mask passed to umask.\nIf omitted when daemonizing, fpgad uses 0.\n</code></pre> <p><code>-s, --socket &lt;sock&gt;</code></p> <pre><code>Listen for event API registration requests on the UNIX domain socket on the specified path. \nThe default=/tmp/fpga_event_socket.\n</code></pre> <p><code>-n, --null-bitstream &lt;file&gt;</code></p> <pre><code>Specify the NULL bitstream to program when an AP6 event occurs. This option may be specified multiple\ntimes. The AF, if any, that matches the FPGA's PR interface ID is programmed when an AP6\nevent occurs.\n</code></pre>"},{"location":"sw/fpga_tools/fpgad/fpgad/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>If you encounter any issues, you can get debug information in two ways:</p> <ol> <li>By examining the log file when in daemon mode.</li> <li>By running in non-daemon mode and viewing stdout.</li> </ol>"},{"location":"sw/fpga_tools/fpgad/fpgad/#examples","title":"EXAMPLES","text":"<p><code>fpgad --daemon --null-bitstream=my_null_bits.gbs</code></p> <p>This command starts fpgad as a system daemon process: <pre><code>sudo systemctl start fpgad\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgadiag/","title":"fpgadiag","text":""},{"location":"sw/fpga_tools/fpgadiag/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgadiag [-m | --mode=] &lt;mode&gt; [-t | --target=] &lt;target&gt; [options]\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#description","title":"DESCRIPTION","text":"<p>Includes several tests to diagnose, test, and report on the FPGA hardware.</p> <p><code>&lt;mode&gt;</code> chooses which test to run.  <code>&lt;target&gt;</code> specifies the platform that runs the test. <code>&lt;target&gt;</code> can be either <code>fpga</code> or <code>ase</code> where <code>ase</code>.  <code>&lt;ase&gt;</code> is the abbreviation for Accelerator Simulation Environment.</p> <p>The <code>&lt;mode&gt;</code> selects from the  following tests:</p> <p>lpbk1</p> <p>This test runs a loopback test on the number of cachelines specified with  the <code>BEGIN</code> option. <code>fpgadiag</code> sets up source and  destination buffers in  main memory. The FPGA then performs a <code>memcpy</code> from a source buffer to the  destination buffer, one cacheline at a time. </p> <p>A cacheline is 64 bytes. When <code>BEGIN = END</code>, the test performs one iteration. When  <code>BEGIN = END + x</code>, the test performs <code>x</code> iterations. The first iteration consists  of copying <code>BEGIN</code> cachelines; the second iteration consists of copying  <code>BEGIN+1</code> cache lines. The third iteration consists of copying <code>BEGIN+2</code>  cache lines, and so on. </p> <p>The latency is shown as the number of clock cycles. </p> <p>When you specify <code>MULTI-CL</code>, you copy <code>MULTI-CL</code> cache lines at a time. The WR-FENCE chooses on which virtual channel the WrFence occurs.</p> <p>If you specify continuous mode with <code>--cont</code>, the program iterates until the timeout specified in <code>TIMEOUT</code> completes.</p> <p>read</p> <p>This test performs reads. Use this test to measure read bandwidth. </p> <p>write </p> <p>This test performs writes. Use it to measure write bandwidth. </p> <p>trput</p> <p>This test measures both read and write bandwidth by performing 50% read and  50% write tests.</p> <p>sw</p> <p>This is a send-and-respond (ping-pong) test. One side sends data and  waits for response.</p> <p>Each test requires a particular AF. Before running a test, make sure the required AF is properly configured on the platform. </p> <ul> <li>The lpbk1 test requires the nlb mode 0 AF.</li> <li>The trput test requires the nlb mode 3 AF. </li> <li>The sw test requires the nlb mode 7 AF. This AF is only available for the integrated FPGA platform.      You cannot run it on the PCIe accelerator card (PAC).</li> </ul> <p>fpgalpbk</p> <p>This enable/disable FPGA loopback.</p> <p>fpgastats</p> <p>This get fpga mac statistics.</p> <p>mactest</p> <p>This compare mac addresses that read from MAC ROM with mac addresses read from Host side.</p>"},{"location":"sw/fpga_tools/fpgadiag/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/fpgadiag/#common-options","title":"Common options","text":"<p><code>--help, -h</code></p> <pre><code>Print help information and exit.\n</code></pre> <p><code>--target=, -t</code></p> <pre><code>This switch specifies fpga (hardware) or ase (simulation). The default=fpga.\n</code></pre> <p><code>--mode=, -m</code></p> <pre><code>The test to run. The valid values are `lpbk1`, `read`,\n`write`, `trput`, and `sw`.\n</code></pre> <p><code>--config=, -c</code></p> <pre><code>A configuration file in the JSON format that specifies options for a test.\nIf an option is specified both in the configuration file and on the command \nline, the value in the configuration file takes precedence.\n</code></pre> <p><code>--dsm-timeout-usec</code></p> <pre><code>Timeout in microseconds for test completion. The test fails if not completed by \nspecified timeout. The default=1000000.\n</code></pre> <p><code>--socket-id=, -s</code></p> <pre><code>Socket ID encoded in FPGA Interface Manager (FIM). The default=0.\n</code></pre> <p><code>--bus=, -B</code></p> <pre><code>Bus number of the PCIe device. The default=0.\n</code></pre> <p><code>--device=, -D</code></p> <pre><code>Device number of the PCIe device. The default=0.\n</code></pre> <p><code>--function=, -F</code></p> <pre><code>Function number of the PCIe device. The default=0.\n</code></pre> <p><code>--freq=, -T</code></p> <pre><code>Clock frequency (in Hz) used for bandwidth calculation. The default=400000000 Hz (400 MHz).\n</code></pre> <p><code>eval_rst .. note::     This frequency is used only when the software cannot infer the frequency from the accelerator.</code></p> <p><code>--suppress-hdr, -S</code></p> <pre><code>Suppress column headers for text output. The default=off.\n</code></pre> <p><code>--csv, -V</code></p> <pre><code>Comma separated value format. The default=off.\n</code></pre> <p><code>--suppress-stats</code></p> <pre><code>Suppress statistics output at the end of test. The default=off.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#lpbk1-test-options","title":"lpbk1 test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=D8424DC4-A4A3-C413-F89E-433683F9040B.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I The default=wrline-M.\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. The default=auto.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#read-test-options","title":"read test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. The default=1.\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Try to prime the cache with hits. The default=off. Try to prime the \ncache with misses. The default=off.\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Try to prime the cpu cache with misses. The default=off.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#write-test-options","title":"write test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. The default=1.\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I The default=wrline-M\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Try to prime the cache with hits. The default=off. Try to prime the \ncache with misses. The default=off.\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Try to prime the cpu cache with misses. The default=off.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=`WRITE-VC`.\n</code></pre> <p><code>--alt-wr-pattern, -l</code></p> <pre><code>Alternate Write Pattern. The default=off.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#trput-test-options","title":"trput test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. The default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I The default=wrline-M.\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be  auto, vl0, vh0, vh1. The default=`WRITE-VC`.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#sw-test-options","title":"sw test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=7BAF4DEA-A57C-E91E-168A-455D9BDA88A3.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I. The default=wrline-M.\n</code></pre> <p><code>--cache-hint= -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random The default=auto.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. The default=`WRITE-VC`.\n</code></pre> <p><code>--notice=, -N</code></p> <pre><code>Can be poll or csr-write. The default=poll.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#enable-fpga-n3000-ethernet-group-vfio-mdev","title":"Enable FPGA N3000 Ethernet group VFIO mdev","text":"<p>FPGA DFL driver does not support any ioctls to read/write ethernet group info and registers. Users can read/write eth group registers by enabling VFIO mdev. Unbind the dfl_eth_group driver and bind vfio-mdev-dfl driver for ethernet group dfl-device; then userspace can take full control of ethernet group feature id 10.</p> <p>Ethernet group must be enabled before running fpgalpbk, mactest tools.</p>"},{"location":"sw/fpga_tools/fpgadiag/#steps-to-enablecreate-vfio-mdev","title":"Steps to enable/create vfio mdev","text":"<pre><code>unbind eth group feature id 10:\n    echo dfl-fme.0.8 &gt; /sys/bus/dfl/drivers/dfl-eth-group/unbind\n    echo dfl-fme.0.7 &gt; /sys/bus/dfl/drivers/dfl-eth-group/unbind\nbind to vfio-mdev-dfl:\n    echo vfio-mdev-dfl &gt; /sys/bus/dfl/devices/dfl-fme.0.7/driver_override\n    echo vfio-mdev-dfl &gt; /sys/bus/dfl/devices/dfl-fme.0.8/driver_override\nload vfio driver:\n    modprobe vfio_pci\n    modprobe vfio_iommu_type1\n    modprobe vfio_mdev\n    modprobe vfio_mdev_dfl\ntrigger mdev:\n    echo dfl-fme.0.7 &gt;/sys/bus/dfl/drivers_probe\n    echo dfl-fme.0.8 &gt;/sys/bus/dfl/drivers_probe\n    echo 83b8f4f2-509f-382f-3c1e-e6bfe0fa1001 &gt; /sys/bus/dfl/devices/dfl-fme.0.7/mdev_supported_types/vfio-mdev-dfl-1/create\n    echo 83b8f4f2-509f-382f-3c1e-e6bfe0fa1002 &gt; /sys/bus/dfl/devices/dfl-fme.0.8/mdev_supported_types/vfio-mdev-dfl-1/create\n\nlinux kerenl msg after enabling mdev:\n    i40e 0000:b3:00.0 eth1: NIC Link is Down\n    i40e 0000:b1:00.1 eth0: NIC Link is Down\n    vfio-mdev-dfl dfl-fme.2.7: MDEV: Registered\n    vfio-mdev-dfl dfl-fme.2.8: MDEV: Registered\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1005: Adding to iommu group 140\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1005: MDEV: group_id = 140\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1006: Adding to iommu group 141\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1006: MDEV: group_id = 141\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#remove-vfio-mdev","title":"Remove vfio mdev","text":"<pre><code>    echo 1 | sudo tee /sys/bus/mdev/devices/83b8f4f2-509f-382f-3c1e-e6bfe0fa1002/remove\n    echo 1 | sudo tee /sys/bus/mdev/devices/83b8f4f2-509f-382f-3c1e-e6bfe0fa1001/remove\n\n    rmmod vfio_mdev_dfl\n    modprobe dfl_eth_group\n\n    echo dfl-fme.0.7 &gt;/sys/bus/dfl/drivers_probe\n    echo dfl-fme.0.8 &gt;/sys/bus/dfl/drivers_probe\n\n    echo dfl-eth-group &gt; /sys/bus/dfl/devices/dfl-fme.0.7/driver_override\n    echo dfl-eth-group &gt; /sys/bus/dfl/devices/dfl-fme.0.8/driver_override\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#fpgalpbk-test-options","title":"fpgalpbk test options","text":"<p><code>--enable</code></p> <pre><code>Enable fpga phy loopback.\n</code></pre> <p><code>--disable</code></p> <pre><code>Disable fpga phy loopback.\n</code></pre> <p><code>--direction</code></p> <pre><code>Can be local, remote.\n</code></pre> <p><code>--type</code></p> <pre><code>Can be serial, precdr, postcdr.\n</code></pre> <p><code>--side</code></p> <pre><code>Can be line, host.\n</code></pre> <p><code>--port</code></p> <pre><code>0 &lt;= port &lt;= 7, the default is all.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#mactest-test-options","title":"mactest test options","text":"<p><code>--offset</code></p> <pre><code>Read mac addresses from an offset, The default=0.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#examples","title":"EXAMPLES","text":"<p>This command starts a <code>lpbk1</code> test for the FPGA on bus <code>0x5e</code>. The test  copies 57535, 57536, 57537 ... up to 65535 cache lines, one line at a time. The test prints output in the comma separated values (CSV) format with the header suppressed. <pre><code>./fpgadiag --mode=lpbk1 --target=fpga -V --bus=0x5e --begin=57535\n--end=65535 --cache-hint=rdline-I --cache-policy=wrpush-I --multi-cl=1\n--write-vc=vl0 --read-vc=vh1 --wrfence-vc=auto\n</code></pre></p> <p>This command starts a <code>read</code> test on the FPGA located on bus <code>0xbe</code>. The test reads 2045 cache lines in the continuous mode with a 15-second timeout period.  The reads use a strided pattern with a 10-byte stride length. <pre><code>./fpgadiag --mode=read --target=fpga -V --bus=0xbe --begin=2045 --cont\n--timeout-sec=15 --cache-hint=rdline-I --multi-cl=1 -a=10 \n--read-vc=auto --wrfence-vc=auto\n</code></pre></p> <p>This command starts a <code>sw</code> test on the FPGA located on bus <code>0xbe</code>. The test signals completion using a CSR write. <pre><code>./fpgadiag --mode=sw --target=fpga -V --bus=0xbe --begin=4 --end=8192\n--cache-hint=rdline-I --cache-policy=wrline-I --notice=csr-write --write-vc=vl0\n--wrfence-vc=auto --read-vc=random \n</code></pre></p> <p>This command enable a <code>fpgalpbk</code> on the FPGA located on bus <code>0xbe</code>. <pre><code>./fpgadiag -m fpgalpbk --bus 0xbe --enable --direction local --type postcdr\n--side host\n</code></pre></p> <p>This command show <code>fpgastats</code> on the FPGA located on bus <code>0xbe</code>. <pre><code>./fpgadiag -m fpgastats --bus 0xbe\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgadiag/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>When a test fails to run or gives errors, check the following:</p> <ul> <li>Is the Intel FPGA driver properly installed?  See Installation Guide  for driver installation instructions.</li> <li>Are FPGA port permissions set properly? Check the permission bits of the port, for example, <code>/dev/intel-fpga-port-0</code>. You need READ and WRITE permissions to run <code>fpgadiag</code> tests.</li> <li>Is hugepage properly configured on the system?  See Installation Guide for hugepage configuration steps. In particular, <code>fpgadiag</code> requires a few 1 GB pages. </li> <li>Is the required AFU loaded? See DESCRIPTION for information about what AFU the test requires.</li> <li>Are <code>--begin</code> and <code>--end</code> values set properly? <code>--end</code> must be larger than the <code>--begin</code>. Also, <code>--begin</code> must be a multiple of the <code>--multi-cl</code> value.</li> <li>The <code>--warm-fpga-cache</code> and <code>--cool-fpga-cache</code> options in the <code>read</code> and <code>write</code> tests are mutually exclusive.</li> <li>The timeout options are only meaningful for the continuous mode  (with the <code>--cont</code> option).</li> </ul>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/","title":"fpgaflash","text":""},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgaflash [-h] {user,factory} file [bdf]\n</code></pre>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#description","title":"DESCRIPTION","text":"<p>fpgaflash updates the static FIM image loaded from flash at power-on.</p> <p>If there are multiple devices in the system, fpgaflash must specify a BDF to select the correct device. If no BDF is specified, fpgaflash prints out the BDFs of any compatible devices.</p>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{user, factory}</code></p> <p>Specifies the type of flash programming.</p> <p><code>user</code> </p> <p>Only reprograms the user image in flash.  </p> <p><code>factory</code> </p> <p>Reprograms the entire flash.  A catastrophic failure during a factory update such as a power outage  requires a USB cable and <code>quartus_pgm</code> to recover.</p> <p><code>file</code></p> <p>Specifies the Raw Programming Data File (rpd) to program into flash.</p> <p><code>bdf</code></p> <p>Specifies the bus, device and function (BDF) of device to program such as 04:00.0 or 0000:04:00.0. This flag is optional when there is a single device in the system.</p>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Print usage information.</p>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#example","title":"EXAMPLE","text":"<p><code>fpgaflash user new_image.rpd 0000:04:00.0</code></p> <p>Programs new_image.rpd to flash of device with BDF 0000:04:00.0.</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/","title":"super-rsu","text":""},{"location":"sw/fpga_tools/fpgaflash/superrsu/#synopsis","title":"SYNOPSIS","text":"<pre><code>super-rsu [-h] [-n] [--verify] | [ [--log-level {trace,debug,error,warn,info,notset}]\n          [--log-file &lt;filename&gt;] [--rsu-only] [--with-rsu] [--force-flash] ]\n      rsu_config\n</code></pre>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#description","title":"DESCRIPTION","text":"<p>super-rsu is a tool that can be used for flashing image files and commanding an Intel PAC device to perform RSU (remote system update - or a board reboot). Performing an RSU on an Intel PAC device will cause it to reload any firmware or programmable logic and restart its execution, a requirement for any updated firmware or programmable logic to take effect.</p> <p>At the core of super-rsu is its configuration file (referred to in this document as 'rsu_config') which is essentially a manifest file for identifying both the target device and the binary images (and their versions) to be flashed.</p> <p>At a high level, the flow of super-rsu should be: 1. Read and parse rsu_config file 2. Use product identifiers (like vendor, device and any additional vendor, device    pairs that may be present in the PCIe bus) to locate all compatible    devices on the PCIe bus. 3. For every device found on the system, update the device using the flash    images defined in the \"flash\" section in the rsu_config data (or nvmupdate    section).    Each item in the \"flash\" section is a \"flash spec\" that contains:    * The flash type (\"user\", \"bmc_fw\", \"bmc_img\", ...)    * The filename of the image to flash. super-rsu will look for this file      first in the same directory of the rsu_config file, and then look in the      current working directory.    * The version of the image.    * An optional \"force\" indicator    * An optional \"requires\" indicator    The \"nvmupdate\" section is used to describe an Ethernet firmware file and    its version. 4. Using the data in the \"nvmupdate\" and \"flash\" sections, the update routine    involves:   * If an \"nvmupdate\" section is present:     1. Locate the file on the file system to use to flash the Ethernet device.     2. Call nvmupdate to get an \"inventory\" of devices matching the vendor and        device id in this section.     3. Use this data to dynamically generate an nvmupdate compatible        configuration file.     4. Call nvmupdate with the generated configuration file to flash the        Ethernet interfaces in the Vista Creek card (if version reported by        system does not match the version in this section).   * For each spec in the \"flash\" section:     1. Locate the file on the file system to use to flash.     2. Compare the version listed in the \"flash spec\" to version reported by        the target component.     3. Create a task to call fpgaflash if either of the following conditions is        met (and the revision specified is compatible):        * The \"force\" indicator is present and set to true.        * The version in the spec does not match the version reported by the          system OR the flash type is factory type.   * For each task created from the \"flash\" section:     1. Call fpgaflash with the command line arguments that correspond to the        flash type and the file name in the spec used to create the task.        This opens and controls the execution of fpgaflash in another process.</p> <p>NOTE: If the system reports a revision for one of the components being flashed, this revision must be in the set of revisions listed in the manifest. Example: if the system reports 'a' for bmc_img and the manifest includes 'ab', then the image will be flashed.</p> <p>NOTE: Each update routine is run in a thread specific to a device located on the PCIe bus. Every task in an update routine involves opening a new process that is controlled and managed by its update routine thread. If a task includes a timeout and the timeout is reached, a termination request will be sent to its process and it will be counted as a failure. If a global timeout is reached in the main thread, a termination request will be sent to each thread performing the update. Consequently, the update routine will give the current task extra time before terminating the process. The RSU operation will only be performed if requested with either <code>--with-rsu</code> command line argument or with the <code>--rsu-only</code> command line argument. The former will perform the RSU command upon successful completion of flash operations. The latter will skip the process of version matching and flashing images and will only perform the RSU command. It is recommended that super-rsu be executed again if any flash operation is interrupted.</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>rsu config</code></p> <p>Specifies the name of the file containing the RSU configuration (in JSON format)</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Print usage information.</p> <p><code>--verify</code></p> <p>Compare versions of flashable components on the system against the manifest.   Return non-zero exit if compatible components are not up to date.</p> <p><code>-n, --dry-run</code></p> <p>Don't perform any updates, just a dry run.   This will print out commands that can be executed   in a Linux shell.</p> <p><code>--log-level {trace,debug,error,warn,info,notset}</code></p> <p>Log level to use. Default is 'info'.</p> <p>`--log-file  (default: /tmp/super-rsu.log) <p>Emit log messages (with DEBUG level) to filename   NOTE: The default log file (/tmp/super-rsu.log) is set to rollover every   time super-rsu is executed. This will create numbered backups before   truncating the log file. The maximum number of backups is 50.</p> <p><code>--rsu-only</code></p> <p>Only perform the RSU command.</p> <p><code>--with-rsu</code></p> <p>Perform RSU after updating flash components(experimental)</p> <p><code>--force-flash</code></p> <p>Flash all images regardless of versions matching or not.</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#configuration","title":"CONFIGURATION","text":"<p>The following is the JSON schema expected by super-rsu. Any deviance from this schema may result in errors executing super-rsu.</p> <pre><code>{\n\"definitions\": {},\n\"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\"$id\": \"http://example.com/root.json\",\n\"type\": \"object\",\n\"title\": \"The Root Schema\",\n\"required\": [\n\"product\",\n\"vendor\",\n\"device\",\n\"flash\"\n],\n\"optional\": [\n\"nvmupdate\",\n],\n\"properties\": {\n\"product\": {\n\"$id\": \"#/properties/product\",\n\"type\": \"string\",\n\"title\": \"The Product Schema\",\n\"default\": \"\",\n\"examples\": [\n\"n3000\"\n],\n\"pattern\": \"^(.*)$\"\n},\n\"vendor\": {\n\"$id\": \"#/properties/vendor\",\n\"type\": \"string\",\n\"title\": \"The Vendor Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x8086\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"device\": {\n\"$id\": \"#/properties/device\",\n\"type\": \"string\",\n\"title\": \"The Device Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x0b30\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"nvmupdate\": {\n\"$id\": \"#/properties/nvmupdate\",\n\"type\": \"object\",\n\"title\": \"The nvmupdate Schema\",\n\"required\": [\n\"vendor\",\n\"device\",\n\"filename\",\n\"version\"\n],\n\"optional\": [\n\"interfaces\"\n],\n\"properties\": {\n\"vendor\": {\n\"$id\": \"#/properties/nvmupdate/vendor\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Vendor Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x8086\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"device\": {\n\"$id\": \"#/properties/nvmupdate/device\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Device Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x0d58\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"interfaces\": {\n\"$id\": \"#/properties/nvmupdate/interfaces\",\n\"type\": \"number\",\n\"title\": \"The nvmupdate Interfaces Schema\",\n\"default\": \"1\",\n\"examples\": [\n2, 4\n]\n},\n\"filename\": {\n\"$id\": \"#/properties/nvmupdate/filename\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Filename Schema\",\n\"default\": \"\",\n\"examples\": [\n\"PSG_XL710_6p80_XLAUI_NCSI_CFGID2p61_Dual_DID_0D58_800049C6.bin\"\n],\n\"pattern\": \"^(.*)$\"\n},\n\"version\": {\n\"$id\": \"#/properties/nvmupdate/version\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Version Schema\",\n\"default\": \"\",\n\"examples\": [\n\"800049C6\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{8})$\"\n},\n\"timeout\": {\n\"$id\": \"#/properties/nvmupdate/timeout\",\n\"type\": \"string\",\n\"title\": \"The Timeout Schema\",\n\"default\": \"\",\n\"examples\": [\n\"10m\"\n],\n\"pattern\": \"^([0-9]+(\\\\.[0-9]+)?([dhms]))+$\"\n}\n}\n},\n\"flash\": {\n\"$id\": \"#/properties/flash\",\n\"type\": \"array\",\n\"title\": \"The Flash Schema\",\n\"items\": {\n\"$id\": \"#/properties/flash/items\",\n\"type\": \"object\",\n\"title\": \"The Items Schema\",\n\"required\": [\n\"filename\",\n\"type\",\n\"version\",\n\"revision\"\n],\n\"optional\": [\n\"enabled\",\n\"force\",\n\"timeout\",\n\"requires\"\n],\n\"properties\": {\n\"enabled\": {\n\"$id\": \"#/properties/flash/items/properties/enabled\",\n\"type\": \"boolean\",\n\"title\": \"The Enabled Schema\",\n\"default\": \"true\"\n},\n\"filename\": {\n\"$id\": \"#/properties/flash/items/properties/filename\",\n\"type\": \"string\",\n\"title\": \"The Filename Schema\",\n\"default\": \"\",\n\"examples\": [\n\"vista_creek_qspi_xip_v1.0.6.ihex\"\n],\n\"pattern\": \"^(.*)$\"\n},\n\"type\": {\n\"$id\": \"#/properties/flash/items/properties/type\",\n\"type\": \"string\",\n\"title\": \"The Type Schema\",\n\"default\": \"\",\n\"examples\": [\n\"bmc_fw\"\n],\n\"enum\": [\"user\", \"bmc_fw\", \"bmc_img\", \"dtb\", \"factory_only\",\n\"phy_eeprom\"]\n},\n\"version\": {\n\"$id\": \"#/properties/flash/items/properties/version\",\n\"type\": \"string\",\n\"title\": \"The Version Schema\",\n\"default\": \"\",\n\"examples\": [\n\"1.0.6\"\n],\n\"pattern\": \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\"\n},\n\"force\": {\n\"$id\": \"#/properties/flash/items/properties/force\",\n\"type\": \"boolean\",\n\"title\": \"The Force Schema\",\n\"default\": false,\n\"examples\": [\ntrue\n]\n},\n\"revision\": {\n\"$id\": \"#/properties/flash/items/properties/revision\",\n\"type\": \"string\",\n\"title\": \"The Revision Schema\",\n\"default\": \"\",\n\"examples\": [\n\"C\"\n],\n\"pattern\": \"^([A-Za-z])$\"\n},\n\"timeout\": {\n\"$id\": \"#/properties/nvmupdate/timeout\",\n\"type\": \"string\",\n\"title\": \"The Timeout Schema\",\n\"default\": \"\",\n\"examples\": [\n\"10m\"\n],\n\"pattern\": \"^([0-9]+(\\.[0-9]+)?([dhms]))+$\"\n},\n\"requires\": {\n\"$id\": \"#/properties/flash/items/properties/requires\",\n\"type\": \"string\",\n\"title\": \"The Requires Schema\",\n\"default\": \"\",\n\"examples\": [\n\"bmc_img &gt;= 1.0.12\"\n],\n\"pattern\": \"^(([a-z_]+) ((&lt;&gt;!=)?=) ([0-9a-z\\\\.]+)$\"\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/","title":"fpgainfo","text":""},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#synopsis","title":"SYNOPSIS","text":"<pre><code>   fpgainfo [-h] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\n            {errors,power,temp,fme,port,bmc,mac,phy,security}\n</code></pre>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#description","title":"DESCRIPTION","text":"<p>fpgainfo displays FPGA information derived from sysfs files. The command argument is one of the following: <code>errors</code>, <code>power</code>, <code>temp</code>, <code>port</code>, <code>fme</code>, <code>bmc</code>, <code>phy</code> or <code>mac</code>,<code>security</code>,<code>events</code>. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#fpgainfo-commands","title":"FPGAINFO COMMANDS","text":"<p><code>errors</code></p> <p>Show/clear errors of an FPGA resource that the first argument specifies. <code>fpgainfo</code> displays information in human readable form.</p> <p><code>power</code></p> <p>Show total the power in watts that the FPGA hardware consumes.</p> <p><code>temp</code></p> <p>Show FPGA temperature values in degrees Celcius.</p> <p><code>port</code></p> <p>Show information about the port such as the AFU ID of currently loaded AFU.</p> <p><code>fme</code></p> <p>Show information about the FPGA platform including the partial reconfiguration (PR) Interface ID, the OPAE version, and the FPGA Interface Manager (FIM) ID.</p> <p><code>bmc</code></p> <p>Show all Board Management Controller sensor values for the FPGA resource, if available.</p> <p><code>phy</code></p> <p>Show information about the PHY integrated in the FPGA, if available.</p> <p><code>mac</code></p> <p>Show information about the MAC address in ROM attached to the FPGA, if available.</p> <p><code>security</code></p> <p>Show information about the security keys, hashs and flash count, if available.</p> <p><code>events</code></p> <p>Show information about events and sensors, if available.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p> <p><code>--version, -v</code></p> <p>Prints version information and exit.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#common-arguments","title":"COMMON ARGUMENTS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-S, --segment</code></p> <p>PCIe segment number of resource.</p> <p><code>-B, --bus</code></p> <p>PCIe bus number of resource.</p> <p><code>-D, --device</code></p> <p>PCIe device number of resource.</p> <p><code>-F, --function</code></p> <p>PCIe function number of resource.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#errors-arguments","title":"ERRORS ARGUMENTS","text":"<p>The first argument to the <code>errors</code> command specifies the resource type. It must be one of the following:    <code>fme</code>,<code>port</code>,<code>all</code></p> <p><code>fme</code></p> <p>Show/clear FME errors. </p> <p><code>port</code></p> <p>Show/clear PORT errors.</p> <p><code>all</code></p> <p>Show/clear errors for all resources.</p> <p>The optional <code>&lt;command-args&gt;</code> arguments are:</p> <p><code>--clear, -c</code></p> <p>Clear errors for the given FPGA resource.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#phy-arguments","title":"PHY ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--group, -G</code></p> <p>Select which PHY group(s) information to show.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#events-arguments","title":"EVENTS ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--list,-l</code></p> <p>List boots (implies --all).</p> <p><code>--boot,-b</code></p> <p>Boot index to use, i.e: \u00a0\u00a0\u00a0\u00a00 for current boot (default). \u00a0\u00a0\u00a0\u00a01 for previous boot, etc.</p> <p><code>--count,-c</code></p> <p>Number of events to print.</p> <p><code>--all,-a</code></p> <p>Print all events.</p> <p><code>--sensors,-s</code></p> <p>Print sensor data too.</p> <p><code>--bits,-i</code></p> <p>Print bit values too.</p> <p><code>--help,-h</code></p> <p>Print this help.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#examples","title":"EXAMPLES","text":"<p>This command shows the current power telemetry: <pre><code>./fpgainfo power\n</code></pre></p> <p>This command shows the current temperature readings: <pre><code>./fpgainfo temp\n</code></pre></p> <p>This command shows FME resource errors: <pre><code>./fpgainfo errors fme\n</code></pre> This command clears all errors on all resources: <pre><code>./fpgainfo errors all -c\n</code></pre> This command shows information of the FME on bus 0x5e <pre><code>./fpgainfo fme -B 0x5e\n</code></pre> This command shows information of the FPGA security on bus 0x5e <pre><code>./fpgainfo security -B 0x5e\n</code></pre> This command shows all events and sensors information including sensor bits: <pre><code>./fpgainfo events -asi\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/","title":"fpgamux","text":""},{"location":"sw/fpga_tools/fpgamux/fpgamux/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgamux [-h] [-S|--socket-id SOCKET_ID] [-B|--bus-number BUS] [-D|--device DEVICE] [-F|--function FUNCTION]\n        [-G|--guid GUID] -m|--muxfile &lt;filepath.json&gt;\n</code></pre>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#description","title":"DESCRIPTION","text":"<p><code>fpgamux</code> tests multiple AFUs that are synthesized into a single AFU along with the CCIP-MUX basic building block (BBB). The CCIP-MUX uses the upper bits in the MMIO addresses to route MMIO reads and writes to the AFU running on the corresponding CCIP-MUX port. <code>fpgamux</code> uses a configuration file that lists the software components and correct configuration. <code>fpgamux</code> only runs on the Integrated FPGA Platform.  You cannot run it on the PCIe accelerator card (PAC).</p> <p>.. note::</p> <pre><code>  The OPAE driver discovers only the first AFU. The first software component in the configuration \n  determines the GUID to use for enumeration. Use the -G|--guid option to override the GUID\n  for the first software component.\n</code></pre>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#options","title":"OPTIONS","text":"<p><code>-S SOCKET_ID, --socket-id SOCKET_ID</code></p> <p>socket id of FPGA resource.</p> <p><code>-B BUS, --bus BUS</code></p> <p>bus id of FPGA resource.</p> <p><code>-D DEVICE, --device DEVICE</code></p> <p>The device id of FPGA resource.</p> <p><code>-F FUNCTION, --function FUNCTION</code></p> <p>The function id of FPGA resource.</p> <p><code>-G, --guid</code></p> <p>Specifies the GUID to use for the resource enumeration.</p> <p><code>-m, --muxfile &lt;filepath.json&gt;</code></p> <p>The path to the <code>fpgamux</code> configuration file. This file must be in JSON format following the schema described below.</p>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#configuration","title":"CONFIGURATION","text":"<p><code>fpgamux</code> uses a configuration file (in JSON format) to determine what software components to instantiate and how to configure them to work with the AFUs. The schema includes the following elements:</p> <pre><code>    [\n        {\n            \"app\" : \"fpga_app\",\n            \"name\" : \"String\",\n            \"config\" : \"Object\"\n        }\n    ]\n</code></pre>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#examples","title":"EXAMPLES","text":"<p>The following example shows a configuration with two components: <pre><code>    [\n        {\n            \"app\" : \"nlb0\",\n            \"name\" : \"nlb0\",\n            \"config\" :\n            {\n                \"begin\" : 1,\n                \"end\" : 1,\n                \"multi-cl\" : 1,\n                \"cont\" : false,\n                \"cache-policy\" : \"wrline-M\",\n                \"cache-hint\" : \"rdline-I\",\n                \"read-vc\" : \"vh0\",\n                \"write-vc\" : \"vh1\",\n                \"wrfence-vc\" : \"write-vc\",\n                \"timeout-usec\" : 0,\n                \"timeout-msec\" : 0,\n                \"timeout-sec\" : 1,\n                \"timeout-min\" : 0,\n                \"timeout-hour\" : 0,\n                \"freq\" : 400000000\n            }\n        },\n        {\n            \"app\" : \"nlb3\",\n            \"name\" : \"nlb3\",\n            \"config\" :\n            {\n                \"mode\" : \"read\",\n                \"begin\" : 1,\n                \"end\" : 1,\n                \"multi-cl\" : 1,\n                \"strided-access\" : 1,\n                \"cont\" : false,\n                \"warm-fpga-cache\" : false,\n                \"cool-fpga-cache\" : false,\n                \"cool-cpu-cache\" : false,\n                \"cache-policy\" : \"wrline-M\",\n                \"cache-hint\" : \"rdline-I\",\n                \"read-vc\" : \"vh0\",\n                \"write-vc\" : \"vh1\",\n                \"wrfence-vc\" : \"write-vc\",\n                \"alt-wr-pattern\" : false,\n                \"timeout-usec\" : 0,\n                \"timeout-msec\" : 0,\n                \"timeout-sec\" : 1,\n                \"timeout-min\" : 0,\n                \"timeout-hour\" : 0,\n                \"freq\" : 400000000\n            }\n        }\n    ]\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/","title":"fpgaport","text":""},{"location":"sw/fpga_tools/fpgaport/fpgaport/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgaport [-h] [-N NUMVFS] [-X] [--debug] {assign,release} device [port]\n</code></pre>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#description","title":"DESCRIPTION","text":"<p>The <code>fpgaport</code> enables and disables virtualization. It assigns and releases control of the port to the virtual function (VF). By default, the driver assigns the port to the physical function (PF) in the non-virtualization use case.</p>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{assign, release}</code></p> <pre><code>Action to perform.\n</code></pre> <p><code>device</code></p> <pre><code>The FPGA device being targeted with this action.\n</code></pre> <p><code>port</code></p> <pre><code>The number of the port.\n</code></pre>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-N NUMVFS, --numvfs NUMVFS</code></p> <pre><code>Create NUMVFS virtual functions. The typical value is 1.\n</code></pre> <p><code>-X, --destroy-vfs</code></p> <pre><code>Destroy all virtual functions prior to assigning.\n</code></pre> <p><code>--debug</code></p> <pre><code>Display additional log information.\n</code></pre> <p><code>-h, --help</code></p> <pre><code>Print usage information.\n</code></pre>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#example","title":"EXAMPLE","text":"<p><code>fpgaport release /dev/dfl-fme.0 0</code></p> <pre><code>Release port 0 from physical function control.\n</code></pre> <p><code>fpgaport assign /dev/dfl-fme.0 0</code></p> <pre><code>Assign port 0 to physical function control.\n</code></pre>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/","title":"fpgasupdate","text":""},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgasupdate [--log-level=&lt;level&gt;] file [bdf]</code></p>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#description","title":"DESCRIPTION","text":"<p>The <code>fpgasupdate</code> command implements a secure firmware update for the following programmable accelerator cards (PACs): * Intel\u00ae PAC with Intel Arria\u00ae 10 GX FPGA * Intel FPGA PAC D5005 * Intel PAC N3000</p> <p><code>--log-level &lt;level&gt;</code></p> <pre><code>Specifies the `log-level` which is the level of information output to your command tool.\nThe following seven levels  are available: `state`, `ioctl`, `debug`, `info`, `warning`,\n`error`, `critical`. Setting `--log-level=state` provides the most verbose output.\nSetting `--log-level=ioctl` provides the second most information, and so on. The default\nlevel is `info`.\n</code></pre> <p><code>file</code></p> <pre><code>Specifies the secure update firmware file to be programmed. This file may be to program a\nstatic region (SR), programmable region (PR), root entry hash, key cancellation, or other\ndevice-specific firmware.\n</code></pre> <p><code>bdf</code></p> <pre><code>The PCIe&amp;reg; address of the PAC to program. `bdf` is of the form `[ssss:]bb:dd:f`,\ncorresponding to PCIe segment, bus, device, function. The segment is optional. If\nyou do not specify a segment, the segment defaults to `0000`. If the system has only\none PAC you can omit the `bdf` and let `fpgasupdate`  determine the address\nautomatically.\n</code></pre>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>To gather more debug output, decrease the <code>--log-level</code> parameter. </p>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#examples","title":"EXAMPLES","text":"<p><code>fpgasupdate firmware.bin</code> <code>fpgasupdate firmware.bin 05:00.0</code> <code>fpgasupdate firmware.bin 0001:04:02.0 --log-level=ioctl</code></p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/","title":"host_exerciser","text":""},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: host_exerciser [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=warning\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mode UINT:value in {lpbk-&gt;0,read-&gt;1,trput-&gt;3,write-&gt;2} OR {0,1,3,2}=lpbk\n                              host exerciser mode {lpbk,read, write, trput}\n  --cls UINT:value in {cl_1-&gt;0,cl_2-&gt;1,cl_4-&gt;2,cl_8-&gt;3} OR {0,1,2,3}=cl_1\n                              number of CLs per request{cl_1, cl_2, cl_4, cl_8}\n  --continuousmode BOOLEAN=false\n                              test rollover or test termination\n  --atomic UINT:value in {cas_4-&gt;9,cas_8-&gt;11,fadd_4-&gt;1,fadd_8-&gt;3,off-&gt;0,swap_4-&gt;5,swap_8-&gt;7} OR {9,11,1,3,0,5,7}=off\n                              atomic requests (only permitted in combination with lpbk/cl_1)\n  --encoding UINT:value in {default-&gt;0,dm-&gt;1,pu-&gt;2,random-&gt;3} OR {0,1,2,3}=default\n                              data mover or power user encoding -- random interleaves both in the same stream\n  -d,--delay BOOLEAN=false    Enables random delay insertion between requests\n  --interleave UINT=0         Interleave requests pattern to use in throughput mode {0, 1, 2}\n                              indicating one of the following series of read/write requests:\n                              0: rd-wr-rd-wr\n                              1: rd-rd-wr-wr\n                              2: rd-rd-rd-rd-wr-wr-wr-wr\n  --interrupt UINT:INT in [0 - 3]\n                              The Interrupt Vector Number for the device\n  --contmodetime UINT=1       Continuous mode time in seconds\n  --testall BOOLEAN=false     Run all tests\n  --clock-mhz UINT=0          Clock frequency (MHz) -- when zero, read the frequency from the AFU\nSubcommands:\n  lpbk                        run simple loopback test\n  mem                         run simple mem test\n</code></pre>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#description","title":"DESCRIPTION","text":"<p>The host exerciser used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc.</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#host-exerciser-loopback-he-lbk","title":"Host Exerciser Loopback (HE-LBK)","text":"<p>HE-LB is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth.  Host Exerciser Loopback (HE-LBK) AFU can move data between host memory and FPGA.</p> <p>HE-LBK supports: 1. Latency (AFU to Host memory read) 2. MMIO latency (Write+Read) 3. MMIO BW (64B MMIO writes) 4. BW (Read/Write, Read only, Wr only)</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#host-exerciser-memory-he-mem","title":"Host Exerciser Memory (HE-MEM)","text":"<p>HE-MEM is used to exercise use of FPGA connected DDR; data read from the host is  written to DDR, and the same data is read from DDR before sending it back to the  host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller.</p> <p>Execution of these exercisors requires the user to bind specific VF endpoint to vfio-pci Bind the correct endpoint for a device with B/D/F 0000:b1:00.0</p> <p><code>[user@localhost]: sudo opae.io init -d 0000:b1:00.2 user:user</code></p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#host-exerciser-sub-commands","title":"HOST EXERCISER SUB COMMANDS","text":"<p><code>lpbk</code></p> <p>run host exerciser loopback test</p> <p><code>mem</code></p> <p>run host exerciser memory test</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set host exerciser tool log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>host exerciser tool time out, by default time out 60000</p> <p><code>-m,--mode</code></p> <p>host exerciser test modes are lpbk, read, write, trput</p> <p><code>--cls</code></p> <p>Number of cachelines per request 1, 2, 3, 4.</p> <p><code>--continuousmode</code></p> <p>Configures test rollover or test termination mode.</p> <p><code>--atomic</code></p> <p>atomic requests.</p> <p><code>--encoding</code></p> <p>select data mover mode or power user mode or random.</p> <p><code>-d,--delay</code></p> <p>Enables random delay insertion between requests.</p> <p><code>--interleave</code></p> <p>Enables interleave requests in throughput mode. Value:3'b000-Rd,Wr,Rd,Wr Value:3'b001-Rd,Rd,Wr,Wr Value:3'b010-Rd,Rd,Rd,Rd,Wr,Wr,Wr,Wr Value:3'b011-Not supported</p> <p><code>--interrupt</code></p> <p>Accelerator interrupt vector Number.</p> <p><code>--contmodetime</code></p> <p>Continuous mode time in seconds.</p> <p><code>--testall</code></p> <p>Run all host exerciser tests.</p> <p><code>--clock-mhz</code></p> <p>pcie clock frequency, default value 350Mhz.</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#examples","title":"EXAMPLES","text":"<p>This command exerciser Loopback afu: <pre><code>host_exerciser lpbk\n</code></pre></p> <p>This command exerciser memory afu: <pre><code>host_exerciser mem\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0: <pre><code>host_exerciser --pci-address 000:3b:00.0    lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run in write mode: <pre><code>host_exerciser --pci-address 000:3b:00.0   --mode write lpbl\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run 2 cache lines per request: <pre><code>host_exerciser --pci-address 000:3b:00.0   --cls cl_2  lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run continuous mode for 10 seconds: <pre><code>host_exerciser --pci-address 000:3b:00.0   -cls cl_1   -m 0 --continuousmode true --contmodetime 10 lpbk\n</code></pre></p>"},{"location":"sw/fpga_tools/hssi/hssi/","title":"hssi","text":""},{"location":"sw/fpga_tools/hssi/hssi/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi COMMON_OPTIONS MODE MODE_OPTIONS</code></p>"},{"location":"sw/fpga_tools/hssi/hssi/#description","title":"DESCRIPTION","text":"<p>The <code>hssi</code> application provides a means of interacting with the 10G and with the 100G HE-HSSI AFUs. In both 10G and 100G operating modes, the application initializes the AFU and completes the desired transfer as described by the mode- specific options.</p> <p>COMMON_OPTIONS - application options common to both 10G and 100G modes.</p> <p><code>-h, --help</code></p> <pre><code>Display common command-line help and exit.\n</code></pre> <p><code>-p, --pci-address ADDR</code></p> <pre><code>The PCIe address of the desired accelerator in ssss:bb:dd.f format.\n</code></pre> <p><code>-s, --shared on|off</code></p> <pre><code>Whether to open the accelerator in shared mode. The default is off.\n</code></pre> <p><code>-t, --timeout VALUE</code></p> <pre><code>The application timeout value in milliseconds. The default timeout is 60000 msec.\n</code></pre> <p>MODE - select AFU. Valid values are hssi_10g and hssi_100g.</p> <p>MODE_OPTIONS [hssi_10g] - application options specific to the 10G AFU.</p> <p><code>-h, --help</code></p> <pre><code>Display 10G AFU specific command-line help and exit.\n</code></pre> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--random-length fixed|random</code></p> <pre><code>Specify packet length randomization. Valid values are fixed and\nrandom. The default is fixed (no randomization).\n</code></pre> <p><code>--random-payload incremental|random</code></p> <pre><code>Specify payload randomization. Valid values are incremental and\nrandom. The default is incremental.\n</code></pre> <p><code>--packet-length LENGTH</code></p> <pre><code>Specify packet length. The default is 64 bytes.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--rnd-seed0 SEED0</code></p> <pre><code>Specify the prbs generator bits [31:0]. The default is 1592590336.\n</code></pre> <p><code>--rnd-seed1 SEED1</code></p> <pre><code>Specify the prbs generator bits [47:32]. The default is 1592590337.\n</code></pre> <p><code>--rnd-seed2 SEED2</code></p> <pre><code>Specify the prbs generator bits [91:64]. The default is 155373.\n</code></pre> <p>MODE_OPTIONS [hssi_100g] - application options specific to the 100G AFU.</p> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--gap random|none</code></p> <pre><code>Inter-packet gap. Valid values are random and none. The default is none.\n</code></pre> <p><code>--pattern random|fixed|increment</code></p> <pre><code>Pattern mode. Valid values are random, fixed, or increment. The default\nis random.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--start-size SIZE</code></p> <pre><code>Specify the packet size in bytes, or the first packet size for --pattern increment.\n</code></pre> <p><code>--end-size SIZE</code></p> <pre><code>Specify the end packet size in bytes.\n</code></pre> <p><code>--end-select pkt_num|gen_idle</code></p> <pre><code>Specify packet generation end mode.\n</code></pre> <p>MODE_OPTIONS [pkt_filt_10g] - application options specific to the Packet Filter 10G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.0\n</code></pre> <p>MODE_OPTIONS [pkt_filt_100g] - application options specific to the Packet Filter 100G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.1\n</code></pre>"},{"location":"sw/fpga_tools/hssi/hssi/#examples","title":"EXAMPLES","text":"<p><code>hssi -h</code> <code>hssi hssi_10g -h</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_10g --eth-loopback=on --num-packets=500</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_100g --pattern=increment</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/","title":"hssi_config","text":""},{"location":"sw/fpga_tools/hssi_config/readme/#synopsis","title":"Synopsis","text":"<p><code>hssi_config</code> reads or writes HSSI registers on either on an Intel\u00ae FPGA using the  FPGA Interface Manager (FIM) or on an HSSI retimer card attached to the board. <code>hssi_config</code> is only available for the Integrated FPGA Platform. You cannot run it  on the PCIe accelerator card (PAC).</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#usage","title":"Usage","text":"<p><code>hssi_config [--resource|-r &lt;sysfs resource&gt;] [--socket-id|s 0|1] command [command options]</code></p> <p>Where command is one of the following:</p> <pre><code>    dump [outfile.csv] [--input-file inputfile.csv]\niread instance (0,1) device-addr byte-address byte-count\n    iwrite instance (0,1) device-addr byte-address byte1 [byte2 [byte3...]]\nload [inputfile.csv] [--c-header]\nread lane(0-15) reg-address\n    rread device(0x30, 0x32, 0x34, 0x36) channel(0-3) address\n    rwrite device(0x30, 0x32, 0x34, 0x36) channel(0-3) address value\n    test (rd|rw) inputfile.csv [--acktimes] [--repeat N]\nwrite lane(0-15) reg-address value\n</code></pre> <p>The first argument is the command and any additional arguments are command arguments. The following options and commands are available:</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#options","title":"Options","text":"<p><code>[--resource|-r &lt;sysfs resource path&gt;</code></p> <p>The resource path in the sysfs pseudo-filesystem. Example:     <code>/sys/devices/pci0000\\:5e/0000\\:5e\\:00.0/resource0</code></p> <p><code>[--socket-id 0|1]</code></p> <p>The socket id of the target FPGA. Required on two-socket systems to differentiate between the two possible target FPGAs.</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#commands","title":"Commands","text":"<p><code>dump [outfile.csv] [--input-file inputfile.csv]</code></p> <p>Dump registers to stdout or to a file, if provided. <code>hssi_config</code> has a built-in set of registers to dump. The first argument is the path to a file to write. The command dumps to stdout if you do not  specify a file name. Use the --input-file option to specify a different set of registers. </p> <p><code>load [inputfile.csv] [--c-header]</code></p> <p>Load a set of register values from either stdin or an input file, if provided. The first argument  is the path to a file containing the registers to load. Loads from stdin if omitted.  </p> <p>Use --c-header to generate a C header file with an array of 64-bit numbers to write to the  <code>HSSI_CTRL</code> register. This header file can substitute for the input file.  NOTE: You must perform the acknowledge routine after each write.</p> <p><code>read lane(0-15) reg-address</code></p> <p>Read from a single XCVR (transceiver) register. The first command argument is the XCVR lane. Use -1 to specify a read from all lanes. The second argument is the XCVR address (offset).</p> <p><code>write lane(0-15) reg-address value</code></p> <p>Write to a single XCVR register. The first argument is the XCVR lane. The second argument is the XCVR address(offset). The third argument is the value to write to the register.</p> <p><code>rread device(0x30, 0x32, 0x34, 0x36) channel(0-3) address</code></p> <p>Read from a single retimer register. The first argument is the I2C device address. The second argument is the channel. The third argument is the register address (or I2C byte address).</p> <p><code>rwrite device(0x30, 0x32, 0x34, 0x36) channel(0-3) address value</code></p> <p>Write to a single retimer register. The first argument is the I2C device address. The second argument is the channel. The third argument is the register address (or I2C byte address). The fourth argument is the value to write.</p> <p><code>iread instance (0,1) device-addr byte-address byte-count</code></p> <p>Read from a device on the I2C bus. The first argument is the I2C controller instance (0 or 1). The second argument is the device address to read from. The third argument is the byte address of the register to read from the device. The fourth argument is the number of bytes to read.</p> <p><code>iwrite instance (0,1) device-addr byte-address byte1 [byte2 [byte3...]]</code></p> <p>Write to a device on the I2C bus. The first argument is the I2C controller instance (0 or 1). The second argument is the device address to read from. The third argument is the byte address of the register to read from the device. All subsequent arguments are the bytes to write to the device.</p> <p><code>test (rd|rw) inputfile.csv [--acktimes]</code></p> <p>Perform built-in test for reading or writing XCVR registers. The first argument is the path to a file containing the registers to test.</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#overview","title":"Overview","text":"<p>The <code>hssi_config</code> utility reads or writes hssi equalization parameters stored in either the transceiver (XCVR) registers or the registers of the retimer on the I2C bus. To access registers,  the hssi controller writes to the <code>HSSI_CTRL</code> register and reads from the <code>HSSI_STAT</code> register in the FPGA Management Engine (FME). These two registers implement the HSSI AUX bus mailbox protocol to access devices on other buses. Because <code>hssi_config</code> maps the FME MMIO space directly, the FPGA driver is not required.</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#locating-the-fme-device","title":"Locating the FME Device","text":"<p>The FME reads and writes the <code>HSSI_CTRL</code> and <code>HSSI_STAT</code> registers on the NIOS device. The FME maps the MMIO address space of the FME identified by its resource in the sysfs psuedo-filesystem in Linux operating systems. To identify resource paths, use the <code>lspci</code> utility to query for Intel devices with device id of bcc0.</p> <p>Example:</p> <p><code>lspci -d 8086:bcc0</code></p> <p>This command should print out at least one line like the following example:</p> <p><code>5e:00.0 Processing accelerators: Intel Corporation Device bcc0</code></p> <p>Use the first three numbers (bus:device.function) to locate the device resource in the sysfs filesystem:</p> <p><code>/sys/devices/pci0000\\:&lt;bus&gt;/0000\\:&lt;bus&gt;\\:&lt;device&gt;.&lt;function&gt;/resource0</code></p> <p>For example, the example above with bus of 5e, device of 00 and function of 0 would use a resource path as follows:</p> <p><code>/sys/devices/pci0000\\:5e/0000\\:5e\\:00.0/resource0</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#csv-file-format","title":"CSV File Format","text":"<p>Any CSV file parsed by <code>hssi_config</code> must meet have at least four columns. The following table provides the column specifications:</p> Column Name Description 1 Register type. Can be either <code>FPGA_RX</code>, <code>FPGA_TX</code>, <code>RTMR_RX</code>, <code>RTMR_TX</code> (or their corresponding numeric values, 1-4). 2 Lane or Channel 0-15 for XCVR lanes on FPGA, 0-3 for retimer channels. -1 to designate all lanes or channels. 3 Device address (on I2C bus) Only applies to retimer registers. 0 - 3, -1 to designate all devices. 4 Register address (or offset) Examples: 0x213, 0x100. 5 Register value to write Examples: 0x1, 1, 0. Applies only when loading or writing registers."},{"location":"sw/fpga_tools/hssi_config/readme/#examples-of-commands","title":"Examples of Commands","text":""},{"location":"sw/fpga_tools/hssi_config/readme/#dumping-registers","title":"Dumping Registers","text":"<p>Dump default register set to stdout:</p> <p><code>&gt;hssi_config dump</code></p> <p>Dump default registers to a file, data.csv:</p> <p><code>&gt;hssi_config dump data.csv</code></p> <p>Dump to an output file, data.csv, Registers specified in an input file, regspec.csv:</p> <p><code>&gt;hssi_config dump data.csv --input-file regspec.csv</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#reading-single-registers","title":"Reading Single Registers","text":"<p>Read register from XCVR at 0x2e1 on lane 0:</p> <p><code>&gt;hssi_config read 0 0x2e1</code></p> <p>Read register 0x109 from retimer on channel 0, device 0x30, channel 1:</p> <p><code>&gt;hssi_config rread 0 0x30 0x109</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#loading-registers","title":"Loading Registers","text":"<p>Load registers specified in an input file called data.csv:</p> <p><code>&gt;hssi_config load data.csv</code></p> <p>Load registers specified from stdin:</p> <p><code>&gt;hssi_config load</code></p> <pre><code>FPGA_RX,1,-1,0x213,0\nFPGA_RX,2,-1,0x213,0\nFPGA_RX,3,-1,0x213,0\n&lt;CTRL-D&gt;\n</code></pre>"},{"location":"sw/fpga_tools/hssi_config/readme/#writing-single-registers","title":"Writing Single Registers","text":"<p>Write 1 to XCVR register at 0x2e1 on lane 0:</p> <p><code>&gt;hssi_config write 0 0x2e1 1</code></p> <p>Read register 0x109 from retimer on channel 0, device 0x30, channel 1:</p> <p><code>&gt;hssi_config rread 0 0x30 0x109</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#testing-hssi-read-and-write","title":"Testing HSSI Read and Write","text":"<p><code>&gt;  test (rd|rw) register-file.csv [--acktimes]</code></p> <p><code>rd|wr</code></p> <p>Specifies either a <code>rd</code> or <code>wr</code> of transceiver registers. For writes, every register in the file is read from and written to in the following sequence:</p> <p>1. Read the register, save the value   2. Write 1 to the register   3. Read the register, verify that the register value is 1   4. Write 0 to the register   5. Read the register, verify that the register value is 0   6. Write the original value to the register   7. Read the register, assert it is the original value</p> <p><code>register=file.csv</code></p> <p>Specifies the path to a file containing the set of registers to test. </p> <p><code>--acktimes</code> </p> <p>Specifies the time spent in the <code>ack</code> routine. When measured, a summary of ack times prints  to stdout. This argument is optional.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/","title":"HSSI ethernet loopback","text":""},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssiloopback [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS] --loopback [{enable,disable}]\n</code></pre>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssiloopback</code>  tool enables and disable ethernet loopback.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p> <p><code>--loopback [{enable,disable}]</code></p> <p>Ethernet enable or disable loopback.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#examples","title":"EXAMPLES","text":"<p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback enable</code></p> <p>Enables ethernet loopback</p> <p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback disable</code></p> <p>Disable ethernet loopback</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/","title":"HSSI ethernet mac","text":""},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssimac [-h] --pcie-address PCIE_ADDRESS [--port PORT]\n</code></pre>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#description","title":"DESCRIPTION","text":"<p>The <code>hssimac</code>  tool provides Maximum TX and RX frame size.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0).</p> <p><code>--port PORT</code></p> <p>hssi port number.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#examples","title":"EXAMPLES","text":"<p><code>hssimac --pcie-address  0000:04:00.0 --port 1</code></p> <p>prints Maximum TX and RX frame size for port 1.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/","title":"HSSI ethernet statistics","text":""},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssistats [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS]\n</code></pre>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#description","title":"DESCRIPTION","text":"<p>The <code>hssistats</code>  tool provides the MAC statistics.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#examples","title":"EXAMPLES","text":"<p><code>hssistats --pcie-address  0000:04:00.0</code></p> <p>prints the MAC statistics </p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/","title":"hssi_loopback","text":""},{"location":"sw/fpga_tools/hssi_loopback/readme/#name","title":"NAME","text":"<p>hssi_loopback - Software utility to run HSSI loopback tests on FPGA</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi_loopback [[--bus|-b &lt;bus number&gt;] [--device | -d &lt;device number&gt;] [--function | -f &lt;function number&gt;]]|[--socket-id &lt;socket-id&gt;]       [--mode|-m auto|e40|e10]        [send [&lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]] |status [clear] | stop | readmacs</code></p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#description","title":"DESCRIPTION","text":"<p>The <code>hssi_loopback</code> utility works in conjunction with a packet generator accelerator function unit (AFU) to test high-speed serial interface (HSSI) cards. The <code>hssi_loopback</code> utility tests both external and internal loopbacks. <code>hssi_loopback</code> runs an external loopback test when the command line arguments include both source and destination ports. <code>hssi_loopback</code> runs an internal loopback test when command line arguments include a single port. <code>hssi_loopback</code> only runs on the Intel Xeon with Arria 10 FPGA. You cannot run it on the Intel PAC (programmable accelerator card).</p> <p>NOTE: The following limitations apply to the current version of hssi_loopback:</p> <ul> <li>For the external loopback the two port arguments can be the same. For the e10 design, the ports should be the same.</li> <li>The <code>hssi_loopback</code> test supports only the e40 and e10 E2E AFUs.  The e10 E2E AFU tests HSSI with a retimer card.</li> <li>The <code>hssi_loopback</code> test uses the control and status registers (CSRs) defined in the AFU.</li> </ul>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#options","title":"OPTIONS","text":"<p><code>-S SOCKET_ID, --socket-id SOCKET_ID</code></p> <p>Socket ID FPGA resource.</p> <p><code>-B BUS, --bus BUS</code></p> <p>Bus ID of FPGA resource.</p> <p><code>-D DEVICE, --device DEVICE</code></p> <p>Device ID of FPGA resource.</p> <p><code>-F FUNCTION, --function FUNCTION</code></p> <p>Function ID of FPGA resource.</p> <p><code>-G, --guid</code></p> <p>Specifies guid for the resource enumeration.</p> <p><code>-m, --mode</code></p> <p>One of the following: [<code>auto</code>, <code>e40</code>, <code>e10</code>] <code>auto</code> is the default and indicates that the software runs the mode based on the first accelerator functional unit it identifies.</p> <p><code>-t, --timeout</code></p> <p>Timeout (in seconds) before the application terminates in continuous mode. Continuous mode is the default when you do not specify the number of packets.</p> <p><code>-y, --delay</code></p> <p>Delay (in seconds) between printing out a simple status line. Default is 0.100 seconds (100 milliseconds).</p> <p><code>-c, --packet-count</code></p> <p>The number of packets to send.</p> <p><code>-d, --packet-delay</code></p> <p>The delay in between packets. This delay is the number of 100 MHz clock cycles, roughly 10 nanoseconds.</p> <p><code>-s, --packet-size</code></p> <p>The packet size to send. The minimum is 46 bytes and the maximum is 1500 bytes. The default is 46 bytes.</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#commands","title":"COMMANDS","text":"<p><code>send &lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]</code></p> <p>Send packets from one port to the other. If the command line does not specify a destination port, the test runs an internal  loopback. Otherwise, the test runs an external loopback from the source port to the destination port.</p> <p><code>status [clear]</code></p> <p>Read and interpret the status registers and print to the screen. <code>clear</code> clears the status registers.</p> <p><code>stop</code></p> <p>Issue a stop command to all Ethernet controllers in the AFU.</p> <p><code>readmacs</code></p> <p>Read and display the port MAC addresses. An EEPROM stores the MAC addresses.</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#exit-codes","title":"EXIT CODES","text":"<p>0    Success - Number of packets received are equal to the number of packets sent and no errors           are reported.</p> <p>-1    Loopback failure - Either number of packets does not match or the test detected errors.</p> <p>-2    Errors parsing arguments.</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#examples","title":"EXAMPLES","text":"<p>Read the MAC addresses of the AFU loaded on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback readmacs -B 0x5e\n</code></pre> <p>Run an external loopback, sending 100 packets from port 0 to port 1. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 1 -c 100\n</code></pre> <p>Run an internal loopback until a timeout of 5 seconds is reached. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 -t 5\n</code></pre>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/","title":"mem_tg","text":""},{"location":"sw/fpga_tools/mem_tg/mem_tg/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: mem_tg [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -g,--guid TEXT=4DADEA34-2C78-48CB-A3DC-5B831F5CECBB\n                              GUID\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=info\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mem-channel UINT=0     Target memory bank for test to run on (0 indexed)\n  --loops UINT=1              Number of read/write loops to be run\n  -w,--writes UINT=1          Number of unique write transactions per loop\n  -r,--reads UINT=1           Number of unique read transactions per loop\n  -b,--bls UINT=1             Burst length of each request\n  --stride UINT=1             Address stride for each sequential transaction\n  --data UINT:value in {fixed-&gt;0,prbs15-&gt;2,prbs31-&gt;3,prbs7-&gt;1,rot1-&gt;3} OR {0,2,3,1,3}=fixed\n                              Memory traffic data pattern: fixed, prbs7, prbs15, prbs31, rot1\n  -f,--mem-frequency UINT=0   Memory traffic clock frequency in MHz\nSubcommands:\n  tg_test                     configure &amp; run mem traffic generator test\n</code></pre>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#description","title":"DESCRIPTION","text":"<p>The memory traffic generator (TG) used to exercise and test available memory channels with a configurable traffic pattern.</p> <p>Execution of this application requires the user to bind the specific VF endpoint containing the mem_tg AFU id to vfio-pci</p> <p>In the TG, read responses are checked against a specified pattern. If the application is configured to perform a read only test on a region of memory that has not previously been initialized to contain that pattern it will flag a test failure.</p>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set application log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>mem_tg application time out, by default time out 60000</p> <p><code>-m,--mem-channel</code></p> <p>Target memory bank for test to run on (0 indexed)  default: 0</p> <p><code>--loops</code></p> <p>Number of read/write loops to be run  default: 1</p> <p><code>-w,--writes</code></p> <p>Number of unique write transactions per loop.  default: 1</p> <p><code>-r,--reads</code></p> <p>Number of unique read transactions per loop  default: 1</p> <p><code>-b,--bls</code></p> <p>AXI4 burst length of each request.  Supports 1-256 transfers beginning from 0. default: 0</p> <p><code>--stride</code></p> <p>Address stride for each sequential transaction (&gt;= burst length)  default: 1</p> <p><code>--data</code></p> <p>Memory traffic data pattern. 0 = fixed {0xFF, 0x00} 1 = prbs7 2 = prbs15 3 = prbs31 4 = rot1</p> <p>default: fixed</p> <p><code>-f, --mem-frequency</code></p> <p>Memory traffic clock frequency in MHz  default: 300 MHz</p>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#examples","title":"EXAMPLES","text":"<p>This command will run a basic read/write test on the channel 0 traffic generator: <pre><code>mem_tg tg_test\n</code></pre></p> <p>This command will run the application for an afu on pcie 000:b1:00.7: <pre><code>mem_tg --pci-address 000:b1:00.7 tg_test\n</code></pre></p> <p>This command will test channel 2 write bandwidth: <pre><code>mem_tg -loops 1000 -w 1000 -r 0 -m 2 tg_test\n</code></pre></p> <p>This command will perform a read bandwidth test with a burst of 16 on channel 1 and perform a data comparison with the prbs7 pattern: <pre><code>mem_tg -loops 1000 -w 0 -r 1000 -b 0xF --data prbs7 -m 1 tg_test\n</code></pre></p> <p>This command will perform a read/write test with 1 MB strided access to channel 0 memory: <pre><code>mem_tg -loops 10000 --stride 0x100000 tg_test\n</code></pre></p>"},{"location":"sw/fpga_tools/mmlink/mmlink/","title":"mmlink","text":""},{"location":"sw/fpga_tools/mmlink/mmlink/#synopsis","title":"Synopsis","text":"<p><code>mmlink [-v] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;TCP port&gt;] [-I &lt;IP Address&gt;]</code></p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#description","title":"Description","text":"<p>The Remote Signal Tap logic analyzer provides real-time hardware debugging for the Accelerator Function Unit (AFU).  It provides a signal trace capability that the Quartus Prime software adds to the AFU. The Remote Signal Tap logic analyzer provides access to the Remote Signal Tap part of the Port MMIO space and then runs the remote protocol.</p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#examples","title":"Examples","text":"<p><code>./mmlink  -B 0x5e -P 3333</code></p> <p>MMLink app starts and listens for connection.</p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#options","title":"Options","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-S,--socket</code> </p> <p>FPGA socket number.</p> <p><code>-P,--port</code> </p> <p>TCP port number.</p> <p><code>-I,--ip</code> </p> <p>IP address of FPGA system. </p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#notes","title":"Notes","text":"<p>Driver privilege:</p> <p>Change AFU driver privilege to user:</p> <pre><code>$ chmod 777 /dev/intel-fpga-port.0\n</code></pre> <p>Change locked memory size:</p> <p>edit the file /etc/security/limits.conf</p> <pre><code>$ sudo vi /etc/security/limits.conf\n\nuser    hard   memlock           10000\n\nuser    soft   memlock           10000\n</code></pre> <p>Exit terminal and log into a new terminal.</p> <p>Verify that the locked memory is now set:  ``` $ ulimit -l 10000</p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/","title":"ofs.uio","text":""},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#synopsis","title":"SYNOPSIS","text":"<p><code>ofs.uio [-h] [--pcie-address PCIE_ADDRESS] [--uio uiox] [--feature-id FEATURE_ID] [--region-index REGION_INDEX]                   [--mailbox-cmdcsr offset] [--bit-size {8,16,32,64}] [--peek offset] [--poke offset value]                   [--mailbox-read offset] [--mailbox-dump address size] [--mailbox-write address value]</code></p> <p><code>ofs.uio [--uio uiox] [--peek offset]</code> <code>ofs.uio [--uio uiox] [--poke offset value]</code> <code>ofs.uio [--uio uiox] [--mailbox-read address]</code> <code>ofs.uio [--uio uiox] [--mailbox-write address value]</code> <code>ofs.uio [--uio uiox] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#description","title":"DESCRIPTION","text":"<p><code>ofs.uio</code> is a tool that provides user space access to DFL UIO devices, command line options like peek, poke, mailbox-read, mailbox-write, mailbox-dump to  access Configuration and Status Registers (CSRs).</p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#peek","title":"Peek","text":"<p>Peek/Read UIO CSR offset <code>ofs.uio [--uio uio] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#poke","title":"Poke","text":"<p>Poke/Write value to UIO CSR offset <code>ofs.uio [--uio uio] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-read","title":"Mailbox Read","text":"<p>Read CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-write","title":"Mailbox Write","text":"<p>Write value to CSR address using mailbox  <code>ofs.uio [--uio uio] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-dump","title":"Mailbox Dump","text":"<p>Reads/Dumps block size of CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#bit-size","title":"Bit size","text":"<p>Read/Write bit-field 8,16,32,64 sizes <code>ofs.uio [--uio uio] --bit-size 8 [--peek offset]</code> <code>ofs.uio [--uio uio] --bit-size 32 [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#pcie-address","title":"PCIe Address","text":"<p>PCIE_ADDR PCIe address of FPGA device <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#uio-region-index","title":"UIO region index","text":"<p>UIO region index, default region index is 0  <code>ofs.uio [--uio uio] --region-index 0 [--peek offset]</code> <code>ofs.uio [--uio uio] --region-index 1 [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-command-status-csr-offset","title":"Mailbox command status csr offset","text":"<p>Mailbox command status csr offset,  default value set to dfl pcie subsystem system feature mailbox command status register offset 0x28  <code>ofs.uio [--uio uio] --mailbox-cmdcsr 0xa8 [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] --mailbox-cmdcsr 0xa8  [--mailbox-read address]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#examples","title":"EXAMPLES","text":"<p>Peek/Read <pre><code>ofs.uio --uio uio0 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio6 --peek 0x0\npeek(0x0): 0x3000000100000020\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio0 --peek 0x0 --bit-size 32\npeek(0x0): 0x10002015\n</code></pre></p> <p>Poke/Write <pre><code>ofs.uio --uio uio6 --peek 0x8\npeek(0x8): 0x0\nofs.uio --uio uio6 --poke  0x8 0xabcdd12345\npoke(0x8):0xabcdd12345\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x8): 0x0\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --poke  0x8 0x1234\npoke(0x8):0x1234\n</code></pre></p> <p>Mailbox Read <pre><code>ofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --uio uio6 --mailbox-read 0x8\nMailboxRead(0x8): 0x110c000\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x8 \nMailboxRead(0x8): 0x110c000\n</code></pre></p> <p>Mailbox Write <pre><code>ofs.uio --uio uio6 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0):0x1234\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0 \nMailboxRead(0x0):0x1234\n</code></pre></p> <p>Mailbox Dump <pre><code>ofs.uio --uio uio6 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n</code></pre></p>"},{"location":"sw/fpga_tools/opae.io/opae.io/","title":"opae.io","text":""},{"location":"sw/fpga_tools/opae.io/opae.io/#synopsis","title":"SYNOPSIS","text":"<p><code>opae.io ls [-v,--viddid VID:DID]</code> <code>opae.io init [-d PCI_ADDR USER[:GROUP]]</code> <code>opae.io release [-d PCI_ADDR]</code> <code>opae.io [-d PCI_ADDR] [-r REGION] walk OFFSET [-u,--show-uuid]</code> <code>opae.io [-d PCI_ADDR] [-r REGION] peek OFFSET</code> <code>opae.io [-d PCI_ADDR] [-r REGION] poke OFFSET VALUE</code> <code>opae.io [-d PCI_ADDR] [-r REGION] SCRIPT ARG1 ARG2 ... ARGN</code> <code>opae.io [-d PCI_ADDR] [-r REGION]</code></p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#description","title":"DESCRIPTION","text":"<p><code>opae.io</code> is an interactive Python environment packaged on top of <code>libopaevfio.so</code>, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device.</p> <p><code>opae.io</code> has two operating modes: command line mode and interactive mode.</p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#command-line-mode","title":"COMMAND LINE MODE","text":"<p>To view the accelerator devices that are present on the system, <code>opae.io</code> provides the <code>ls</code> command option.</p> <p><code>opae.io ls [-v,--viddid VID:DID]</code></p> <p>Each accelerator device is listed along with the PCIe address, the PCIe vendor/device ID, a brief description of the device, and the driver to which the device is currently bound.</p> <p><code>opae.io</code> provide an option to initialize a PCIe device for use with the vfio-pci driver. In order for the device CSRs to be accessed from user space, the device must first be bound to the vfio-pci driver. This is the job of the <code>init</code> command option.</p> <p><code>opae.io init [-d PCI_ADDR USER:[GROUP]]</code></p> <p>The <code>init</code> command unbinds the specified device from its current driver and binds it to vfio-pci. This creates a new vfio group under /dev/vfio. This group path is then used by the <code>libopaevfio.so</code> library to interact with the device.</p> <p>To release the PCIe device from vfio-pci and return it to use with its previous driver, the <code>release</code> command option is used.</p> <p><code>opae.io release [-d PCI_ADDR]</code></p> <p>The <code>release</code> command option reverses the actions of the last <code>init</code> command, releasing the device from vfio-pci and binding it to the driver which was bound at the time the <code>init</code> command was issued.</p> <p>The <code>walk</code> command option traverses and displays the Device Feature List of the given region.</p> <p><code>opae.io walk [-d PCI_ADDR] [-r REGION] [OFFSET] [-u,--show-uuid]</code></p> <p>The various fields of each Device Feature Header are displayed. The <code>--show-uuid</code> option additionally displays the GUID for each feature. OFFSET can be used to specify the beginning of the DFL in the MMIO region.</p> <p>The <code>peek</code> command option reads and displays a CSR value.</p> <p><code>opae.io peek [-d PCI_ADDR] [-r REGION] OFFSET</code></p> <p>The <code>poke</code> command option writes a given value to a CSR.</p> <p><code>opae.io poke [-d PCI_ADDR] [-r REGION] OFFSET VALUE</code></p> <p><code>opae.io</code> can also execute Python scripts from the command line. These Python scripts may contain calls to the device built-in functions that are available during an interactive session. Refer to the description of interactive mode for details.</p> <p><code>opae.io [-d PCI_ADDR] [-r REGION] myscript.py a b c</code></p> <p>In order to enter the interactive mode of <code>opae.io</code>, simply invoke it and optionally pass the desired device address and MMIO region options.</p> <p><code>opae.io [-d PCI_ADDR] [-r REGION]</code></p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#interactive-mode","title":"INTERACTIVE MODE","text":"<p>Upon entering interactive mode, <code>opae.io</code> begins a Python interpreter session and displays the command prompt shown below:</p> <p>0000:3f:00.0[0]&gt;&gt;</p> <p>The first portion of the prompt shows the address of the active PCIe device, here 0000:3f:00.0. The part in square brackets shows the active MMIO region, here [0].</p> <p>The interpreter waits for a valid Python command, then attempts to execute the given command in the usual way. The only differences between the traditional Python command intepreter and <code>opae.io</code> are that opae.io provides 1) the notion of an active PCIe device and MMIO region and 2) several built-in functions and objects that allow manipulating the active device and MMIO region.</p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#built-in-functions","title":"BUILT-IN FUNCTIONS","text":"<p>The <code>opae.io</code> built-in functions assume an active device and MMIO region. Attempting to use the built-in functions without first opening a device and region will result in errors.</p> <p><code>peek(OFFSET)</code></p> <p>The <code>peek</code> built-in function reads and displays a CSR value from the active device and region, at the offset supplied by its argument.</p> <p>0000:3f:00.0[0]&gt;&gt; peek(0x28) 0xdeadbeef</p> <p><code>poke(OFFSET, VALUE)</code></p> <p>The <code>poke</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; poke(0x28, 0xdeadbeef)</p> <p><code>read_csr(OFFSET)</code></p> <p>The <code>read_csr</code> built-in function returns the value of the CSR at the active MMIO region and the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; print('0x{:0x}'.format(read_csr(0x28))) 0xdeadbeef</p> <p><code>write_csr(OFFSET, VALUE)</code></p> <p>The <code>write_csr</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; write_csr(0x28, 0xdeadbeef)</p> <p><code>device(PCI_ADDR)</code></p> <p>The <code>device</code> built-in function allows changing the active PCIe device.</p> <p>0000:3f:00.0[0]&gt;&gt; device('0000:2b:00.0') 0000:2b:00.0&gt;&gt;</p> <p><code>region(REGION)</code></p> <p>The <code>region</code> built-in function allows changing the active MMIO region.</p> <p>0000:2b:00.0&gt;&gt; region(0) 0000:2b:00.0[0]&gt;&gt;</p> <p><code>allocate_buffer(SIZE)</code></p> <p>The <code>allocate_buffer</code> built-in function creates and returns a DMA buffer object. The underlying buffer will be SIZE bytes in length.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = allocate_buffer(4096) 0000:2b:00.0[0]&gt;&gt; print(b1.size, '0x{:0x}'.format(b1.address), b1.io_address) 4096 0x7f9361c66000 0</p> <p><code>version()</code></p> <p>The <code>version</code> built-in function returns a tuple containing the four components used to identify the opae.io version:</p> <p>0000:2b:00.0[0]&gt;&gt; print(version()) ('opae.io', 0, 2, 0)</p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#built-in-objects","title":"BUILT-IN OBJECTS","text":"<p><code>opae.io</code> interactive mode provides two global objects corresponding to the current device and that device's current MMIO region. These objects are referred to by global variables <code>the_device</code> and <code>the_region</code>, respectively.</p> <p>The <code>device</code> class:</p> <p>the_device.descriptor() : method that returns the integer file descriptor of the <code>VFIO container</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.descriptor()) 5</p> <p>the_device.repr() : method that is invoked when a <code>device</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device) 0000:2b:00.0</p> <p>the_device.allocate(SIZE) : method that allocates and returns a <code>system_buffer</code> object. The buffer will be mapped into the DMA space of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = the_device.allocate(4096)</p> <p>the_device.pci_address() : read-only property that returns the PCIe address of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.pci_address) 0000:2b:00.0</p> <p>the_device.num_regions : read-only property that returns the number of MMIO regions in <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.num_regions) 2</p> <p>the_device.regions : read-only property that returns a list of the active MMIO regions of <code>the_device</code>:</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.regions) [0, 2]</p> <p>The <code>region</code> class:</p> <p>the_region.write32(OFFSET, VALUE) : method that writes a 32-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read32(OFFSET) : method that returns a 32-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write32(0x28, 0xdeadbeef) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read32(0x28))) 0xdeadbeef</p> <p>the_region.write64(OFFSET, VALUE): method that writes a 64-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read64(OFFSET): method that returns a 64-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write64(0x28, 0xbaddecaf) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read64(0x28))) 0xbaddecaf</p> <p>the_region.index(): method that returns the MMIO index of <code>the_region</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region.index()) 0</p> <p>the_region.repr(): method that is invoked when a <code>region</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region) 0</p> <p>the_region.len(): method that is invoked to determine the MMIO region size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(len(the_region)) 524288</p> <p>The <code>allocate_buffer()</code> built-in function and the <code>device.allocate()</code> method return objects of type <code>system_buffer</code>.</p> <p>The <code>system_buffer</code> class is as follows:</p> <p><code>buf.size</code>: read-only property that gives the buffer size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(b1.size) 4096</p> <p><code>buf.address</code>: read-only property that gives the buffer's user mode virtual address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.address)) 0x7f2c15d8200</p> <p><code>buf.io_address</code>: read-only property that gives the buffer's IO address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.io_address)) 0x0</p> <p><code>buf.__getitem__</code> and <code>buf.__setitem__</code>: indexing get/set of 64-bit data item.</p> <p>0000:2b:00.0[0]&gt;&gt; b1[0] = 0xdecafbad 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1[0])) 0xdecafbad</p> <p><code>buf.read8(OFFSET)</code> <code>buf.read16(OFFSET)</code> <code>buf.read32(OFFSET)</code> <code>buf.read64(OFFSET)</code> : methods that read the given size data item from the given buffer OFFSET.</p> <p><code>buf.fill8(VALUE)</code> <code>buf.fill16(VALUE)</code> <code>buf.fill32(VALUE)</code> <code>buf.fill64(VALUE)</code> : methods that fill the buffer with the given VALUE, using the given size.</p> <p><code>b1.compare(b2)</code>: method that compares buffers. The method returns the index of the first byte that miscompares, or the length of b1.</p>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/","title":"opaeuio","text":""},{"location":"sw/fpga_tools/opaeuio/opaeuio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaeuio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-v] [device]</code></p>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/#description","title":"DESCRIPTION","text":"<p>The <code>opaeuio</code> command enables the binding/unbinding of a DFL device to/from the dfl-uio-pdev device driver. See https://kernel.org/doc/html/v4.14/driver-api/uio-howto.html for a description of uio.</p>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/#options","title":"OPTIONS","text":"<p><code>device</code>     The DFL device name, eg dfl_dev.10</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given device for uio.\nUsed in conjunction with -u, -g, and -d.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given device from uio.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when binding to uio.\nThe default value is dfl-uio-pdev.\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to uio. A new device node is created in\n/dev when the device is bound to uio. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to uio. Use this option to specify the\nnew device group for the device created in /dev.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/#examples","title":"EXAMPLES","text":"<p><code>opaeuio -h</code> <code>opaeuio -v</code> <code>sudo opaeuio -i -u lab -g labusers dfl_dev.10</code> <code>sudo opaeuio -r dfl_dev.10</code></p>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/","title":"opaevfio","text":""},{"location":"sw/fpga_tools/opaevfio/opaevfio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaevfio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-n] [-v] [addr]</code></p>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/#description","title":"DESCRIPTION","text":"<p>The <code>opaevfio</code> command enables the binding/unbinding of a PCIe device to/from the vfio-pci device driver. See https://kernel.org/doc/Documentation/vfio.txt for a description of vfio-pci.</p>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/#options","title":"OPTIONS","text":"<p><code>addr</code>     The PCIe address of the device in ssss:bb:dd.f format, eg 0000:7f:00.0</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given addr for vfio.\nUsed in conjunction with -u, -g, and -n.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given addr from vfio.\nUsed in conjunction with -d.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when releasing from vfio.\nWhen omitted, the device is not rebound to a driver (default).\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to vfio. A new device node is created in\n/dev/vfio when the device is bound to vfio-pci. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to vfio. Use this option to specify the\nnew device group for the device created in /dev/vfio.\n</code></pre> <p><code>-n, --no-sriov</code></p> <pre><code>Do not enable SR-IOV when binding to vfio. The default value for this option\nis FALSE, ie the script should specify SR-IOV functionality when binding to\nthe vfio-pci driver. When omitted, the modprobe command which loads the vfio-pci\ndriver will contain the `enable_sriov=1` option. When given, it will not.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/#examples","title":"EXAMPLES","text":"<p><code>opaevfio -h</code> <code>opaevfio -v</code> <code>sudo opaevfio -i -u lab -g labusers 0000:7f:00.0</code> <code>sudo opaevfio -r 0000:7f:00.0</code></p>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/","title":"Pac hssi config","text":"<pre><code># pac_hssi_config #\n\n## SYNOPSIS ##\n```console\npac_hssi_config.py [-h] subcommand [subarg] [bdf]\n</code></pre>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#description","title":"DESCRIPTION","text":"<p>The <code>pac_hssi_config.py</code> tool exercises the Ethernet 10 Gbps (10GbE) and 40GbE transceivers for designs using the Intel\u00ae Programmable Acceleration Card (PAC) with Intel Arria\u00ae 10 GX FPGA. This tool does not support the  Intel Xeon\u00ae Processor with Integrated FPGA. </p> <p></p> <p>The two required arguments to the <code>pac_hssi_config.py</code> tool specify the subcommand and bus, device, and function (BDF) for the PCIe device under test. You must provide the BDF parameter for systems with more than one PCIe card. </p> <pre><code>.. note::\n    If you do not provide the BDF when required, the command prints a list of valid BDFs for the system. You can also\n    determine the BDF using the ``lspci`` command.\n</code></pre> <p>For usage help, type the following at a command prompt:</p> <p><code>pac_hssi_config.py [-h|--help]</code></p> <p>To configure the network ports, send data, and read statistics, use the following form of the <code>pac_hssi_config.py</code> script:</p> <p><code>pac_hssi_config.py subcommand [subarg] [bdf]</code></p> <p>Only a subset of subcommand arguments support <code>subarg</code>. </p>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#table-1-general-subcommands","title":"Table 1. General Subcommands","text":"Subcommand Subarg Description <code>stat</code> N/A Prints high speed serial interface (HSSI) controller statistics. <code>eeprom</code> N/A Reads the 128-bit unique board ID, MAC address, and board-specific IDs from EEPROM."},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#table-2-1040-gbe-traffic-generation-subcommands","title":"Table 2. 10/40 GbE Traffic Generation Subcommands","text":"Subcommand Subarg Description <code>e10init</code> and <code>e40init</code> N/A Initializes HSSI PHY to 10GbE or 40GbE mode.  Clears statistics and enable internal HSSI transceiver loopback. <code>e10loop</code> and <code>e40loop</code> On/Off Turns on or off internal HSSI transceiver loopback. <code>e10reset</code> and <code>e40reset</code> On/Off Asserts or deasserts AFU reset.  Clears packet statistics and disables internal HSSI transceiver loopback. <code>e10send</code> and <code>e40send</code> N/A Sends 1,000,000 1500-byte packets. For 10GbE sends packets on all four ports. 40GbE has a single port. <code>e10stat</code> and <code>e40stat</code> N/A Prints packet statistics. <code>e10statclr</code> and <code>e40statclr</code> N/A Clears packet statistics.  Use this command after switching loopback modes to clear any transient statistics accumulated during the mode switch. <p>The transceiver equalization <code>eqwrite</code> and <code>eqread</code> subcommands write and read transceiver equalization settings.  These subcommands require you to specify the transceiver channel, the equalization setting, and the value (for writes).  Use the following form for the <code>eqwrite</code> command:</p> <p><code>pac_hssi_config.py eqwrite [transceiver channel number] [equalization setting] [equalization value] [bdf]</code></p> <p>Use the following form for the <code>eqread</code>command:</p> <p><code>pac_hssi_config.py eqread [transceiver channel number] [equalization setting] [bdf]</code> </p>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#table-3-transceiver-equalization-subcommands","title":"Table 3. Transceiver Equalization Subcommands","text":"Subcommand Channel Number Equalization Setting Value <code>eqwrite</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) Specifies the value for the specified equalization setting. <code>eqread</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) N/A <p>For more information about reconfiguring transceiver analog parameter settings In Arria\u00ae 10 devices, refer to \"Changing PMA Analog Parameters\" in the  Intel\u00ae Arria\u00ae 10 Transceiver PHY User Guide. </p>"},{"location":"sw/fpga_tools/packager/packager/","title":"packager","text":""},{"location":"sw/fpga_tools/packager/packager/#synopsis","title":"SYNOPSIS","text":"<p><code>packager &lt;cmd&gt; [arguments]</code></p>"},{"location":"sw/fpga_tools/packager/packager/#description","title":"Description","text":"<p>The packager provides tools that Accelerator Functional Unit (AFU) developers use to create Accelerator Function (AF)  files. The AF file is the programming file for an AFU on Intel\u00ae FPGA platforms. The packager tool concatenates the metadata from the JSON file to a raw binary file <code>(.rbf)</code> that the Intel Quartus\u00ae Prime software generates. </p> <p>The packager's only function is to create an AF file. Refer to Packager Command Syntax for more information about invoking the packager. The packager depends on a JSON file to describe AFU metadata. Refer to  Accelerator Description File for more information about the JSON file.</p> <p>The packager requires Python 2.7.1 and Python 2.7.3. The tool indicates if it is being called with a compatible  of Python.</p>"},{"location":"sw/fpga_tools/packager/packager/#packager-command-syntax","title":"Packager Command Syntax","text":"<p>The packager is a command line tool with the following syntax:</p> <p><code>$ packager &lt;cmd&gt; [arguments]</code></p> <p>The following table describes the <code>&lt;CMD&gt;</code> arguments:</p> Command Arguments Description <code>create-gbs</code> <code>--rbf=&lt;RBF_PATH&gt;</code> <code>--afu=&lt;AFU_JSON_PATH&gt;</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> Creates the AF file. The engineering name for this file is the green bit stream, abbreviated gbs. The <code>--rbf</code> and <code>--afu</code>   arguments are required.  <code>&lt;RBF_PATH&gt;</code> is the path to the RBF file for the AFU. The Quartus\u00ae Prime software generates this RBF by compiling the AFU design. <code>&lt;AFU_JSON_PATH&gt;</code> is the path to the Accelerator Description file. This is a JSON file that describes the metadata that <code>create-gbs</code> appends to the RBF. <code>&lt;GBS_PATH&gt;</code> is the path to the RBF file for the FPGA Interface Manager (FIM) that contains the FPGA interface unit and other interfaces. If you do not specify the <code>--gbs</code>, the command defaults to <code>&lt;rbf_name&gt;.gbs</code>. You can use the optional <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>modify-gbs</code> <code>--gbs=&lt;gbs_PATH&gt;</code> Modifies the AF file. The <code>--input-gbs</code>argument is required. If you do not provide the <code>--output-gbs</code> argument, <code>modify-gbs</code> overwrites the <code>--input-gbs</code> file. Use the <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>gbs-info</code> <code>--input-gbs=&lt;gbs_PATH&gt;</code> Prints information about the AF file. The <code>--input-gbs</code> argument is required. <code>get-rbf</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--rbf=&lt;RBF_PATH&gt;</code> Creates the RBF by extracting it from the AF file. The <code>--gbs</code>argument is required. If you do not specify the <code>--rbf</code> argument, the command defaults to <code>&lt;gbs_name.rbf</code> . None, or any <code>&lt;CMD&gt;</code> <code>--help</code> Summarizes the <code>&lt;CMD&gt;</code> options. Typing <code>packager --help</code> gives a list of <code>&lt;CMD&gt;</code> values. Typing <code>packager &lt;CMD&gt; --help</code> provides detailed help for <code>&lt;CMD&gt;</code>"},{"location":"sw/fpga_tools/packager/packager/#examples","title":"Examples","text":"<p>To generate an AF file, run:</p> <p><code>$ packager create-gbs --rbf=&lt;RBF_PATH&gt; --afu=&lt;AFU_JSON_PATH&gt; --gbs=&lt;GBS_PATH&gt;</code></p> <p>TIP: JSON files are very particular about syntax such as trailing commas. If you are getting errors, use <code>jsonlint.com</code> to validate that your JSON is formatted correctly. </p> <p>To modify metadata in an existing AF, run the following command:</p> <p><code>$ packager modify-gbs --input-gbs=&lt;PATH_TO_GBS_TO_BE_MODIFIED&gt; --outputgbs=&lt;NAME_FOR_NEW_GBS&gt; --set-value &lt;key&gt;:&lt;value&gt;</code></p> <p>You can pass in a number of : pairs with --set-value to update values in an AF.  <p>To print the metadata of an existing AF: </p> <p><code>$ packager get-info --gbs=&lt;GBS_PATH&gt;</code> </p> <p>To extract the RBF from the AF:</p> <p><code>$ packager get-rbf --gbs=&lt;GBS_PATH&gt; --rbf=&lt;NAME_FOR_RBF&gt;</code></p>"},{"location":"sw/fpga_tools/packager/packager/#accelerator-description-file","title":"Accelerator Description File","text":"<p>The Accelerator Description File is a JSON file that describes the metadata associated with an AFU. The Open Progammable Accelerator Engine (OPAE) uses this metadata during reconfiguration. Here is an example file:</p> <p><pre><code>{\n   \"version\": 1,\n   \"platform-name\": \"DCP\",\n   \"afu-image\": {\n      \"magic-no\": 488605312,\n      \"interface-uuid\": \"01234567-89AB-CDEF-0123-456789ABCDEF\",\n      \"power\": 0,\n      \"accelerator-clusters\": [{\n         \"name\": \"dma_test_afu\",\n         \"total-contexts\": 1,   \n         \"accelerator-type-uuid\": \"331DB30C-9885-41EA-9081-F88B8F655CAA\"\n      }\n      ]  \n   }\n}\n</code></pre> The packager stores these parameter values in the resultant AF. After reprogramming the AFU using partial reconfiguration (PR), the  software driver reconfigures the PLLs by writing the clock-frequency-high and clock-frequency-low values (if present) over the  PCIe\u00ae and CCI interfaces. </p> <p>.. note:: <pre><code>The JSON file format may change as the architecture evolves. Any changes to the current format trigger an update\nto the version number.  \n</code></pre></p> <p>CATEGORY | NAME | TYPE | DESCRIPTION | MANDATORY ---------|------|------|-------------|:----------:| Per-AFU  | version | Integer | Version of the metadata format. | Yes Per-AFU  | magic-no (to be deprecated)| Integer | Magic no. Associated with the FPGA Interface Manager. | No Per-AFU  | platform-name | String | Name of the platform for which the metadata is intended. The field value is \u201cDCP\u201d for Intel  Acceleration Stack for FPGAs. | No Per-AFU  | interface-uuid | UUID | Interface id associated with the FPGA Interface Manager. | Yes Per-AFU  | power | Integer | Accelerator Function power consumption, in watts. Set to 0 for Intel Acceleration Stack for FPGAs platforms. | Yes Per-AFU  | clock-frequency-low | Float | Clock frequency for 1st PLL (Clock network)1 in MHz. | No Per-AFU  | clock-frequency-high | Float | Clock frequency for 2nd PLL (0 if absent) in MHz. | No Per-AFC Cluster | total-contexts | Integer | Number of AFCs in this cluster. Always be 1 in current architectures. | Yes Per-AFC Cluster | afc-type-uuid |  UUID | AFC type = AFU ID in current architectures. | Yes Per-AFC Cluster | name | string | AFC name = AFU name in current architectures. | Yes</p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"sw/fpga_tools/pci_device/pci_device/","title":"pci_device","text":""},{"location":"sw/fpga_tools/pci_device/pci_device/#synopsis","title":"SYNOPSIS","text":"<p><code>pci_device [-h] [-E] device-filter [{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}]</code></p>"},{"location":"sw/fpga_tools/pci_device/pci_device/#description","title":"DESCRIPTION","text":"<p>pci_device is a tool to aid in common operations for managing PCIe devices and drivers.</p>"},{"location":"sw/fpga_tools/pci_device/pci_device/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/pci_device/pci_device/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<pre><code>`device filter`\n\nPCIe address of a device or vendor/device ID pair.\nThe PCIe address follows the format of [segment:]bus:device.function\nwhile the vendor/device ID pair follows the format [vendor ID]:[device ID]\nwhere at least one of these must be present.\n\n`{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}`\n\naction to perform on device\n\n`aer`\nPerform AER (Advanced Error Reporting) operations.\nThe aer action has its own sub-commands which are listed below:\n\n* `dump` sub-command will print out the AER error counters as reported\n   by the sysfs files for the device.\n* `mask` can either print out the current AER mask bits or set them\n  * If `show` or `print` (or nothing) is given after the `mask`\n    command, it will show the current mask bits for AER.\nBy default output will be written in stdout but can be written to an\noutput file if `-o|--output FILENAME` argument is given.\n  * If `all` is given after the `mask` command, it will mask all bits\n    (by setting the values to 0xffffffff and 0xffffffff).\n  * If `off` is given after the `mask` command, it will unmask all\n    bits (by setting the values to 0x0 and 0x0).\n  * If two numbers are present after the `mask` command, those two\n    numbers will be used to set the mask bits.\nValues for setting the mask can also be read in from an input file if\n`-i|--input FILENAME` argument is given.\n\n_NOTE_: mask related operations require root privileges\n\n`bind`\n\nAssociate a device with its driver.\n\n`plug`\n\nRestore a device that was previously given to `pci_device &lt;device&gt; unplug`\n\n`remove`\n\nRemove the pci device from the pci bus\n\n`rescan`\n\nRescan the bus as identified by the bus component of the PCIe device address\n\n'topology`\n\nPrint the PCIe topology from the root port to the PCIe device.\nThis shows the PCIe tree rooted at the PCIe root port.\nEach line shows the the PCIe address, vendor ID, and device ID along with\nthe driver bound to the device. The indentnation is used to show\nparent/child relationship of devices.\n\nThe line listing the target PCIe device as identified by the given PCIe\naddress will be highlighted in green while the endpoints will be\nhighlighted in cyan.\n\nThe example below shows the topology of an N3000 device with eight virtual\nfunctions created from one of the Ethernet controllers:\n\n```console\n[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)\n    [pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)\n        [pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3f:00.0), pci_id(0x8086, 0x0b30)] (dfl-pci)\n        [pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)\n    [pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3d:02.0), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.7), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.5), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.3), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.1), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.6), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.4), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.2), pci_id(0x8086, 0x154c)] (iavf)\n        [pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n\n```\n\n`unbind`\n\nUnbind the driver bound to the device.\n\n`unplug`\n\nRemove device from PCI bus in anticipation of a RSU event by configuring its root port and associated endpoints.\n\n`vf`\n\nCreate/destroy VFs (virtual functions) by setting the number here.\nThe number given here will be written to sriov_numvfs sysfs file triggering\nthe PCIe subsystem to create/destroy VFs so that the current number of VFs\nwill be equal to the given number. If the number given is outside of the total VFs supported, an error message will be displayed to indicate this.\n</code></pre>"},{"location":"sw/fpga_tools/pci_device/pci_device/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<pre><code>`-h, --help`\n\nshow this help message and exit\n\n`-E, --other-endpoints`\n\nperform action on peer PCIe devices\n</code></pre>"},{"location":"sw/fpga_tools/pci_device/pci_device/#examples","title":"EXAMPLES","text":"<pre><code>pci_device 0000:3d:00.0 remove\npci_device 0000:3d:00.0 rescan\npci_device 3d:00.0 topology\npci_device :0b30 topology\npci_device :0b30 aer\npci_device :0b30 aer mask\npci_device :0b30 aer mask all\npci_device :0b30 aer mask -o mask.dat\npci_device :0b30 aer mask -i mask.dat\n</code></pre>"},{"location":"sw/fpga_tools/rsu/rsu/","title":"rsu","text":""},{"location":"sw/fpga_tools/rsu/rsu/#synopsis","title":"SYNOPSIS","text":"<pre><code>rsu [-h] [-d] {bmc,bmcimg,retimer,fpga,sdm,fpgadefault} [PCIE_ADDR]\n</code></pre>"},{"location":"sw/fpga_tools/rsu/rsu/#description","title":"DESCRIPTION","text":""},{"location":"sw/fpga_tools/rsu/rsu/#mode-1-rsu","title":"Mode 1: RSU","text":"<pre><code>rsu bmc --page=(user|factory) [PCIE_ADDR]\nrsu retimer [PCIE_ADDR]\nrsu fpga --page=(user1|user2|factory) [PCIE_ADDR]\nrsu sdm --type=(sr|pr|sr_cancel|pr_cancel) [PCIE_ADDR]\n</code></pre> <p>Perform RSU (remote system update) operation on PAC device given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.</p>"},{"location":"sw/fpga_tools/rsu/rsu/#mode-2-default-fpga-image","title":"Mode 2: Default FPGA Image","text":"<pre><code>rsu fpgadefault --page=(user1|user2|factory) --fallback=&lt;csv&gt; [PCIE_ADDR]\n</code></pre> <p>Set the default FPGA boot sequence. The --page option determines the primary FPGA boot image. The --fallback option allows a comma-separated list of values to specify fallback images.</p>"},{"location":"sw/fpga_tools/rsu/rsu/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{bmc,bmcimg,retimer,fpga,sdm,fpgadefault}</code></p> <p>type of RSU operation or set Default FPGA Image operation.</p> <p><code>PCIE_ADDR</code>  PCIe address of device to do rsu (e.g. 04:00.0 or 0000:04:00.0) </p>"},{"location":"sw/fpga_tools/rsu/rsu/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code> show this help message and exit</p> <p><code>-d, --debug</code> log debug statements</p> <p><code>--force</code> force rsu operation</p>"},{"location":"sw/fpga_tools/rsu/rsu/#example","title":"EXAMPLE","text":"<pre><code># rsu bmc --page=user 25:00.0\n</code></pre> <p>Triggers a boot of the BMC image (user page) for the device with PCIe  address 25:00.0.</p> <pre><code># rsu bmc --page=factory 25:00.0\n</code></pre> <p>Triggers a factory boot of the BMC image for the device with  PCIe address 25:00.0.</p> <pre><code># rsu fpga --page=user2 25:00.0\n</code></pre> <p>Triggers a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0.</p> <pre><code># rsu --force fpga --page=user2 25:00.0\n</code></pre> <p>Forces a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0. Default behavior is to not perform  the rsu operation if DPC (downstream port containment) is not supported  and AER (advanced error reporting) is also not supported. Using --force  changes this behavior to perform rsu operation regardless but may result  in a surprise removal of pci devices which may cause the Linux kernel  to panic.</p> <pre><code># rsu fpga --page=factory 25:00.0\n</code></pre> <p>Triggers a factory reconfiguration of the FPGA for the device  with PCIe address 25:00.0.</p> <pre><code># rsu sdm --type=sr 25:00.0\n</code></pre> <p>Triggers Static Region key programming for the device with  PCIE address 25:00.0.</p> <pre><code># rsu fpgadefault --page=factory --fallback=user1,user2 25:00.0\n</code></pre> <p>Sets the FPGA boot sequence to factory with fallbacks user1, user2.</p>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/","title":"Super Remote System Update User Guide","text":"<pre><code>.. toctree::\n.. highlight:: c\n.. highlight:: console\n</code></pre>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#overview","title":"Overview","text":"<p>Intel Programmable Acceleration Card (PAC) devices are comprised of multiple processors and controllers that execute firmware. Maintaining and updating these firmware images manually is error-prone and does not scale well within the Data Center. The solution described here is derived with the following goals in mind:</p> <ul> <li>The ability to update one or more (possibly all) firwmare images with a single package.</li> <li>The ability to complete all firmware updates within a stipulated time window.</li> <li>The ability to update each PAC in the server, all servers in a Data Center, and multiple Data Centers remotely.</li> <li>The ability to remotely initiate download of the package and its installation with a single command per server instance.</li> <li>The ability to roll back firmware to a previous revision.</li> </ul>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#implementation","title":"Implementation","text":"<p>A single package containing firmware images for all programmable parts on a PAC is delivered as an RPM, eg opae-super-rsu-n3000.M.m.p-r.noarch.rpm. The RPM revision will sequentially increase with every update.</p> <p>Installing or upgrading the RPM invokes the complete update of all programmable parts on all PAC boards in the system.</p> <p>The standard RPM dependency framework ensures that correct versions of dependecy packages opae-intel-fpga-driver and fpga-tools-extra are installed on the system.</p> <p>Rolling back is achieved by uninstalling the current version and re-installing a previous version of the RPM.</p> <p>.. note:: <pre><code>Note: once Secure Update is deployed, roll back restrictions shall be implemented to prevent\nrollback attacks.\n</code></pre></p> <p>RPM management on remote systems is standard practice, requiring no new infrastructure/training.</p>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#details","title":"Details","text":"<p>The post-install hook of the opae-super-rsu-n3000 RPM is leveraged to call out to the super-rsu Python script to update all PAC boards. super-rsu uses the manifest file packaged within opae-super-rsu-n3000 to associate a firmware image with its version. Each of the firmware images contained in opae-super-rsu-n3000 is placed on the target system in /usr/share/opae/n3000.</p>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#algorithm","title":"Algorithm","text":"<ul> <li>Acquire the current firmware versions of all programmable parts.</li> <li>For each programmable image, if the installed version of firmware does not equal the version provided in the RPM manifest file, then update the firmware image, and set image_updated to True.</li> <li>After all updates, if image_updated, then initiate a safe reboot of all boards in the system.</li> <li>After safe reboot, verify that the reported firmware versions match those of the RPM manifest. If they do not match, then RPM installation exits with a failing status.</li> <li>Run board self test. If the self test fails, then the RPM installation exits with a failing status.</li> <li>If all of the above checks is successful, then RPM installation exits with a success status.</li> </ul>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#dependencies","title":"Dependencies","text":"<ul> <li>The standard Python package for the distro (version 2.7).</li> <li>The opae-intel-fpga-driver RPM. (version determined by opae-super-rsu-n3000)</li> <li>The opae-tools-extra RPM. (version determined by opae-super-rsu-n3000)</li> </ul>"},{"location":"sw/fpga_tools/userclk/userclk/","title":"userclk","text":""},{"location":"sw/fpga_tools/userclk/userclk/#synopsis","title":"SYNOPSIS","text":"<p><code>userclk [-hv] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] [-H &lt;User clock high frequency&gt;] -L &lt;User clock low frequency&gt;]</code></p>"},{"location":"sw/fpga_tools/userclk/userclk/#description","title":"DESCRIPTION","text":"<p>userclk sets the frequency range for an AFU. </p>"},{"location":"sw/fpga_tools/userclk/userclk/#examples","title":"EXAMPLES","text":"<p><code>./userclk -B 0x5e -H 400 -L 200</code></p> <p>Sets AFU frequency.</p>"},{"location":"sw/fpga_tools/userclk/userclk/#options","title":"OPTIONS","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-S,--segment</code> </p> <p>FPGA segment number.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-H,--freq-high</code> </p> <p>User clock high frequency. </p> <p><code>-L,--freq-low</code> </p> <p>User clock low frequency. </p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"sw/fpga_tools/vabtool/vabtool/","title":"vabtool","text":""},{"location":"sw/fpga_tools/vabtool/vabtool/#synopsis","title":"SYNOPSIS","text":"<p><code>vabtool [-r RETRIES] [-d] [-y] [-v] &lt;ACTION&gt;</code></p> <p>Where ACTION is defined as one of the following:</p> <p><code>vabtool sr_key_provision PCIE_ADDRESS SR_RKH_FILE FPGA_IMG_FILE</code> <code>vabtool sr_status PCIE_ADDRESS</code> <code>vabtool pr_key_provision PCIE_ADDRESS PR_AUTH_CERT_FILE PR_RKH_FILE</code> <code>vabtool pr_status PCIE_ADDRESS</code> <code>vabtool sr_key_cancel PCIE_ADDRESS SR_RKH_CANCEL_FILE</code> <code>vabtool sr_cancel_status PCIE_ADDRESS</code> <code>vabtool pr_key_cancel PCIE_ADDRESS PR_RKH_CANCEL_FILE</code> <code>vabtool pr_cancel_status PCIE_ADDRESS</code></p>"},{"location":"sw/fpga_tools/vabtool/vabtool/#description","title":"DESCRIPTION","text":"<p>The <code>vabtool</code> command helps perform Vendor Authenticated Boot provisioning of Static Region and Partial Reconfiguration Region key hashes and helps perform SR and PR hash cancellation and status reporting.</p>"},{"location":"sw/fpga_tools/vabtool/vabtool/#options","title":"OPTIONS","text":"<p><code>-r RETRIES, --retries RETRIES</code></p> <pre><code>Specifies the number of times a failed SR or PR key provision is to be\nretried. The default value for RETRIES is 3.\n</code></pre> <p><code>-d, --dry-run</code></p> <pre><code>Don't execute the actual fpgasupdate and rsu commands, but only print\nthe commands that would be executed during a normal run of the script.\n</code></pre> <p><code>-y, --yes</code></p> <pre><code>The tool will respond with an automatic Yes answer to all confirmation\nprompts posed by the sub-tools.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"sw/fpga_tools/vabtool/vabtool/#examples","title":"EXAMPLES","text":"<p><code>sudo vabtool -y sr_key_provision 0000:bc:00.0 my_sr_rkh.bin my_fpga.bin</code> <code>sudo vabtool sr_status 0000:bc:00.0</code> <code>sudo vabtool -y pr_key_provision 0000:bc:00.0 pr_auth_cert.bin my_pr_rkh.bin</code> <code>sudo vabtool pr_status 0000:bc:00.0</code> <code>sudo vabtool sr_key_cancel 0000:bc:00.0 my_sr_rhk_cancel.bin</code> <code>sudo vabtool sr_cancel_status 0000:bc:00.0</code> <code>sudo vabtool pr_key_cancel 0000:bc:00.0 my_pr_rhk_cancel.bin</code> <code>sudo vabtool pr_cancel_status 0000:bc:00.0</code></p>"},{"location":"sw/install_guide/installation_guide/","title":"OPAE Installation Guide","text":""},{"location":"sw/install_guide/installation_guide/#how-to-download-the-opae-sdk","title":"How to download the OPAE SDK","text":"<p>OPAE SDK releases are available on GitHub. Source code for the OPAE DFL device driver for Linux is also available on GitHub.</p>"},{"location":"sw/install_guide/installation_guide/#install-the-fedora","title":"Install the Fedora","text":"<p>Download the Fedora  (x86_64 version) installation file in fedora, and install the Fedora  in yourserver. You can choose Fedora Workstation or Fedora server.</p>"},{"location":"sw/install_guide/installation_guide/#build-the-kernel-and-dfl-drivers","title":"Build the kernel and DFL drivers","text":"<p>For building the OPAE kernel and kernel driver, the kernel development environment is required. So before you build the kernel, you must install the required packages. Run the following commands:</p> <pre><code>subscription-manager release --set=8.6\nsudo dnf update\n\n# If you require the use of a proxy, add it to DNF using by editing the following file\nsudo nano /etc/dnf/dnf.conf\n# Include your proxy by adding the following line, replacing the URL with your proxy's URL\n# proxy=http://proxy.server.com:port\nsudo dnf update\nsubscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\nsudo dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n\nsudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libuuid-devel rpm-build systemd-devel nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\npython3-pyyaml hwloc-devel libedit-devel git kernel-headers kernel-devel elfutils-libelf-devel ncurses-devel openssl-devel bison flex cli11-devel spdlog-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install Pybind11==2.10.0 --proxy http://yourproxy:xxx\n\nsudo pip3 install setuptools==59.6.0 --prefix=/usr --proxy http://yourproxy:xxx\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm -y\n</code></pre> <p>Download the OPAE upstream kernel tree from github, for example download from fpga-ofs-dev-5.15-lts branch. <pre><code>git clone https://github.com/OFS/linux-dfl\ncd linux-dfl\ngit checkout tags/ofs-2023.1-6.1-1\n</code></pre></p> <p>Note: The linux-dfl repository is roughly 5 GB in size</p>"},{"location":"sw/install_guide/installation_guide/#building-and-installing-the-ofs-dfl-kernel-drivers-from-source","title":"Building and Installing the OFS DFL Kernel Drivers from Source","text":"<ol> <li>The following set of instructions walk you through copying an existing kernel configuration file on your machine and changing the minimal required configuration settings:</li> </ol> <pre><code>cd linux-dfl\ncp /boot/config-`uname -r` .config\ncat configs/dfl-config &gt;&gt; .config\necho 'CONFIG_LOCALVERSION=\"-dfl\"' &gt;&gt; .config\necho 'CONFIG_LOCALVERSION_AUTO=y' &gt;&gt; .config\nsed -i -r 's/CONFIG_SYSTEM_TRUSTED_KEYS=.*/CONFIG_SYSTEM_TRUSTED_KEYS=\"\"/' .config\nsed -i '/^CONFIG_DEBUG_INFO_BTF/ s/./#&amp;/' .config\necho 'CONFIG_DEBUG_ATOMIC_SLEEP=y' &gt;&gt; .config\nmake olddefconfig\n</code></pre> <p>Note: The above command may report errors resembling <code>symbol value 'm' invalid for CHELSIO_IPSEC_INLINE</code>. These errors indicate that the nature of the config has changed between the currently executing kernel and the kernel being built. The option \"m\" for a particular kernel module is no longer a valid option, and the default behavior is to simply turn the option off. However the option can likely be turned back on by setting it to 'y'. If the user wants to turn the option back on, change it to 'y' and re-run \"make olddefconfig\":</p> <pre><code>cd /home/OFS/linux-dfl\necho 'CONFIG_CHELSIO_IPSEC_INLINE=y' &gt;&gt; .config\nmake olddefconfig\n</code></pre> <p>(Optional) To use the built-in GUI menu for editing kernel configuration parameters, you can opt to run <code>make menuconfig</code>.</p> <p>2. Linux kernel builds take advantage of multiple processors to parallelize the build process. Display how many processors are available with the <code>nproc</code> command, and then specify how many make threads to utilize with the -j option. Note that number of threads can exceed the number of processors. In this case, the number of threads are set to the number of processors in the system</p> <pre><code>$ make -j $(nproc)\n$ sudo make modules_install -j $(nproc)\n$ sudo make install\n</code></pre> <p>Build linux DFL Kernel instructions please also refer to: https://github.com/OPAE/linux-dfl/wiki/Build-the-linux-dfl-kernel</p>"},{"location":"sw/install_guide/installation_guide/#locally-building-a-set-of-rpmdep-packages","title":"Locally building a set of RPM/DEP packages.","text":"<ol> <li> <p>This first flow will directly install the kernel and kernel module files without the need to create a package first:</p> <pre><code>cd /&lt;your_path&gt;/linux-dfl\nmake INSTALL_MOD_STRIP=1 binrpm-pkg\n</code></pre> </li> <li> <p>By default a directory is created in your <code>home</code> directory called <code>rpmbuild</code>. This directory will house all of the kernel packages which have been built. You need to navigate to the newly built kernel packages and install them. The following files were generated using the build command executed in the previous step:</p> <pre><code>cd ~/rpmbuild/RPMS/x86_64\nls\nkernel-${{ env.DFL_KERNEL_NAME }}.x86_64.rpm  kernel-headers-${{ env.DFL_KERNEL_NAME }}.x86_64.rpm\nsudo dnf localinstall kernel*.rpm\n</code></pre> </li> <li> <p>When install finished, reboot your system.     When the system login again, verify the kernel version is correct. For example:</p> </li> </ol> <pre><code>[figo@localhost linux-dfl]$ uname -r\n${{ env.DFL_KERNEL_NAME }}\n</code></pre> <p>And also you can check the OPAE dfl drivers have auto-loaded. <pre><code>[figo@localhost linux-dfl]$ lsmod | grep fpga\nifpga_sec_mgr          20480  1 intel_m10_bmc_secure\nfpga_region            20480  3 dfl_fme_region,dfl_fme,dfl\nfpga_bridge            24576  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br\nfpga_mgr               16384  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme\n[figo@localhost linux-dfl]$ lsmod | grep dfl\ndfl_eth_group          36864  0\ndfl_fme_region         20480  0\ndfl_emif               16384  0\ndfl_n3000_nios         20480  0\ndfl_fme_br             16384  0\ndfl_fme_mgr            20480  1\ndfl_fme                49152  0\ndfl_afu                36864  0\ndfl_pci                20480  0\ndfl                    40960  7 dfl_pci,dfl_fme,dfl_fme_br,dfl_eth_group,dfl_n3000_nios,dfl_afu,dfl_emif\nfpga_region            20480  3 dfl_fme_region,dfl_fme,dfl\nfpga_bridge            24576  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br\nfpga_mgr               16384  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme\n</code></pre></p> <ol> <li>Two kernel parameters must be added to the boot commandline for the newly installed kernel. First, open the file <code>grub</code>:</li> </ol> <pre><code>sudo vim /etc/default/grub\n</code></pre> <ol> <li>In the variable GRUB_CMDLINE_LINUX add the following parameters in bold: GRUB_CMDLINE_LINUX=\"crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200\"</li> </ol> <p>Note: If you wish to instead set hugepages on a per session bassis, you can perform the following steps. These settings will be lost on reboot.</p> <pre><code>mkdir -p /mnt/huge \nmount -t hugetlbfs nodev /mnt/huge \necho 2048 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages \necho 2048 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages \n</code></pre> <ol> <li>Save your edits, then apply them to the GRUB2 configuration file.</li> </ol> <pre><code>sudo grub2-mkconfig\n</code></pre> <ol> <li>Warm reboot. Your kernel parameter changes should have taken affect.</li> </ol> <pre><code>cat /proc/cmdline\nBOOT_IMAGE=(hd1,gpt2)/vmlinuz-${{ env.DFL_KERNEL_NAME }} root=/dev/mapper/cl-root ro crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200 rhgb quiet\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#build-the-opae-sdk","title":"Build the OPAE-SDK","text":"<p>Before you build the OPAE SDK, you must install the required packages. Run the following commands:</p>"},{"location":"sw/install_guide/installation_guide/#rocky-linux-85","title":"Rocky Linux 8.5","text":"<pre><code>dnf install -y 'dnf-command(config-manager)'\ndnf config-manager --set-enabled powertools\ndnf install -y epel-release\ndnf check-update\ndnf upgrade -y\ndnf install -y python3 python3-pip python3-devel python3-jsonschema python3-pyyaml python3-pybind11 git gcc gcc-c++ make cmake libuuid-devel json-c-devel hwloc-devel tbb-devel cli11-devel spdlog-devel libedit-devel systemd-devel rpm-build rpmdevtools pybind11-devel yaml-cpp-devel libudev-devel linuxptp rsync python3 -m pip install jsonschema virtualenv pyyaml\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#fedora","title":"Fedora","text":"<pre><code>dnf check-update\ndnf upgrade -y\ndnf install -y python3 python3-pip python3-devel python3-jsonschema python3-pyyaml python3-pybind11 git gcc g++ make cmake libuuid-devel json-c-devel hwloc-devel tbb-devel libedit-devel rpm-build rpmdevtools pybind11-devel yaml-cpp-devel libudev-devel cli11-devel spdlog-devel linuxptp rsync\npip3 install jsonschema virtualenv pyyaml\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#ubuntu-2004","title":"Ubuntu 20.04","text":"<pre><code>apt-get update\napt-get upgrade -y\napt-get install -y python3 python3-pip python3-dev git gcc g++ make cmake uuid-dev libjson-c-dev libhwloc-dev libtbb-dev libedit-dev libudev-dev linuxptp pandoc devscripts debhelper doxygen rsync\npip3 install jsonschema virtualenv pyyaml pybind11\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#rhel-82","title":"RHEL 8.2","text":"<p>Register and enable Red Hat subscription to install any packages on the system.</p> <pre><code>subscription-manager register --proxy=PROXY --username=USER --password=PASSWORD --auto-attach\n</code></pre> <p>Set the RHEL version and install packages. Set proxy name and port number.</p> <pre><code># If you require the use of a proxy, add it to DNF using by editing the following file\nsudo nano /etc/dnf/dnf.conf\n# Include your proxy by adding the following line, replacing the URL with your proxy's URL\n# proxy=http://proxy.server.com:port\nsudo dnf update\nsubscription-manager release --set=8.2 --proxy proxy-name.com:port number\nsubscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\nsudo dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n\nsudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libuuid-devel rpm-build systemd-devel nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\npython3-pyyaml hwloc-devel libedit-devel git kernel-headers kernel-devel elfutils-libelf-devel ncurses-devel openssl-devel bison flex cli11-devel spdlog-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install Pybind11==2.10.0 --proxy http://yourproxy:xxx\n\nsudo pip3 install setuptools==59.6.0 --prefix=/usr --proxy http://yourproxy:xxx\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nwget http://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.4/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm -y\n</code></pre> <p>Install the latest version of cmake on top of the outdated cmake package from the package manager.</p> <pre><code># cd cmake-3.25.1/\n# ./bootstrap --prefix=/usr\n# make\n# make install\n# which cmake\n/usr/bin/cmake\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#create-opae-sdk-packages","title":"Create opae-sdk packages","text":"<p>Download the OPAE-SDK source code from github. For example, download from Master branch.</p> <pre><code>$ git clone https://github.com/OPAE/opae-sdk.git\n$ cd opae-sdk\n$ git checkout tags/2.5.0-3\n</code></pre> <p>Compile and build the OPAE-SDK RPMs (Fedora, Rocky, RHEL 8.2). <pre><code>$ cd opae-sdk/packaging/opae/rpm\n$ ./create fedora\n</code></pre></p>"},{"location":"sw/install_guide/installation_guide/#opae-package-description","title":"OPAE Package Description","text":"Package Name Description opae OPAE SDK is a collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. It provides a library implementing the OPAE C API for presenting a streamlined and easy-to-use interface for software applications to discover, access, and manage FPGA devices and accelerators using the OPAE software stack. opae-debuginfo This package provides debug information for package opae. Debug information is useful when developing applications that use this package or when debugging this package. opae-debugsource This package provides debug sources for package opae. Debug sources are useful when developing applications that use this package or when debugging this package. opae-devel OPAE headers, tools, sample source, and documentation opae-devel-debuginfo This package provides debug information for package opae-devel. Debug information is useful when developing applications that use this package or when debugging this package. opae-tools This package contains OPAE base tools binaries opae-extra-tools Additional OPAE tools opae-extra-tools-debuginfo This package provides debug information for package opae-extra-tools. Debug information is useful when developing applications that use this package or when debugging this package. <p>Note that if you find that your distribution has changed package names such that there is a conflict when building RPMs, you can install all of the build dependencies so that the SDK compiles and then build the RPMs in unrestricted mode:</p> <pre><code>$ cd opae-sdk/packaging/opae/rpm\n$ ./create unrestricted\n</code></pre> <p>After a successful compile, there are 3 rpm packages generated (Fedora, Rocky, RHEL8.2). For example: <pre><code>opae-2.5.0-3.fc34.x86_64.rpm\nopae-devel-2.5.0-3.fc34.x86_64.rpm\nopae-extra-tools-2.5.0-3.fc34.x86_64.rpm\n</code></pre></p> <p>Compile and build the OPAE-SDK deb packages (Ubuntu 22.04). <pre><code>$ cd opae-sdk/packaging/opae/deb\n$ ./create\n</code></pre></p> <p>After a successful compile, there are 3 deb packages generated (Ubuntu 22.04). For example: <pre><code>opae_2.5.0-3_amd64.deb  opae-devel_2.5.0-3_amd64.deb  opae-extra-tools_2.5.0-3_amd64.deb\n</code></pre></p>"},{"location":"sw/install_guide/installation_guide/#opae-sdk-installation-with-rpmdeb-packages","title":"OPAE SDK installation with rpm/deb packages","text":"<p>The rpm packages generated in the previous step can be installed using these commands:</p> <pre><code>rm -rf opae-2.5.0-3.el8.src.rpm\nsudo dnf localinstall -y opae*.rpm\n</code></pre> <p>Check that all packages have been installed:</p> <pre><code>[user@localhost opae-sdk]# rpm -qa | grep opae\nopae-packager-2.5.0-3.x86_64\nopae-devel-2.5.0-3.x86_64\nopae-PACSign-2.5.0-3.x86_64\nopae-tools-extra-2.5.0-3.x86_64\nopae-2.5.0-3.x86_64\nopae-tools-2.5.0-3.x86_64\nopae-libs-2.5.0-3.x86_64\nopae-opae.admin-2.5.0-3.x86_64\nopae-tests-2.5.0-3.x86_64\n</code></pre> <p>The deb packages generated in the previous step can be installed using these commands:</p> <pre><code>rm -rf opae-2.5.0-3_amd64.deb\nsudo dpkg -i  ./*.deb\n</code></pre> <p>When you installed the rpms, you can run fpgainfo command to check the FPGA FME infomation. For example: <pre><code>[figo@localhost install_guide]$ fpgainfo fme\nBoard Management Controller, xxxx NIOS FW version: xxxxxx\nBoard Management Controller, xxxx Build version: xxxxx\n//****** FME ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:08:00.0\nDevice Id                        : 0x0B30\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x2300011001030F\nBitstream Version                : 0.2.3\nPr Interface Id                  : f3c99413-5081-4aad-bced-07eb84a6d0bb\nBoot Page                        : user\n</code></pre></p> <p>To uninstall the OPAE rpms, you can use this commands <pre><code>$ dnf list installed | grep opae\n$ sudo dnf remove opae*.x86_64\n</code></pre></p> <p>To uninstall the OPAE deb, you can use this commands <pre><code>$ dpkg -l  | grep opae\n$ dpkg -r opae-extra-tools:amd64\n$ dpkg -r opae-devel:amd64\n$ dpkg -r opae\n</code></pre></p>"},{"location":"sw/install_guide/installation_guide/#fpga-device-access-permissions","title":"FPGA Device Access Permissions","text":"<p>Access to FPGA accelerators and devices is controlled using file access permissions on the Intel\u00ae FPGA device files, <code>/dev/dfl-fme.*</code> and <code>/dev/dfl-port.*</code>, as well as to the files reachable through <code>/sys/class/fpga_region/</code>.</p> <p>In order to allow regular (non-root) users to access accelerators, you need to grant them read and write permissions on <code>/dev/dfl-port.*</code> (with <code>*</code> denoting the respective socket, i.e. 0 or 1). E.g.:</p> <pre><code>$ sudo chmod a+rw /dev/dfl-port.0\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#memlock-limit","title":"Memlock limit","text":"<p>Depending on the requirements of your application, you may also want to increase the maximum amount of memory a user process is allowed to lock. The exact way to do this depends on your Linux distribution.</p> <p>You can check the current memlock limit using</p> <pre><code>$ ulimit -l\n</code></pre> <p>A way to permanently remove the limit for locked memory for a regular user is to add the following lines to your /etc/security/limits.conf:</p> <pre><code>user1    hard   memlock           unlimited\nuser1    soft   memlock           unlimited\n</code></pre> <p>This removes the limit on locked memory for user <code>user1</code>. To remove it for all users, you can replace <code>user1</code> with <code>*</code>:</p> <pre><code>*    hard   memlock           unlimited\n*    soft   memlock           unlimited\n</code></pre> <p>Note that settings in the /etc/security/limits.conf file don't apply to services.  To increase the locked memory limit for a service you need to modify the application's systemd service file and add the line:</p> <pre><code>[Service]\nLimitMEMLOCK=infinity\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#hugepage-settings","title":"Hugepage Settings","text":"<p>Users need to configure system hugepages to reserve 2MB-hugepages or 1GB-hugepages. For example, the 'hello_fpga' sample requires several 2MB-hugepages. And the fpgadiag tool requires several 1GB-hugepages.</p> <p>The command below reserves 20 2M-hugepages:</p> <pre><code>$ sudo sh -c 'echo 20 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages'\n</code></pre> <p>The command below reserves 4 1GB-hugepages:</p> <pre><code>$ sudo sh -c 'echo 4 &gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages'\n</code></pre> <p>For x86_64 architecture processors, user can use following command to find out avaiable hugepage sizes:</p> <pre><code>$ grep pse /proc/cpuinfo | uniq\nflags : ... pse ...\n</code></pre> <p>If this commands returns a non-empty string, 2MB pages are supported.</p> <pre><code>$ grep pse /proc/cpuinfo | uniq\nflags : ... pdpe1gb ...\n</code></pre> <p>If this commands returns a non-empty string, 1GB pages are supported.</p>"},{"location":"sw/pyopae/python_bindings/","title":"OPAE Python Bindings","text":"<p>OPAE (Open Programmable Acceleration Engine) now includes Python bindings for interacting with FPGA resources. The OPAE Python API is built on top of the OPAE C++ Core API and its object model. Because of this, developing OPAE applications in Python is very similar to developing OPAE applications in C++ which significantly reduces the learning curve required to adapt to the Python API. While the object model remains the same, some static factory functions in the OPAE C++ Core API have been moved to module level methods in the OPAE Python API with the exception of the properties class. The goal of the OPAE Python API is to enable fast prototyping, test automation, infrastructure managment, and an easy to use framework for FPGA resource interactions that don\u2019t rely on software algorithms with a high runtime complexity.</p> <p>Currently, the only Python package that is part of OPAE is <code>opae.fpga</code></p>"},{"location":"sw/pyopae/python_bindings/#implementation","title":"Implementation","text":"<p>The OPAE Python API is implemented by creating a Python extension using <code>pybind11 &lt;http://pybind11.readthedocs.io/en/stable&gt;</code>. This extension is created by using the pybind11 API which relies mostly on macros and compile time introspection to define the module initialization point as well as type converters between OPAE C++ Core types and OPAE Python types.</p>"},{"location":"sw/pyopae/python_bindings/#benefits","title":"Benefits","text":"<p>The major benefits of using pybind11 for developing the OPAE Python API include, but are not limited to, the following features of pybind11:</p> <ul> <li>Uses C++ 11 standard library although it can use C++ 14 or C++17.</li> <li>Automatic conversions of shared_ptr types</li> <li>Built-in support for numpy and Eigen numerical libraries</li> <li>Interoperable with the Python C API</li> </ul>"},{"location":"sw/pyopae/python_bindings/#runtime-requirements","title":"Runtime Requirements","text":"<p>Because opae.fpga is built on top of the opae-cxx-core API, it does require that the runtime libraries for both opae-cxx-core and opae-c be installed on the system (as well as any other libraries they depend on). Those libraries can be installed using the opae-libs package (from either RPM or DEB format - depending on your Linux distribution).</p>"},{"location":"sw/pyopae/python_bindings/#installation","title":"Installation","text":""},{"location":"sw/pyopae/python_bindings/#python-wheels","title":"Python Wheels","text":"<p>The preferred method of installation is to use a binary wheel package for your version of Python.</p> <p>The following table lists example names for different Python versions and platforms.</p> <p>| Python Version | Python ABI | Linux Platform | Package Name | |\u2014\u2014\u2014\u2014\u2014-|\u2014\u2014\u2014\u2014\u2014\u2013|\u2014\u2014\u2014\u2014\u2014-|\u2014\u2014\u2014\u2014\u2013| | 2.7 | CPython w/ UCS4 | x86_64 | opae.fpga.-cp27-cp27mu-linux_x86_64.whl | | 3.4 | CPython w/ UCS4 | x86_64 | opae.fpga.-cp34-cp34mu-linux_x86_64.whl | | 3.6 | CPython w/ UCS4 | x86_64 | opae.fpga.-cp36-cp36mu-linux_x86_64.whl |</p> <p>opae.fpga is currently not available in the Python Package Index but once it does become available, one should be able to install using pip by simply typing the following:</p> <pre><code>&gt; pip install --user opae.fpga\n</code></pre>"},{"location":"sw/pyopae/python_bindings/#installing-from-source","title":"Installing From Source","text":"<p>In addition to the runtime libraries mentioned above, installing from source does require that the OPAE header files be installed as well as those header files for pybind11. The former can be installed with the opae-devel package and the latter can be installed by installing pybind11 Python module.</p>"},{"location":"sw/pyopae/python_bindings/#example-installation","title":"Example Installation","text":"<p>The following example shows how to build from source by installing the prerequisites before running the setup.py file.</p> <pre><code>&gt;sudo yum install opae-libs-&lt;release&gt;.x86_64.rpm\n&gt;sudo yum install opae-devel-&lt;release&gt;.x86_64.rpm\n&gt;pip install --user pybind11\n&gt;pip install --user opae.fpga-&lt;release&gt;.tar.gz\n</code></pre> <p>NOTE: The <code>pip</code> examples above use the <code>--user</code> flag to avoid requiring root permissions. Those packages will be installed in the user\u2019s <code>site-packages</code> directory found in the user\u2019s <code>.local</code> directory.</p>"},{"location":"sw/pyopae/python_bindings/#example-scripts","title":"Example Scripts","text":"<p>The following example is an implementation of the sample, hello_fpga.c, which is designed to configure the NLB0 diagnostic accelerator for a simple loopback.</p> <pre><code>import time\nfrom opae import fpga\n\nNLB0 = \"d8424dc4-a4a3-c413-f89e-433683f9040b\"\nCTL = 0x138\nCFG = 0x140\nNUM_LINES = 0x130\nSRC_ADDR = 0x0120\nDST_ADDR = 0x0128\nDSM_ADDR = 0x0110\nDSM_STATUS = 0x40\n\ndef cl_align(addr):\n    return addr &gt;&gt; 6\n\ntokens = fpga.enumerate(type=fpga.ACCELERATOR, guid=NLB0)\nassert tokens, \"Could not enumerate accelerator: {}\".format(NlB0)\n\nwith fpga.open(tokens[0], fpga.OPEN_SHARED) as handle:\n    src = fpga.allocate_shared_buffer(handle, 4096)\n    dst = fpga.allocate_shared_buffer(handle, 4096)\n    dsm = fpga.allocate_shared_buffer(handle, 4096)\n    handle.write_csr32(CTL, 0)\n    handle.write_csr32(CTL, 1)\n    handle.write_csr64(DSM_ADDR, dsm.io_address())\n    handle.write_csr64(SRC_ADDR, cl_align(src.io_address())) # cacheline-aligned\n    handle.write_csr64(DST_ADDR, cl_align(dst.io_address())) # cacheline-aligned\n    handle.write_csr32(CFG, 0x42000)\n    handle.write_csr32(NUM_LINES, 4096/64)\n    handle.write_csr32(CTL, 3)\n    while dsm[DSM_STATUS] &amp; 0x1 == 0:\n        time.sleep(0.001)\n    handle.write_csr32(CTL, 7)\n</code></pre> <p>This example shows how one might reprogram (Partial Reconfiguration) an accelerator on a given bus, 0x5e, using a bitstream file, m0.gbs.</p> <pre><code>from opae import fpga\n\nBUS = 0x5e\nGBS = 'm0.gbs'\ntokens = fpga.enumerate(type=fpga.DEVICE, bus=BUS)\nassert tokens, \"Could not enumerate device on bus: {}\".format(BUS)\nwith open(GBS, 'rb') as fd, fpga.open(tokens[0]) as device:\n    device.reconfigure(0, fd)\n</code></pre>"},{"location":"sw/tod/tod/","title":"Time of Day (ToD)","text":""},{"location":"sw/tod/tod/#synopsis","title":"SYNOPSIS","text":"<p>The Intel FPGA ToD driver in the kernel space exposes ToD IP as PHC (PTP Hardware Clock) device to the Linux PTP (Precision Time Protocol) stack to synchronize the system clock to its ToD information. The phc2sys utility of Linux PTP stack is used to access ToD information and synchronize the system clock.</p> <p>Install the Linux PTP utilities: <pre><code># sudo yum install linuxptp\n</code></pre></p> <p>phc_ctl and phc2sys utilities (linuxptp package) are used to control the PHC device and synchronize the system clock to its ToD information.</p> <p>phc_ctl: directly controls PHC device clock. <pre><code>Usage: phc_ctl [options] &lt;device&gt; -- [command]\n    device         ethernet or ptp clock device\nOptions:\n    -l [num]       set the logging level to 'num'\n    -q             do not print messages to the syslog\n    -Q             do not print messages to stdout\n    -v             prints the software version and exits\n    -h             prints this message and exits\nCommands:\n specify commands with arguments. Can specify multiple commands to be executed in order. \n Seconds are read as double precision floating point values.\n    set  [seconds]  set PHC time (defaults to time on CLOCK_REALTIME)\n    get             get PHC time\n    adj  &lt;seconds&gt;  adjust PHC time by offset\n    freq [ppb]      adjust PHC frequency (default returns current offset)\n    cmp             compare PHC offset to CLOCK_REALTIME\n    caps            display device capabilities (default if no command given)\n    wait &lt;seconds&gt;  pause between commands\n                    This command may be useful for sanity checking whether the PHC clock is\n                    running as expected.\n                    The arguments specified in seconds are read as double precision floating point\n                    values, and will scale to nanoseconds. This means providing a value of 5.5 means 5\n                    and one half seconds. This allows specifying fairly precise values for time.\n</code></pre></p> <p>phc2sys: synchronize two clocks. <pre><code>Usage: phc2sys [options]\nAutomatic configuration:\n    -a             turn on autoconfiguration\n    -r             synchronize system (realtime) clock\n                   repeat -r to consider it also as a time source\nManual configuration:\n    -c [dev|name]  slave clock (CLOCK_REALTIME)\n    -d [dev]       master PPS device\n    -s [dev|name]  master clock\n    -O [offset]    slave-master time offset (0)\n    -w             wait for ptp4l\nOptions:\n    -f [file]      configuration file\n    -E [pi|linreg] clock servo (pi)\n    -P [kp]        proportional constant (0.7)\n    -I [ki]        integration constant (0.3)\n    -S [step]      step threshold (disabled)\n    -F [step]      step threshold only on start (0.00002)\n    -R [rate]      slave clock update rate in HZ (1.0)\n    -N [num]       number of master clock readings per update (5)\n    -L [limit]     sanity frequency limit in ppb (200000000)\n    -M [num]       NTP SHM segment number (0)\n    -u [num]       number of clock updates in summary stats (0)\n    -n [num]       domain number (0)\n    -x             apply leap seconds by servo instead of kernel\n    -z [path]      server address for UDS (/var/run/ptp4l)\n    -l [num]       set the logging level to 'num' (6)\n    -t [tag]       add tag to log messages\n    -m             print messages to stdout\n    -q             do not print messages to the syslog\n    -v             prints the software version and exits\n    -h             prints this message and exits\n</code></pre></p>"},{"location":"sw/tod/tod/#description","title":"DESCRIPTION","text":"<p>The phc2sys utility is used to synchronize the system clock to the PTP Hardware Clock (PHC) or ToD clock. The phc_ctl utility is used to directly control PHC clock device.</p>"},{"location":"sw/tod/tod/#configuring-the-ptp-service","title":"Configuring the PTP service","text":"<ol> <li>Install the linuxptp package: <pre><code># sudo yum install linuxptp\n</code></pre></li> <li>Check PTP device is created successfully by the ToD driver. </li> </ol> <p>ToD driver registering as PHC device (clock_name: dfl_tod) to the Linux PTP stack and exposing to the Linux kernel to synchronize the system clock to its ToD information. <pre><code># cat /sys/class/ptp/ptp0/clock_name\ndfl_tod\n</code></pre></p> <ol> <li>Configure phc2sys service on a system:</li> </ol> <p>The phc2sys service is configured in the /etc/sysconfig/phc2sys configuration file. Define start-up option for phc2sys daemon in /etc/sysconfig/phc2sys. The master clock is /dev/ptp0 device and the slave clock is system clock/CLOCK_REALTIME: <pre><code> OPTIONS=\"-s /dev/ptp0 -c CLOCK_REALTIME -r -O 0 -R 16\"\n</code></pre></p> <ol> <li> <p>Start phc2sys service: <pre><code># service phc2sys start\n</code></pre></p> </li> <li> <p>Stop phc2sys service: <pre><code># service phc2sys stop\n</code></pre></p> </li> </ol>"},{"location":"sw/tod/tod/#examples","title":"Examples","text":""},{"location":"sw/tod/tod/#using-phc_ctl-utility","title":"using phc_ctl utility","text":"<p>Read the current clock time from the PHC clock device: <pre><code># sudo phc_ctl /dev/ptp0 get\n</code></pre></p> <p>Set the PHC clock time to CLOCK_REALTIME: <pre><code># sudo phc_ctl /dev/ptp0 set\n</code></pre></p> <p>Set PHC clock time to 0: <pre><code># sudo phc_ctl /dev/ptp0 set 0.0\n</code></pre></p> <p>Set PHC clock time to 0 and wait for 10 sec and read the clock time: <pre><code># sudo phc_ctl /dev/ptp0 set 0.0 wait 10.0 get\n</code></pre></p> <p>Set and compare PHC clock time to CLOCK_REALTIME: <pre><code># sudo phc_ctl /dev/ptp0 set cmp\n</code></pre></p> <p>Read the PHC device capabilities: <pre><code># sudo phc_ctl /dev/ptp0 caps\n</code></pre></p>"},{"location":"sw/tod/tod/#using-phc2sys-utility","title":"using phc2sys utility","text":"<p>To synchronize the system clock to the PHC clock: <pre><code># sudo phc2sys -s /dev/ptp0 -c CLOCK_REALTIME -r -O 0 -R 16 -m\nphc2sys[7896.789]: CLOCK_REALTIME phc offset  -1259509 s0 freq  -31462 delay   1338\nphc2sys[7896.852]: CLOCK_REALTIME phc offset  -1261498 s1 freq  -63144 delay   1328\nphc2sys[7896.914]: CLOCK_REALTIME phc offset       -15 s2 freq  -63159 delay   1328\nphc2sys[7896.977]: CLOCK_REALTIME phc offset       -19 s2 freq  -63167 delay   1327\nphc2sys[7897.039]: CLOCK_REALTIME phc offset       -35 s2 freq  -63189 delay   1328\nphc2sys[7897.102]: CLOCK_REALTIME phc offset       -37 s2 freq  -63201 delay   1331\nphc2sys[7897.165]: CLOCK_REALTIME phc offset       -30 s2 freq  -63205 delay   1328\nphc2sys[7897.227]: CLOCK_REALTIME phc offset       -50 s2 freq  -63234 delay   1331\nphc2sys[7897.290]: CLOCK_REALTIME phc offset       -50 s2 freq  -63249 delay   1329\nphc2sys[7897.353]: CLOCK_REALTIME phc offset       -62 s2 freq  -63276 delay   1334\nphc2sys[7897.415]: CLOCK_REALTIME phc offset       -53 s2 freq  -63286 delay   1335\nphc2sys[7897.478]: CLOCK_REALTIME phc offset       -46 s2 freq  -63295 delay   1325\nphc2sys[7897.541]: CLOCK_REALTIME phc offset       -57 s2 freq  -63320 delay   1334\nphc2sys[7897.603]: CLOCK_REALTIME phc offset       -39 s2 freq  -63319 delay   1327\nphc2sys[7897.666]: CLOCK_REALTIME phc offset       -31 s2 freq  -63323 delay   1328\nphc2sys[7897.728]: CLOCK_REALTIME phc offset       -48 s2 freq  -63349 delay   1327\nphc2sys[7897.791]: CLOCK_REALTIME phc offset       -42 s2 freq  -63357 delay   1323\nphc2sys[7897.854]: CLOCK_REALTIME phc offset       -41 s2 freq  -63369 delay   1324\nphc2sys[7897.916]: CLOCK_REALTIME phc offset       -44 s2 freq  -63384 delay   1328\nphc2sys[7897.979]: CLOCK_REALTIME phc offset       -13 s2 freq  -63366 delay   1327\nphc2sys[7898.042]: CLOCK_REALTIME phc offset       -16 s2 freq  -63373 delay   1327\nphc2sys[7898.104]: CLOCK_REALTIME phc offset       -19 s2 freq  -63381 delay   1328\nphc2sys[7898.167]: CLOCK_REALTIME phc offset       -16 s2 freq  -63384 delay   1327\nphc2sys[7898.229]: CLOCK_REALTIME phc offset         3 s2 freq  -63370 delay   1327\nphc2sys[7898.292]: CLOCK_REALTIME phc offset        16 s2 freq  -63356 delay   1325\nphc2sys[7898.355]: CLOCK_REALTIME phc offset        10 s2 freq  -63357 delay   1319\nphc2sys[7898.417]: CLOCK_REALTIME phc offset        23 s2 freq  -63341 delay   1327\nphc2sys[7898.480]: CLOCK_REALTIME phc offset        13 s2 freq  -63344 delay   1335\nphc2sys[7898.543]: CLOCK_REALTIME phc offset        23 s2 freq  -63330 delay   1323\nphc2sys[7898.605]: CLOCK_REALTIME phc offset        29 s2 freq  -63317 delay   1312\nphc2sys[7898.668]: CLOCK_REALTIME phc offset        22 s2 freq  -63315 delay   1324\nphc2sys[7898.730]: CLOCK_REALTIME phc offset        42 s2 freq  -63289 delay   1325\nphc2sys[7898.793]: CLOCK_REALTIME phc offset        29 s2 freq  -63289 delay   1333\nphc2sys[7898.856]: CLOCK_REALTIME phc offset        34 s2 freq  -63276 delay   1327\nphc2sys[7898.918]: CLOCK_REALTIME phc offset        21 s2 freq  -63278 delay   1331\nphc2sys[7898.981]: CLOCK_REALTIME phc offset        22 s2 freq  -63271 delay   1335\nphc2sys[7899.044]: CLOCK_REALTIME phc offset        30 s2 freq  -63256 delay   1327\nphc2sys[7899.106]: CLOCK_REALTIME phc offset        30 s2 freq  -63247 delay   1328\nphc2sys[7899.169]: CLOCK_REALTIME phc offset        37 s2 freq  -63231 delay   1333\nphc2sys[7899.232]: CLOCK_REALTIME phc offset        29 s2 freq  -63228 delay   1331\nphc2sys[7899.294]: CLOCK_REALTIME phc offset        24 s2 freq  -63225 delay   1330\n</code></pre></p>"},{"location":"opae-code/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct _fpga_token_header Internal token type header. </li> <li>struct _opae_hash_map Hash map object. </li> <li>struct _opae_hash_map_item List link item. </li> <li>struct cache_line </li> <li>struct config </li> <li>struct fpga_error_info </li> <li>struct fpga_metric Metric struct. </li> <li>struct fpga_metric_info Metric info struct. </li> <li>struct fpga_version Semantic version. </li> <li>struct mem_alloc </li> <li>struct mem_link Provides an API for allocating/freeing a logical address space. </li> <li>struct metric_threshold </li> <li>union metric_value Metric value union. </li> <li>namespace opae <ul> <li>namespace fpga <ul> <li>namespace types <ul> <li>class busy busy exception </li> <li>namespace detail </li> <li>class error An error object represents an error register for a resource. </li> <li>class event Wraps fpga event routines in OPAE C. <ul> <li>struct type_t C++ struct that is interchangeable with fpga_event_type enum. </li> </ul> </li> <li>class except Generic OPAE exception. </li> <li>class exception exception exception </li> <li>struct guid_t Representation of the guid member of a properties object. </li> <li>class handle An allocated accelerator resource. </li> <li>class invalid_param invalid_param exception </li> <li>class no_access no_access exception </li> <li>class no_daemon no_daemon exception </li> <li>class no_driver no_driver exception </li> <li>class no_memory no_memory exception </li> <li>class not_found not_found exception </li> <li>class not_supported not_supported exception </li> <li>class properties Wraps an OPAE fpga_properties object. </li> <li>struct pvalue Wraps OPAE properties defined in the OPAE C API by associating an <code>fpga_properties</code> reference with the getters and setters defined for a property. </li> <li>class reconf_error reconf_error exception </li> <li>class shared_buffer Host/AFU shared memory blocks. </li> <li>class src_location Identify a particular line in a source file. </li> <li>class sysobject Wraps the OPAE fpga_object primitive. </li> <li>class token Wraps the OPAE fpga_token primitive. </li> <li>class version </li> </ul> </li> </ul> </li> </ul> </li> <li>struct opae_uio OPAE UIO device abstraction. </li> <li>struct opae_uio_device_region MMIO region info. </li> <li>struct opae_vfio OPAE VFIO device abstraction. </li> <li>struct opae_vfio_buffer System DMA buffer. </li> <li>struct opae_vfio_device VFIO device. </li> <li>struct opae_vfio_device_irq Interrupt info. </li> <li>struct opae_vfio_device_region MMIO region info. </li> <li>struct opae_vfio_group VFIO group. </li> <li>struct opae_vfio_iova_range IO Virtual Address Range. </li> <li>struct opae_vfio_sparse_info MMIO sparse-mappable region info. </li> <li>struct ras_inject_error </li> <li>namespace std </li> <li>struct threshold Threshold struct. </li> </ul>"},{"location":"opae-code/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir sw <ul> <li>dir include <ul> <li>dir opae <ul> <li>file access.h Functions to acquire, release, and reset OPAE FPGA resources. </li> <li>file buffer.h Functions for allocating and sharing system memory with an FPGA accelerator. </li> <li>dir cxx <ul> <li>file core.h </li> <li>dir core <ul> <li>file errors.h </li> <li>file events.h </li> <li>file except.h </li> <li>file handle.h </li> <li>file properties.h </li> <li>file pvalue.h </li> <li>file shared_buffer.h </li> <li>file sysobject.h </li> <li>file token.h </li> <li>file version.h </li> </ul> </li> </ul> </li> <li>file enum.h APIs for resource enumeration and managing tokens. </li> <li>file error.h Functions for reading and clearing errors in resources. </li> <li>file event.h Functions for registering events and managing the lifecycle for <code>fpga_event_handle</code> s. </li> <li>file fpga.h FPGA API. </li> <li>file hash_map.h A general-purpose hybrid array/list hash map implementation. </li> <li>file init.h Initialization routine. </li> <li>file log.h </li> <li>file manage.h Functions for managing FPGA configurations. </li> <li>file mem_alloc.h </li> <li>file metrics.h Functions for Discover/ Enumerates metrics and retrieves values. </li> <li>file mmio.h Functions for mapping and accessing MMIO space. </li> <li>file properties.h Functions for examining and manipulating <code>fpga_properties</code> objects. </li> <li>file sysobject.h Functions to read/write from system objects. </li> <li>file types.h Type definitions for FPGA API. </li> <li>file types_enum.h Definitions of enumerated types for the OPAE C API. </li> <li>file uio.h APIs to manage a PCIe device via UIO. </li> <li>file umsg.h FPGA UMsg API. </li> <li>file userclk.h Functions for setting and get afu user clock. </li> <li>file utils.h Utility functions and macros for the FPGA API. </li> <li>file version.h </li> <li>file vfio.h APIs to manage a PCIe device via vfio-pci. </li> </ul> </li> </ul> </li> <li>dir samples <ul> <li>dir hello_events <ul> <li>file hello_events.c A code sample of using OPAE event API. </li> </ul> </li> <li>dir hello_fpga <ul> <li>file hello_fpga.c A code sample illustrates the basic usage of the OPAE C API. </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"opae-code/struct__fpga__token__header/","title":"Struct _fpga_token_header","text":"<p>ClassList &gt; _fpga_token_header</p> <p>Internal token type header. More...</p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/struct__fpga__token__header/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bus uint8_t device uint16_t device_id uint8_t function fpga_guid guid fpga_interface interface uint64_t magic uint64_t object_id fpga_objtype objtype uint16_t segment uint16_t subsystem_device_id uint16_t subsystem_vendor_id uint16_t vendor_id"},{"location":"opae-code/struct__fpga__token__header/#detailed-description","title":"Detailed Description","text":"<p>Each plugin (dfl: libxfpga.so, vfio: libopae-v.so) implements its own proprietary token type. This header must appear at offset zero within that structure.</p> <p>eg, see lib/plugins/xfpga/types_int.h:struct _fpga_token and lib/plugins/vfio/opae_vfio.h:struct _vfio_token. </p>"},{"location":"opae-code/struct__fpga__token__header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/struct__fpga__token__header/#variable-bus","title":"variable bus","text":"<pre><code>uint8_t _fpga_token_header::bus;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-device","title":"variable device","text":"<pre><code>uint8_t _fpga_token_header::device;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-device_id","title":"variable device_id","text":"<pre><code>uint16_t _fpga_token_header::device_id;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-function","title":"variable function","text":"<pre><code>uint8_t _fpga_token_header::function;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-guid","title":"variable guid","text":"<pre><code>fpga_guid _fpga_token_header::guid;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-interface","title":"variable interface","text":"<pre><code>fpga_interface _fpga_token_header::interface;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-magic","title":"variable magic","text":"<pre><code>uint64_t _fpga_token_header::magic;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-object_id","title":"variable object_id","text":"<pre><code>uint64_t _fpga_token_header::object_id;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-objtype","title":"variable objtype","text":"<pre><code>fpga_objtype _fpga_token_header::objtype;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-segment","title":"variable segment","text":"<pre><code>uint16_t _fpga_token_header::segment;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-subsystem_device_id","title":"variable subsystem_device_id","text":"<pre><code>uint16_t _fpga_token_header::subsystem_device_id;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-subsystem_vendor_id","title":"variable subsystem_vendor_id","text":"<pre><code>uint16_t _fpga_token_header::subsystem_vendor_id;\n</code></pre>"},{"location":"opae-code/struct__fpga__token__header/#variable-vendor_id","title":"variable vendor_id","text":"<pre><code>uint16_t _fpga_token_header::vendor_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/struct__opae__hash__map/","title":"Struct _opae_hash_map","text":"<p>ClassList &gt; _opae_hash_map</p> <p>Hash map object. More...</p> <ul> <li><code>#include &lt;hash_map.h&gt;</code></li> </ul>"},{"location":"opae-code/struct__opae__hash__map/#public-attributes","title":"Public Attributes","text":"Type Name opae_hash_map_item ** buckets void * cleanup_context Optional second parameter to key_cleanup and value_cleanup. int flags uint32_t hash_seed void(* key_cleanup (optional) int(* key_compare (required) uint32_t(* key_hash uint32_t num_buckets void(* value_cleanup (optional)"},{"location":"opae-code/struct__opae__hash__map/#detailed-description","title":"Detailed Description","text":"<p>This structure defines the internals of the hash map. Each of the parameters supplied to opae_hash_map_init() is stored in the structure. All parameters are required, except key_cleanup and value_cleanup, which may optionally be NULL. </p>"},{"location":"opae-code/struct__opae__hash__map/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/struct__opae__hash__map/#variable-buckets","title":"variable buckets","text":"<pre><code>opae_hash_map_item** _opae_hash_map::buckets;\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-cleanup_context","title":"variable cleanup_context","text":"<pre><code>void* _opae_hash_map::cleanup_context;\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-flags","title":"variable flags","text":"<pre><code>int _opae_hash_map::flags;\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-hash_seed","title":"variable hash_seed","text":"<pre><code>uint32_t _opae_hash_map::hash_seed;\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-key_cleanup","title":"variable key_cleanup","text":"<pre><code>void(* _opae_hash_map::key_cleanup) (void *key, void *context);\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-key_compare","title":"variable key_compare","text":"<pre><code>int(* _opae_hash_map::key_compare) (void *keya, void *keyb);\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-key_hash","title":"variable key_hash","text":"<pre><code>uint32_t(* _opae_hash_map::key_hash) (uint32_t num_buckets, uint32_t hash_seed, void *key);\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-num_buckets","title":"variable num_buckets","text":"<pre><code>uint32_t _opae_hash_map::num_buckets;\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map/#variable-value_cleanup","title":"variable value_cleanup","text":"<pre><code>void(* _opae_hash_map::value_cleanup) (void *value, void *context);\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/hash_map.h</code></p>"},{"location":"opae-code/struct__opae__hash__map__item/","title":"Struct _opae_hash_map_item","text":"<p>ClassList &gt; _opae_hash_map_item</p> <p>List link item. More...</p> <ul> <li><code>#include &lt;hash_map.h&gt;</code></li> </ul>"},{"location":"opae-code/struct__opae__hash__map__item/#public-attributes","title":"Public Attributes","text":"Type Name void * key struct _opae_hash_map_item * next void * value"},{"location":"opae-code/struct__opae__hash__map__item/#detailed-description","title":"Detailed Description","text":"<p>This structure provides the association between key and value. When the supplied hash function for keys A and B returns the same bucket index, both A and B can co-exist on the same list rooted at the bucket index. </p>"},{"location":"opae-code/struct__opae__hash__map__item/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/struct__opae__hash__map__item/#variable-key","title":"variable key","text":"<pre><code>void* _opae_hash_map_item::key;\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map__item/#variable-next","title":"variable next","text":"<pre><code>struct _opae_hash_map_item* _opae_hash_map_item::next;\n</code></pre>"},{"location":"opae-code/struct__opae__hash__map__item/#variable-value","title":"variable value","text":"<pre><code>void* _opae_hash_map_item::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/hash_map.h</code></p>"},{"location":"opae-code/structcache__line/","title":"Struct cache_line","text":"<p>ClassList &gt; cache_line</p>"},{"location":"opae-code/structcache__line/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t uint"},{"location":"opae-code/structcache__line/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structcache__line/#variable-uint","title":"variable uint","text":"<pre><code>uint32_t cache_line::uint[16];\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/samples/hello_fpga/hello_fpga.c</code></p>"},{"location":"opae-code/structconfig/","title":"Struct config","text":"<p>ClassList &gt; config</p>"},{"location":"opae-code/structconfig/#public-attributes","title":"Public Attributes","text":"Type Name int open_flags int run_n3000"},{"location":"opae-code/structconfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structconfig/#variable-open_flags","title":"variable open_flags","text":"<pre><code>int config::open_flags;\n</code></pre>"},{"location":"opae-code/structconfig/#variable-run_n3000","title":"variable run_n3000","text":"<pre><code>int config::run_n3000;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/samples/hello_fpga/hello_fpga.c</code></p>"},{"location":"opae-code/structfpga__error__info/","title":"Struct fpga_error_info","text":"<p>ClassList &gt; fpga_error_info</p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/structfpga__error__info/#public-attributes","title":"Public Attributes","text":"Type Name bool can_clear name of the error char name"},{"location":"opae-code/structfpga__error__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structfpga__error__info/#variable-can_clear","title":"variable can_clear","text":"<pre><code>bool fpga_error_info::can_clear;\n</code></pre>"},{"location":"opae-code/structfpga__error__info/#variable-name","title":"variable name","text":"<pre><code>char fpga_error_info::name[FPGA_ERROR_NAME_MAX];\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/structfpga__metric/","title":"Struct fpga_metric","text":"<p>ClassList &gt; fpga_metric</p> <p>Metric struct. </p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/structfpga__metric/#public-attributes","title":"Public Attributes","text":"Type Name bool isvalid uint64_t metric_num metric_value value"},{"location":"opae-code/structfpga__metric/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structfpga__metric/#variable-isvalid","title":"variable isvalid","text":"<pre><code>bool fpga_metric::isvalid;\n</code></pre>"},{"location":"opae-code/structfpga__metric/#variable-metric_num","title":"variable metric_num","text":"<pre><code>uint64_t fpga_metric::metric_num;\n</code></pre>"},{"location":"opae-code/structfpga__metric/#variable-value","title":"variable value","text":"<pre><code>metric_value fpga_metric::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/structfpga__metric__info/","title":"Struct fpga_metric_info","text":"<p>ClassList &gt; fpga_metric_info</p> <p>Metric info struct. </p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/structfpga__metric__info/#public-attributes","title":"Public Attributes","text":"Type Name char group_name enum fpga_metric_datatype metric_datatype fpga_guid metric_guid char metric_name uint64_t metric_num enum fpga_metric_type metric_type char metric_units char qualifier_name"},{"location":"opae-code/structfpga__metric__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structfpga__metric__info/#variable-group_name","title":"variable group_name","text":"<pre><code>char fpga_metric_info::group_name[FPGA_METRIC_STR_SIZE];\n</code></pre>"},{"location":"opae-code/structfpga__metric__info/#variable-metric_datatype","title":"variable metric_datatype","text":"<pre><code>enum fpga_metric_datatype fpga_metric_info::metric_datatype;\n</code></pre>"},{"location":"opae-code/structfpga__metric__info/#variable-metric_guid","title":"variable metric_guid","text":"<pre><code>fpga_guid fpga_metric_info::metric_guid;\n</code></pre>"},{"location":"opae-code/structfpga__metric__info/#variable-metric_name","title":"variable metric_name","text":"<pre><code>char fpga_metric_info::metric_name[FPGA_METRIC_STR_SIZE];\n</code></pre>"},{"location":"opae-code/structfpga__metric__info/#variable-metric_num","title":"variable metric_num","text":"<pre><code>uint64_t fpga_metric_info::metric_num;\n</code></pre>"},{"location":"opae-code/structfpga__metric__info/#variable-metric_type","title":"variable metric_type","text":"<pre><code>enum fpga_metric_type fpga_metric_info::metric_type;\n</code></pre>"},{"location":"opae-code/structfpga__metric__info/#variable-metric_units","title":"variable metric_units","text":"<pre><code>char fpga_metric_info::metric_units[FPGA_METRIC_STR_SIZE];\n</code></pre>"},{"location":"opae-code/structfpga__metric__info/#variable-qualifier_name","title":"variable qualifier_name","text":"<pre><code>char fpga_metric_info::qualifier_name[FPGA_METRIC_STR_SIZE];\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/structfpga__version/","title":"Struct fpga_version","text":"<p>ClassList &gt; fpga_version</p> <p>Semantic version. More...</p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/structfpga__version/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t major Major version. uint8_t minor Minor version. uint16_t patch Revision or patchlevel."},{"location":"opae-code/structfpga__version/#detailed-description","title":"Detailed Description","text":"<p>Data structure for expressing version identifiers following the semantic versioning scheme. Used in various properties for tracking component versions. </p>"},{"location":"opae-code/structfpga__version/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structfpga__version/#variable-major","title":"variable major","text":"<pre><code>uint8_t fpga_version::major;\n</code></pre>"},{"location":"opae-code/structfpga__version/#variable-minor","title":"variable minor","text":"<pre><code>uint8_t fpga_version::minor;\n</code></pre>"},{"location":"opae-code/structfpga__version/#variable-patch","title":"variable patch","text":"<pre><code>uint16_t fpga_version::patch;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/structmem__alloc/","title":"Struct mem_alloc","text":"<p>ClassList &gt; mem_alloc</p> <ul> <li><code>#include &lt;mem_alloc.h&gt;</code></li> </ul>"},{"location":"opae-code/structmem__alloc/#public-attributes","title":"Public Attributes","text":"Type Name struct mem_link allocated struct mem_link free"},{"location":"opae-code/structmem__alloc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structmem__alloc/#variable-allocated","title":"variable allocated","text":"<pre><code>struct mem_link mem_alloc::allocated;\n</code></pre>"},{"location":"opae-code/structmem__alloc/#variable-free","title":"variable free","text":"<pre><code>struct mem_link mem_alloc::free;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/mem_alloc.h</code></p>"},{"location":"opae-code/structmem__link/","title":"Struct mem_link","text":"<p>ClassList &gt; mem_link</p> <p>Provides an API for allocating/freeing a logical address space. More...</p> <ul> <li><code>#include &lt;mem_alloc.h&gt;</code></li> </ul>"},{"location":"opae-code/structmem__link/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t address struct mem_link * next struct mem_link * prev uint64_t size"},{"location":"opae-code/structmem__link/#detailed-description","title":"Detailed Description","text":"<p>There is no interaction with any OS memory allocation infrastructure, whether malloc, mmap, etc. The \"address ranges\" tracked by this allocator are arbitrary 64-bit integers. The allocator simply provides the bookeeping logic that ensures that a unique address with the appropriate size is returned for each allocation request, and that an allocation can be freed, ie released back to the available pool of logical address space for future allocations. The memory backing the allocator's internal data structures is managed by malloc()/free(). </p>"},{"location":"opae-code/structmem__link/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structmem__link/#variable-address","title":"variable address","text":"<pre><code>uint64_t mem_link::address;\n</code></pre>"},{"location":"opae-code/structmem__link/#variable-next","title":"variable next","text":"<pre><code>struct mem_link* mem_link::next;\n</code></pre>"},{"location":"opae-code/structmem__link/#variable-prev","title":"variable prev","text":"<pre><code>struct mem_link* mem_link::prev;\n</code></pre>"},{"location":"opae-code/structmem__link/#variable-size","title":"variable size","text":"<pre><code>uint64_t mem_link::size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/mem_alloc.h</code></p>"},{"location":"opae-code/structmetric__threshold/","title":"Struct metric_threshold","text":"<p>ClassList &gt; metric_threshold</p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/structmetric__threshold/#public-attributes","title":"Public Attributes","text":"Type Name threshold hysteresis threshold lower_c_threshold threshold lower_nc_threshold threshold lower_nr_threshold char metric_name threshold upper_c_threshold threshold upper_nc_threshold threshold upper_nr_threshold"},{"location":"opae-code/structmetric__threshold/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structmetric__threshold/#variable-hysteresis","title":"variable hysteresis","text":"<pre><code>threshold metric_threshold::hysteresis;\n</code></pre>"},{"location":"opae-code/structmetric__threshold/#variable-lower_c_threshold","title":"variable lower_c_threshold","text":"<pre><code>threshold metric_threshold::lower_c_threshold;\n</code></pre>"},{"location":"opae-code/structmetric__threshold/#variable-lower_nc_threshold","title":"variable lower_nc_threshold","text":"<pre><code>threshold metric_threshold::lower_nc_threshold;\n</code></pre>"},{"location":"opae-code/structmetric__threshold/#variable-lower_nr_threshold","title":"variable lower_nr_threshold","text":"<pre><code>threshold metric_threshold::lower_nr_threshold;\n</code></pre>"},{"location":"opae-code/structmetric__threshold/#variable-metric_name","title":"variable metric_name","text":"<pre><code>char metric_threshold::metric_name[FPGA_METRIC_STR_SIZE];\n</code></pre>"},{"location":"opae-code/structmetric__threshold/#variable-upper_c_threshold","title":"variable upper_c_threshold","text":"<pre><code>threshold metric_threshold::upper_c_threshold;\n</code></pre>"},{"location":"opae-code/structmetric__threshold/#variable-upper_nc_threshold","title":"variable upper_nc_threshold","text":"<pre><code>threshold metric_threshold::upper_nc_threshold;\n</code></pre>"},{"location":"opae-code/structmetric__threshold/#variable-upper_nr_threshold","title":"variable upper_nr_threshold","text":"<pre><code>threshold metric_threshold::upper_nr_threshold;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/unionmetric__value/","title":"Union metric_value","text":"<p>ClassList &gt; metric_value</p> <p>Metric value union. </p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/unionmetric__value/#public-attributes","title":"Public Attributes","text":"Type Name bool bvalue double dvalue float fvalue uint64_t ivalue"},{"location":"opae-code/unionmetric__value/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/unionmetric__value/#variable-bvalue","title":"variable bvalue","text":"<pre><code>bool metric_value::bvalue;\n</code></pre>"},{"location":"opae-code/unionmetric__value/#variable-dvalue","title":"variable dvalue","text":"<pre><code>double metric_value::dvalue;\n</code></pre>"},{"location":"opae-code/unionmetric__value/#variable-fvalue","title":"variable fvalue","text":"<pre><code>float metric_value::fvalue;\n</code></pre>"},{"location":"opae-code/unionmetric__value/#variable-ivalue","title":"variable ivalue","text":"<pre><code>uint64_t metric_value::ivalue;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/namespaceopae/","title":"Namespace opae","text":"<p>Namespace List &gt; opae</p>"},{"location":"opae-code/namespaceopae/#namespaces","title":"Namespaces","text":"Type Name namespace fpga <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/errors.h</code></p>"},{"location":"opae-code/namespaceopae_1_1fpga/","title":"Namespace opae::fpga","text":"<p>Namespace List &gt; opae &gt; fpga</p>"},{"location":"opae-code/namespaceopae_1_1fpga/#namespaces","title":"Namespaces","text":"Type Name namespace types <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/errors.h</code></p>"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types/","title":"Namespace opae::fpga::types","text":"<p>Namespace List &gt; opae &gt; fpga &gt; types</p>"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types/#namespaces","title":"Namespaces","text":"Type Name namespace detail"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types/#classes","title":"Classes","text":"Type Name class busy busy exception class error An error object represents an error register for a resource. class event Wraps fpga event routines in OPAE C. class except Generic OPAE exception. class exception exception exception struct guid_t Representation of the guid member of a properties object. class handle An allocated accelerator resource. class invalid_param invalid_param exception class no_access no_access exception class no_daemon no_daemon exception class no_driver no_driver exception class no_memory no_memory exception class not_found not_found exception class not_supported not_supported exception class properties Wraps an OPAE fpga_properties object. struct pvalue &lt;typename T&gt;Wraps OPAE properties defined in the OPAE C API by associating an <code>fpga_properties</code> reference with the getters and setters defined for a property. class reconf_error reconf_error exception class shared_buffer Host/AFU shared memory blocks. class src_location Identify a particular line in a source file. class sysobject Wraps the OPAE fpga_object primitive. class token Wraps the OPAE fpga_token primitive. class version <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/errors.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/","title":"Class opae::fpga::types::busy","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; busy</p> <p>busy exception More...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/#public-functions","title":"Public Functions","text":"Type Name busy (src_location loc) noexceptbusy constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/#detailed-description","title":"Detailed Description","text":"<p>busy tracks the source line of origin for exceptions thrown when the error code FPGA_BUSY is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1busy/#function-busy","title":"function busy","text":"<p>busy constructor <pre><code>inline opae::fpga::types::busy::busy (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/","title":"Namespace opae::fpga::types::detail","text":"<p>Namespace List &gt; opae &gt; fpga &gt; types &gt; detail</p>"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-types","title":"Public Types","text":"Type Name typedef bool(* exception_fn typedef function pointer that returns bool if result is FPGA_OK"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-static-attributes","title":"Public Static Attributes","text":"Type Name exception_fn opae_exceptions   = = { is_ok&lt;opae::fpga::types::invalid_param&gt;, is_ok&lt;opae::fpga::types::busy&gt;, is_ok&lt;opae::fpga::types::exception&gt;, is_ok&lt;opae::fpga::types::not_found&gt;, is_ok&lt;opae::fpga::types::no_memory&gt;, is_ok&lt;opae::fpga::types::not_supported&gt;, is_ok&lt;opae::fpga::types::no_driver&gt;, is_ok&lt;opae::fpga::types::no_daemon&gt;, is_ok&lt;opae::fpga::types::no_access&gt;, is_ok&lt;opae::fpga::types::reconf_error&gt;}"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-functions","title":"Public Functions","text":"Type Name constexpr bool is_ok (fpga_result result, const opae::fpga::types::src_location &amp; loc) is_ok is a template function that throws an excpetion of its template argument type if the result code is not FPGA_OK."},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-static-functions","title":"Public Static Functions","text":"Type Name void assert_fpga_ok (fpga_result result, const opae::fpga::types::src_location &amp; loc)"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#typedef-exception_fn","title":"typedef exception_fn","text":"<pre><code>typedef bool(* opae::fpga::types::detail::exception_fn) (fpga_result, const opae::fpga::types::src_location &amp;loc);\n</code></pre>"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#variable-opae_exceptions","title":"variable opae_exceptions","text":"<pre><code>exception_fn opae::fpga::types::detail::opae_exceptions[12];\n</code></pre>"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#function-is_ok","title":"function is_ok","text":"<p>is_ok is a template function that throws an excpetion of its template argument type if the result code is not FPGA_OK. <pre><code>template&lt;typename T typename T&gt;\nconstexpr bool opae::fpga::types::detail::is_ok (\nfpga_result result,\nconst opae::fpga::types::src_location &amp; loc\n) </code></pre></p> <p>Otherwise it returns true. </p>"},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/namespaceopae_1_1fpga_1_1types_1_1detail/#function-assert_fpga_ok","title":"function assert_fpga_ok","text":"<pre><code>static inline void opae::fpga::types::detail::assert_fpga_ok (\nfpga_result result,\nconst opae::fpga::types::src_location &amp; loc\n) </code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/","title":"Class opae::fpga::types::error","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; error</p> <p>An error object represents an error register for a resource. More...</p> <ul> <li><code>#include &lt;errors.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; error &gt; ptr_t"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#public-functions","title":"Public Functions","text":"Type Name fpga_error_info c_type () constGet the C data structure. bool can_clear () Indicates whether an error register can be cleared. error (const error &amp; e) = delete std::string name () Get the error register name. error &amp; operator= (const error &amp; e) = delete uint64_t read_value () Read the raw value contained in the associated error register. ~error ()"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#public-static-functions","title":"Public Static Functions","text":"Type Name error::ptr_t get (token::ptr_t tok, uint32_t num) Factory function for creating an error object."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#detailed-description","title":"Detailed Description","text":"<p>This is used to read out the raw value in the register. No parsing is done by this class. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#typedef-ptr_t","title":"typedef ptr_t","text":"<pre><code>typedef std::shared_ptr&lt;error&gt; opae::fpga::types::error::ptr_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-c_type","title":"function c_type","text":"<p>Get the C data structure. <pre><code>inline fpga_error_info opae::fpga::types::error::c_type () const\n</code></pre></p> <p>Returns:</p> <p>The fpga_error_info that contains the name and the can_clear boolean. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-can_clear","title":"function can_clear","text":"<p>Indicates whether an error register can be cleared. <pre><code>inline bool opae::fpga::types::error::can_clear () </code></pre></p> <p>Returns:</p> <p>A boolean value indicating if the error register can be cleared. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-error-12","title":"function error [\u00bd]","text":"<pre><code>opae::fpga::types::error::error (\nconst error &amp; e\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-name","title":"function name","text":"<p>Get the error register name. <pre><code>inline std::string opae::fpga::types::error::name () </code></pre></p> <p>Returns:</p> <p>A std::string object set to the error name. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-operator","title":"function operator=","text":"<pre><code>error &amp; opae::fpga::types::error::operator= (\nconst error &amp; e\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-read_value","title":"function read_value","text":"<p>Read the raw value contained in the associated error register. <pre><code>uint64_t opae::fpga::types::error::read_value () </code></pre></p> <p>Returns:</p> <p>A 64-bit value (unparsed) read from the error register </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-error","title":"function ~error","text":"<pre><code>inline opae::fpga::types::error::~error () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1error/#function-get","title":"function get","text":"<p>Factory function for creating an error object. <pre><code>static error::ptr_t opae::fpga::types::error::get (\ntoken::ptr_t tok,\nuint32_t num\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tok</code> The token object representing a resource. </li> <li><code>num</code> The index of the error register. This must be lower than the num_errors property of the resource.</li> </ul> <p>Returns:</p> <p>A shared_ptr containing the error object </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/errors.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/","title":"Class opae::fpga::types::event","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; event</p> <p>Wraps fpga event routines in OPAE C. </p> <ul> <li><code>#include &lt;events.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#classes","title":"Classes","text":"Type Name struct type_t C++ struct that is interchangeable with fpga_event_type enum."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; event &gt; ptr_t"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#public-functions","title":"Public Functions","text":"Type Name fpga_event_handle get () Get the fpga_event_handle contained in this object. operator fpga_event_handle () Coversion operator for converting to fpga_event_handle objects. int os_object () constGet OS Object from the event object. virtual ~event () Destroy event and associated resources."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#public-static-functions","title":"Public Static Functions","text":"Type Name event::ptr_t register_event (handle::ptr_t h, event::type_t t, int flags=0) Factory function to create event objects."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#typedef-ptr_t","title":"typedef ptr_t","text":"<pre><code>typedef std::shared_ptr&lt;event&gt; opae::fpga::types::event::ptr_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#function-get","title":"function get","text":"<p>Get the fpga_event_handle contained in this object. <pre><code>inline fpga_event_handle opae::fpga::types::event::get () </code></pre></p> <p>Returns:</p> <p>The fpga_event_handle contained in this object </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#function-operator-fpga_event_handle","title":"function operator fpga_event_handle","text":"<p>Coversion operator for converting to fpga_event_handle objects. <pre><code>opae::fpga::types::event::operator fpga_event_handle () </code></pre></p> <p>Returns:</p> <p>The fpga_event_handle contained in this object </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#function-os_object","title":"function os_object","text":"<p>Get OS Object from the event object. <pre><code>int opae::fpga::types::event::os_object () const\n</code></pre></p> <p>Get an OS specific object from the event which can be used to subscribe for events. On Linux, the object corresponds to a file descriptor that can be used with select/poll/epoll calls.</p> <p>Returns:</p> <p>An integer object representing the OS object </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#function-event","title":"function ~event","text":"<pre><code>virtual opae::fpga::types::event::~event () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1event/#function-register_event","title":"function register_event","text":"<p>Factory function to create event objects. <pre><code>static event::ptr_t opae::fpga::types::event::register_event (\nhandle::ptr_t h,\nevent::type_t t,\nint flags=0\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>h</code> A shared ptr of a resource handle </li> <li><code>t</code> The resource type </li> <li><code>flags</code> Event registration flags passed on to fpgaRegisterEvent</li> </ul> <p>Returns:</p> <p>A shared ptr to an event object </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/events.h</code></p>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/","title":"Struct opae::fpga::types::event::type_t","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; event &gt; type_t</p> <p>C++ struct that is interchangeable with fpga_event_type enum. </p> <ul> <li><code>#include &lt;events.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr fpga_event_type error   = = FPGA_EVENT_ERROR constexpr fpga_event_type interrupt   = = FPGA_EVENT_INTERRUPT constexpr fpga_event_type power_thermal   = = FPGA_EVENT_POWER_THERMAL"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#public-functions","title":"Public Functions","text":"Type Name operator fpga_event_type ()  type_t (fpga_event_type c_type)"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#variable-error","title":"variable error","text":"<pre><code>constexpr fpga_event_type opae::fpga::types::event::type_t::error;\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#variable-interrupt","title":"variable interrupt","text":"<pre><code>constexpr fpga_event_type opae::fpga::types::event::type_t::interrupt;\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#variable-power_thermal","title":"variable power_thermal","text":"<pre><code>constexpr fpga_event_type opae::fpga::types::event::type_t::power_thermal;\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#function-operator-fpga_event_type","title":"function operator fpga_event_type","text":"<pre><code>inline opae::fpga::types::event::type_t::operator fpga_event_type () </code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1event_1_1type__t/#function-type_t","title":"function type_t","text":"<pre><code>inline opae::fpga::types::event::type_t::type_t (\nfpga_event_type c_type\n) </code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/events.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/","title":"Class opae::fpga::types::except","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; except</p> <p>Generic OPAE exception. More...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: std::exception</p> <p>Inherited by the following classes: opae::fpga::types::busy,  opae::fpga::types::exception,  opae::fpga::types::invalid_param,  opae::fpga::types::no_access,  opae::fpga::types::no_daemon,  opae::fpga::types::no_driver,  opae::fpga::types::no_memory,  opae::fpga::types::not_found,  opae::fpga::types::not_supported,  opae::fpga::types::reconf_error</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#public-functions","title":"Public Functions","text":"Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#protected-attributes","title":"Protected Attributes","text":"Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#detailed-description","title":"Detailed Description","text":"<p>An except tracks the source line of origin and an optional fpga_result. If no fpga_result is given, then FPGA_EXCEPTION is used. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#variable-max_except","title":"variable MAX_EXCEPT","text":"<pre><code>const std::size_t opae::fpga::types::except::MAX_EXCEPT;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#function-except-13","title":"function except [\u2153]","text":"<p>except constructor The fpga_result value is FPGA_EXCEPTION. <pre><code>opae::fpga::types::except::except (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#function-except-23","title":"function except [\u2154]","text":"<p>except constructor <pre><code>opae::fpga::types::except::except (\nfpga_result res,\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>res</code> The fpga_result value associated with this exception. </li> <li><code>loc</code> Location where the exception was constructed. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#function-except-33","title":"function except [3/3]","text":"<p>except constructor <pre><code>opae::fpga::types::except::except (\nfpga_result res,\nconst char * msg,\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>res</code> The fpga_result value associated with this exception. </li> <li><code>msg</code> The error message as a string </li> <li><code>loc</code> Location where the exception was constructed. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#function-operator-fpga_result","title":"function operator fpga_result","text":"<pre><code>inline opae::fpga::types::except::operator fpga_result () noexcept const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#function-what","title":"function what","text":"<pre><code>virtual const char * opae::fpga::types::except::what () noexcept override const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#variable-buf_","title":"variable buf_","text":"<pre><code>char opae::fpga::types::except::buf_[MAX_EXCEPT];\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#variable-loc_","title":"variable loc_","text":"<pre><code>src_location opae::fpga::types::except::loc_;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#variable-msg_","title":"variable msg_","text":"<pre><code>const char* opae::fpga::types::except::msg_;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1except/#variable-res_","title":"variable res_","text":"<pre><code>fpga_result opae::fpga::types::except::res_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/","title":"Class opae::fpga::types::exception","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; exception</p> <p>exception exception More...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/#public-functions","title":"Public Functions","text":"Type Name exception (src_location loc) noexceptexception constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/#detailed-description","title":"Detailed Description","text":"<p>exception tracks the source line of origin for exceptions thrown when the error code FPGA_EXCEPTION is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1exception/#function-exception","title":"function exception","text":"<p>exception constructor <pre><code>inline opae::fpga::types::exception::exception (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/","title":"Struct opae::fpga::types::guid_t","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; guid_t</p> <p>Representation of the guid member of a properties object. </p> <ul> <li><code>#include &lt;pvalue.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#public-functions","title":"Public Functions","text":"Type Name const uint8_t * c_type () constReturn a raw pointer to the guid. guid_t (fpga_properties * p) Construct the guid_t given its containing fpga_properties. void invalidate () Invalidate the cached local copy of the guid. bool is_set () constTracks whether the cached local copy of the guid is valid. operator uint8_t * () Return a raw pointer to the guid. guid_t &amp; operator= (fpga_guid g) Assign from fpga_guid Sets the guid field of the associated properties object using the OPAE properties API. bool operator== (const fpga_guid &amp; g) Compare contents with an fpga_guid. void parse (const char * str) Convert a string representation of a guid to binary. void update () Update the local cached copy of the guid."},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-c_type","title":"function c_type","text":"<pre><code>inline const uint8_t * opae::fpga::types::guid_t::c_type () const\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-guid_t","title":"function guid_t","text":"<pre><code>inline opae::fpga::types::guid_t::guid_t (\nfpga_properties * p\n) </code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-invalidate","title":"function invalidate","text":"<pre><code>inline void opae::fpga::types::guid_t::invalidate () </code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-is_set","title":"function is_set","text":"<pre><code>inline bool opae::fpga::types::guid_t::is_set () const\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-operator-uint8_t","title":"function operator uint8_t *","text":"<p>Return a raw pointer to the guid. <pre><code>inline opae::fpga::types::guid_t::operator uint8_t * () </code></pre></p> <p>Return value:</p> <ul> <li><code>nullptr</code> if the guid could not be queried. </li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-operator","title":"function operator=","text":"<p>Assign from fpga_guid Sets the guid field of the associated properties object using the OPAE properties API. <pre><code>inline guid_t &amp; opae::fpga::types::guid_t::operator= (\nfpga_guid g\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>g</code> The given fpga_guid. </li> </ul> <p>Returns:</p> <p>a reference to this guid_t. </p>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-operator_1","title":"function operator==","text":"<p>Compare contents with an fpga_guid. <pre><code>inline bool opae::fpga::types::guid_t::operator== (\nconst fpga_guid &amp; g\n) </code></pre></p> <p>Return value:</p> <ul> <li><code>The</code> result of memcmp of the two objects. </li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-parse","title":"function parse","text":"<p>Convert a string representation of a guid to binary. <pre><code>inline void opae::fpga::types::guid_t::parse (\nconst char * str\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> The guid string. </li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#function-update","title":"function update","text":"<pre><code>inline void opae::fpga::types::guid_t::update () </code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#friends-documentation","title":"Friends Documentation","text":""},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1guid__t/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; opae::fpga::types::guid_t::operator&lt;&lt; (\nstd::ostream &amp; ostr,\nconst guid_t &amp; g\n) </code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/pvalue.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/","title":"Class opae::fpga::types::handle","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; handle</p> <p>An allocated accelerator resource. More...</p> <ul> <li><code>#include &lt;handle.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; handle &gt; ptr_t"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#public-functions","title":"Public Functions","text":"Type Name fpga_handle c_type () constRetrieve the underlying OPAE handle. fpga_result close () Close an accelerator resource (if opened) token::ptr_t get_token () constRetrieve the token corresponding to this handle object. handle (const handle &amp;) = delete uint8_t * mmio_ptr (uint64_t offset, uint32_t csr_space=0) constRetrieve a pointer to the MMIO region. operator fpga_handle () constRetrieve the underlying OPAE handle. handle &amp; operator= (const handle &amp;) = delete uint32_t read_csr32 (uint64_t offset, uint32_t csr_space=0) constRead 32 bits from a CSR belonging to a resource associated with a handle. uint64_t read_csr64 (uint64_t offset, uint32_t csr_space=0) constRead 64 bits from a CSR belonging to a resource associated with a handle. void reconfigure (uint32_t slot, const uint8_t * bitstream, size_t size, int flags) Load a bitstream into an FPGA slot. virtual void reset () Reset the accelerator identified by this handle. void write_csr32 (uint64_t offset, uint32_t value, uint32_t csr_space=0) Write 32 bit to a CSR belonging to a resource associated with a handle. void write_csr512 (uint64_t offset, const void * value, uint32_t csr_space=0) Write 512 bits to a CSR belonging to a resource associated with a handle. void write_csr64 (uint64_t offset, uint64_t value, uint32_t csr_space=0) Write 64 bits to a CSR belonging to a resource associated with a handle. virtual ~handle ()"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#public-static-functions","title":"Public Static Functions","text":"Type Name handle::ptr_t open (fpga_token token, int flags) Open an accelerator resource, given a raw fpga_token. handle::ptr_t open (token::ptr_t token, int flags) Open an accelerator resource, given a token object."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#detailed-description","title":"Detailed Description","text":"<p>Represents an accelerator resource that has been allocated by OPAE. Depending on the type of resource, its register space may be read/written using a handle object. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#typedef-ptr_t","title":"typedef ptr_t","text":"<pre><code>typedef std::shared_ptr&lt;handle&gt; opae::fpga::types::handle::ptr_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-c_type","title":"function c_type","text":"<pre><code>inline fpga_handle opae::fpga::types::handle::c_type () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-close","title":"function close","text":"<p>Close an accelerator resource (if opened) <pre><code>fpga_result opae::fpga::types::handle::close () </code></pre></p> <p>Returns:</p> <p>fpga_result indication the result of closing the handle or FPGA_EXCEPTION if handle is not opened</p> <p>Note:</p> <p>This is available for explicitly closing a handle. The destructor for handle will call close. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-get_token","title":"function get_token","text":"<pre><code>token::ptr_t opae::fpga::types::handle::get_token () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-handle-12","title":"function handle [\u00bd]","text":"<pre><code>opae::fpga::types::handle::handle (\nconst handle &amp;\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-mmio_ptr","title":"function mmio_ptr","text":"<p>Retrieve a pointer to the MMIO region. <pre><code>uint8_t * opae::fpga::types::handle::mmio_ptr (\nuint64_t offset,\nuint32_t csr_space=0\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The byte offset to add to MMIO base. </li> <li><code>csr_space</code> The desired CSR space. Default is 0. </li> </ul> <p>Returns:</p> <p>MMIO base + offset </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-operator-fpga_handle","title":"function operator fpga_handle","text":"<pre><code>inline opae::fpga::types::handle::operator fpga_handle () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-operator","title":"function operator=","text":"<pre><code>handle &amp; opae::fpga::types::handle::operator= (\nconst handle &amp;\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-read_csr32","title":"function read_csr32","text":"<p>Read 32 bits from a CSR belonging to a resource associated with a handle. <pre><code>uint32_t opae::fpga::types::handle::read_csr32 (\nuint64_t offset,\nuint32_t csr_space=0\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The register offset </li> <li><code>csr_space</code> The CSR space to read from. Default is 0.</li> </ul> <p>Returns:</p> <p>The 32-bit value read from the CSR </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-read_csr64","title":"function read_csr64","text":"<p>Read 64 bits from a CSR belonging to a resource associated with a handle. <pre><code>uint64_t opae::fpga::types::handle::read_csr64 (\nuint64_t offset,\nuint32_t csr_space=0\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The register offset </li> <li><code>csr_space</code> The CSR space to read from. Default is 0.</li> </ul> <p>Returns:</p> <p>The 64-bit value read from the CSR </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-reconfigure","title":"function reconfigure","text":"<p>Load a bitstream into an FPGA slot. <pre><code>void opae::fpga::types::handle::reconfigure (\nuint32_t slot,\nconst uint8_t * bitstream,\nsize_t size,\nint flags\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>slot</code> The slot number to program </li> <li><code>bitstream</code> The bitstream binary data </li> <li><code>size</code> The size of the bitstream </li> <li><code>flags</code> Flags that control behavior of reconfiguration. Value of 0 indicates no flags. FPGA_RECONF_FORCE indicates that the bitstream is programmed into the slot without checking if the resource is currently in use.</li> </ul> <p>Exception:</p> <ul> <li>invalid_param if the handle is not an FPGA device handle or if the other parameters are not valid. </li> <li><code>exception</code> if an internal error is encountered. </li> <li><code>busy</code> if the accelerator for the given slot is in use. </li> <li>reconf_error if errors are reported by the driver (CRC or protocol errors). </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-reset","title":"function reset","text":"<pre><code>virtual void opae::fpga::types::handle::reset () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-write_csr32","title":"function write_csr32","text":"<p>Write 32 bit to a CSR belonging to a resource associated with a handle. <pre><code>void opae::fpga::types::handle::write_csr32 (\nuint64_t offset,\nuint32_t value,\nuint32_t csr_space=0\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The register offset. </li> <li><code>value</code> The 32-bit value to write to the register. </li> <li><code>csr_space</code> The CSR space to read from. Default is 0. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-write_csr512","title":"function write_csr512","text":"<p>Write 512 bits to a CSR belonging to a resource associated with a handle. <pre><code>void opae::fpga::types::handle::write_csr512 (\nuint64_t offset,\nconst void * value,\nuint32_t csr_space=0\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The register offset. </li> <li><code>value</code> Pointer to the 512-bit value to write to the register. </li> <li><code>csr_space</code> The CSR space to read from. Default is 0. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-write_csr64","title":"function write_csr64","text":"<p>Write 64 bits to a CSR belonging to a resource associated with a handle. <pre><code>void opae::fpga::types::handle::write_csr64 (\nuint64_t offset,\nuint64_t value,\nuint32_t csr_space=0\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The register offset. </li> <li><code>value</code> The 64-bit value to write to the register. </li> <li><code>csr_space</code> The CSR space to read from. Default is 0. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-handle","title":"function ~handle","text":"<pre><code>virtual opae::fpga::types::handle::~handle () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-open-12","title":"function open [\u00bd]","text":"<p>Open an accelerator resource, given a raw fpga_token. <pre><code>static handle::ptr_t opae::fpga::types::handle::open (\nfpga_token token,\nint flags\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>token</code> A token describing the accelerator resource to be allocated.</li> <li><code>flags</code> The flags parameter to fpgaOpen().</li> </ul> <p>Returns:</p> <p>pointer to the mmio base + offset for the given csr space </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1handle/#function-open-22","title":"function open [2/2]","text":"<p>Open an accelerator resource, given a token object. <pre><code>static handle::ptr_t opae::fpga::types::handle::open (\ntoken::ptr_t token,\nint flags\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>token</code> A token object describing the accelerator resource to be allocated.</li> <li><code>flags</code> The flags parameter to fpgaOpen().</li> </ul> <p>Returns:</p> <p>shared ptr to a handle object </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/handle.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/","title":"Class opae::fpga::types::invalid_param","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; invalid_param</p> <p>invalid_param exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/#public-functions","title":"Public Functions","text":"Type Name invalid_param (src_location loc) noexceptinvalid_param constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/#detailed-description","title":"Detailed Description","text":"<p>invalid_param tracks the source line of origin for exceptions thrown when the error code FPGA_INVALID_PARAM is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1invalid__param/#function-invalid_param","title":"function invalid_param","text":"<p>invalid_param constructor <pre><code>inline opae::fpga::types::invalid_param::invalid_param (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/","title":"Class opae::fpga::types::no_access","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; no_access</p> <p>no_access exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/#public-functions","title":"Public Functions","text":"Type Name no_access (src_location loc) noexceptno_access constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/#detailed-description","title":"Detailed Description","text":"<p>no_access tracks the source line of origin for exceptions thrown when the error code FPGA_NO_ACCESS is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__access/#function-no_access","title":"function no_access","text":"<p>no_access constructor <pre><code>inline opae::fpga::types::no_access::no_access (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/","title":"Class opae::fpga::types::no_daemon","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; no_daemon</p> <p>no_daemon exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/#public-functions","title":"Public Functions","text":"Type Name no_daemon (src_location loc) noexceptno_daemon constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/#detailed-description","title":"Detailed Description","text":"<p>no_daemon tracks the source line of origin for exceptions thrown when the error code FPGA_NO_DAEMON is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__daemon/#function-no_daemon","title":"function no_daemon","text":"<p>no_daemon constructor <pre><code>inline opae::fpga::types::no_daemon::no_daemon (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/","title":"Class opae::fpga::types::no_driver","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; no_driver</p> <p>no_driver exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/#public-functions","title":"Public Functions","text":"Type Name no_driver (src_location loc) noexceptno_driver constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/#detailed-description","title":"Detailed Description","text":"<p>no_driver tracks the source line of origin for exceptions thrown when the error code FPGA_NO_DRIVER is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__driver/#function-no_driver","title":"function no_driver","text":"<p>no_driver constructor <pre><code>inline opae::fpga::types::no_driver::no_driver (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/","title":"Class opae::fpga::types::no_memory","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; no_memory</p> <p>no_memory exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/#public-functions","title":"Public Functions","text":"Type Name no_memory (src_location loc) noexceptno_memory constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/#detailed-description","title":"Detailed Description","text":"<p>no_memory tracks the source line of origin for exceptions thrown when the error code FPGA_NO_MEMORY is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1no__memory/#function-no_memory","title":"function no_memory","text":"<p>no_memory constructor <pre><code>inline opae::fpga::types::no_memory::no_memory (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/","title":"Class opae::fpga::types::not_found","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; not_found</p> <p>not_found exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/#public-functions","title":"Public Functions","text":"Type Name not_found (src_location loc) noexceptnot_found constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/#detailed-description","title":"Detailed Description","text":"<p>not_found tracks the source line of origin for exceptions thrown when the error code FPGA_NOT_FOUND is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__found/#function-not_found","title":"function not_found","text":"<p>not_found constructor <pre><code>inline opae::fpga::types::not_found::not_found (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/","title":"Class opae::fpga::types::not_supported","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; not_supported</p> <p>not_supported exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/#public-functions","title":"Public Functions","text":"Type Name not_supported (src_location loc) noexceptnot_supported constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/#detailed-description","title":"Detailed Description","text":"<p>not_supported tracks the source line of origin for exceptions thrown when the error code FPGA_NOT_SUPPORTED is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1not__supported/#function-not_supported","title":"function not_supported","text":"<p>not_supported constructor <pre><code>inline opae::fpga::types::not_supported::not_supported (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/","title":"Class opae::fpga::types::properties","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; properties</p> <p>Wraps an OPAE fpga_properties object. More...</p> <ul> <li><code>#include &lt;properties.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; properties &gt; ptr_t"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-attributes","title":"Public Attributes","text":"Type Name pvalue&lt; fpga_accelerator_state &gt; accelerator_state pvalue&lt; uint64_t &gt; bbs_id pvalue&lt; fpga_version &gt; bbs_version pvalue&lt; uint8_t &gt; bus pvalue&lt; uint64_t &gt; capabilities pvalue&lt; uint8_t &gt; device pvalue&lt; uint16_t &gt; device_id pvalue&lt; uint8_t &gt; function guid_t guid pvalue&lt; fpga_interface &gt; interface pvalue&lt; uint64_t &gt; local_memory_size pvalue&lt; char * &gt; model pvalue&lt; uint32_t &gt; num_errors pvalue&lt; uint32_t &gt; num_interrupts pvalue&lt; uint32_t &gt; num_mmio pvalue&lt; uint32_t &gt; num_slots pvalue&lt; uint64_t &gt; object_id pvalue&lt; fpga_token &gt; parent pvalue&lt; uint16_t &gt; segment pvalue&lt; uint8_t &gt; socket_id pvalue&lt; uint16_t &gt; subsystem_device_id pvalue&lt; uint16_t &gt; subsystem_vendor_id pvalue&lt; fpga_objtype &gt; type pvalue&lt; uint16_t &gt; vendor_id"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const std::vector&lt; properties::ptr_t &gt; none An empty vector of properties."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-functions","title":"Public Functions","text":"Type Name fpga_properties c_type () constGet the underlying fpga_properties object. operator fpga_properties () constGet the underlying fpga_properties object. properties &amp; operator= (const properties &amp; p) = delete properties (const properties &amp; p) = delete ~properties ()"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-static-functions","title":"Public Static Functions","text":"Type Name properties::ptr_t get () Create a new properties object. properties::ptr_t get (fpga_guid guid_in) Create a new properties object from a guid. properties::ptr_t get (fpga_objtype objtype) Create a new properties object from an fpga_objtype. properties::ptr_t get (std::shared_ptr&lt; token &gt; t) Retrieve the properties for a given token object. properties::ptr_t get (fpga_token t) Retrieve the properties for a given fpga_token. properties::ptr_t get (std::shared_ptr&lt; handle &gt; h) Retrieve the properties for a given handle object."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#detailed-description","title":"Detailed Description","text":"<p>properties are information describing an accelerator resource that is identified by its token. The properties are used during enumeration to narrow the search for an accelerator resource, and after enumeration to provide the configuration of that resource. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#typedef-ptr_t","title":"typedef ptr_t","text":"<pre><code>typedef std::shared_ptr&lt;properties&gt; opae::fpga::types::properties::ptr_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-accelerator_state","title":"variable accelerator_state","text":"<pre><code>pvalue&lt;fpga_accelerator_state&gt; opae::fpga::types::properties::accelerator_state;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-bbs_id","title":"variable bbs_id","text":"<pre><code>pvalue&lt;uint64_t&gt; opae::fpga::types::properties::bbs_id;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-bbs_version","title":"variable bbs_version","text":"<pre><code>pvalue&lt;fpga_version&gt; opae::fpga::types::properties::bbs_version;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-bus","title":"variable bus","text":"<pre><code>pvalue&lt;uint8_t&gt; opae::fpga::types::properties::bus;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-capabilities","title":"variable capabilities","text":"<pre><code>pvalue&lt;uint64_t&gt; opae::fpga::types::properties::capabilities;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-device","title":"variable device","text":"<pre><code>pvalue&lt;uint8_t&gt; opae::fpga::types::properties::device;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-device_id","title":"variable device_id","text":"<pre><code>pvalue&lt;uint16_t&gt; opae::fpga::types::properties::device_id;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-function","title":"variable function","text":"<pre><code>pvalue&lt;uint8_t&gt; opae::fpga::types::properties::function;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-guid","title":"variable guid","text":"<pre><code>guid_t opae::fpga::types::properties::guid;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-interface","title":"variable interface","text":"<pre><code>pvalue&lt;fpga_interface&gt; opae::fpga::types::properties::interface;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-local_memory_size","title":"variable local_memory_size","text":"<pre><code>pvalue&lt;uint64_t&gt; opae::fpga::types::properties::local_memory_size;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-model","title":"variable model","text":"<pre><code>pvalue&lt;char *&gt; opae::fpga::types::properties::model;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-num_errors","title":"variable num_errors","text":"<pre><code>pvalue&lt;uint32_t&gt; opae::fpga::types::properties::num_errors;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-num_interrupts","title":"variable num_interrupts","text":"<pre><code>pvalue&lt;uint32_t&gt; opae::fpga::types::properties::num_interrupts;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-num_mmio","title":"variable num_mmio","text":"<pre><code>pvalue&lt;uint32_t&gt; opae::fpga::types::properties::num_mmio;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-num_slots","title":"variable num_slots","text":"<pre><code>pvalue&lt;uint32_t&gt; opae::fpga::types::properties::num_slots;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-object_id","title":"variable object_id","text":"<pre><code>pvalue&lt;uint64_t&gt; opae::fpga::types::properties::object_id;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-parent","title":"variable parent","text":"<pre><code>pvalue&lt;fpga_token&gt; opae::fpga::types::properties::parent;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-segment","title":"variable segment","text":"<pre><code>pvalue&lt;uint16_t&gt; opae::fpga::types::properties::segment;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-socket_id","title":"variable socket_id","text":"<pre><code>pvalue&lt;uint8_t&gt; opae::fpga::types::properties::socket_id;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-subsystem_device_id","title":"variable subsystem_device_id","text":"<pre><code>pvalue&lt;uint16_t&gt; opae::fpga::types::properties::subsystem_device_id;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-subsystem_vendor_id","title":"variable subsystem_vendor_id","text":"<pre><code>pvalue&lt;uint16_t&gt; opae::fpga::types::properties::subsystem_vendor_id;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-type","title":"variable type","text":"<pre><code>pvalue&lt;fpga_objtype&gt; opae::fpga::types::properties::type;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-vendor_id","title":"variable vendor_id","text":"<pre><code>pvalue&lt;uint16_t&gt; opae::fpga::types::properties::vendor_id;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#variable-none","title":"variable none","text":"<p>An empty vector of properties. <pre><code>const std::vector&lt;properties::ptr_t&gt; opae::fpga::types::properties::none;\n</code></pre></p> <p>Useful for enumerating based on a \"match all\" criteria. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-c_type","title":"function c_type","text":"<pre><code>inline fpga_properties opae::fpga::types::properties::c_type () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-operator-fpga_properties","title":"function operator fpga_properties","text":"<pre><code>inline opae::fpga::types::properties::operator fpga_properties () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-operator","title":"function operator=","text":"<pre><code>properties &amp; opae::fpga::types::properties::operator= (\nconst properties &amp; p\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-properties-12","title":"function properties [\u00bd]","text":"<pre><code>opae::fpga::types::properties::properties (\nconst properties &amp; p\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-properties","title":"function ~properties","text":"<pre><code>opae::fpga::types::properties::~properties () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-get-16","title":"function get [\u2159]","text":"<p>Create a new properties object. <pre><code>static properties::ptr_t opae::fpga::types::properties::get () </code></pre></p> <p>Returns:</p> <p>A properties smart pointer. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-get-26","title":"function get [2/6]","text":"<p>Create a new properties object from a guid. <pre><code>static properties::ptr_t opae::fpga::types::properties::get (\nfpga_guid guid_in\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>guid_in</code> A guid to set in the properties </li> </ul> <p>Returns:</p> <p>A properties smart pointer with its guid initialized to guid_in </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-get-36","title":"function get [3/6]","text":"<p>Create a new properties object from an fpga_objtype. <pre><code>static properties::ptr_t opae::fpga::types::properties::get (\nfpga_objtype objtype\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>objtype</code> An object type to set in the properties </li> </ul> <p>Returns:</p> <p>A properties smart pointer with its object type set to objtype. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-get-46","title":"function get [4/6]","text":"<p>Retrieve the properties for a given token object. <pre><code>static properties::ptr_t opae::fpga::types::properties::get (\nstd::shared_ptr&lt; token &gt; t\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>t</code> A token identifying the accelerator resource. </li> </ul> <p>Returns:</p> <p>A properties smart pointer for the given token. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-get-56","title":"function get [\u215a]","text":"<p>Retrieve the properties for a given fpga_token. <pre><code>static properties::ptr_t opae::fpga::types::properties::get (\nfpga_token t\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>t</code> An fpga_token identifying the accelerator resource. </li> </ul> <p>Returns:</p> <p>A properties smart pointer for the given fpga_token. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1properties/#function-get-66","title":"function get [6/6]","text":"<p>Retrieve the properties for a given handle object. <pre><code>static properties::ptr_t opae::fpga::types::properties::get (\nstd::shared_ptr&lt; handle &gt; h\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>h</code> A handle identifying the accelerator resource. </li> </ul> <p>Returns:</p> <p>A properties smart pointer for the given handle. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/properties.h</code></p>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/","title":"Struct opae::fpga::types::pvalue","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; opae &gt; fpga &gt; types &gt; pvalue</p> <p>Wraps OPAE properties defined in the OPAE C API by associating an <code>fpga_properties</code> reference with the getters and setters defined for a property.More...</p> <ul> <li><code>#include &lt;pvalue.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#public-types","title":"Public Types","text":"Type Name typedef std::conditional&lt; std::is_same&lt; T, char * &gt;::value, typename std::string, T &gt;::type copy_t Define the type of our copy variable For <code>char*</code> types use std::string as the copy. typedef std::conditional&lt; std::is_same&lt; T, char * &gt;::value, fpga_result(*)(fpga_properties, T), fpga_result(*)(fpga_properties, T *)&gt;::type getter_t Define getter function as getter_t For <code>char*</code> types, do not use T* as the second argument but instead use T. typedef fpga_result(* setter_t Define the setter function as setter_t."},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#public-functions","title":"Public Functions","text":"Type Name fpga_result get_value (T &amp; value) const void invalidate () Invalidate the cached local copy of the pvalue. bool is_set () constTracks whether the cached local copy of the pvalue is valid. operator copy_t () Implicit converter operator - calls the wrapped getter. pvalue&lt; T &gt; &amp; operator= (const T &amp; v) Overload of <code>=</code> operator that calls the wrapped setter. bool operator== (const T &amp; other) Compare a property for equality with a value. pvalue ()  pvalue (fpga_properties * p, getter_t g, setter_t s) pvalue contructor that takes in a reference to fpga_properties and corresponding accessor methods for a property void update ()  void update () Template specialization of <code>char*</code> type property updater."},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> The type of the property value being wrapped </li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#typedef-copy_t","title":"typedef copy_t","text":"<pre><code>typedef std::conditional&lt;std::is_same&lt;T, char *&gt;::value, typename std::string, T&gt;::type opae::fpga::types::pvalue&lt; T &gt;::copy_t;\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#typedef-getter_t","title":"typedef getter_t","text":"<pre><code>typedef std::conditional&lt; std::is_same&lt;T, char *&gt;::value, fpga_result (*)(fpga_properties, T), fpga_result (*)(fpga_properties, T *)&gt;::type opae::fpga::types::pvalue&lt; T &gt;::getter_t;\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#typedef-setter_t","title":"typedef setter_t","text":"<pre><code>typedef fpga_result(* opae::fpga::types::pvalue&lt; T &gt;::setter_t) (fpga_properties, T);\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-get_value","title":"function get_value","text":"<pre><code>inline fpga_result opae::fpga::types::pvalue::get_value (\nT &amp; value\n) const\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-invalidate","title":"function invalidate","text":"<pre><code>inline void opae::fpga::types::pvalue::invalidate () </code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-is_set","title":"function is_set","text":"<pre><code>inline bool opae::fpga::types::pvalue::is_set () const\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-operator-copy_t","title":"function operator copy_t","text":"<p>Implicit converter operator - calls the wrapped getter. <pre><code>inline opae::fpga::types::pvalue::operator copy_t () </code></pre></p> <p>Returns:</p> <p>The property value after calling the getter or a default value of the value type </p>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-operator","title":"function operator=","text":"<p>Overload of <code>=</code> operator that calls the wrapped setter. <pre><code>inline pvalue &lt; T &gt; &amp; opae::fpga::types::pvalue::operator= (\nconst T &amp; v\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The value to set</li> </ul> <p>Returns:</p> <p>A reference to itself </p>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-operator_1","title":"function operator==","text":"<p>Compare a property for equality with a value. <pre><code>inline bool opae::fpga::types::pvalue::operator== (\nconst T &amp; other\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> The value being compared to</li> </ul> <p>Returns:</p> <p>Whether or not the property is equal to the value </p>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-pvalue-12","title":"function pvalue [\u00bd]","text":"<pre><code>inline opae::fpga::types::pvalue::pvalue () </code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-pvalue-22","title":"function pvalue [2/2]","text":"<p>pvalue contructor that takes in a reference to fpga_properties and corresponding accessor methods for a property <pre><code>inline opae::fpga::types::pvalue::pvalue (\nfpga_properties * p,\ngetter_t g,\nsetter_t s\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>p</code> A reference to an fpga_properties </li> <li><code>g</code> The getter function </li> <li><code>s</code> The setter function </li> </ul>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-update-12","title":"function update [\u00bd]","text":"<pre><code>inline void opae::fpga::types::pvalue::update () </code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#function-update-22","title":"function update [2/2]","text":"<p>Template specialization of <code>char*</code> type property updater. <pre><code>inline void opae::fpga::types::pvalue::update () </code></pre></p> <p>Returns:</p> <p>The result of the property getter function. </p> <pre><code>    ## Friends Documentation\n</code></pre>"},{"location":"opae-code/structopae_1_1fpga_1_1types_1_1pvalue/#friend-operator","title":"friend operator&lt;&lt;","text":"<p>Stream overalod operator. <pre><code>inline std::ostream &amp; opae::fpga::types::pvalue::operator&lt;&lt; (\nstd::ostream &amp; ostr,\nconst pvalue &lt; T &gt; &amp; p\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ostr</code> The output stream </li> <li><code>p</code> A reference to a pvalue&lt;T&gt; object</li> </ul> <p>Returns:</p> <p>The stream operator after streaming the property value </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/pvalue.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/","title":"Class opae::fpga::types::reconf_error","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; reconf_error</p> <p>reconf_error exceptionMore...</p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul> <p>Inherits the following classes: opae::fpga::types::except</p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/#public-static-attributes-inherited-from-opaefpgatypesexcept","title":"Public Static Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name const std::size_t MAX_EXCEPT   = = 256"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/#public-functions","title":"Public Functions","text":"Type Name reconf_error (src_location loc) noexceptreconf_error constructor"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/#public-functions-inherited-from-opaefpgatypesexcept","title":"Public Functions inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name except (src_location loc) noexceptexcept constructor The fpga_result value is FPGA_EXCEPTION. except (fpga_result res, src_location loc) noexceptexcept constructor except (fpga_result res, const char * msg, src_location loc) noexceptexcept constructor operator fpga_result () noexcept constConvert this except to its fpga_result. virtual const char * what () noexcept override constConvert this except to an informative string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/#protected-attributes-inherited-from-opaefpgatypesexcept","title":"Protected Attributes inherited from opae::fpga::types::except","text":"<p>See opae::fpga::types::except</p> Type Name char buf_ src_location loc_ const char * msg_ fpga_result res_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/#detailed-description","title":"Detailed Description","text":"<p>reconf_error tracks the source line of origin for exceptions thrown when the error code FPGA_RECONF_ERROR is returned from a call to an OPAE C API function </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1reconf__error/#function-reconf_error","title":"function reconf_error","text":"<p>reconf_error constructor <pre><code>inline opae::fpga::types::reconf_error::reconf_error (\nsrc_location loc\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>loc</code> Location where the exception was constructed. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/","title":"Class opae::fpga::types::shared_buffer","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; shared_buffer</p> <p>Host/AFU shared memory blocks. More...</p> <ul> <li><code>#include &lt;shared_buffer.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; shared_buffer &gt; ptr_t typedef std::size_t size_t"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#public-functions","title":"Public Functions","text":"Type Name uint8_t * c_type () constRetrieve the virtual address of the buffer base. int compare (ptr_t other, size_t len) constCompare this shared_buffer (the first len bytes) to that held in other, using memcmp(). void fill (int c) Write c to each byte location in the buffer. uint64_t io_address () constRetrieve the address of the buffer suitable for programming into the accelerator device. shared_buffer &amp; operator= (const shared_buffer &amp;) = delete handle::ptr_t owner () constRetrieve the handle smart pointer associated with this buffer. T read (size_t offset) constRead a T-sized block of memory at the given location. void release () Disassociate the shared_buffer object from the resource used to create it. shared_buffer (const shared_buffer &amp;) = delete size_t size () constRetrieve the length of the buffer in bytes. void write (const T &amp; value, size_t offset) Write a T-sized block of memory to the given location. uint64_t wsid () constRetrieve the underlying buffer's workspace id. virtual ~shared_buffer () shared_buffer destructor."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#public-static-functions","title":"Public Static Functions","text":"Type Name shared_buffer::ptr_t allocate (handle::ptr_t handle, size_t len, bool read_only=false) shared_buffer factory method - allocate ashared_buffer . shared_buffer::ptr_t attach (handle::ptr_t handle, uint8_t * base, size_t len, bool read_only=false) Attach a pre-allocated buffer to a shared_buffer object."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#protected-attributes","title":"Protected Attributes","text":"Type Name handle::ptr_t handle_ uint64_t io_address_ size_t len_ uint8_t * virt_ uint64_t wsid_"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#protected-functions","title":"Protected Functions","text":"Type Name shared_buffer (handle::ptr_t handle, size_t len, uint8_t * virt, uint64_t wsid, uint64_t io_address)"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#detailed-description","title":"Detailed Description","text":"<p>shared_buffer abstracts a memory block that may be shared between the host cpu and an accelerator. The block may be allocated by the shared_buffer class itself (see allocate), or it may be allocated elsewhere and then attached to a shared_buffer object via attach. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#typedef-ptr_t","title":"typedef ptr_t","text":"<pre><code>typedef std::shared_ptr&lt;shared_buffer&gt; opae::fpga::types::shared_buffer::ptr_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#typedef-size_t","title":"typedef size_t","text":"<pre><code>typedef std::size_t opae::fpga::types::shared_buffer::size_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-c_type","title":"function c_type","text":"<p>Retrieve the virtual address of the buffer base. <pre><code>inline uint8_t * opae::fpga::types::shared_buffer::c_type () const\n</code></pre></p> <p>Note:</p> <p>Instances of a shared buffer can only be created using either 'allocate' or 'attach' static factory function. Because these functions return a shared pointer (std::shared_ptr) to the instance, references to an instance are counted automatically by design of the shared_ptr class. Calling 'c_type()' function is provided to get access to the raw data but isn't used in tracking its reference count. Assigning this to a variable should be done in limited scopes as this variable can be defined in an outer scope and may outlive the shared_buffer object. Once the reference count in the shared_ptr reaches zero, the shared_buffer object will be released and deallocated, turning any variables assigned from a call to 'c_type()' into dangling pointers. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-compare","title":"function compare","text":"<pre><code>int opae::fpga::types::shared_buffer::compare (\nptr_t other,\nsize_t len\n) const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-fill","title":"function fill","text":"<pre><code>void opae::fpga::types::shared_buffer::fill (\nint c\n) </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-io_address","title":"function io_address","text":"<pre><code>inline uint64_t opae::fpga::types::shared_buffer::io_address () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-operator","title":"function operator=","text":"<pre><code>shared_buffer &amp; opae::fpga::types::shared_buffer::operator= (\nconst shared_buffer &amp;\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-owner","title":"function owner","text":"<pre><code>inline handle::ptr_t opae::fpga::types::shared_buffer::owner () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-read","title":"function read","text":"<p>Read a T-sized block of memory at the given location. <pre><code>template&lt;typename T typename T&gt;\ninline T opae::fpga::types::shared_buffer::read (\nsize_t offset\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The byte offset from the start of the buffer. </li> </ul> <p>Returns:</p> <p>A T from buffer base + offset. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-release","title":"function release","text":"<p>Disassociate the shared_buffer object from the resource used to create it. <pre><code>void opae::fpga::types::shared_buffer::release () </code></pre></p> <p>If the buffer was allocated using the allocate function then the buffer is freed. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-shared_buffer-12","title":"function shared_buffer [\u00bd]","text":"<pre><code>opae::fpga::types::shared_buffer::shared_buffer (\nconst shared_buffer &amp;\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-size","title":"function size","text":"<pre><code>inline size_t opae::fpga::types::shared_buffer::size () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-write","title":"function write","text":"<p>Write a T-sized block of memory to the given location. <pre><code>template&lt;typename T typename T&gt;\ninline void opae::fpga::types::shared_buffer::write (\nconst T &amp; value,\nsize_t offset\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>value</code> The value to write. </li> <li><code>offset</code> The byte offset from the start of the buffer. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-wsid","title":"function wsid","text":"<pre><code>inline uint64_t opae::fpga::types::shared_buffer::wsid () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-shared_buffer","title":"function ~shared_buffer","text":"<pre><code>virtual opae::fpga::types::shared_buffer::~shared_buffer () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-allocate","title":"function allocate","text":"<p>shared_buffer factory method - allocate ashared_buffer . <pre><code>static shared_buffer::ptr_t opae::fpga::types::shared_buffer::allocate (\nhandle::ptr_t handle,\nsize_t len,\nbool read_only=false\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> The handle used to allocate the buffer. </li> <li><code>len</code> The length in bytes of the requested buffer. </li> </ul> <p>Returns:</p> <p>A valid shared_buffer smart pointer on success, or an empty smart pointer on failure. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-attach","title":"function attach","text":"<p>Attach a pre-allocated buffer to a shared_buffer object. <pre><code>static shared_buffer::ptr_t opae::fpga::types::shared_buffer::attach (\nhandle::ptr_t handle,\nuint8_t * base,\nsize_t len,\nbool read_only=false\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> The handle used to attach the buffer. </li> <li><code>base</code> The base of the pre-allocated memory. </li> <li><code>len</code> The size of the pre-allocated memory, which must be a multiple of the page size. </li> </ul> <p>Returns:</p> <p>A valid shared_buffer smart pointer on success, or an empty smart pointer on failure. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#variable-handle_","title":"variable handle_","text":"<pre><code>handle::ptr_t opae::fpga::types::shared_buffer::handle_;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#variable-io_address_","title":"variable io_address_","text":"<pre><code>uint64_t opae::fpga::types::shared_buffer::io_address_;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#variable-len_","title":"variable len_","text":"<pre><code>size_t opae::fpga::types::shared_buffer::len_;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#variable-virt_","title":"variable virt_","text":"<pre><code>uint8_t* opae::fpga::types::shared_buffer::virt_;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#variable-wsid_","title":"variable wsid_","text":"<pre><code>uint64_t opae::fpga::types::shared_buffer::wsid_;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1shared__buffer/#function-shared_buffer-22","title":"function shared_buffer [2/2]","text":"<pre><code>opae::fpga::types::shared_buffer::shared_buffer (\nhandle::ptr_t handle,\nsize_t len,\nuint8_t * virt,\nuint64_t wsid,\nuint64_t io_address\n) </code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/shared_buffer.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/","title":"Class opae::fpga::types::src_location","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; src_location</p> <p>Identify a particular line in a source file. </p> <ul> <li><code>#include &lt;except.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#public-functions","title":"Public Functions","text":"Type Name const char * file () noexcept constRetrieve the file name component of the location. const char * fn () noexcept constRetrieve the function name component of the location. int line () noexcept constRetrieve the line number component of the location. src_location &amp; operator= (const src_location &amp; other) noexcept src_location (const char * file, const char * fn, int line) noexceptsrc_location constructor src_location (const src_location &amp; other) noexcept"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#function-file","title":"function file","text":"<pre><code>const char * opae::fpga::types::src_location::file () noexcept const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#function-fn","title":"function fn","text":"<pre><code>inline const char * opae::fpga::types::src_location::fn () noexcept const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#function-line","title":"function line","text":"<pre><code>inline int opae::fpga::types::src_location::line () noexcept const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#function-operator","title":"function operator=","text":"<pre><code>src_location &amp; opae::fpga::types::src_location::operator= (\nconst src_location &amp; other\n) noexcept\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#function-src_location-12","title":"function src_location [\u00bd]","text":"<p>src_location constructor <pre><code>opae::fpga::types::src_location::src_location (\nconst char * file,\nconst char * fn,\nint line\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>file</code> The source file name, typically FILE. </li> <li><code>fn</code> The current function, typically func. </li> <li><code>line</code> The current line number, typically LINE. </li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1src__location/#function-src_location-22","title":"function src_location [2/2]","text":"<pre><code>opae::fpga::types::src_location::src_location (\nconst src_location &amp; other\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/","title":"Class opae::fpga::types::sysobject","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; sysobject</p> <p>Wraps the OPAE fpga_object primitive. More...</p> <ul> <li><code>#include &lt;sysobject.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; sysobject &gt; ptr_t"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; uint8_t &gt; bytes (int flags=0) constGet all raw bytes from the object. std::vector&lt; uint8_t &gt; bytes (uint32_t offset, uint32_t size, int flags=0) constGet a subset of raw bytes from the object. fpga_object c_type () constRetrieve the underlying fpga_object primitive. sysobject::ptr_t get (const std::string &amp; name, int flags=0) Get a sysobject from an object. sysobject::ptr_t get (int index) Get a sysobject from a container object. operator fpga_object () constRetrieve the underlying fpga_object primitive. sysobject &amp; operator= (const sysobject &amp; o) = delete uint64_t read64 (int flags=0) constRead a 64-bit value from an FPGA object. uint32_t size () constGet the size (in bytes) of the object. sysobject () = delete sysobject (const sysobject &amp; o) = delete enum fpga_sysobject_type type () constGet the object type (attribute or container) void write64 (uint64_t value, int flags=0) constWrite 64-bit value to an FPGA object. virtual ~sysobject ()"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#public-static-functions","title":"Public Static Functions","text":"Type Name sysobject::ptr_t get (token::ptr_t t, const std::string &amp; name, int flags=0) Get a sysobject from a token. sysobject::ptr_t get (handle::ptr_t h, const std::string &amp; name, int flags=0) Get a sysobject from a handle."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#detailed-description","title":"Detailed Description","text":"<p>sysobject's are created from a call to fpgaTokenGetObject, fpgaHandleGetObject, or fpgaObjectGetObject </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#typedef-ptr_t","title":"typedef ptr_t","text":"<pre><code>typedef std::shared_ptr&lt;sysobject&gt; opae::fpga::types::sysobject::ptr_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-bytes-12","title":"function bytes [\u00bd]","text":"<p>Get all raw bytes from the object. <pre><code>std::vector&lt; uint8_t &gt; opae::fpga::types::sysobject::bytes (\nint flags=0\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>flags</code> Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.</li> </ul> <p>Returns:</p> <p>A vector of all bytes in the object. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-bytes-22","title":"function bytes [2/2]","text":"<p>Get a subset of raw bytes from the object. <pre><code>std::vector&lt; uint8_t &gt; opae::fpga::types::sysobject::bytes (\nuint32_t offset,\nuint32_t size,\nint flags=0\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>offset</code> The bytes offset for the start of the returned vector. </li> <li><code>size</code> The number of bytes for the returned vector. </li> <li><code>flags</code> Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.</li> </ul> <p>Returns:</p> <p>A vector of size bytes in the object starting at offset. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-c_type","title":"function c_type","text":"<pre><code>inline fpga_object opae::fpga::types::sysobject::c_type () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-get-14","title":"function get [\u00bc]","text":"<p>Get a sysobject from an object. <pre><code>sysobject::ptr_t opae::fpga::types::sysobject::get (\nconst std::string &amp; name,\nint flags=0\n) </code></pre></p> <p>This will be read-write if its parent was created from a handle..</p> <p>Parameters:</p> <ul> <li><code>name</code> An identifier representing an object belonging to this object. </li> <li><code>flags</code> Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects. Flags are defaulted to 0 meaning no flags.</li> </ul> <p>Returns:</p> <p>A shared_ptr to a sysobject instance. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-get-24","title":"function get [2/4]","text":"<p>Get a sysobject from a container object. <pre><code>sysobject::ptr_t opae::fpga::types::sysobject::get (\nint index\n) </code></pre></p> <p>This will be read-write if its parent was created from a handle..</p> <p>Parameters:</p> <ul> <li><code>index</code> An index number to get.</li> </ul> <p>Returns:</p> <p>A shared_ptr to a sysobject instance. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-operator-fpga_object","title":"function operator fpga_object","text":"<pre><code>inline opae::fpga::types::sysobject::operator fpga_object () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-operator","title":"function operator=","text":"<pre><code>sysobject &amp; opae::fpga::types::sysobject::operator= (\nconst sysobject &amp; o\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-read64","title":"function read64","text":"<p>Read a 64-bit value from an FPGA object. <pre><code>uint64_t opae::fpga::types::sysobject::read64 (\nint flags=0\n) const\n</code></pre></p> <p>The value is assumed to be in string format and will be parsed. See flags below for changing that behavior.</p> <p>Parameters:</p> <ul> <li><code>flags</code> Flags that control how the object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data. If FPGA_OBJECT_RAW is used, then the data will be read as raw bytes into the uint64_t pointer variable. Flags are defaulted to 0 meaning no flags.</li> </ul> <p>Returns:</p> <p>A 64-bit value from the object. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-size","title":"function size","text":"<p>Get the size (in bytes) of the object. <pre><code>uint32_t opae::fpga::types::sysobject::size () const\n</code></pre></p> <p>Returns:</p> <p>The number of bytes that the object occupies in memory. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-sysobject-13","title":"function sysobject [\u2153]","text":"<pre><code>opae::fpga::types::sysobject::sysobject () = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-sysobject-23","title":"function sysobject [\u2154]","text":"<pre><code>opae::fpga::types::sysobject::sysobject (\nconst sysobject &amp; o\n) = delete\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-type","title":"function type","text":"<pre><code>enum fpga_sysobject_type opae::fpga::types::sysobject::type () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-write64","title":"function write64","text":"<p>Write 64-bit value to an FPGA object. <pre><code>void opae::fpga::types::sysobject::write64 (\nuint64_t value,\nint flags=0\n) const\n</code></pre></p> <p>The value will be converted to string before writing. See flags below for changing that behavior.</p> <p>Parameters:</p> <ul> <li><code>value</code> The value to write to the object. </li> <li><code>flags</code> Flags that control how the object is written If FPGA_OBJECT_RAW is used, then the value will be written as raw bytes. Flags are defaulted to 0 meaning no flags.</li> </ul> <p>Note:</p> <p>This operation will force a sync operation to update its cached buffer </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-sysobject","title":"function ~sysobject","text":"<pre><code>virtual opae::fpga::types::sysobject::~sysobject () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-get-34","title":"function get [\u00be]","text":"<p>Get a sysobject from a token. <pre><code>static sysobject::ptr_t opae::fpga::types::sysobject::get (\ntoken::ptr_t t,\nconst std::string &amp; name,\nint flags=0\n) </code></pre></p> <p>This will be read-only.</p> <p>Parameters:</p> <ul> <li><code>t</code> Token object representing a resource. </li> <li><code>name</code> An identifier representing an object belonging to a resource represented by the token. </li> <li><code>flags</code> Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.</li> </ul> <p>Returns:</p> <p>A shared_ptr to a sysobject instance. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1sysobject/#function-get-44","title":"function get [4/4]","text":"<p>Get a sysobject from a handle. <pre><code>static sysobject::ptr_t opae::fpga::types::sysobject::get (\nhandle::ptr_t h,\nconst std::string &amp; name,\nint flags=0\n) </code></pre></p> <p>This will be read-write.</p> <p>Parameters:</p> <ul> <li><code>h</code> Handle object representing an open resource. </li> <li><code>name</code> An identifier representing an object belonging to a resource represented by the handle. </li> <li><code>flags</code> Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.</li> </ul> <p>Returns:</p> <p>A shared_ptr to a sysobject instance. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/sysobject.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/","title":"Class opae::fpga::types::token","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; token</p> <p>Wraps the OPAE fpga_token primitive. More...</p> <ul> <li><code>#include &lt;token.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#public-types","title":"Public Types","text":"Type Name typedef std::shared_ptr&lt; token &gt; ptr_t"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#public-functions","title":"Public Functions","text":"Type Name fpga_token c_type () constRetrieve the underlying fpga_token primitive. ptr_t get_parent () constRetrieve the parent token, or an empty pointer if there is none. operator fpga_token () constRetrieve the underlying fpga_token primitive. ~token ()"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#public-static-functions","title":"Public Static Functions","text":"Type Name std::vector&lt; token::ptr_t &gt; enumerate (const std::vector&lt; properties::ptr_t &gt; &amp; props) Obtain a vector of token smart pointers for given search criteria."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#detailed-description","title":"Detailed Description","text":"<p>token's are created from an enumeration operation that uses properties describing an accelerator resource as search criteria. </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#typedef-ptr_t","title":"typedef ptr_t","text":"<pre><code>typedef std::shared_ptr&lt;token&gt; opae::fpga::types::token::ptr_t;\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#function-c_type","title":"function c_type","text":"<pre><code>inline fpga_token opae::fpga::types::token::c_type () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#function-get_parent","title":"function get_parent","text":"<pre><code>ptr_t opae::fpga::types::token::get_parent () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#function-operator-fpga_token","title":"function operator fpga_token","text":"<pre><code>inline opae::fpga::types::token::operator fpga_token () const\n</code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#function-token","title":"function ~token","text":"<pre><code>opae::fpga::types::token::~token () </code></pre>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1token/#function-enumerate","title":"function enumerate","text":"<p>Obtain a vector of token smart pointers for given search criteria. <pre><code>static std::vector&lt; token::ptr_t &gt; opae::fpga::types::token::enumerate (\nconst std::vector&lt; properties::ptr_t &gt; &amp; props\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>props</code> The search criteria. </li> </ul> <p>Returns:</p> <p>A set of known tokens that match the search. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/token.h</code></p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1version/","title":"Class opae::fpga::types::version","text":"<p>ClassList &gt; opae &gt; fpga &gt; types &gt; version</p> <ul> <li><code>#include &lt;version.h&gt;</code></li> </ul>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1version/#public-static-functions","title":"Public Static Functions","text":"Type Name std::string as_string () Get the package version information as a string. fpga_version as_struct () Get the package version information as a struct. std::string build () Get the package build information as a string."},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1version/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1version/#function-as_string","title":"function as_string","text":"<p>Get the package version information as a string. <pre><code>static std::string opae::fpga::types::version::as_string () </code></pre></p> <p>Returns:</p> <p>The package version as an <code>std::string</code> object </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1version/#function-as_struct","title":"function as_struct","text":"<p>Get the package version information as a struct. <pre><code>static fpga_version opae::fpga::types::version::as_struct () </code></pre></p> <p>Returns:</p> <p>The package version as an <code>fpga_version</code> struct </p>"},{"location":"opae-code/classopae_1_1fpga_1_1types_1_1version/#function-build","title":"function build","text":"<p>Get the package build information as a string. <pre><code>static std::string opae::fpga::types::version::build () </code></pre></p> <p>Returns:</p> <p>The package build as an <code>std::string</code> object </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/version.h</code></p>"},{"location":"opae-code/structopae__uio/","title":"Struct opae_uio","text":"<p>ClassList &gt; opae_uio</p> <p>OPAE UIO device abstraction. More...</p> <ul> <li><code>#include &lt;uio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__uio/#public-attributes","title":"Public Attributes","text":"Type Name int device_fd char device_path struct opae_uio_device_region * regions"},{"location":"opae-code/structopae__uio/#detailed-description","title":"Detailed Description","text":"<p>This structure is used to interact with the OPAE UIO API. Each UIO device has a file descriptor that is used to mmap its regions into user address space. Each device also has one or more MMIO regions. </p>"},{"location":"opae-code/structopae__uio/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__uio/#variable-device_fd","title":"variable device_fd","text":"<pre><code>int opae_uio::device_fd;\n</code></pre>"},{"location":"opae-code/structopae__uio/#variable-device_path","title":"variable device_path","text":"<pre><code>char opae_uio::device_path[OPAE_UIO_PATH_MAX];\n</code></pre>"},{"location":"opae-code/structopae__uio/#variable-regions","title":"variable regions","text":"<pre><code>struct opae_uio_device_region* opae_uio::regions;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/uio.h</code></p>"},{"location":"opae-code/structopae__uio__device__region/","title":"Struct opae_uio_device_region","text":"<p>ClassList &gt; opae_uio_device_region</p> <p>MMIO region info. More...</p> <ul> <li><code>#include &lt;uio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__uio__device__region/#public-attributes","title":"Public Attributes","text":"Type Name struct opae_uio_device_region * next uint32_t region_index size_t region_page_offset uint8_t * region_ptr size_t region_size"},{"location":"opae-code/structopae__uio__device__region/#detailed-description","title":"Detailed Description","text":"<p>Describes a range of mappable MMIO. </p>"},{"location":"opae-code/structopae__uio__device__region/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__uio__device__region/#variable-next","title":"variable next","text":"<pre><code>struct opae_uio_device_region* opae_uio_device_region::next;\n</code></pre>"},{"location":"opae-code/structopae__uio__device__region/#variable-region_index","title":"variable region_index","text":"<pre><code>uint32_t opae_uio_device_region::region_index;\n</code></pre>"},{"location":"opae-code/structopae__uio__device__region/#variable-region_page_offset","title":"variable region_page_offset","text":"<pre><code>size_t opae_uio_device_region::region_page_offset;\n</code></pre>"},{"location":"opae-code/structopae__uio__device__region/#variable-region_ptr","title":"variable region_ptr","text":"<pre><code>uint8_t* opae_uio_device_region::region_ptr;\n</code></pre>"},{"location":"opae-code/structopae__uio__device__region/#variable-region_size","title":"variable region_size","text":"<pre><code>size_t opae_uio_device_region::region_size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/uio.h</code></p>"},{"location":"opae-code/structopae__vfio/","title":"Struct opae_vfio","text":"<p>ClassList &gt; opae_vfio</p> <p>OPAE VFIO device abstraction. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio/#public-attributes","title":"Public Attributes","text":"Type Name opae_hash_map cont_buffers Map of allocated DMA buffers. char * cont_device \"/dev/vfio/vfio\" int cont_fd Container file descriptor. char * cont_pciaddr PCIe address, eg 0000:00:00.0. struct opae_vfio_iova_range * cont_ranges List of IOVA ranges. struct opae_vfio_device device The VFIO device. struct opae_vfio_group group The VFIO device group. struct mem_alloc iova_alloc Allocator for IOVA space. pthread_mutex_t lock For thread safety."},{"location":"opae-code/structopae__vfio/#detailed-description","title":"Detailed Description","text":"<p>This structure is used to interact with the OPAE VFIO API. It tracks data related to the VFIO container, group, and device. A mutex is provided for thread safety. </p>"},{"location":"opae-code/structopae__vfio/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio/#variable-cont_buffers","title":"variable cont_buffers","text":"<pre><code>opae_hash_map opae_vfio::cont_buffers;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-cont_device","title":"variable cont_device","text":"<pre><code>char* opae_vfio::cont_device;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-cont_fd","title":"variable cont_fd","text":"<pre><code>int opae_vfio::cont_fd;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-cont_pciaddr","title":"variable cont_pciaddr","text":"<pre><code>char* opae_vfio::cont_pciaddr;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-cont_ranges","title":"variable cont_ranges","text":"<pre><code>struct opae_vfio_iova_range* opae_vfio::cont_ranges;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-device","title":"variable device","text":"<pre><code>struct opae_vfio_device opae_vfio::device;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-group","title":"variable group","text":"<pre><code>struct opae_vfio_group opae_vfio::group;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-iova_alloc","title":"variable iova_alloc","text":"<pre><code>struct mem_alloc opae_vfio::iova_alloc;\n</code></pre>"},{"location":"opae-code/structopae__vfio/#variable-lock","title":"variable lock","text":"<pre><code>pthread_mutex_t opae_vfio::lock;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structopae__vfio__buffer/","title":"Struct opae_vfio_buffer","text":"<p>ClassList &gt; opae_vfio_buffer</p> <p>System DMA buffer. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio__buffer/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t buffer_iova Buffer IOVA address. uint8_t * buffer_ptr Buffer virtual address. size_t buffer_size Buffer size. int flags See opae_vfio_buffer_flags."},{"location":"opae-code/structopae__vfio__buffer/#detailed-description","title":"Detailed Description","text":"<p>Describes a system memory address space that is capable of DMA. </p>"},{"location":"opae-code/structopae__vfio__buffer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio__buffer/#variable-buffer_iova","title":"variable buffer_iova","text":"<pre><code>uint64_t opae_vfio_buffer::buffer_iova;\n</code></pre>"},{"location":"opae-code/structopae__vfio__buffer/#variable-buffer_ptr","title":"variable buffer_ptr","text":"<pre><code>uint8_t* opae_vfio_buffer::buffer_ptr;\n</code></pre>"},{"location":"opae-code/structopae__vfio__buffer/#variable-buffer_size","title":"variable buffer_size","text":"<pre><code>size_t opae_vfio_buffer::buffer_size;\n</code></pre>"},{"location":"opae-code/structopae__vfio__buffer/#variable-flags","title":"variable flags","text":"<pre><code>int opae_vfio_buffer::flags;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structopae__vfio__device/","title":"Struct opae_vfio_device","text":"<p>ClassList &gt; opae_vfio_device</p> <p>VFIO device. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio__device/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t device_config_offset Offset of PCIe config space. int device_fd Device file descriptor. uint32_t device_num_irqs IRQ index count. uint32_t device_num_regions Total MMIO region count. struct opae_vfio_device_irq * irqs IRQ list pointer. struct opae_vfio_device_region * regions Region list pointer."},{"location":"opae-code/structopae__vfio__device/#detailed-description","title":"Detailed Description","text":"<p>Each VFIO device has a file descriptor that is used to query information about the device MMIO regions and config space. </p>"},{"location":"opae-code/structopae__vfio__device/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio__device/#variable-device_config_offset","title":"variable device_config_offset","text":"<pre><code>uint64_t opae_vfio_device::device_config_offset;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device/#variable-device_fd","title":"variable device_fd","text":"<pre><code>int opae_vfio_device::device_fd;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device/#variable-device_num_irqs","title":"variable device_num_irqs","text":"<pre><code>uint32_t opae_vfio_device::device_num_irqs;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device/#variable-device_num_regions","title":"variable device_num_regions","text":"<pre><code>uint32_t opae_vfio_device::device_num_regions;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device/#variable-irqs","title":"variable irqs","text":"<pre><code>struct opae_vfio_device_irq* opae_vfio_device::irqs;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device/#variable-regions","title":"variable regions","text":"<pre><code>struct opae_vfio_device_region* opae_vfio_device::regions;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structopae__vfio__device__irq/","title":"Struct opae_vfio_device_irq","text":"<p>ClassList &gt; opae_vfio_device_irq</p> <p>Interrupt info. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio__device__irq/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t count Number of IRQs at this index. int32_t * event_fds Event file descriptors. uint32_t flags Flags. uint32_t index The IRQ index. int32_t * masks IRQ masks. struct opae_vfio_device_irq * next Pointer to next in list."},{"location":"opae-code/structopae__vfio__device__irq/#detailed-description","title":"Detailed Description","text":"<p>Describes an interrupt capability. </p>"},{"location":"opae-code/structopae__vfio__device__irq/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio__device__irq/#variable-count","title":"variable count","text":"<pre><code>uint32_t opae_vfio_device_irq::count;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__irq/#variable-event_fds","title":"variable event_fds","text":"<pre><code>int32_t* opae_vfio_device_irq::event_fds;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__irq/#variable-flags","title":"variable flags","text":"<p>Flags. <pre><code>uint32_t opae_vfio_device_irq::flags;\n</code></pre></p> <p>See struct vfio_irq_info. </p>"},{"location":"opae-code/structopae__vfio__device__irq/#variable-index","title":"variable index","text":"<pre><code>uint32_t opae_vfio_device_irq::index;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__irq/#variable-masks","title":"variable masks","text":"<pre><code>int32_t* opae_vfio_device_irq::masks;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__irq/#variable-next","title":"variable next","text":"<pre><code>struct opae_vfio_device_irq* opae_vfio_device_irq::next;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structopae__vfio__device__region/","title":"Struct opae_vfio_device_region","text":"<p>ClassList &gt; opae_vfio_device_region</p> <p>MMIO region info. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio__device__region/#public-attributes","title":"Public Attributes","text":"Type Name struct opae_vfio_device_region * next Pointer to next in list. uint32_t region_index Region index, from 0. uint8_t * region_ptr Virtual address of region. size_t region_size Size of region. struct opae_vfio_sparse_info * region_sparse For sparse regions."},{"location":"opae-code/structopae__vfio__device__region/#detailed-description","title":"Detailed Description","text":"<p>Describes a range of mappable MMIO. </p>"},{"location":"opae-code/structopae__vfio__device__region/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio__device__region/#variable-next","title":"variable next","text":"<pre><code>struct opae_vfio_device_region* opae_vfio_device_region::next;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__region/#variable-region_index","title":"variable region_index","text":"<pre><code>uint32_t opae_vfio_device_region::region_index;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__region/#variable-region_ptr","title":"variable region_ptr","text":"<pre><code>uint8_t* opae_vfio_device_region::region_ptr;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__region/#variable-region_size","title":"variable region_size","text":"<pre><code>size_t opae_vfio_device_region::region_size;\n</code></pre>"},{"location":"opae-code/structopae__vfio__device__region/#variable-region_sparse","title":"variable region_sparse","text":"<pre><code>struct opae_vfio_sparse_info* opae_vfio_device_region::region_sparse;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structopae__vfio__group/","title":"Struct opae_vfio_group","text":"<p>ClassList &gt; opae_vfio_group</p> <p>VFIO group. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio__group/#public-attributes","title":"Public Attributes","text":"Type Name char * group_device Full path to the group device. int group_fd File descriptor for the group device."},{"location":"opae-code/structopae__vfio__group/#detailed-description","title":"Detailed Description","text":"<p>Each device managed by vfio-pci belongs to a VFIO group rooted at /dev/vfio/N, where N is the group number. </p>"},{"location":"opae-code/structopae__vfio__group/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio__group/#variable-group_device","title":"variable group_device","text":"<pre><code>char* opae_vfio_group::group_device;\n</code></pre>"},{"location":"opae-code/structopae__vfio__group/#variable-group_fd","title":"variable group_fd","text":"<pre><code>int opae_vfio_group::group_fd;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structopae__vfio__iova__range/","title":"Struct opae_vfio_iova_range","text":"<p>ClassList &gt; opae_vfio_iova_range</p> <p>IO Virtual Address Range. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio__iova__range/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t end End of this range of offsets. struct opae_vfio_iova_range * next Pointer to next in list. uint64_t start Start of this range of offsets."},{"location":"opae-code/structopae__vfio__iova__range/#detailed-description","title":"Detailed Description","text":"<p>A range of allocatable IOVA offsets. Used for mapping DMA buffers. </p>"},{"location":"opae-code/structopae__vfio__iova__range/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio__iova__range/#variable-end","title":"variable end","text":"<pre><code>uint64_t opae_vfio_iova_range::end;\n</code></pre>"},{"location":"opae-code/structopae__vfio__iova__range/#variable-next","title":"variable next","text":"<pre><code>struct opae_vfio_iova_range* opae_vfio_iova_range::next;\n</code></pre>"},{"location":"opae-code/structopae__vfio__iova__range/#variable-start","title":"variable start","text":"<pre><code>uint64_t opae_vfio_iova_range::start;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structopae__vfio__sparse__info/","title":"Struct opae_vfio_sparse_info","text":"<p>ClassList &gt; opae_vfio_sparse_info</p> <p>MMIO sparse-mappable region info. More...</p> <ul> <li><code>#include &lt;vfio.h&gt;</code></li> </ul>"},{"location":"opae-code/structopae__vfio__sparse__info/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t index Region index, from 0. struct opae_vfio_sparse_info * next Pointer to next in list. uint32_t offset Offset of sparse region. uint8_t * ptr Virtual address of sparse region. uint32_t size Size of sparse region."},{"location":"opae-code/structopae__vfio__sparse__info/#detailed-description","title":"Detailed Description","text":"<p>Describes a range of sparse-mappable MMIO, for MMIO ranges that have non-contiguous addresses. </p>"},{"location":"opae-code/structopae__vfio__sparse__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structopae__vfio__sparse__info/#variable-index","title":"variable index","text":"<pre><code>uint32_t opae_vfio_sparse_info::index;\n</code></pre>"},{"location":"opae-code/structopae__vfio__sparse__info/#variable-next","title":"variable next","text":"<pre><code>struct opae_vfio_sparse_info* opae_vfio_sparse_info::next;\n</code></pre>"},{"location":"opae-code/structopae__vfio__sparse__info/#variable-offset","title":"variable offset","text":"<pre><code>uint32_t opae_vfio_sparse_info::offset;\n</code></pre>"},{"location":"opae-code/structopae__vfio__sparse__info/#variable-ptr","title":"variable ptr","text":"<pre><code>uint8_t* opae_vfio_sparse_info::ptr;\n</code></pre>"},{"location":"opae-code/structopae__vfio__sparse__info/#variable-size","title":"variable size","text":"<pre><code>uint32_t opae_vfio_sparse_info::size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/structras__inject__error/","title":"Struct ras_inject_error","text":"<p>ClassList &gt; ras_inject_error</p>"},{"location":"opae-code/structras__inject__error/#public-attributes","title":"Public Attributes","text":"Type Name union ras_inject_error::@0 @1 uint64_t catastrophicr_error uint64_t csr uint64_t fatal_error uint64_t nonfatal_error uint64_t rsvd"},{"location":"opae-code/structras__inject__error/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structras__inject__error/#variable-1","title":"variable @1","text":"<pre><code>union ras_inject_error::@0 ras_inject_error::@1;\n</code></pre>"},{"location":"opae-code/structras__inject__error/#variable-catastrophicr_error","title":"variable catastrophicr_error","text":"<pre><code>uint64_t ras_inject_error::catastrophicr_error;\n</code></pre>"},{"location":"opae-code/structras__inject__error/#variable-csr","title":"variable csr","text":"<pre><code>uint64_t ras_inject_error::csr;\n</code></pre>"},{"location":"opae-code/structras__inject__error/#variable-fatal_error","title":"variable fatal_error","text":"<pre><code>uint64_t ras_inject_error::fatal_error;\n</code></pre>"},{"location":"opae-code/structras__inject__error/#variable-nonfatal_error","title":"variable nonfatal_error","text":"<pre><code>uint64_t ras_inject_error::nonfatal_error;\n</code></pre>"},{"location":"opae-code/structras__inject__error/#variable-rsvd","title":"variable rsvd","text":"<pre><code>uint64_t ras_inject_error::rsvd;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/samples/hello_events/hello_events.c</code></p>"},{"location":"opae-code/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"opae-code/structthreshold/","title":"Struct threshold","text":"<p>ClassList &gt; threshold</p> <p>Threshold struct. </p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"opae-code/structthreshold/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t is_valid char threshold_name double value"},{"location":"opae-code/structthreshold/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/structthreshold/#variable-is_valid","title":"variable is_valid","text":"<pre><code>uint32_t threshold::is_valid;\n</code></pre>"},{"location":"opae-code/structthreshold/#variable-threshold_name","title":"variable threshold_name","text":"<pre><code>char threshold::threshold_name[FPGA_METRIC_STR_SIZE];\n</code></pre>"},{"location":"opae-code/structthreshold/#variable-value","title":"variable value","text":"<pre><code>double threshold::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/dir_49e56c817e5e54854c35e136979f97ca/","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"opae-code/dir_49e56c817e5e54854c35e136979f97ca/#directories","title":"Directories","text":"Type Name dir sw <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"opae-code/dir_55721a669a8e0900d975c02921addb49/","title":"Dir docs/sw","text":"<p>FileList &gt; docs &gt; sw</p>"},{"location":"opae-code/dir_55721a669a8e0900d975c02921addb49/#directories","title":"Directories","text":"Type Name dir include dir samples <p>The documentation for this class was generated from the following file <code>docs/sw/</code></p>"},{"location":"opae-code/dir_97b4588afba69bf89bbe554642ac6431/","title":"Dir docs/sw/include","text":"<p>FileList &gt; docs &gt; sw &gt; include</p>"},{"location":"opae-code/dir_97b4588afba69bf89bbe554642ac6431/#directories","title":"Directories","text":"Type Name dir opae <p>The documentation for this class was generated from the following file <code>docs/sw/include/</code></p>"},{"location":"opae-code/dir_ade97cd9199f278c0723672dd8647ba4/","title":"Dir docs/sw/include/opae","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae</p>"},{"location":"opae-code/dir_ade97cd9199f278c0723672dd8647ba4/#files","title":"Files","text":"Type Name file access.h Functions to acquire, release, and reset OPAE FPGA resources. file buffer.h Functions for allocating and sharing system memory with an FPGA accelerator. file enum.h APIs for resource enumeration and managing tokens. file error.h Functions for reading and clearing errors in resources. file event.h Functions for registering events and managing the lifecycle for <code>fpga_event_handle</code> s. file fpga.h FPGA API. file hash_map.h A general-purpose hybrid array/list hash map implementation. file init.h Initialization routine. file log.h file manage.h Functions for managing FPGA configurations. file mem_alloc.h file metrics.h Functions for Discover/ Enumerates metrics and retrieves values. file mmio.h Functions for mapping and accessing MMIO space. file properties.h Functions for examining and manipulating <code>fpga_properties</code> objects. file sysobject.h Functions to read/write from system objects. file types.h Type definitions for FPGA API. file types_enum.h Definitions of enumerated types for the OPAE C API. file uio.h APIs to manage a PCIe device via UIO. file umsg.h FPGA UMsg API. file userclk.h Functions for setting and get afu user clock. file utils.h Utility functions and macros for the FPGA API. file version.h file vfio.h APIs to manage a PCIe device via vfio-pci."},{"location":"opae-code/dir_ade97cd9199f278c0723672dd8647ba4/#directories","title":"Directories","text":"Type Name dir cxx <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/</code></p>"},{"location":"opae-code/access_8h/","title":"File access.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; access.h</p> <p>Go to the source code of this file.</p> <p>Functions to acquire, release, and reset OPAE FPGA resources. </p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/access_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaClose (fpga_handle handle) Close a previously opened FPGA object. fpga_result fpgaOpen (fpga_token token, fpga_handle * handle, int flags) Open an FPGA object. fpga_result fpgaReset (fpga_handle handle) Reset an FPGA object."},{"location":"opae-code/access_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/access_8h/#function-fpgaclose","title":"function fpgaClose","text":"<p>Close a previously opened FPGA object. <pre><code>fpga_result fpgaClose (\nfpga_handle handle\n) </code></pre></p> <p>Relinquishes ownership of a previously fpgaOpen()ed resource. This enables others to acquire ownership if the resource was opened exclusively. Also deallocates / unmaps MMIO and UMsg memory areas.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened FPGA object </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to an acquired resource, or if handle is NULL. FPGA_EXCEPTION if an internal error occurred while accessing the handle. </p>"},{"location":"opae-code/access_8h/#function-fpgaopen","title":"function fpgaOpen","text":"<p>Open an FPGA object. <pre><code>fpga_result fpgaOpen (\nfpga_token token,\nfpga_handle * handle,\nint flags\n) </code></pre></p> <p>Acquires ownership of the FPGA resource referred to by 'token'.</p> <p>Most often this will be used to open an accelerator object to directly interact with an accelerator function, or to open an FPGA object to perform management functions.</p> <p>Parameters:</p> <ul> <li><code>token</code> Pointer to token identifying resource to acquire ownership of </li> <li><code>handle</code> Pointer to preallocated memory to place a handle in. This handle will be used in subsequent API calls. </li> <li><code>flags</code> One of the following flags:<ul> <li>FPGA_OPEN_SHARED allows the resource to be opened multiple times (not supported in ASE) Shared resources (including buffers) are released when all associated handles have been closed (either explicitly with fpgaClose() or by process termination). </li> </ul> </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NOT_FOUND if the resource for 'token' could not be found. FPGA_INVALID_PARAM if 'token' does not refer to a resource that can be opened, or if either argument is NULL or invalid. FPGA_EXCEPTION if an internal exception occurred while creating the handle. FPGA_NO_DRIVER if the driver is not loaded. FPGA_BUSY if trying to open a resource that has already been opened in exclusive mode. FPGA_NO_ACCESS if the current process' privileges are not sufficient to open the resource. </p>"},{"location":"opae-code/access_8h/#function-fpgareset","title":"function fpgaReset","text":"<p>Reset an FPGA object. <pre><code>fpga_result fpgaReset (\nfpga_handle handle\n) </code></pre></p> <p>Performs an accelerator reset.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened FPGA object </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to an acquired resource or to a resource that cannot be reset. FPGA_EXCEPTION if an internal error occurred while trying to access the handle or resetting the resource. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/access.h</code></p>"},{"location":"opae-code/access_8h_source/","title":"File access.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; access.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_ACCESS_H__\n#define __FPGA_ACCESS_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaOpen(fpga_token token, fpga_handle *handle,\nint flags);\nfpga_result fpgaClose(fpga_handle handle);\nfpga_result fpgaReset(fpga_handle handle);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_ACCESS_H__\n</code></pre>"},{"location":"opae-code/buffer_8h/","title":"File buffer.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; buffer.h</p> <p>Go to the source code of this file.</p> <p>Functions for allocating and sharing system memory with an FPGA accelerator. More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/buffer_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaGetIOAddress (fpga_handle handle, uint64_t wsid, uint64_t * ioaddr) Retrieve base IO address for buffer. fpga_result fpgaPrepareBuffer (fpga_handle handle, uint64_t len, void ** buf_addr, uint64_t * wsid, int flags) Prepare a shared memory buffer. fpga_result fpgaReleaseBuffer (fpga_handle handle, uint64_t wsid) Release a shared memory buffer."},{"location":"opae-code/buffer_8h/#detailed-description","title":"Detailed Description","text":"<p>To share memory between a software application and an FPGA accelerator, these functions set up system components (e.g. an IOMMU) to allow accelerator access to a provided memory region.</p> <p>There are a number of restrictions on what memory can be shared, depending on platform capabilities. Usually, FPGA accelerators to not have access to virtual address mappings of the CPU, so they can only access physical addresses. To support this, the OPAE C library on Linux uses hugepages to allocate large, contiguous pages of physical memory that can be shared with an accelerator. It also supports sharing memory that has already been allocated by an application, as long as that memory satisfies the requirements of being physically contigous and page-aligned. </p>"},{"location":"opae-code/buffer_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/buffer_8h/#function-fpgagetioaddress","title":"function fpgaGetIOAddress","text":"<p>Retrieve base IO address for buffer. <pre><code>fpga_result fpgaGetIOAddress (\nfpga_handle handle,\nuint64_t wsid,\nuint64_t * ioaddr\n) </code></pre></p> <p>This function is used to acquire the physical base address (on some platforms called IO Virtual Address or IOVA) for a shared buffer identified by wsid.</p> <p>Note:</p> <p>This function will disappear once the APIs for secure sharing of buffer addresses is implemented.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>wsid</code> Buffer handle / workspace ID referring to the buffer for which the IO address is requested </li> <li><code>ioaddr</code> Pointer to memory where the IO address will be returned </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. FPGA_NOT_FOUND if <code>wsid</code> does not refer to a previously shared buffer. </p>"},{"location":"opae-code/buffer_8h/#function-fpgapreparebuffer","title":"function fpgaPrepareBuffer","text":"<p>Prepare a shared memory buffer. <pre><code>fpga_result fpgaPrepareBuffer (\nfpga_handle handle,\nuint64_t len,\nvoid ** buf_addr,\nuint64_t * wsid,\nint flags\n) </code></pre></p> <p>Prepares a memory buffer for shared access between an accelerator and the calling process. This may either include allocation of physical memory, or preparation of already allocated memory for sharing. The latter case is indicated by supplying the FPGA_BUF_PREALLOCATED flag.</p> <p>This function will ask the driver to pin the indicated memory (make it non-swappable), and program the IOMMU to allow access from the accelerator. If the buffer was not pre-allocated (flag FPGA_BUF_PREALLOCATED), the function will also allocate physical memory of the requested size and map the memory into the caller's process' virtual address space. It returns in 'wsid' an fpga_buffer object that can be used to program address registers in the accelerator for shared access to the memory.</p> <p>When using FPGA_BUF_PREALLOCATED, the input len must be a non-zero multiple of the page size, else the function returns FPGA_INVALID_PARAM. When not using FPGA_BUF_PREALLOCATED, the input len is rounded up to the nearest multiple of page size.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>len</code> Length of the buffer to allocate/prepare in bytes </li> <li><code>buf_addr</code> Virtual address of buffer. Contents may be NULL (OS will choose mapping) or non-NULL (OS will take contents as a hint for the virtual address). </li> <li><code>wsid</code> Handle to the allocated/prepared buffer to be used with other functions </li> <li><code>flags</code> Flags. FPGA_BUF_PREALLOCATED indicates that memory pointed at in '*buf_addr' is already allocated an mapped into virtual memory. FPGA_BUF_READ_ONLY pins pages with only read access from the FPGA. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NO_MEMORY if the requested memory could not be allocated. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle.</p> <p>Note:</p> <p>As a special case, when FPGA_BUF_PREALLOCATED is present in flags, if len == 0 and buf_addr == NULL, then the function returns FPGA_OK if pre-allocated buffers are supported. In this case, a return value other than FPGA_OK indicates that pre-allocated buffers are not supported. </p>"},{"location":"opae-code/buffer_8h/#function-fpgareleasebuffer","title":"function fpgaReleaseBuffer","text":"<p>Release a shared memory buffer. <pre><code>fpga_result fpgaReleaseBuffer (\nfpga_handle handle,\nuint64_t wsid\n) </code></pre></p> <p>Releases a previously prepared shared buffer. If the buffer was allocated using fpgaPrepareBuffer (FPGA_BUF_PREALLOCATED was not specified), this call will deallocate/free that memory. Otherwise, it will only be returned to it's previous state (pinned/unpinned, cached/non-cached).</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>wsid</code> Handle to the allocated/prepared buffer </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/buffer.h</code></p>"},{"location":"opae-code/buffer_8h_source/","title":"File buffer.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; buffer.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_BUFFER_H__\n#define __FPGA_BUFFER_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaPrepareBuffer(fpga_handle handle,\nuint64_t len,\nvoid **buf_addr, uint64_t *wsid, int flags);\nfpga_result fpgaReleaseBuffer(fpga_handle handle, uint64_t wsid);\nfpga_result fpgaGetIOAddress(fpga_handle handle, uint64_t wsid,\nuint64_t *ioaddr);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_BUFFER_H__\n</code></pre>"},{"location":"opae-code/dir_3731a7e5669218b938d292e51b4e531c/","title":"Dir docs/sw/include/opae/cxx","text":"<p>FileList &gt; cxx</p>"},{"location":"opae-code/dir_3731a7e5669218b938d292e51b4e531c/#files","title":"Files","text":"Type Name file core.h"},{"location":"opae-code/dir_3731a7e5669218b938d292e51b4e531c/#directories","title":"Directories","text":"Type Name dir core <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/</code></p>"},{"location":"opae-code/core_8h/","title":"File core.h","text":"<p>FileList &gt; cxx &gt; core.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/cxx/core/errors.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/events.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/except.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/handle.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/properties.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/pvalue.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/shared_buffer.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/token.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/version.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core.h</code></p>"},{"location":"opae-code/core_8h_source/","title":"File core.h","text":"<p>File List &gt; cxx &gt; core.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2020, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/cxx/core/errors.h&gt;\n#include &lt;opae/cxx/core/events.h&gt;\n#include &lt;opae/cxx/core/except.h&gt;\n#include &lt;opae/cxx/core/handle.h&gt;\n#include &lt;opae/cxx/core/properties.h&gt;\n#include &lt;opae/cxx/core/pvalue.h&gt;\n#include &lt;opae/cxx/core/shared_buffer.h&gt;\n#include &lt;opae/cxx/core/token.h&gt;\n#include &lt;opae/cxx/core/version.h&gt;\n</code></pre>"},{"location":"opae-code/dir_23b1b9d7ef54caa3fa7bb54d9bc2d47a/","title":"Dir docs/sw/include/opae/cxx/core","text":"<p>FileList &gt; core</p>"},{"location":"opae-code/dir_23b1b9d7ef54caa3fa7bb54d9bc2d47a/#files","title":"Files","text":"Type Name file errors.h file events.h file except.h file handle.h file properties.h file pvalue.h file shared_buffer.h file sysobject.h file token.h file version.h <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/</code></p>"},{"location":"opae-code/errors_8h/","title":"File errors.h","text":"<p>FileList &gt; core &gt; errors.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/cxx/core/token.h&gt;</code></li> <li><code>#include &lt;opae/types_enum.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"opae-code/errors_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/errors_8h/#classes","title":"Classes","text":"Type Name class error An error object represents an error register for a resource. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/errors.h</code></p>"},{"location":"opae-code/errors_8h_source/","title":"File errors.h","text":"<p>File List &gt; core &gt; errors.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/cxx/core/token.h&gt;\n#include &lt;opae/types_enum.h&gt;\n#include &lt;memory&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass error {\npublic:\ntypedef std::shared_ptr&lt;error&gt; ptr_t;\nerror(const error &amp;e) = delete;\nerror &amp;operator=(const error &amp;e) = delete;\nstatic error::ptr_t get(token::ptr_t tok, uint32_t num);\nstd::string name() { return error_info_.name; }\nbool can_clear() { return error_info_.can_clear; }\nuint64_t read_value();\n~error() {}\nfpga_error_info c_type() const { return error_info_; }\nprivate:\nerror(token::ptr_t token, uint32_t num);\ntoken::ptr_t token_;\nfpga_error_info error_info_;\nuint32_t error_num_;\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/events_8h/","title":"File events.h","text":"<p>FileList &gt; core &gt; events.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/cxx/core/handle.h&gt;</code></li> <li><code>#include &lt;opae/types_enum.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"opae-code/events_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/events_8h/#classes","title":"Classes","text":"Type Name class event Wraps fpga event routines in OPAE C. struct type_t C++ struct that is interchangeable with fpga_event_type enum. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/events.h</code></p>"},{"location":"opae-code/events_8h_source/","title":"File events.h","text":"<p>File List &gt; core &gt; events.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/cxx/core/handle.h&gt;\n#include &lt;opae/types_enum.h&gt;\n#include &lt;memory&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass event {\npublic:\ntypedef std::shared_ptr&lt;event&gt; ptr_t;\nvirtual ~event();\nstruct type_t {\ntype_t(fpga_event_type c_type) : type_(c_type) {}\noperator fpga_event_type() { return type_; }\nstatic constexpr fpga_event_type interrupt = FPGA_EVENT_INTERRUPT;\nstatic constexpr fpga_event_type error = FPGA_EVENT_ERROR;\nstatic constexpr fpga_event_type power_thermal = FPGA_EVENT_POWER_THERMAL;\nprivate:\nfpga_event_type type_;\n};\nfpga_event_handle get() { return event_handle_; }\noperator fpga_event_handle();\nstatic event::ptr_t register_event(handle::ptr_t h, event::type_t t,\nint flags = 0);\nint os_object() const;\nprivate:\nevent(handle::ptr_t h, event::type_t t, fpga_event_handle event_h);\nhandle::ptr_t handle_;\nevent::type_t type_;\nfpga_event_handle event_handle_;\nint os_object_;\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/except_8h/","title":"File except.h","text":"<p>FileList &gt; core &gt; except.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/types_enum.h&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> </ul>"},{"location":"opae-code/except_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types namespace detail"},{"location":"opae-code/except_8h/#classes","title":"Classes","text":"Type Name class busy busy exception class except Generic OPAE exception. class exception exception exception class invalid_param invalid_param exception class no_access no_access exception class no_daemon no_daemon exception class no_driver no_driver exception class no_memory no_memory exception class not_found not_found exception class not_supported not_supported exception class reconf_error reconf_error exception class src_location Identify a particular line in a source file."},{"location":"opae-code/except_8h/#macros","title":"Macros","text":"Type Name define ASSERT_FPGA_OK \u00ae Macro to check of result is FPGA_OK If not, throw exception that corresponds to the result code. define OPAECXX_HERE opae::fpga::types::src_location(__FILE__, __func__, __LINE__)Construct a src_location object for the current source line."},{"location":"opae-code/except_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"opae-code/except_8h/#define-assert_fpga_ok","title":"define ASSERT_FPGA_OK","text":"<pre><code>#define ASSERT_FPGA_OK (\nr\n) opae::fpga::types::detail::assert_fpga_ok( \\\n      r, opae::fpga::types::src_location (__FILE__, __func__, __LINE__));\n</code></pre>"},{"location":"opae-code/except_8h/#define-opaecxx_here","title":"define OPAECXX_HERE","text":"<pre><code>#define OPAECXX_HERE opae::fpga::types::src_location (__FILE__, __func__, __LINE__)\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/except.h</code></p>"},{"location":"opae-code/except_8h_source/","title":"File except.h","text":"<p>File List &gt; core &gt; except.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/types_enum.h&gt;\n#include &lt;cstdint&gt;\n#include &lt;exception&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass src_location {\npublic:\nsrc_location(const char *file, const char *fn, int line) noexcept;\nsrc_location(const src_location &amp;other) noexcept;\nsrc_location &amp;operator=(const src_location &amp;other) noexcept;\nconst char *file() const noexcept;\nconst char *fn() const noexcept { return fn_; }\nint line() const noexcept { return line_; }\nprivate:\nconst char *file_;\nconst char *fn_;\nint line_;\n};\n#define OPAECXX_HERE \\\n  opae::fpga::types::src_location(__FILE__, __func__, __LINE__)\nclass except : public std::exception {\npublic:\nstatic const std::size_t MAX_EXCEPT = 256;\nexcept(src_location loc) noexcept;\nexcept(fpga_result res, src_location loc) noexcept;\nexcept(fpga_result res, const char *msg, src_location loc) noexcept;\nvirtual const char *what() const noexcept override;\noperator fpga_result() const noexcept { return res_; }\nprotected:\nfpga_result res_;\nconst char *msg_;\nsrc_location loc_;\nmutable char buf_[MAX_EXCEPT];\n};\nclass invalid_param : public except {\npublic:\ninvalid_param(src_location loc) noexcept\n: except(FPGA_INVALID_PARAM, \"failed with return code FPGA_INVALID_PARAM\",\nloc) {}\n};\nclass busy : public except {\npublic:\nbusy(src_location loc) noexcept\n: except(FPGA_BUSY, \"failed with return code FPGA_BUSY\", loc) {}\n};\nclass exception : public except {\npublic:\nexception(src_location loc) noexcept\n: except(FPGA_EXCEPTION, \"failed with return code FPGA_EXCEPTION\", loc) {}\n};\nclass not_found : public except {\npublic:\nnot_found(src_location loc) noexcept\n: except(FPGA_NOT_FOUND, \"failed with return code FPGA_NOT_FOUND\", loc) {}\n};\nclass no_memory : public except {\npublic:\nno_memory(src_location loc) noexcept\n: except(FPGA_NO_MEMORY, \"failed with return code FPGA_NO_MEMORY\", loc) {}\n};\nclass not_supported : public except {\npublic:\nnot_supported(src_location loc) noexcept\n: except(FPGA_NOT_SUPPORTED, \"failed with return code FPGA_NOT_SUPPORTED\",\nloc) {}\n};\nclass no_driver : public except {\npublic:\nno_driver(src_location loc) noexcept\n: except(FPGA_NO_DRIVER, \"failed with return code FPGA_NO_DRIVER\", loc) {}\n};\nclass no_daemon : public except {\npublic:\nno_daemon(src_location loc) noexcept\n: except(FPGA_NO_DAEMON, \"failed with return code FPGA_NO_DAEMON\", loc) {}\n};\nclass no_access : public except {\npublic:\nno_access(src_location loc) noexcept\n: except(FPGA_NO_ACCESS, \"failed with return code FPGA_NO_ACCESS\", loc) {}\n};\nclass reconf_error : public except {\npublic:\nreconf_error(src_location loc) noexcept\n: except(FPGA_RECONF_ERROR, \"failed with return code FPGA_RECONF_ERROR\",\nloc) {}\n};\nnamespace detail {\ntypedef bool (*exception_fn)(fpga_result,\nconst opae::fpga::types::src_location &amp;loc);\ntemplate &lt;typename T&gt;\nconstexpr bool is_ok(fpga_result result,\nconst opae::fpga::types::src_location &amp;loc) {\nreturn result == FPGA_OK ? true : throw T(loc);\n}\nstatic exception_fn opae_exceptions[12] = {\nis_ok&lt;opae::fpga::types::invalid_param&gt;,\nis_ok&lt;opae::fpga::types::busy&gt;,\nis_ok&lt;opae::fpga::types::exception&gt;,\nis_ok&lt;opae::fpga::types::not_found&gt;,\nis_ok&lt;opae::fpga::types::no_memory&gt;,\nis_ok&lt;opae::fpga::types::not_supported&gt;,\nis_ok&lt;opae::fpga::types::no_driver&gt;,\nis_ok&lt;opae::fpga::types::no_daemon&gt;,\nis_ok&lt;opae::fpga::types::no_access&gt;,\nis_ok&lt;opae::fpga::types::reconf_error&gt;};\nstatic inline void assert_fpga_ok(fpga_result result,\nconst opae::fpga::types::src_location &amp;loc) {\nif (result &gt; FPGA_OK &amp;&amp; result &lt;= FPGA_RECONF_ERROR)\n// our exception table above starts at invalid_param with index 0\n// but FPGA_INVALID_PARAM is actually enum 1 - let's account for that\nopae_exceptions[result - 1](result, loc);\n}\n}  // end of namespace detail\n#define ASSERT_FPGA_OK(r)                    \\\n  opae::fpga::types::detail::assert_fpga_ok( \\\n      r, opae::fpga::types::src_location(__FILE__, __func__, __LINE__));\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/handle_8h/","title":"File handle.h","text":"<p>FileList &gt; core &gt; handle.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/cxx/core/token.h&gt;</code></li> <li><code>#include &lt;opae/enum.h&gt;</code></li> <li><code>#include &lt;opae/types.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"opae-code/handle_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/handle_8h/#classes","title":"Classes","text":"Type Name class handle An allocated accelerator resource. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/handle.h</code></p>"},{"location":"opae-code/handle_8h_source/","title":"File handle.h","text":"<p>File List &gt; core &gt; handle.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018-2021, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/cxx/core/token.h&gt;\n#include &lt;opae/enum.h&gt;\n#include &lt;opae/types.h&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass handle {\npublic:\ntypedef std::shared_ptr&lt;handle&gt; ptr_t;\nhandle(const handle &amp;) = delete;\nhandle &amp;operator=(const handle &amp;) = delete;\nvirtual ~handle();\nfpga_handle c_type() const { return handle_; }\noperator fpga_handle() const { return handle_; }\nvoid reconfigure(uint32_t slot, const uint8_t *bitstream, size_t size,\nint flags);\nuint32_t read_csr32(uint64_t offset, uint32_t csr_space = 0) const;\nvoid write_csr32(uint64_t offset, uint32_t value, uint32_t csr_space = 0);\nuint64_t read_csr64(uint64_t offset, uint32_t csr_space = 0) const;\nvoid write_csr64(uint64_t offset, uint64_t value, uint32_t csr_space = 0);\nvoid write_csr512(uint64_t offset, const void *value, uint32_t csr_space = 0);\nuint8_t *mmio_ptr(uint64_t offset, uint32_t csr_space = 0) const;\nstatic handle::ptr_t open(fpga_token token, int flags);\nstatic handle::ptr_t open(token::ptr_t token, int flags);\nvirtual void reset();\nfpga_result close();\ntoken::ptr_t get_token() const;\nprivate:\nhandle(fpga_handle h);\nfpga_handle handle_;\nfpga_token token_;\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/cxx_2core_2properties_8h/","title":"File properties.h","text":"<p>FileList &gt; core &gt; properties.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/cxx/core/pvalue.h&gt;</code></li> <li><code>#include &lt;opae/properties.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"opae-code/cxx_2core_2properties_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/cxx_2core_2properties_8h/#classes","title":"Classes","text":"Type Name class properties Wraps an OPAE fpga_properties object. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/properties.h</code></p>"},{"location":"opae-code/cxx_2core_2properties_8h_source/","title":"File properties.h","text":"<p>File List &gt; core &gt; properties.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018-2022, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/cxx/core/pvalue.h&gt;\n#include &lt;opae/properties.h&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass token;\nclass handle;\nclass properties {\npublic:\ntypedef std::shared_ptr&lt;properties&gt; ptr_t;\nconst static std::vector&lt;properties::ptr_t&gt; none;\nproperties(const properties &amp;p) = delete;\nproperties &amp;operator=(const properties &amp;p) = delete;\n~properties();\nfpga_properties c_type() const { return props_; }\noperator fpga_properties() const { return props_; }\nstatic properties::ptr_t get();\nstatic properties::ptr_t get(fpga_guid guid_in);\nstatic properties::ptr_t get(fpga_objtype objtype);\nstatic properties::ptr_t get(std::shared_ptr&lt;token&gt; t);\nstatic properties::ptr_t get(fpga_token t);\nstatic properties::ptr_t get(std::shared_ptr&lt;handle&gt; h);\nprivate:\nproperties(bool alloc_props = true);\nfpga_properties props_;\npublic:\npvalue&lt;fpga_objtype&gt; type;\npvalue&lt;uint32_t&gt; num_errors;\npvalue&lt;uint16_t&gt; segment;\npvalue&lt;uint8_t&gt; bus;\npvalue&lt;uint8_t&gt; device;\npvalue&lt;uint8_t&gt; function;\npvalue&lt;uint8_t&gt; socket_id;\npvalue&lt;uint32_t&gt; num_slots;\npvalue&lt;uint64_t&gt; bbs_id;\npvalue&lt;fpga_version&gt; bbs_version;\npvalue&lt;uint16_t&gt; vendor_id;\npvalue&lt;uint16_t&gt; device_id;\npvalue&lt;uint16_t&gt; subsystem_vendor_id;\npvalue&lt;uint16_t&gt; subsystem_device_id;\npvalue&lt;char *&gt; model;\npvalue&lt;uint64_t&gt; local_memory_size;\npvalue&lt;uint64_t&gt; capabilities;\npvalue&lt;uint32_t&gt; num_mmio;\npvalue&lt;uint32_t&gt; num_interrupts;\npvalue&lt;fpga_accelerator_state&gt; accelerator_state;\npvalue&lt;uint64_t&gt; object_id;\npvalue&lt;fpga_token&gt; parent;\npvalue&lt;fpga_interface&gt; interface;\nguid_t guid;\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/pvalue_8h/","title":"File pvalue.h","text":"<p>FileList &gt; core &gt; pvalue.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/cxx/core/except.h&gt;</code></li> <li><code>#include &lt;opae/properties.h&gt;</code></li> <li><code>#include &lt;opae/utils.h&gt;</code></li> <li><code>#include &lt;uuid/uuid.h&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"opae-code/pvalue_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/pvalue_8h/#classes","title":"Classes","text":"Type Name struct guid_t Representation of the guid member of a properties object. struct pvalue &lt;typename T&gt;Wraps OPAE properties defined in the OPAE C API by associating an <code>fpga_properties</code> reference with the getters and setters defined for a property. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/pvalue.h</code></p>"},{"location":"opae-code/pvalue_8h_source/","title":"File pvalue.h","text":"<p>File List &gt; core &gt; pvalue.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018-2020, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/cxx/core/except.h&gt;\n#include &lt;opae/properties.h&gt;\n#include &lt;opae/utils.h&gt;\n#include &lt;uuid/uuid.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nstruct guid_t {\nguid_t(fpga_properties *p) : props_(p), is_set_(false) {}\nvoid update() {\nfpga_result res = fpgaPropertiesGetGUID(\n*props_, reinterpret_cast&lt;fpga_guid *&gt;(data_.data()));\nASSERT_FPGA_OK(res);\nis_set_ = true;\n}\noperator uint8_t *() {\nupdate();\nreturn data_.data();\n}\nconst uint8_t *c_type() const { return data_.data(); }\nguid_t &amp;operator=(fpga_guid g) {\nis_set_ = false;\nASSERT_FPGA_OK(fpgaPropertiesSetGUID(*props_, g));\nis_set_ = true;\nuint8_t *begin = &amp;g[0];\nuint8_t *end = begin + sizeof(fpga_guid);\nstd::copy(begin, end, data_.begin());\nreturn *this;\n}\nbool operator==(const fpga_guid &amp;g) {\nreturn is_set() &amp;&amp; (0 == std::memcmp(data_.data(), g, sizeof(fpga_guid)));\n}\nvoid parse(const char *str) {\nis_set_ = false;\nif (0 != uuid_parse(str, data_.data())) {\nthrow except(OPAECXX_HERE);\n}\nASSERT_FPGA_OK(fpgaPropertiesSetGUID(*props_, data_.data()));\nis_set_ = true;\n}\nfriend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;ostr, const guid_t &amp;g) {\nfpga_properties props = *g.props_;\nfpga_guid guid_value;\nfpga_result res;\nif ((res = fpgaPropertiesGetGUID(props, &amp;guid_value)) == FPGA_OK) {\nchar guid_str[84];\nuuid_unparse(guid_value, guid_str);\nostr &lt;&lt; guid_str;\n} else if (FPGA_NOT_FOUND == res) {\nstd::cerr &lt;&lt; \"[guid_t::&lt;&lt;] GUID property not set\\n\";\n} else {\nASSERT_FPGA_OK(res);\n}\nreturn ostr;\n}\nbool is_set() const { return is_set_; }\nvoid invalidate() { is_set_ = false; }\nprivate:\nfpga_properties *props_;\nbool is_set_;\nstd::array&lt;uint8_t, 16&gt; data_;\n};\ntemplate &lt;typename T&gt;\nstruct pvalue {\ntypedef typename std::conditional&lt;\nstd::is_same&lt;T, char *&gt;::value, fpga_result (*)(fpga_properties, T),\nfpga_result (*)(fpga_properties, T *)&gt;::type getter_t;\ntypedef fpga_result (*setter_t)(fpga_properties, T);\ntypedef typename std::conditional&lt;std::is_same&lt;T, char *&gt;::value,\ntypename std::string, T&gt;::type copy_t;\npvalue() : props_(0), is_set_(false), get_(nullptr), set_(nullptr), copy_() {}\npvalue(fpga_properties *p, getter_t g, setter_t s)\n: props_(p), is_set_(false), get_(g), set_(s), copy_() {}\npvalue&lt;T&gt; &amp;operator=(const T &amp;v) {\nis_set_ = false;\nASSERT_FPGA_OK(set_(*props_, v));\nis_set_ = true;\ncopy_ = v;\nreturn *this;\n}\nbool operator==(const T &amp;other) { return is_set() &amp;&amp; (copy_ == other); }\nvoid update() {\nASSERT_FPGA_OK(get_(*props_, &amp;copy_));\nis_set_ = true;\n}\noperator copy_t() {\nupdate();\nreturn copy_;\n}\n// TODO: Remove this once all properties are tested\nfpga_result get_value(T &amp;value) const { return get_(*props_, &amp;value); }\nfriend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;ostr, const pvalue&lt;T&gt; &amp;p) {\nT value;\nfpga_properties props = *p.props_;\nfpga_result res;\nif ((res = p.get_(props, &amp;value)) == FPGA_OK) {\nostr &lt;&lt; +(value);\n} else if (FPGA_NOT_FOUND == res) {\nstd::cerr &lt;&lt; \"property getter returned (\" &lt;&lt; res &lt;&lt; \") \"\n&lt;&lt; fpgaErrStr(res);\n} else {\nASSERT_FPGA_OK(res);\n}\nreturn ostr;\n}\nbool is_set() const { return is_set_; }\nvoid invalidate() { is_set_ = false; }\nprivate:\nfpga_properties *props_;\nbool is_set_;\ngetter_t get_;\nsetter_t set_;\ncopy_t copy_;\n};\ntemplate &lt;&gt;\ninline void pvalue&lt;char *&gt;::update() {\nchar buf[256];\nASSERT_FPGA_OK(get_(*props_, buf));\ncopy_.assign(buf);\nis_set_ = true;\n}\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/shared__buffer_8h/","title":"File shared_buffer.h","text":"<p>FileList &gt; core &gt; shared_buffer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/buffer.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/except.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/handle.h&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"opae-code/shared__buffer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/shared__buffer_8h/#classes","title":"Classes","text":"Type Name class shared_buffer Host/AFU shared memory blocks. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/shared_buffer.h</code></p>"},{"location":"opae-code/shared__buffer_8h_source/","title":"File shared_buffer.h","text":"<p>File List &gt; core &gt; shared_buffer.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/buffer.h&gt;\n#include &lt;opae/cxx/core/except.h&gt;\n#include &lt;opae/cxx/core/handle.h&gt;\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;initializer_list&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass shared_buffer {\npublic:\ntypedef std::size_t size_t;\ntypedef std::shared_ptr&lt;shared_buffer&gt; ptr_t;\nshared_buffer(const shared_buffer &amp;) = delete;\nshared_buffer &amp;operator=(const shared_buffer &amp;) = delete;\nvirtual ~shared_buffer();\nstatic shared_buffer::ptr_t allocate(handle::ptr_t handle, size_t len,\nbool read_only = false);\nstatic shared_buffer::ptr_t attach(handle::ptr_t handle, uint8_t *base,\nsize_t len, bool read_only = false);\nvoid release();\nvolatile uint8_t *c_type() const { return virt_; }\nhandle::ptr_t owner() const { return handle_; }\nsize_t size() const { return len_; }\nuint64_t wsid() const { return wsid_; }\nuint64_t io_address() const { return io_address_; }\nvoid fill(int c);\nint compare(ptr_t other, size_t len) const;\ntemplate &lt;typename T&gt;\nT read(size_t offset) const {\nif ((offset &lt; len_) &amp;&amp; (virt_ != nullptr)) {\nreturn *reinterpret_cast&lt;T *&gt;(virt_ + offset);\n} else if (offset &gt;= len_) {\nthrow except(OPAECXX_HERE);\n} else {\nthrow except(OPAECXX_HERE);\n}\nreturn T();\n}\ntemplate &lt;typename T&gt;\nvoid write(const T &amp;value, size_t offset) {\nif ((offset &lt; len_) &amp;&amp; (virt_ != nullptr)) {\n*reinterpret_cast&lt;T *&gt;(virt_ + offset) = value;\n} else if (offset &gt;= len_) {\nthrow except(OPAECXX_HERE);\n} else {\nthrow except(OPAECXX_HERE);\n}\n}\nprotected:\nshared_buffer(handle::ptr_t handle, size_t len, uint8_t *virt, uint64_t wsid,\nuint64_t io_address);\nhandle::ptr_t handle_;\nsize_t len_;\nuint8_t *virt_;\nuint64_t wsid_;\nuint64_t io_address_;\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/cxx_2core_2sysobject_8h/","title":"File sysobject.h","text":"<p>FileList &gt; core &gt; sysobject.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/cxx/core/handle.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/token.h&gt;</code></li> <li><code>#include &lt;opae/types.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"opae-code/cxx_2core_2sysobject_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/cxx_2core_2sysobject_8h/#classes","title":"Classes","text":"Type Name class sysobject Wraps the OPAE fpga_object primitive. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/sysobject.h</code></p>"},{"location":"opae-code/cxx_2core_2sysobject_8h_source/","title":"File sysobject.h","text":"<p>File List &gt; core &gt; sysobject.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/cxx/core/handle.h&gt;\n#include &lt;opae/cxx/core/token.h&gt;\n#include &lt;opae/types.h&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass sysobject {\npublic:\ntypedef std::shared_ptr&lt;sysobject&gt; ptr_t;\nsysobject() = delete;\nsysobject(const sysobject &amp;o) = delete;\nsysobject &amp;operator=(const sysobject &amp;o) = delete;\nstatic sysobject::ptr_t get(token::ptr_t t, const std::string &amp;name,\nint flags = 0);\nstatic sysobject::ptr_t get(handle::ptr_t h, const std::string &amp;name,\nint flags = 0);\nsysobject::ptr_t get(const std::string &amp;name, int flags = 0);\nsysobject::ptr_t get(int index);\nvirtual ~sysobject();\nuint32_t size() const;\nuint64_t read64(int flags = 0) const;\nvoid write64(uint64_t value, int flags = 0) const;\nstd::vector&lt;uint8_t&gt; bytes(int flags = 0) const;\nstd::vector&lt;uint8_t&gt; bytes(uint32_t offset, uint32_t size,\nint flags = 0) const;\nenum fpga_sysobject_type type() const;\nfpga_object c_type() const { return sysobject_; }\noperator fpga_object() const { return sysobject_; }\nprivate:\nsysobject(fpga_object sysobj, token::ptr_t token, handle::ptr_t hnd);\nfpga_object sysobject_;\ntoken::ptr_t token_;\nhandle::ptr_t handle_;\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/token_8h/","title":"File token.h","text":"<p>FileList &gt; core &gt; token.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/access.h&gt;</code></li> <li><code>#include &lt;opae/cxx/core/properties.h&gt;</code></li> <li><code>#include &lt;opae/enum.h&gt;</code></li> <li><code>#include &lt;opae/types.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"opae-code/token_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/token_8h/#classes","title":"Classes","text":"Type Name class token Wraps the OPAE fpga_token primitive. <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/token.h</code></p>"},{"location":"opae-code/token_8h_source/","title":"File token.h","text":"<p>File List &gt; core &gt; token.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018-2021, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/access.h&gt;\n#include &lt;opae/cxx/core/properties.h&gt;\n#include &lt;opae/enum.h&gt;\n#include &lt;opae/types.h&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass token {\npublic:\ntypedef std::shared_ptr&lt;token&gt; ptr_t;\nstatic std::vector&lt;token::ptr_t&gt; enumerate(\nconst std::vector&lt;properties::ptr_t&gt;&amp; props);\n~token();\nfpga_token c_type() const { return token_; }\noperator fpga_token() const { return token_; }\nptr_t get_parent() const;\nprivate:\ntoken(fpga_token tok);\nfpga_token token_;\nfriend class handle;\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/cxx_2core_2version_8h/","title":"File version.h","text":"<p>FileList &gt; core &gt; version.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"opae-code/cxx_2core_2version_8h/#namespaces","title":"Namespaces","text":"Type Name namespace opae namespace fpga namespace types"},{"location":"opae-code/cxx_2core_2version_8h/#classes","title":"Classes","text":"Type Name class version <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/cxx/core/version.h</code></p>"},{"location":"opae-code/cxx_2core_2version_8h_source/","title":"File version.h","text":"<p>File List &gt; core &gt; version.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#pragma once\n#include &lt;opae/types.h&gt;\n#include &lt;string&gt;\nnamespace opae {\nnamespace fpga {\nnamespace types {\nclass version {\npublic:\nstatic fpga_version as_struct();\nstatic std::string as_string();\nstatic std::string build();\n};\n}  // end of namespace types\n}  // end of namespace fpga\n}  // end of namespace opae\n</code></pre>"},{"location":"opae-code/enum_8h/","title":"File enum.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; enum.h</p> <p>Go to the source code of this file.</p> <p>APIs for resource enumeration and managing tokens. More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/enum_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaCloneToken (fpga_token src, fpga_token * dst) Clone a fpga_token object. fpga_result fpgaDestroyToken (fpga_token * token) Destroy a Token. fpga_result fpgaEnumerate (const fpga_properties * filters, uint32_t num_filters, fpga_token * tokens, uint32_t max_tokens, uint32_t * num_matches) Enumerate FPGA resources present in the system."},{"location":"opae-code/enum_8h/#detailed-description","title":"Detailed Description","text":"<p>These APIs are the first step for any application using OPAE to discover resources that are present on the system. They allow selective enumeration (i.e. getting a list of resources that match a given list of criteria) and methods to manage the lifecycle of tokens generated by fpgaEnumerate(). </p>"},{"location":"opae-code/enum_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/enum_8h/#function-fpgaclonetoken","title":"function fpgaCloneToken","text":"<p>Clone a fpga_token object. <pre><code>fpga_result fpgaCloneToken (\nfpga_token src,\nfpga_token * dst\n) </code></pre></p> <p>Creates a copy of an fpga_token object.</p> <p>Note:</p> <p>This call creates a new token object and allocates memory for it. It is the responsibility of the using application to free this memory after use by calling fpgaDestroyToken() for the cloned token.</p> <p>Parameters:</p> <ul> <li><code>src</code> fpga_token object to copy </li> <li><code>dst</code> New fpga_token object cloned from 'src' </li> </ul> <p>Returns:</p> <p>FPGA_OK on success </p>"},{"location":"opae-code/enum_8h/#function-fpgadestroytoken","title":"function fpgaDestroyToken","text":"<p>Destroy a Token. <pre><code>fpga_result fpgaDestroyToken (\nfpga_token * token\n) </code></pre></p> <p>This function destroys a token created by fpgaEnumerate() and frees the associated memory.</p> <p>Note:</p> <p>fpgaDestroyToken() requires the address of an fpga_token as previously created by fpgaEnumerate() or fpgaCloneToken(). Passing any other value results in undefined behavior.</p> <p>Parameters:</p> <ul> <li><code>token</code> fpga_token to destroy </li> </ul> <p>Returns:</p> <p>FPGA_OK on success </p>"},{"location":"opae-code/enum_8h/#function-fpgaenumerate","title":"function fpgaEnumerate","text":"<p>Enumerate FPGA resources present in the system. <pre><code>fpga_result fpgaEnumerate (\nconst fpga_properties * filters,\nuint32_t num_filters,\nfpga_token * tokens,\nuint32_t max_tokens,\nuint32_t * num_matches\n) </code></pre></p> <p>This call allows the user to query the system for FPGA resources that match a certain set of criteria, e.g. all accelerators that are assigned to a host interface and available, all FPGAs of a specific type, etc.</p> <p>fpgaEnumerate() will create a number of <code>fpga_token</code>s to represent the matching resources and populate the array <code>tokens</code> with these tokens. The <code>max_tokens</code> argument can be used to limit the number of tokens allocated/returned by fpgaEnumerate(); i.e., the number of tokens in the returned <code>tokens</code> array will be either <code>max_tokens</code> or <code>num_matches</code> (the number of resources matching the filter), whichever is smaller. Use fpgaDestroyToken() to destroy tokens that are no longer needed.</p> <p>To query the number of matches for a particular set of filters (e.g. to allocate a <code>tokens</code> array of the appropriate size), call fpgaEnumerate() with the parameter <code>tokens</code> set to NULL; this will only return the number of matches in <code>num_matches</code>.</p> <p>Note:</p> <p>fpgaEnumerate() will allocate memory for the created tokens returned in <code>tokens</code>. It is the responsibility of the using application to free this memory after use by calling fpgaDestroyToken() for each of the returned tokens.</p> <p>Parameters:</p> <ul> <li><code>filters</code> Array of <code>fpga_properties</code> objects describing the properties of the objects that should be returned. A resource is considered matching if its properties match any one of the supplied filters. To match all FPGA resources, pass an empty filters object (one without any filter criteria set) or pass a NULL filters parameter with num_filters set to 0. </li> <li><code>num_filters</code> Number of entries in the <code>filters</code> array, or 0 to match all FPGA resources when <code>filters</code> is NULL. </li> <li><code>tokens</code> Pointer to an array of fpga_token variables to be populated. If NULL is supplied, fpgaEnumerate() will not create any tokens, but it will return the number of possible matches in <code>num_match</code>. </li> <li><code>max_tokens</code> Maximum number of tokens that fpgaEnumerate() shall return (length of <code>tokens</code> array). There may be more or fewer matches than this number; <code>num_matches</code> is set to the number of actual matches. </li> <li><code>num_matches</code> Number of resources matching the <code>filter</code> criteria. This number can be higher than the number of tokens returned in the <code>tokens</code> array (depending on the value of <code>max_tokens</code>). </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if invalid pointers or objects are passed into the function. FPGA_NO_DRIVER if OPAE can't find the respective enumeration data structures usually provided by the driver. FPGA_NO_MEMORY if there was not enough memory to create tokens. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/enum.h</code></p>"},{"location":"opae-code/enum_8h_source/","title":"File enum.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; enum.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_ENUM_H__\n#define __FPGA_ENUM_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaEnumerate(const fpga_properties *filters,\nuint32_t num_filters, fpga_token *tokens,\nuint32_t max_tokens, uint32_t *num_matches);\nfpga_result fpgaCloneToken(fpga_token src, fpga_token *dst);\nfpga_result fpgaDestroyToken(fpga_token *token);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_ENUM_H__\n</code></pre>"},{"location":"opae-code/error_8h/","title":"File error.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; error.h</p> <p>Go to the source code of this file.</p> <p>Functions for reading and clearing errors in resources. More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/error_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaClearAllErrors (fpga_token token) Clear all error registers of a particular resource. fpga_result fpgaClearError (fpga_token token, uint32_t error_num) Clear error register. fpga_result fpgaGetErrorInfo (fpga_token token, uint32_t error_num, struct fpga_error_info * error_info) Get information about a particular error register. fpga_result fpgaReadError (fpga_token token, uint32_t error_num, uint64_t * value) Read error value."},{"location":"opae-code/error_8h/#detailed-description","title":"Detailed Description","text":"<p>Many FPGA resources have the ability to track the occurrence of errors. This file provides functions to retrieve information about errors within resources. </p>"},{"location":"opae-code/error_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/error_8h/#function-fpgaclearallerrors","title":"function fpgaClearAllErrors","text":"<p>Clear all error registers of a particular resource. <pre><code>fpga_result fpgaClearAllErrors (\nfpga_token token\n) </code></pre></p> <p>This function will clear all error registers of the resource referenced by <code>token</code>, observing the necessary order of clearing errors, if any.</p> <p>Parameters:</p> <ul> <li><code>token</code> Token to accelerator resource to query </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the token, and FPGA_BUSY if error could not be cleared. </p>"},{"location":"opae-code/error_8h/#function-fpgaclearerror","title":"function fpgaClearError","text":"<p>Clear error register. <pre><code>fpga_result fpgaClearError (\nfpga_token token,\nuint32_t error_num\n) </code></pre></p> <p>This function will clear the error register <code>error_num</code> of the resource referenced by <code>token</code>.</p> <p>Parameters:</p> <ul> <li><code>token</code> Token to accelerator resource to query </li> <li><code>error_num</code> Number of error register to clear </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the token, and FPGA_BUSY if error could not be cleared. </p>"},{"location":"opae-code/error_8h/#function-fpgageterrorinfo","title":"function fpgaGetErrorInfo","text":"<p>Get information about a particular error register. <pre><code>fpga_result fpgaGetErrorInfo (\nfpga_token token,\nuint32_t error_num,\nstruct fpga_error_info * error_info\n) </code></pre></p> <p>This function will populate a <code>fpga_error_info</code> struct with information about error number <code>error_num</code> of the resource referenced by <code>token</code>.</p> <p>Parameters:</p> <ul> <li><code>token</code> Token to accelerator resource to query </li> <li><code>error_num</code> Error register to retrieve information about </li> <li><code>error_info</code> Pointer to memory to store information into </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the token. </p>"},{"location":"opae-code/error_8h/#function-fpgareaderror","title":"function fpgaReadError","text":"<p>Read error value. <pre><code>fpga_result fpgaReadError (\nfpga_token token,\nuint32_t error_num,\nuint64_t * value\n) </code></pre></p> <p>This function will read the value of error register <code>error_num</code> of the resource referenced by <code>token</code> into the memory location pointed to by <code>value</code>.</p> <p>Parameters:</p> <ul> <li><code>token</code> Token to accelerator resource to query </li> <li><code>error_num</code> Number of error register to read </li> <li><code>value</code> Pointer to memory to store error value into (64 bit) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the token. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/error.h</code></p>"},{"location":"opae-code/error_8h_source/","title":"File error.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; error.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_ERROR_H__\n#define __FPGA_ERROR_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaReadError(fpga_token token, uint32_t error_num, uint64_t *value);\nfpga_result fpgaClearError(fpga_token token, uint32_t error_num);\nfpga_result fpgaClearAllErrors(fpga_token token);\nfpga_result fpgaGetErrorInfo(fpga_token token,\nuint32_t error_num,\nstruct fpga_error_info *error_info);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_ERROR_H__\n</code></pre>"},{"location":"opae-code/event_8h/","title":"File event.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; event.h</p> <p>Go to the source code of this file.</p> <p>Functions for registering events and managing the lifecycle for <code>fpga_event_handle</code> s.More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/event_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaCreateEventHandle (fpga_event_handle * event_handle) Initialize an event_handle. fpga_result fpgaDestroyEventHandle (fpga_event_handle * event_handle) Destroy an event_handle. fpga_result fpgaGetOSObjectFromEventHandle (const fpga_event_handle eh, int * fd) Get OS object from event handle. fpga_result fpgaRegisterEvent (fpga_handle handle, fpga_event_type event_type, fpga_event_handle event_handle, uint32_t flags) Register an FPGA event. fpga_result fpgaUnregisterEvent (fpga_handle handle, fpga_event_type event_type, fpga_event_handle event_handle) Unregister an FPGA event."},{"location":"opae-code/event_8h/#detailed-description","title":"Detailed Description","text":"<p>OPAE provides an interface to asynchronous events that can be generated by different FPGA resources. The event API provides functions to register for these events; associated with every event a process has registered for is an fpga_event_handle, which encapsulates the OS-specific data structure for event objects. On Linux, an fpga_event_handle can be used as a file descriptor and passed to select(), poll(), epoll() and similar functions to wait for asynchronous events. </p>"},{"location":"opae-code/event_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/event_8h/#function-fpgacreateeventhandle","title":"function fpgaCreateEventHandle","text":"<p>Initialize an event_handle. <pre><code>fpga_result fpgaCreateEventHandle (\nfpga_event_handle * event_handle\n) </code></pre></p> <p>Platform independent way to initialize an event_handle used for notifications from the driver to application. For Linux, this function creates an eventfd and returns the eventfd file descriptor in <code>*event_handle</code>.</p> <p>Parameters:</p> <ul> <li><code>event_handle</code> Pointer to event handle variable.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if <code>event_handle</code> is NULL. FPGA_NOT_SUPPORTED if platform does not support events. </p>"},{"location":"opae-code/event_8h/#function-fpgadestroyeventhandle","title":"function fpgaDestroyEventHandle","text":"<p>Destroy an event_handle. <pre><code>fpga_result fpgaDestroyEventHandle (\nfpga_event_handle * event_handle\n) </code></pre></p> <p>Destroy handle and free resources. On Linux this corresponds to closing the file descriptor pointed to by handle</p> <p>Note:</p> <p>fpgaDestroyEventHandle() requires the address of an event_handle as created by fpgaCreateEventHandle(). Passing any other value results in undefined behavior.</p> <p>Parameters:</p> <ul> <li><code>event_handle</code> Pointer to handle to be destroyed</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if <code>event_handle</code> is NULL. </p>"},{"location":"opae-code/event_8h/#function-fpgagetosobjectfromeventhandle","title":"function fpgaGetOSObjectFromEventHandle","text":"<p>Get OS object from event handle. <pre><code>fpga_result fpgaGetOSObjectFromEventHandle (\nconst fpga_event_handle eh,\nint * fd\n) </code></pre></p> <p>Check validity of event handle, and get the OS object used to subscribe and unsubscribe to events. On Linux, the object corresponds to a file descriptor.</p> <p>Parameters:</p> <ul> <li><code>eh</code> Event handle to get the descriptor value from </li> <li><code>fd</code> integer to store the descriptor value</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if <code>event_handle</code> is invalid. </p>"},{"location":"opae-code/event_8h/#function-fpgaregisterevent","title":"function fpgaRegisterEvent","text":"<p>Register an FPGA event. <pre><code>fpga_result fpgaRegisterEvent (\nfpga_handle handle,\nfpga_event_type event_type,\nfpga_event_handle event_handle,\nuint32_t flags\n) </code></pre></p> <p>This function tells the driver that the caller is interested in notification for the event specified by the type and flags pair.</p> <p>The event_handle points to an OS specific mechanism for event notification. An event_handle is associated with only a single event.</p> <p>In case of user interrupts, the flags parameter will be used to specify the vector ID. The value of the flags parameter indicates the vector ID, no bit encoding is used.</p> <p>Todo</p> <p>define if calling fpgaRegisterEvent multiple times with the same event_handle is an error condition or if it is silently ignored.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened FPGA resource. </li> <li><code>event_type</code> Type of event </li> <li><code>event_handle</code> Handle to previously opened resource for event notification. </li> <li><code>flags</code> Optional argument for specifying additional information about event. For example irq number for interrupt events. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to a resource supporting the requested event, or if event_handle is not valid. FPGA_EXCEPTION if an internal exception occurred while accessing the handle or the event_handle. On Linux: FPGA_NO_DAEMON if the driver does not support the requested event and there is no FPGA Daemon (fpgad) running to proxy it. </p>"},{"location":"opae-code/event_8h/#function-fpgaunregisterevent","title":"function fpgaUnregisterEvent","text":"<p>Unregister an FPGA event. <pre><code>fpga_result fpgaUnregisterEvent (\nfpga_handle handle,\nfpga_event_type event_type,\nfpga_event_handle event_handle\n) </code></pre></p> <p>This function tells the driver that the caller is no longer interested in notification for the event associated with the event_handle</p> <p>The event_handle points to an OS specific mechanism for event notification. An event_handle is associated with only a single event.</p> <p>Todo</p> <p>define if calling fpgaUnregisterEvent multiple times with the same event_handle is an error condition or if it is silently ignored.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened FPGA resource. </li> <li><code>event_type</code> Type of event to unregister. </li> <li><code>event_handle</code> Handle to previously registered resource for event notification. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if handle does not refer to a resource supporting the requested event, or if event_handle is not valid. FPGA_EXCEPTION if an internal error occurred accessing the handle or the event_handle. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/event.h</code></p>"},{"location":"opae-code/event_8h_source/","title":"File event.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; event.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_EVENT_H__\n#define __FPGA_EVENT_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaCreateEventHandle(fpga_event_handle *event_handle);\nfpga_result fpgaDestroyEventHandle(fpga_event_handle *event_handle);\nfpga_result fpgaGetOSObjectFromEventHandle(const fpga_event_handle eh, int *fd);\nfpga_result fpgaRegisterEvent(fpga_handle handle,\nfpga_event_type event_type,\nfpga_event_handle event_handle,\nuint32_t flags);\nfpga_result fpgaUnregisterEvent(fpga_handle handle,\nfpga_event_type event_type,\nfpga_event_handle event_handle);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_EVENT_H__\n</code></pre>"},{"location":"opae-code/fpga_8h/","title":"File fpga.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; fpga.h</p> <p>Go to the source code of this file.</p> <p>FPGA API. More...</p> <ul> <li><code>#include &lt;opae/log.h&gt;</code></li> <li><code>#include &lt;opae/init.h&gt;</code></li> <li><code>#include &lt;opae/types.h&gt;</code></li> <li><code>#include &lt;opae/access.h&gt;</code></li> <li><code>#include &lt;opae/buffer.h&gt;</code></li> <li><code>#include &lt;opae/enum.h&gt;</code></li> <li><code>#include &lt;opae/event.h&gt;</code></li> <li><code>#include &lt;opae/manage.h&gt;</code></li> <li><code>#include &lt;opae/mmio.h&gt;</code></li> <li><code>#include &lt;opae/properties.h&gt;</code></li> <li><code>#include &lt;opae/umsg.h&gt;</code></li> <li><code>#include &lt;opae/utils.h&gt;</code></li> <li><code>#include &lt;opae/error.h&gt;</code></li> <li><code>#include &lt;opae/version.h&gt;</code></li> <li><code>#include &lt;opae/sysobject.h&gt;</code></li> <li><code>#include &lt;opae/userclk.h&gt;</code></li> <li><code>#include &lt;opae/metrics.h&gt;</code></li> </ul>"},{"location":"opae-code/fpga_8h/#detailed-description","title":"Detailed Description","text":"<p>This conveniently includes all APIs that a part of the OPAE release (base and extensions). </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/fpga.h</code></p>"},{"location":"opae-code/fpga_8h_source/","title":"File fpga.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; fpga.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_FPGA_H__\n#define __FPGA_FPGA_H__\n#include &lt;opae/log.h&gt;\n#include &lt;opae/init.h&gt;\n#include &lt;opae/types.h&gt;\n#include &lt;opae/access.h&gt;\n#include &lt;opae/buffer.h&gt;\n#include &lt;opae/enum.h&gt;\n#include &lt;opae/event.h&gt;\n#include &lt;opae/manage.h&gt;\n#include &lt;opae/mmio.h&gt;\n#include &lt;opae/properties.h&gt;\n#include &lt;opae/umsg.h&gt;\n#include &lt;opae/utils.h&gt;\n#include &lt;opae/error.h&gt;\n#include &lt;opae/version.h&gt;\n#include &lt;opae/sysobject.h&gt;\n#include &lt;opae/userclk.h&gt;\n#include &lt;opae/metrics.h&gt;\n#endif // __FPGA_FPGA_H__\n</code></pre>"},{"location":"opae-code/hash__map_8h/","title":"File hash_map.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; hash_map.h</p> <p>Go to the source code of this file.</p> <p>A general-purpose hybrid array/list hash map implementation. More...</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;opae/types_enum.h&gt;</code></li> </ul>"},{"location":"opae-code/hash__map_8h/#classes","title":"Classes","text":"Type Name struct _opae_hash_map Hash map object. struct _opae_hash_map_item List link item."},{"location":"opae-code/hash__map_8h/#public-types","title":"Public Types","text":"Type Name enum _opae_hash_map_flags Flags used to initialize a hash map. typedef struct _opae_hash_map opae_hash_map Hash map object. typedef enum _opae_hash_map_flags opae_hash_map_flags Flags used to initialize a hash map. typedef struct _opae_hash_map_item opae_hash_map_item List link item."},{"location":"opae-code/hash__map_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result opae_hash_map_add (opae_hash_map * hm, void * key, void * value) Map a key to a value. fpga_result opae_hash_map_destroy (opae_hash_map * hm) Tear down a hash map. fpga_result opae_hash_map_find (opae_hash_map * hm, void * key, void ** value) Retrieve the value for a given key. fpga_result opae_hash_map_init (opae_hash_map * hm, uint32_t num_buckets, uint32_t hash_seed, int flags, uint32_t(*)(uint32_t num_buckets, uint32_t hash_seed, void *key) key_hash, int(*)(void *keya, void *keyb) key_compare, void(*)(void *key, void *context) key_cleanup, void(*)(void *value, void *context) value_cleanup) Initialize a hash map. bool opae_hash_map_is_empty (opae_hash_map * hm) Determine whether a hash map is empty. fpga_result opae_hash_map_remove (opae_hash_map * hm, void * key) Remove a key/value association. int opae_u64_key_compare (void * keya, void * keyb) Convenience key comparison function for 64-bit values. uint32_t opae_u64_key_hash (uint32_t num_buckets, uint32_t hash_seed, void * key) Convenience hash function for arbitrary pointers/64-bit values."},{"location":"opae-code/hash__map_8h/#detailed-description","title":"Detailed Description","text":"<p>Presents a generic interface for mapping key objects to value objects. Both keys and values may be arbitrary data structures. The user supplies the means by which the hash of values is generated and by which the keys are compared to each other. </p>"},{"location":"opae-code/hash__map_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/hash__map_8h/#enum-_opae_hash_map_flags","title":"enum _opae_hash_map_flags","text":"<p>Flags used to initialize a hash map. <pre><code>enum _opae_hash_map_flags {\nOPAE_HASH_MAP_UNIQUE_KEYSPACE = (1u &lt;&lt; 0)\n};\n</code></pre></p> <p>OPAE_HASH_MAP_UNIQUE_KEYSPACE says that the user provides a guarantee that the key space is truly unique. In other words, when the provided hash function for keys A and B returns the same bucket index, the key comparison function when comparing A and B will never return a result saying that the keys are equal in value. This is helpful in situations where the key space is guaranteed to produce unique values, for example a memory allocator. When the key space is guaranteed to be unique, opae_hash_map_add() can implement a small performance improvement. </p>"},{"location":"opae-code/hash__map_8h/#typedef-opae_hash_map","title":"typedef opae_hash_map","text":"<p>Hash map object. <pre><code>typedef struct _opae_hash_map opae_hash_map;\n</code></pre></p> <p>This structure defines the internals of the hash map. Each of the parameters supplied to opae_hash_map_init() is stored in the structure. All parameters are required, except key_cleanup and value_cleanup, which may optionally be NULL. </p>"},{"location":"opae-code/hash__map_8h/#typedef-opae_hash_map_flags","title":"typedef opae_hash_map_flags","text":"<p>Flags used to initialize a hash map. <pre><code>typedef enum _opae_hash_map_flags opae_hash_map_flags;\n</code></pre></p> <p>OPAE_HASH_MAP_UNIQUE_KEYSPACE says that the user provides a guarantee that the key space is truly unique. In other words, when the provided hash function for keys A and B returns the same bucket index, the key comparison function when comparing A and B will never return a result saying that the keys are equal in value. This is helpful in situations where the key space is guaranteed to produce unique values, for example a memory allocator. When the key space is guaranteed to be unique, opae_hash_map_add() can implement a small performance improvement. </p>"},{"location":"opae-code/hash__map_8h/#typedef-opae_hash_map_item","title":"typedef opae_hash_map_item","text":"<p>List link item. <pre><code>typedef struct _opae_hash_map_item opae_hash_map_item;\n</code></pre></p> <p>This structure provides the association between key and value. When the supplied hash function for keys A and B returns the same bucket index, both A and B can co-exist on the same list rooted at the bucket index. </p>"},{"location":"opae-code/hash__map_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/hash__map_8h/#function-opae_hash_map_add","title":"function opae_hash_map_add","text":"<p>Map a key to a value. <pre><code>fpga_result opae_hash_map_add (\nopae_hash_map * hm,\nvoid * key,\nvoid * value\n) </code></pre></p> <p>Inserts a mapping from key to value in the given hash map object. Subsequent calls to opae_hash_map_find() that are given the key will retrieve the value.</p> <p>Parameters:</p> <ul> <li><code>hm</code> A pointer to the storage for the hash map object. </li> <li><code>key</code> The hash map key. </li> <li><code>value</code> The hash map value. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if hm is NULL, FPGA_NO_MEMORY if malloc() fails when allocating the list item, or FPGA_INVALID_PARAM if the key hash produced by key_hash is out of bounds. </p>"},{"location":"opae-code/hash__map_8h/#function-opae_hash_map_destroy","title":"function opae_hash_map_destroy","text":"<p>Tear down a hash map. <pre><code>fpga_result opae_hash_map_destroy (\nopae_hash_map * hm\n) </code></pre></p> <p>Given a hash map that was previously initialized by opae_hash_map_init(), destroy the hash map, releasing all keys, values, and the bucket array.</p> <p>Parameters:</p> <ul> <li><code>hm</code> A pointer to the storage for the hash map object. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success or FPGA_INVALID_PARAM is hm is NULL. </p>"},{"location":"opae-code/hash__map_8h/#function-opae_hash_map_find","title":"function opae_hash_map_find","text":"<p>Retrieve the value for a given key. <pre><code>fpga_result opae_hash_map_find (\nopae_hash_map * hm,\nvoid * key,\nvoid ** value\n) </code></pre></p> <p>Given a key that was previously passed to opae_hash_map_add(), retrieve its associated value.</p> <p>Parameters:</p> <ul> <li><code>hm</code> A pointer to the storage for the hash map object. </li> <li><code>key</code> The hash map key. </li> <li><code>value</code> A pointer to receive the hash map value. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if hm is NULL or if the key hash produced by key_hash is out of bounds, or FPGA_NOT_FOUND if the given key was not found in the hash map. </p>"},{"location":"opae-code/hash__map_8h/#function-opae_hash_map_init","title":"function opae_hash_map_init","text":"<p>Initialize a hash map. <pre><code>fpga_result opae_hash_map_init (\nopae_hash_map * hm,\nuint32_t num_buckets,\nuint32_t hash_seed,\nint flags,\nuint32_t(*)(uint32_t num_buckets, uint32_t hash_seed, void *key) key_hash,\nint(*)(void *keya, void *keyb) key_compare,\nvoid(*)(void *key, void *context) key_cleanup,\nvoid(*)(void *value, void *context) value_cleanup\n) </code></pre></p> <p>Populates the hash map data structure and allocates the buckets array.</p> <p>Parameters:</p> <ul> <li><code>hm</code> A pointer to the storage for the hash map object. </li> <li><code>num_buckets</code> The desired size of the buckets array. Each array entry may be empty (NULL), or may contain a list of opae_hash_map_item structures for which the given key_hash function returned the same key hash value. </li> <li><code>hash_seed</code> A seed value used during key hash computation. This value will be the hash_seed parameter to the key hash function. </li> <li><code>flags</code> Initialization flags. See opae_hash_map_flags. </li> <li><code>key_hash</code> A pointer to a function that produces the hash value, given the number of buckets, the hash seed, and the key. Valid values are between 0 and num_buckets - 1, inclusively. </li> <li><code>key_compare</code> A pointer to a function that compares two keys. The return value is similar to that of strcmp(), where a negative value means that keya &lt; keyb, 0 means that keya == keyb, and a positive values means that keya &gt; keyb. </li> <li><code>key_cleanup</code> A pointer to a function that is called when a key is being removed from the map. This function is optional and may be NULL. When supplied, the function is responsible for freeing any resources allocated when the key was created. </li> <li><code>value_cleanup</code> A pointer to a function that is called when a value is being removed from the map. This function is optional and may be NULL. When supplied, the function is responsible for freeing any resources allocated when the value was created. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if any of the required parameters are NULL, or FPGA_NO_MEMORY if the bucket array could not be allocated. </p>"},{"location":"opae-code/hash__map_8h/#function-opae_hash_map_is_empty","title":"function opae_hash_map_is_empty","text":"<p>Determine whether a hash map is empty. <pre><code>bool opae_hash_map_is_empty (\nopae_hash_map * hm\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>hm</code> A pointer to the storage for the hash map object. </li> </ul> <p>Returns:</p> <p>true if there are no key/value mappings present, false otherwise. </p>"},{"location":"opae-code/hash__map_8h/#function-opae_hash_map_remove","title":"function opae_hash_map_remove","text":"<p>Remove a key/value association. <pre><code>fpga_result opae_hash_map_remove (\nopae_hash_map * hm,\nvoid * key\n) </code></pre></p> <p>Given a key that was previously passed to opae_hash_map_add(), remove the key and its associated value, calling the cleanup functions as needed.</p> <p>Parameters:</p> <ul> <li><code>hm</code> A pointer to the storage for the hash map object. </li> <li><code>key</code> The hash map key. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM when hm is NULL or when the key hash produced by key_hash is out of bounds, or FPGA_NOT_FOUND if the key is not found in the hash map. </p>"},{"location":"opae-code/hash__map_8h/#function-opae_u64_key_compare","title":"function opae_u64_key_compare","text":"<p>Convenience key comparison function for 64-bit values. <pre><code>int opae_u64_key_compare (\nvoid * keya,\nvoid * keyb\n) </code></pre></p> <p>Simply converts the key pointers to uint64_t's and performs unsigned integer comparison. </p>"},{"location":"opae-code/hash__map_8h/#function-opae_u64_key_hash","title":"function opae_u64_key_hash","text":"<p>Convenience hash function for arbitrary pointers/64-bit values. <pre><code>uint32_t opae_u64_key_hash (\nuint32_t num_buckets,\nuint32_t hash_seed,\nvoid * key\n) </code></pre></p> <p>Simply converts the key to a uint64_t and then performs the modulus operation with the configured num_buckets. hash_seed is unused. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/hash_map.h</code></p>"},{"location":"opae-code/hash__map_8h_source/","title":"File hash_map.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; hash_map.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2022-2023, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __OPAE_HASH_MAP_H__\n#define __OPAE_HASH_MAP_H__\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;opae/types_enum.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\ntypedef enum _opae_hash_map_flags {\nOPAE_HASH_MAP_UNIQUE_KEYSPACE = (1u &lt;&lt; 0)\n} opae_hash_map_flags;\ntypedef struct _opae_hash_map_item {\nvoid *key;\nvoid *value;\nstruct _opae_hash_map_item *next;\n} opae_hash_map_item;\ntypedef struct _opae_hash_map {\nuint32_t num_buckets;\nuint32_t hash_seed;\nopae_hash_map_item **buckets;\nint flags;\nvoid *cleanup_context; uint32_t (*key_hash)(uint32_t num_buckets,     uint32_t hash_seed,\nvoid *key);\nint (*key_compare)(void *keya, void *keyb);    void (*key_cleanup)(void *key, void *context);     void (*value_cleanup)(void *value, void *context); } opae_hash_map;\nfpga_result opae_hash_map_init(opae_hash_map *hm,\nuint32_t num_buckets,\nuint32_t hash_seed,\nint flags,\nuint32_t (*key_hash)(uint32_t num_buckets,\nuint32_t hash_seed,\nvoid *key),\nint (*key_compare)(void *keya, void *keyb),\nvoid (*key_cleanup)(void *key, void *context),\nvoid (*value_cleanup)(void *value, void *context));\nfpga_result opae_hash_map_add(opae_hash_map *hm,\nvoid *key,\nvoid *value);\nfpga_result opae_hash_map_find(opae_hash_map *hm,\nvoid *key,\nvoid **value);\nfpga_result opae_hash_map_remove(opae_hash_map *hm,\nvoid *key);\nfpga_result opae_hash_map_destroy(opae_hash_map *hm);\nbool opae_hash_map_is_empty(opae_hash_map *hm);\nuint32_t opae_u64_key_hash(uint32_t num_buckets,\nuint32_t hash_seed,\nvoid *key);\nint opae_u64_key_compare(void *keya, void *keyb);\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n#endif // __OPAE_HASH_MAP_H__\n</code></pre>"},{"location":"opae-code/init_8h/","title":"File init.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; init.h</p> <p>Go to the source code of this file.</p> <p>Initialization routine. </p> <ul> <li><code>#include &lt;opae/types_enum.h&gt;</code></li> </ul>"},{"location":"opae-code/init_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaFinalize (void) Finalize the OPAE library. fpga_result fpgaInitialize (const char * config_file) Initialize the OPAE library."},{"location":"opae-code/init_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/init_8h/#function-fpgafinalize","title":"function fpgaFinalize","text":"<p>Finalize the OPAE library. <pre><code>fpga_result fpgaFinalize (\nvoid\n) </code></pre></p> <p>Returns:</p> <p>Whether OPAE finalized successfully. </p>"},{"location":"opae-code/init_8h/#function-fpgainitialize","title":"function fpgaInitialize","text":"<p>Initialize the OPAE library. <pre><code>fpga_result fpgaInitialize (\nconst char * config_file\n) </code></pre></p> <p>Initialize OPAE using the given configuration file path, or perform default initialization if config_file is NULL.</p> <p>Parameters:</p> <ul> <li><code>config_file</code> Path to OPAE configuration file. </li> </ul> <p>Returns:</p> <p>Whether OPAE initialized successfully. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/init.h</code></p>"},{"location":"opae-code/init_8h_source/","title":"File init.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; init.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_INIT_H__\n#define __FPGA_INIT_H__\n#include &lt;opae/types_enum.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaInitialize(const char *config_file);\nfpga_result fpgaFinalize(void);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_INIT_H__\n</code></pre>"},{"location":"opae-code/log_8h/","title":"File log.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; log.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;errno.h&gt;</code></li> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/log_8h/#public-types","title":"Public Types","text":"Type Name enum opae_loglevel"},{"location":"opae-code/log_8h/#public-functions","title":"Public Functions","text":"Type Name void opae_print (int loglevel, const char * fmt, ...)"},{"location":"opae-code/log_8h/#macros","title":"Macros","text":"Type Name define OPAE_DBG (format, ...) {  } define OPAE_DEFAULT_LOGLEVEL  OPAE_LOG_ERROR define OPAE_ERR (format, ...)  define OPAE_MSG (format, ...)  define __SHORT_FILE__"},{"location":"opae-code/log_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/log_8h/#enum-opae_loglevel","title":"enum opae_loglevel","text":"<pre><code>enum opae_loglevel {\nOPAE_LOG_ERROR = 0,\nOPAE_LOG_MESSAGE,\nOPAE_LOG_DEBUG\n};\n</code></pre>"},{"location":"opae-code/log_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/log_8h/#function-opae_print","title":"function opae_print","text":"<pre><code>void opae_print (\nint loglevel,\nconst char * fmt,\n...\n) </code></pre>"},{"location":"opae-code/log_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"opae-code/log_8h/#define-opae_dbg","title":"define OPAE_DBG","text":"<pre><code>#define OPAE_DBG (\nformat,\n...\n) { }\n</code></pre>"},{"location":"opae-code/log_8h/#define-opae_default_loglevel","title":"define OPAE_DEFAULT_LOGLEVEL","text":"<pre><code>#define OPAE_DEFAULT_LOGLEVEL OPAE_LOG_ERROR\n</code></pre>"},{"location":"opae-code/log_8h/#define-opae_err","title":"define OPAE_ERR","text":"<pre><code>#define OPAE_ERR (\nformat,\n...\n) opae_print ( OPAE_LOG_ERROR ,                                \\\n    \"%s:%u:%s() **ERROR** : \" format \"\\n\",                    \\\n    __SHORT_FILE__, __LINE__, __func__, ##__VA_ARGS__)\n</code></pre>"},{"location":"opae-code/log_8h/#define-opae_msg","title":"define OPAE_MSG","text":"<pre><code>#define OPAE_MSG (\nformat,\n...\n) opae_print ( OPAE_LOG_MESSAGE , \"%s:%u:%s() : \" format \"\\n\", \\\n    __SHORT_FILE__, __LINE__, __func__, ##__VA_ARGS__)\n</code></pre>"},{"location":"opae-code/log_8h/#define-__short_file__","title":"define __SHORT_FILE__","text":"<pre><code>#define __SHORT_FILE__ ({                                                     \\\n    const char *file = __FILE__;                           \\\n    const char *p = file;                                  \\\n    while (*p)                                             \\\n        ++p;                                           \\\n    while ((p &gt; file) &amp;&amp; ('/' != *p) &amp;&amp; ('\\\\' != *p))      \\\n        --p;                                           \\\n    if (p &gt; file)                                          \\\n        ++p;                                           \\\n    p;                                                     \\\n    })\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/log.h</code></p>"},{"location":"opae-code/log_8h_source/","title":"File log.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; log.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018-2021, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __OPAE_LOG_H__\n#define __OPAE_LOG_H__\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;opae/types.h&gt;\n/*\n* Convenience macros for printing messages and errors.\n*/\n#ifdef __SHORT_FILE__\n#undef __SHORT_FILE__\n#endif // __SHORT_FILE__\n#define __SHORT_FILE__                                         \\\n    ({                                                     \\\n    const char *file = __FILE__;                           \\\n    const char *p = file;                                  \\\n    while (*p)                                             \\\n        ++p;                                           \\\n    while ((p &gt; file) &amp;&amp; ('/' != *p) &amp;&amp; ('\\\\' != *p))      \\\n        --p;                                           \\\n    if (p &gt; file)                                          \\\n        ++p;                                           \\\n    p;                                                     \\\n    })\n#ifdef OPAE_MSG\n#undef OPAE_MSG\n#endif // OPAE_MSG\n#define OPAE_MSG(format, ...)                                     \\\n    opae_print(OPAE_LOG_MESSAGE, \"%s:%u:%s() : \" format \"\\n\", \\\n    __SHORT_FILE__, __LINE__, __func__, ##__VA_ARGS__)\n#ifdef OPAE_ERR\n#undef OPAE_ERR\n#endif // OPAE_ERR\n#define OPAE_ERR(format, ...)                                     \\\n    opae_print(OPAE_LOG_ERROR,                                \\\n    \"%s:%u:%s() **ERROR** : \" format \"\\n\",                    \\\n    __SHORT_FILE__, __LINE__, __func__, ##__VA_ARGS__)\n#ifdef OPAE_DBG\n#undef OPAE_DBG\n#endif // OPAE_DBG\n#ifdef LIBOPAE_DEBUG\n#define OPAE_DBG(format, ...)                                    \\\n    opae_print(OPAE_LOG_DEBUG,                               \\\n    \"%s:%u:%s() *DEBUG* : \" format \"\\n\",                     \\\n    __SHORT_FILE__, __LINE__, __func__, ##__VA_ARGS__)\n#else\n#define OPAE_DBG(format, ...)                                    \\\n{   }\n#endif // LIBOPAE_DEBUG\n/*\n* Logging functions\n*/\nenum opae_loglevel {\nOPAE_LOG_ERROR = 0, /* critical errors (always print) */\nOPAE_LOG_MESSAGE,   /* information (i.e. explain return code */\nOPAE_LOG_DEBUG      /* debugging (also needs #define DEBUG 1) */\n};\n#define OPAE_DEFAULT_LOGLEVEL OPAE_LOG_ERROR\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\nvoid opae_print(int loglevel, const char *fmt, ...);\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n#endif // __OPAE_LOG_H__\n</code></pre>"},{"location":"opae-code/manage_8h/","title":"File manage.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; manage.h</p> <p>Go to the source code of this file.</p> <p>Functions for managing FPGA configurations. More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/manage_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaAssignPortToInterface (fpga_handle fpga, uint32_t interface_num, uint32_t slot_num, int flags) Assign Port to a host interface. fpga_result fpgaAssignToInterface (fpga_handle fpga, fpga_token accelerator, uint32_t host_interface, int flags) Assign an accelerator to a host interface. fpga_result fpgaReconfigureSlot (fpga_handle fpga, uint32_t slot, const uint8_t * bitstream, size_t bitstream_len, int flags) Reconfigure a slot. fpga_result fpgaReleaseFromInterface (fpga_handle fpga, fpga_token accelerator) Unassign a previously assigned accelerator."},{"location":"opae-code/manage_8h/#detailed-description","title":"Detailed Description","text":"<p>FPGA accelerators can be reprogrammed at run time by providing new partial bitstreams (\"green bitstreams\"). This file defines API functions for programming green bitstreams as well as for assigning accelerators to host interfaces for more complex deployment setups, such as virtualized systems. </p>"},{"location":"opae-code/manage_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/manage_8h/#function-fpgaassignporttointerface","title":"function fpgaAssignPortToInterface","text":"<p>Assign Port to a host interface. <pre><code>fpga_result fpgaAssignPortToInterface (\nfpga_handle fpga,\nuint32_t interface_num,\nuint32_t slot_num,\nint flags\n) </code></pre></p> <p>This function assign Port to a host interface for subsequent use. Only Port that have been assigned to a host interface can be opened by fpgaOpen().</p> <p>Parameters:</p> <ul> <li><code>fpga</code> Handle to an FPGA object previously opened that both the host interface and the slot belong to </li> <li><code>interface_num</code> Host interface number </li> <li><code>slot_num</code> Slot number </li> <li><code>flags</code> Flags (to be defined) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if an exception occcurred accessing the <code>fpga</code> handle. FPGA_NOT_SUPPORTED if driver does not support assignment. </p>"},{"location":"opae-code/manage_8h/#function-fpgaassigntointerface","title":"function fpgaAssignToInterface","text":"<p>Assign an accelerator to a host interface. <pre><code>fpga_result fpgaAssignToInterface (\nfpga_handle fpga,\nfpga_token accelerator,\nuint32_t host_interface,\nint flags\n) </code></pre></p> <p>This function assigns an accelerator to a host interface for subsequent use. Only accelerators that have been assigned to a host interface can be opened by fpgaOpen().</p> <p>Note:</p> <p>This function is currently not supported.</p> <p>Parameters:</p> <ul> <li><code>fpga</code> Handle to an FPGA object previously opened that both the host interface and the accelerator belong to </li> <li><code>accelerator</code> accelerator to assign </li> <li><code>host_interface</code> Host interface to assign accelerator to </li> <li><code>flags</code> Flags (to be defined) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success </p>"},{"location":"opae-code/manage_8h/#function-fpgareconfigureslot","title":"function fpgaReconfigureSlot","text":"<p>Reconfigure a slot. <pre><code>fpga_result fpgaReconfigureSlot (\nfpga_handle fpga,\nuint32_t slot,\nconst uint8_t * bitstream,\nsize_t bitstream_len,\nint flags\n) </code></pre></p> <p>Sends a green bitstream file to an FPGA to reconfigure a specific slot. This call, if successful, will overwrite the currently programmed AFU in that slot with the AFU in the provided bitstream.</p> <p>As part of the reconfiguration flow, all accelerators associated with this slot will be unassigned and reset.</p> <p>Parameters:</p> <ul> <li><code>fpga</code> Handle to an FPGA object previously opened </li> <li><code>slot</code> Token identifying the slot to reconfigure </li> <li><code>bitstream</code> Pointer to memory holding the bitstream </li> <li><code>bitstream_len</code> Length of the bitstream in bytes </li> <li><code>flags</code> Flags that control behavior of reconfiguration. Value of 0 indicates no flags. FPGA_RECONF_FORCE indicates that the bitstream is programmed into the slot without checking if the resource is currently in use. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if the provided parameters are not valid. FPGA_EXCEPTION if an internal error occurred accessing the handle or while sending the bitstream data to the driver. FPGA_BUSY if the accelerator for the given slot is in use. FPGA_RECONF_ERROR on errors reported by the driver (such as CRC or protocol errors).</p> <p>Note:</p> <p>By default, fpgaReconfigureSlot will not allow reconfiguring a slot with an accelerator in use. Add the flag FPGA_RECONF_FORCE to force reconfiguration without checking for accelerators in use. </p>"},{"location":"opae-code/manage_8h/#function-fpgareleasefrominterface","title":"function fpgaReleaseFromInterface","text":"<p>Unassign a previously assigned accelerator. <pre><code>fpga_result fpgaReleaseFromInterface (\nfpga_handle fpga,\nfpga_token accelerator\n) </code></pre></p> <p>This function removes the assignment of an accelerator to an host interface (e.g. to be later assigned to a different host interface). As a consequence, the accelerator referred to by token 'accelerator' will be reset during the course of this function.</p> <p>Note:</p> <p>This function is currently not supported.</p> <p>Parameters:</p> <ul> <li><code>fpga</code> Handle to an FPGA object previously opened that both the host interface and the accelerator belong to </li> <li><code>accelerator</code> accelerator to unassign/release </li> </ul> <p>Returns:</p> <p>FPGA_OK on success </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/manage.h</code></p>"},{"location":"opae-code/manage_8h_source/","title":"File manage.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; manage.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_MANAGE_H__\n#define __FPGA_MANAGE_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaAssignPortToInterface(fpga_handle fpga,\nuint32_t interface_num,\nuint32_t slot_num,\nint flags);\nfpga_result fpgaAssignToInterface(fpga_handle fpga,\nfpga_token accelerator,\nuint32_t host_interface,\nint flags);\nfpga_result fpgaReleaseFromInterface(fpga_handle fpga,\nfpga_token accelerator);\nfpga_result fpgaReconfigureSlot(fpga_handle fpga,\nuint32_t slot,\nconst uint8_t *bitstream,\nsize_t bitstream_len, int flags);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_MANAGE_H__\n</code></pre>"},{"location":"opae-code/mem__alloc_8h/","title":"File mem_alloc.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; mem_alloc.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"opae-code/mem__alloc_8h/#classes","title":"Classes","text":"Type Name struct mem_alloc struct mem_link Provides an API for allocating/freeing a logical address space."},{"location":"opae-code/mem__alloc_8h/#public-functions","title":"Public Functions","text":"Type Name int mem_alloc_add_free (struct mem_alloc * m, uint64_t address, uint64_t size) Add a memory region to an allocator. void mem_alloc_destroy (struct mem_alloc * m) Destroy a memory allocator object. int mem_alloc_get (struct mem_alloc * m, uint64_t * address, uint64_t size) Allocate memory. void mem_alloc_init (struct mem_alloc * m) Initialize a memory allocator object. int mem_alloc_put (struct mem_alloc * m, uint64_t address) Free memory."},{"location":"opae-code/mem__alloc_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/mem__alloc_8h/#function-mem_alloc_add_free","title":"function mem_alloc_add_free","text":"<p>Add a memory region to an allocator. <pre><code>int mem_alloc_add_free (\nstruct mem_alloc * m,\nuint64_t address,\nuint64_t size\n) </code></pre></p> <p>The memory region is added to the allocatable space and is immediately ready for allocation.</p> <p>Parameters:</p> <ul> <li><code>m</code> The memory allocator object. </li> <li><code>address</code> The beginning address of the memory region. </li> <li><code>size</code> The size of the memory region. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  struct mem_alloc m;</p> <p>mem_alloc_init(&amp;m);</p> <p>if (mem_alloc_add_free(&amp;m, 0x4000, 4096)) {   // handle error }</p>"},{"location":"opae-code/mem__alloc_8h/#function-mem_alloc_destroy","title":"function mem_alloc_destroy","text":"<p>Destroy a memory allocator object. <pre><code>void mem_alloc_destroy (\nstruct mem_alloc * m\n) </code></pre></p> <p>Frees all of the allocator's internal resources.</p> <p>Parameters:</p> <ul> <li><code>m</code> The address of the memory allocator to destroy. </li> </ul>"},{"location":"opae-code/mem__alloc_8h/#function-mem_alloc_get","title":"function mem_alloc_get","text":"<p>Allocate memory. <pre><code>int mem_alloc_get (\nstruct mem_alloc * m,\nuint64_t * address,\nuint64_t size\n) </code></pre></p> <p>Retrieve an available memory address for a free block that is at least size bytes.</p> <p>Parameters:</p> <ul> <li><code>m</code> The memory allocator object. </li> <li><code>address</code> The retrieved address for the allocation. </li> <li><code>size</code> The request size in bytes. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  struct mem_alloc m; uint64_t addr = 0;</p> <p>mem_alloc_init(&amp;m);</p> <p>if (mem_alloc_add_free(&amp;m, 0x4000, 4096)) {   // handle error }</p> <p>...</p> <p>if (mem_alloc_get(&amp;m, &amp;addr, 4096)) {   // handle allocation error }</p>"},{"location":"opae-code/mem__alloc_8h/#function-mem_alloc_init","title":"function mem_alloc_init","text":"<p>Initialize a memory allocator object. <pre><code>void mem_alloc_init (\nstruct mem_alloc * m\n) </code></pre></p> <p>After the call, the allocator is initialized but \"empty\". To add allocatable memory regions, further initialize the allocator with mem_alloc_add_free().</p> <p>Parameters:</p> <ul> <li><code>m</code> The address of the memory allocator to initialize. </li> </ul>"},{"location":"opae-code/mem__alloc_8h/#function-mem_alloc_put","title":"function mem_alloc_put","text":"<p>Free memory. <pre><code>int mem_alloc_put (\nstruct mem_alloc * m,\nuint64_t address\n) </code></pre></p> <p>Release a previously-allocated memory block.</p> <p>Parameters:</p> <ul> <li><code>m</code> The memory allocator object. </li> <li><code>address</code> The address to free. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  struct mem_alloc m; uint64_t addr = 0;</p> <p>mem_alloc_init(&amp;m);</p> <p>if (mem_alloc_add_free(&amp;m, 0x4000, 4096)) {   // handle error }</p> <p>...</p> <p>if (mem_alloc_get(&amp;m, &amp;addr, 4096)) {   // handle allocation error }</p> <p>...</p> <p>if (mem_alloc_put(&amp;m, addr)) {   // handle free error }</p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/mem_alloc.h</code></p>"},{"location":"opae-code/mem__alloc_8h_source/","title":"File mem_alloc.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; mem_alloc.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2020, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __OPAE_MEM_ALLOC_H__\n#define __OPAE_MEM_ALLOC_H__\n#include &lt;stdint.h&gt;\nstruct mem_link {\nuint64_t address;\nuint64_t size;\nstruct mem_link *prev;\nstruct mem_link *next;\n};\nstruct mem_alloc {\nstruct mem_link free;\nstruct mem_link allocated;\n};\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\nvoid mem_alloc_init(struct mem_alloc *m);\nvoid mem_alloc_destroy(struct mem_alloc *m);\nint mem_alloc_add_free(struct mem_alloc *m,\nuint64_t address,\nuint64_t size);\nint mem_alloc_get(struct mem_alloc *m,\nuint64_t *address,\nuint64_t size);\nint mem_alloc_put(struct mem_alloc *m,\nuint64_t address);\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n#endif // __OPAE_MEM_ALLOC_H__\n</code></pre>"},{"location":"opae-code/metrics_8h/","title":"File metrics.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; metrics.h</p> <p>Go to the source code of this file.</p> <p>Functions for Discover/ Enumerates metrics and retrieves values. </p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/metrics_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaGetMetricsByIndex (fpga_handle handle, uint64_t * metric_num, uint64_t num_metric_indexes, fpga_metric * metrics) Retrieve metrics values by index. fpga_result fpgaGetMetricsByName (fpga_handle handle, char ** metrics_names, uint64_t num_metric_names, fpga_metric * metrics) Retrieve metric values by names. fpga_result fpgaGetMetricsInfo (fpga_handle handle, fpga_metric_info * metric_info, uint64_t * num_metrics) Retrieve metrics information. fpga_result fpgaGetMetricsThresholdInfo (fpga_handle handle, struct metric_threshold * metric_thresholds, uint32_t * num_thresholds) Retrieve metrics / sendor threshold information and values. fpga_result fpgaGetNumMetrics (fpga_handle handle, uint64_t * num_metrics) Enumerates number of metrics."},{"location":"opae-code/metrics_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/metrics_8h/#function-fpgagetmetricsbyindex","title":"function fpgaGetMetricsByIndex","text":"<p>Retrieve metrics values by index. <pre><code>fpga_result fpgaGetMetricsByIndex (\nfpga_handle handle,\nuint64_t * metric_num,\nuint64_t num_metric_indexes,\nfpga_metric * metrics\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened fpga resource </li> <li><code>metric_num</code> Pointer to array of metric index user allocates metric array </li> <li><code>num_metric_indexes</code> Size of metric array </li> <li><code>metrics</code> pointer to array of metric struct</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found. FPGA_NO_MEMORY if there was not enough memory to enumerates metrics. </p>"},{"location":"opae-code/metrics_8h/#function-fpgagetmetricsbyname","title":"function fpgaGetMetricsByName","text":"<p>Retrieve metric values by names. <pre><code>fpga_result fpgaGetMetricsByName (\nfpga_handle handle,\nchar ** metrics_names,\nuint64_t num_metric_names,\nfpga_metric * metrics\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened fpga resource </li> <li><code>metrics_names</code> Pointer to array of metrics name user allocates metrics name array </li> <li><code>num_metric_names</code> Size of metric name array </li> <li><code>metrics</code> Pointer to array of metric struct</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found </p>"},{"location":"opae-code/metrics_8h/#function-fpgagetmetricsinfo","title":"function fpgaGetMetricsInfo","text":"<p>Retrieve metrics information. <pre><code>fpga_result fpgaGetMetricsInfo (\nfpga_handle handle,\nfpga_metric_info * metric_info,\nuint64_t * num_metrics\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened fpga resource </li> <li><code>metric_info</code> Pointer to array of metric info struct user allocates metrics info array</li> <li><code>num_metrics</code> Size of metric info array</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found. FPGA_NO_MEMORY if there was not enough memory to enumerates metrics. </p>"},{"location":"opae-code/metrics_8h/#function-fpgagetmetricsthresholdinfo","title":"function fpgaGetMetricsThresholdInfo","text":"<p>Retrieve metrics / sendor threshold information and values. <pre><code>fpga_result fpgaGetMetricsThresholdInfo (\nfpga_handle handle,\nstruct metric_threshold * metric_thresholds,\nuint32_t * num_thresholds\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened fpga resource </li> <li><code>metrics_threshold</code> pointer to array of metric thresholds user allocates threshold array memory Number of thresholds returns enumerated thresholds if user pass NULL metrics_thresholds </li> <li><code>num_thresholds</code> number of thresholds</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not found. FPGA_NO_MEMORY if there was not enough memory to enumerates metrics. </p>"},{"location":"opae-code/metrics_8h/#function-fpgagetnummetrics","title":"function fpgaGetNumMetrics","text":"<p>Enumerates number of metrics. <pre><code>fpga_result fpgaGetNumMetrics (\nfpga_handle handle,\nuint64_t * num_metrics\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened fpga resource </li> <li><code>num_metrics</code> Number of metrics are discovered in fpga resource</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not discovered </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/metrics.h</code></p>"},{"location":"opae-code/metrics_8h_source/","title":"File metrics.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; metrics.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_METRICS_H__\n#define __FPGA_METRICS_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaGetNumMetrics(fpga_handle handle,\nuint64_t *num_metrics);\nfpga_result fpgaGetMetricsInfo(fpga_handle handle,\nfpga_metric_info *metric_info,\nuint64_t *num_metrics);\nfpga_result fpgaGetMetricsByIndex(fpga_handle handle,\nuint64_t *metric_num,\nuint64_t num_metric_indexes,\nfpga_metric *metrics);\nfpga_result fpgaGetMetricsByName(fpga_handle handle,\nchar **metrics_names,\nuint64_t num_metric_names,\nfpga_metric *metrics);\nfpga_result fpgaGetMetricsThresholdInfo(fpga_handle handle,\nstruct metric_threshold *metric_thresholds,\nuint32_t *num_thresholds);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_METRICS_H__\n</code></pre>"},{"location":"opae-code/mmio_8h/","title":"File mmio.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; mmio.h</p> <p>Go to the source code of this file.</p> <p>Functions for mapping and accessing MMIO space. More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/mmio_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaMapMMIO (fpga_handle handle, uint32_t mmio_num, uint64_t ** mmio_ptr) Map MMIO space. fpga_result fpgaReadMMIO32 (fpga_handle handle, uint32_t mmio_num, uint64_t offset, uint32_t * value) Read 32 bit value from MMIO space. fpga_result fpgaReadMMIO64 (fpga_handle handle, uint32_t mmio_num, uint64_t offset, uint64_t * value) Read 64 bit value from MMIO space. fpga_result fpgaUnmapMMIO (fpga_handle handle, uint32_t mmio_num) Unmap MMIO space. fpga_result fpgaWriteMMIO32 (fpga_handle handle, uint32_t mmio_num, uint64_t offset, uint32_t value) Write 32 bit value to MMIO space. fpga_result fpgaWriteMMIO512 (fpga_handle handle, uint32_t mmio_num, uint64_t offset, const void * value) Write 512 bit value to MMIO space. fpga_result fpgaWriteMMIO64 (fpga_handle handle, uint32_t mmio_num, uint64_t offset, uint64_t value) Write 64 bit value to MMIO space."},{"location":"opae-code/mmio_8h/#detailed-description","title":"Detailed Description","text":"<p>Most FPGA accelerators provide access to control registers through memory-mappable address spaces, commonly referred to as \"MMIO spaces\". This file provides functions to map, unmap, read, and write MMIO spaces.</p> <p>Note that an accelerator may have multiple MMIO spaces, denoted by the <code>mmio_num</code> argument of the APIs below. The meaning and properties of each MMIO space are up to the accelerator designer. </p>"},{"location":"opae-code/mmio_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/mmio_8h/#function-fpgamapmmio","title":"function fpgaMapMMIO","text":"<p>Map MMIO space. <pre><code>fpga_result fpgaMapMMIO (\nfpga_handle handle,\nuint32_t mmio_num,\nuint64_t ** mmio_ptr\n) </code></pre></p> <p>This function will return a pointer to the specified MMIO space of the target object in process virtual memory, if supported by the target. Some MMIO spaces may be restricted to privileged processes, depending on the used handle and type.</p> <p>After mapping the respective MMIO space, you can access it through direct pointer operations (observing supported access sizes and alignments of the target platform and accelerator).</p> <p>Note:</p> <p>Some targets (such as the ASE simulator) do not support memory-mapping of IO register spaces and will not return a pointer to an actually mapped space. Instead, they will return <code>FPGA_NOT_SUPPORTED</code>. Usually, these platforms still allow the application to issue MMIO operations using fpgaReadMMIO32(), fpgaWriteMMIO32(), fpgeReadMMIO64(), and fpgaWriteMMIO64().</p> <p>If the caller passes in NULL for mmio_ptr, no mapping will be performed, and no virtual address will be returned, though the call will return <code>FPGA_OK</code>. This implies that all accesses will be performed through fpgaReadMMIO32(), fpgaWriteMMIO32(), fpgeReadMMIO64(), and fpgaWriteMMIO64(). This is the only supported case for ASE.</p> <p>The number of available MMIO spaces can be retrieved through the num_mmio property (fpgaPropertyGetNumMMIO()).</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened resource </li> <li><code>mmio_num</code> Number of MMIO space to access </li> <li><code>mmio_ptr</code> Pointer to memory where a pointer to the MMIO space will be returned. May be NULL, in which case no pointer is returned. Returned address may be NULL if underlying platform does not support memory mapping for register access. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. FPGA_NO_ACCESS if the process' permissions are not sufficient to map the requested MMIO space. FPGA_NOT_SUPPORTED if platform does not support memory mapped IO. </p>"},{"location":"opae-code/mmio_8h/#function-fpgareadmmio32","title":"function fpgaReadMMIO32","text":"<p>Read 32 bit value from MMIO space. <pre><code>fpga_result fpgaReadMMIO32 (\nfpga_handle handle,\nuint32_t mmio_num,\nuint64_t offset,\nuint32_t * value\n) </code></pre></p> <p>This function will read from MMIO space of the target object at a specified offset.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>mmio_num</code> Number of MMIO space to access </li> <li><code>offset</code> Byte offset into MMIO space </li> <li><code>value</code> Pointer to memory where read value is returned (32 bit) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p>"},{"location":"opae-code/mmio_8h/#function-fpgareadmmio64","title":"function fpgaReadMMIO64","text":"<p>Read 64 bit value from MMIO space. <pre><code>fpga_result fpgaReadMMIO64 (\nfpga_handle handle,\nuint32_t mmio_num,\nuint64_t offset,\nuint64_t * value\n) </code></pre></p> <p>This function will read from MMIO space of the target object at a specified offset.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>mmio_num</code> Number of MMIO space to access </li> <li><code>offset</code> Byte offset into MMIO space </li> <li><code>value</code> Pointer to memory where read value is returned (64 bit) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p>"},{"location":"opae-code/mmio_8h/#function-fpgaunmapmmio","title":"function fpgaUnmapMMIO","text":"<p>Unmap MMIO space. <pre><code>fpga_result fpgaUnmapMMIO (\nfpga_handle handle,\nuint32_t mmio_num\n) </code></pre></p> <p>This function will unmap a previously mapped MMIO space of the target object, rendering any pointers to it invalid.</p> <p>Note:</p> <p>This call is only supported by hardware targets, not by ASE simulation.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened resource </li> <li><code>mmio_num</code> Number of MMIO space to access </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p>"},{"location":"opae-code/mmio_8h/#function-fpgawritemmio32","title":"function fpgaWriteMMIO32","text":"<p>Write 32 bit value to MMIO space. <pre><code>fpga_result fpgaWriteMMIO32 (\nfpga_handle handle,\nuint32_t mmio_num,\nuint64_t offset,\nuint32_t value\n) </code></pre></p> <p>This function will write to MMIO space of the target object at a specified offset.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>mmio_num</code> Number of MMIO space to access </li> <li><code>offset</code> Byte offset into MMIO space </li> <li><code>value</code> Value to write (32 bit) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p>"},{"location":"opae-code/mmio_8h/#function-fpgawritemmio512","title":"function fpgaWriteMMIO512","text":"<p>Write 512 bit value to MMIO space. <pre><code>fpga_result fpgaWriteMMIO512 (\nfpga_handle handle,\nuint32_t mmio_num,\nuint64_t offset,\nconst void * value\n) </code></pre></p> <p>512 bit MMIO writes may not be supported on all platforms.</p> <p>This function will write to MMIO space of the target object at a specified offset.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>mmio_num</code> Number of MMIO space to access </li> <li><code>offset</code> Byte offset into MMIO space </li> <li><code>value</code> Pointer to memory holding value to write (512 bits) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p>"},{"location":"opae-code/mmio_8h/#function-fpgawritemmio64","title":"function fpgaWriteMMIO64","text":"<p>Write 64 bit value to MMIO space. <pre><code>fpga_result fpgaWriteMMIO64 (\nfpga_handle handle,\nuint32_t mmio_num,\nuint64_t offset,\nuint64_t value\n) </code></pre></p> <p>This function will write to MMIO space of the target object at a specified offset.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>mmio_num</code> Number of MMIO space to access </li> <li><code>offset</code> Byte offset into MMIO space </li> <li><code>value</code> Value to write (64 bit) </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/mmio.h</code></p>"},{"location":"opae-code/mmio_8h_source/","title":"File mmio.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; mmio.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_MMIO_H__\n#define __FPGA_MMIO_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaWriteMMIO64(fpga_handle handle,\nuint32_t mmio_num, uint64_t offset,\nuint64_t value);\nfpga_result fpgaReadMMIO64(fpga_handle handle,\nuint32_t mmio_num,\nuint64_t offset, uint64_t *value);\nfpga_result fpgaWriteMMIO32(fpga_handle handle,\nuint32_t mmio_num, uint64_t offset,\nuint32_t value);\nfpga_result fpgaReadMMIO32(fpga_handle handle,\nuint32_t mmio_num,\nuint64_t offset, uint32_t *value);\nfpga_result fpgaWriteMMIO512(fpga_handle handle,\nuint32_t mmio_num, uint64_t offset,\nconst void *value);\nfpga_result fpgaMapMMIO(fpga_handle handle,\nuint32_t mmio_num, uint64_t **mmio_ptr);\nfpga_result fpgaUnmapMMIO(fpga_handle handle,\nuint32_t mmio_num);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_MMIO_H__\n</code></pre>"},{"location":"opae-code/properties_8h/","title":"File properties.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; properties.h</p> <p>Go to the source code of this file.</p> <p>Functions for examining and manipulating <code>fpga_properties</code> objects.More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/properties_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaClearProperties (fpga_properties prop) Clear a fpga_properties object. fpga_result fpgaCloneProperties (fpga_properties src, fpga_properties * dst) Clone a fpga_properties object. fpga_result fpgaDestroyProperties (fpga_properties * prop) Destroy a fpga_properties object. fpga_result fpgaGetProperties (fpga_token token, fpga_properties * prop) Create a fpga_properties object. fpga_result fpgaGetPropertiesFromHandle (fpga_handle handle, fpga_properties * prop) Create a fpga_properties object. fpga_result fpgaPropertiesGetAcceleratorState (const fpga_properties prop, fpga_accelerator_state * state) Get the state of a accelerator resource property. fpga_result fpgaPropertiesGetBBSID (const fpga_properties prop, uint64_t * bbs_id) Get the BBS ID of an FPGA resource property. fpga_result fpgaPropertiesGetBBSVersion (const fpga_properties prop, fpga_version * bbs_version) Get the BBS Version of an FPGA resource property. fpga_result fpgaPropertiesGetBus (const fpga_properties prop, uint8_t * bus) Get the PCI bus number of a resource. fpga_result fpgaPropertiesGetCapabilities (const fpga_properties prop, uint64_t * capabilities) Get the capabilities FPGA resource property. fpga_result fpgaPropertiesGetDevice (const fpga_properties prop, uint8_t * device) Get the PCI device number of a resource. fpga_result fpgaPropertiesGetDeviceID (const fpga_properties prop, uint16_t * device_id) Get the device id of the resource. fpga_result fpgaPropertiesGetFunction (const fpga_properties prop, uint8_t * function) Get the PCI function number of a resource. fpga_result fpgaPropertiesGetGUID (const fpga_properties prop, fpga_guid * guid) Get the GUID of a resource. fpga_result fpgaPropertiesGetInterface (const fpga_properties prop, fpga_interface * interface) Get the OPAE plugin interface implemented by a resource. fpga_result fpgaPropertiesGetLocalMemorySize (const fpga_properties prop, uint64_t * lms) Get the local memory size of an FPGA resource property. fpga_result fpgaPropertiesGetModel (const fpga_properties prop, char * model) Get the model of an FPGA resource property. fpga_result fpgaPropertiesGetNumErrors (const fpga_properties prop, uint32_t * num_errors) Get the number of errors that can be reported by a resource. fpga_result fpgaPropertiesGetNumInterrupts (const fpga_properties prop, uint32_t * num_interrupts) Get the number of interrupts. fpga_result fpgaPropertiesGetNumMMIO (const fpga_properties prop, uint32_t * mmio_spaces) Get the number of mmio spaces. fpga_result fpgaPropertiesGetNumSlots (const fpga_properties prop, uint32_t * num_slots) Get the number of slots of an FPGA resource property. fpga_result fpgaPropertiesGetObjectID (const fpga_properties prop, uint64_t * object_id) Get the object ID of a resource. fpga_result fpgaPropertiesGetObjectType (const fpga_properties prop, fpga_objtype * objtype) Get the object type of a resource. fpga_result fpgaPropertiesGetParent (const fpga_properties prop, fpga_token * parent) Get the token of the parent object. fpga_result fpgaPropertiesGetSegment (const fpga_properties prop, uint16_t * segment) Get the PCI segment number of a resource. fpga_result fpgaPropertiesGetSocketID (const fpga_properties prop, uint8_t * socket_id) Get the socket id of a resource. fpga_result fpgaPropertiesGetSubsystemDeviceID (const fpga_properties prop, uint16_t * subsystem_device_id) Get the subsystem device id of an FPGA resource property. fpga_result fpgaPropertiesGetSubsystemVendorID (const fpga_properties prop, uint16_t * subsystem_vendor_id) Get the subsystem vendor id of an FPGA resource property. fpga_result fpgaPropertiesGetVendorID (const fpga_properties prop, uint16_t * vendor_id) Get the vendor id of an FPGA resource property. fpga_result fpgaPropertiesSetAcceleratorState (fpga_properties prop, fpga_accelerator_state state) Set the state of an accelerator resource property. fpga_result fpgaPropertiesSetBBSID (fpga_properties prop, uint64_t bbs_id) Set the BBS ID of an FPGA resource property. fpga_result fpgaPropertiesSetBBSVersion (fpga_properties prop, fpga_version version) Set the BBS Version of an FPGA resource property. fpga_result fpgaPropertiesSetBus (fpga_properties prop, uint8_t bus) Set the PCI bus number of a resource. fpga_result fpgaPropertiesSetCapabilities (fpga_properties prop, uint64_t capabilities) Set the capabilities of an FPGA resource property. fpga_result fpgaPropertiesSetDevice (fpga_properties prop, uint8_t device) Set the PCI device number of a resource. fpga_result fpgaPropertiesSetDeviceID (fpga_properties prop, uint16_t device_id) Set the device id of the resource. fpga_result fpgaPropertiesSetFunction (fpga_properties prop, uint8_t function) Set the PCI function number of a resource. fpga_result fpgaPropertiesSetGUID (fpga_properties prop, fpga_guid guid) Set the GUID of a resource. fpga_result fpgaPropertiesSetInterface (const fpga_properties prop, fpga_interface interface) Set the OPAE plugin interface implemented by a resource. fpga_result fpgaPropertiesSetLocalMemorySize (fpga_properties prop, uint64_t lms) Set the local memory size of an FPGA resource property. fpga_result fpgaPropertiesSetModel (fpga_properties prop, char * model) Set the model of an FPGA resource property. fpga_result fpgaPropertiesSetNumErrors (const fpga_properties prop, uint32_t num_errors) Set the number of error registers. fpga_result fpgaPropertiesSetNumInterrupts (fpga_properties prop, uint32_t num_interrupts) Set the number of interrupts. fpga_result fpgaPropertiesSetNumMMIO (fpga_properties prop, uint32_t mmio_spaces) Set the number of mmio spaces. fpga_result fpgaPropertiesSetNumSlots (fpga_properties prop, uint32_t num_slots) Set the number of slots of an FPGA resource property. fpga_result fpgaPropertiesSetObjectID (const fpga_properties prop, uint64_t object_id) Set the object ID of a resource. fpga_result fpgaPropertiesSetObjectType (fpga_properties prop, fpga_objtype objtype) Set the object type of a resource. fpga_result fpgaPropertiesSetParent (fpga_properties prop, fpga_token parent) Set the token of the parent object. fpga_result fpgaPropertiesSetSegment (fpga_properties prop, uint16_t segment) Set the PCI segment number of a resource. fpga_result fpgaPropertiesSetSocketID (fpga_properties prop, uint8_t socket_id) Set the socket id of the resource. fpga_result fpgaPropertiesSetSubsystemDeviceID (fpga_properties prop, uint16_t subsystem_device_id) Set the subsystem device id of an FPGA resource property. fpga_result fpgaPropertiesSetSubsystemVendorID (fpga_properties prop, uint16_t subsystem_vendor_id) Set the subsystem vendor id of an FPGA resource property. fpga_result fpgaPropertiesSetVendorID (fpga_properties prop, uint16_t vendor_id) Set the vendor id of an FPGA resource property. fpga_result fpgaUpdateProperties (fpga_token token, fpga_properties prop) Update a fpga_properties object."},{"location":"opae-code/properties_8h/#detailed-description","title":"Detailed Description","text":"<p>In OPAE, <code>fpga_properties</code> objects are used both for obtaining information about resources and for selectively enumerating resources based on their properties. This file provides accessor functions (get/set) to allow reading and writing individual items of an <code>fpga_properties</code> object. Generally, not all object types supported by OPAE carry all properties. If you call a property accessor method on a <code>fpga_properties</code> object that does not support this particular property, it will return FPGA_INVALID_PARAM.</p>"},{"location":"opae-code/properties_8h/#accessor-return-values","title":"Accessor Return Values","text":"<p>In addition to the return values specified in the documentation below, all accessor functions return FPGA_OK on success, FPGA_INVALID_PARAM if you pass NULL or invalid parameters (i.e. non-initialized properties objects), FPGA_EXCEPTION if an internal exception occurred trying to access the properties object, FPGA_NOT_FOUND if the requested property is not part of the supplied properties object. </p>"},{"location":"opae-code/properties_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/properties_8h/#function-fpgaclearproperties","title":"function fpgaClearProperties","text":"<p>Clear a fpga_properties object. <pre><code>fpga_result fpgaClearProperties (\nfpga_properties prop\n) </code></pre></p> <p>Sets all fields of the properties object pointed at by 'prop' to 'don't care', which implies that the fpga_properties object would match all FPGA resources if used for an fpgaEnumerate() query. The matching criteria can be further refined by using fpgaSet* functions on the properties object.</p> <p>Instead of creating a new fpga_properties object every time, this function can be used to re-use fpga_properties objects from previous queries.</p> <p>Parameters:</p> <ul> <li><code>prop</code> fpga_properties object to clear </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if <code>prop</code> is not a valid object. FPGA_EXCEPTION if an * internal exception occured when trying to access <code>prop</code>. </p>"},{"location":"opae-code/properties_8h/#function-fpgacloneproperties","title":"function fpgaCloneProperties","text":"<p>Clone a fpga_properties object. <pre><code>fpga_result fpgaCloneProperties (\nfpga_properties src,\nfpga_properties * dst\n) </code></pre></p> <p>Creates a copy of an fpga_properties object.</p> <p>Note:</p> <p>This call creates a new properties object and allocates memory for it. Both the 'src' and the newly created 'dst' objects will eventually need to be destroyed using fpgaDestroyProperties().</p> <p>Parameters:</p> <ul> <li><code>src</code> fpga_properties object to copy </li> <li><code>dst</code> New fpga_properties object cloned from 'src' </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if <code>src</code> is not a valid object, or if <code>dst</code> is NULL. FPGA_NO_MEMORY if there was not enough memory to allocate an <code>fpga_properties</code> object for <code>dst</code>. FPGA_EXCEPTION if an internal exception occurred either accessing <code>src</code> or updating <code>dst</code>. </p>"},{"location":"opae-code/properties_8h/#function-fpgadestroyproperties","title":"function fpgaDestroyProperties","text":"<p>Destroy a fpga_properties object. <pre><code>fpga_result fpgaDestroyProperties (\nfpga_properties * prop\n) </code></pre></p> <p>Destroys an existing fpga_properties object that the caller has previously created using fpgaGetProperties() or fpgaCloneProperties().</p> <p>Note:</p> <p>fpgaDestroyProperties() requires the address of an fpga_properties object, similar to fpgaGetPropertiesFromHandle(), fpgaGetProperties(), and fpgaCloneProperties(). Passing any other value results in undefined behavior.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Pointer to the fpga_properties object to destroy </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM is <code>prop</code> is not a valid object. FPGA_EXCEPTION if an internal exception occurrred while trying to access <code>prop</code>. </p>"},{"location":"opae-code/properties_8h/#function-fpgagetproperties","title":"function fpgaGetProperties","text":"<p>Create a fpga_properties object. <pre><code>fpga_result fpgaGetProperties (\nfpga_token token,\nfpga_properties * prop\n) </code></pre></p> <p>Initializes the memory pointed at by <code>prop</code> to represent a properties object, and populates it with the properties of the resource referred to by <code>token</code>. Individual properties can then be queried using fpgaPropertiesGet*() accessor functions.</p> <p>If <code>token</code> is NULL, an \"empty\" properties object is created to be used as a filter for fpgaEnumerate(). All individual fields are set to <code>don</code>t care`, which implies that the fpga_properties object would match all FPGA resources if used for an fpgaEnumerate() query. The matching criteria can be further refined by using fpgaSet* functions on the properties object, or the object can be populated with the actual properties of a resource by using fpgaUpdateProperties().</p> <p>Note:</p> <p>fpgaGetProperties() will allocate memory for the created properties object returned in <code>prop</code>. It is the responsibility of the caller to free this memory after use by calling fpgaDestroyProperties().</p> <p>Parameters:</p> <ul> <li><code>token</code> Token to get properties for. Can be NULL, which will create an empty properties object to be used as a filter for fpgaEnumerate(). </li> <li><code>prop</code> Pointer to a variable of type fpga_properties </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NO_MEMORY if no memory could be allocated to create the <code>fpga_properties</code> object. FPGA_EXCEPTION if an exception happend while initializing the <code>fpga_properties</code> object. </p>"},{"location":"opae-code/properties_8h/#function-fpgagetpropertiesfromhandle","title":"function fpgaGetPropertiesFromHandle","text":"<p>Create a fpga_properties object. <pre><code>fpga_result fpgaGetPropertiesFromHandle (\nfpga_handle handle,\nfpga_properties * prop\n) </code></pre></p> <p>Initializes the memory pointed at by <code>prop</code> to represent a properties object, and populates it with the properties of the resource referred to by <code>handle</code>. Individual properties can then be queried using fpgaPropertiesGet*() accessor functions.</p> <p>Note:</p> <p>fpgaGetPropertiesFromHandle() will allocate memory for the created properties object returned in <code>prop</code>. It is the responsibility of the caller to free this memory after use by calling fpgaDestroyProperties().</p> <p>Parameters:</p> <ul> <li><code>handle</code> Open handle to get properties for. </li> <li><code>prop</code> Pointer to a variable of type fpga_properties </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_NO_MEMORY if no memory could be allocated to create the <code>fpga_properties</code> object. FPGA_EXCEPTION if an exception happend while initializing the <code>fpga_properties</code> object. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetacceleratorstate","title":"function fpgaPropertiesGetAcceleratorState","text":"<p>Get the state of a accelerator resource property. <pre><code>fpga_result fpgaPropertiesGetAcceleratorState (\nconst fpga_properties prop,\nfpga_accelerator_state * state\n) </code></pre></p> <p>Returns the accelerator state of a accelerator.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_ACCELERATOR </li> <li><code>state</code> Pointer to a accelerator state variable of the accelerator </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetbbsid","title":"function fpgaPropertiesGetBBSID","text":"<p>Get the BBS ID of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetBBSID (\nconst fpga_properties prop,\nuint64_t * bbs_id\n) </code></pre></p> <p>Returns the blue bitstream id of an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_DEVICE </li> <li><code>bbs_id</code> Pointer to a bbs id variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetbbsversion","title":"function fpgaPropertiesGetBBSVersion","text":"<p>Get the BBS Version of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetBBSVersion (\nconst fpga_properties prop,\nfpga_version * bbs_version\n) </code></pre></p> <p>Returns the blue bitstream version of an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_DEVICE </li> <li><code>bbs_version</code> Pointer to a bbs version variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetbus","title":"function fpgaPropertiesGetBus","text":"<p>Get the PCI bus number of a resource. <pre><code>fpga_result fpgaPropertiesGetBus (\nconst fpga_properties prop,\nuint8_t * bus\n) </code></pre></p> <p>Returns the bus number the queried resource.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>bus</code> Pointer to a PCI bus variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetcapabilities","title":"function fpgaPropertiesGetCapabilities","text":"<p>Get the capabilities FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetCapabilities (\nconst fpga_properties prop,\nuint64_t * capabilities\n) </code></pre></p> <p>Returns the capabilities of an FPGA. Capabilities is a bitfield value</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_DEVICE </li> <li><code>capabilities</code> Pointer to a capabilities variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetdevice","title":"function fpgaPropertiesGetDevice","text":"<p>Get the PCI device number of a resource. <pre><code>fpga_result fpgaPropertiesGetDevice (\nconst fpga_properties prop,\nuint8_t * device\n) </code></pre></p> <p>Returns the device number the queried resource.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>device</code> Pointer to a PCI device variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetdeviceid","title":"function fpgaPropertiesGetDeviceID","text":"<p>Get the device id of the resource. <pre><code>fpga_result fpgaPropertiesGetDeviceID (\nconst fpga_properties prop,\nuint16_t * device_id\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>device_id</code> Pointer to a device id variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetfunction","title":"function fpgaPropertiesGetFunction","text":"<p>Get the PCI function number of a resource. <pre><code>fpga_result fpgaPropertiesGetFunction (\nconst fpga_properties prop,\nuint8_t * function\n) </code></pre></p> <p>Returns the function number the queried resource.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>function</code> Pointer to PCI function variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetguid","title":"function fpgaPropertiesGetGUID","text":"<p>Get the GUID of a resource. <pre><code>fpga_result fpgaPropertiesGetGUID (\nconst fpga_properties prop,\nfpga_guid * guid\n) </code></pre></p> <p>Returns the GUID of an FPGA or accelerator object.</p> <p>For an accelerator, the GUID uniquely identifies a specific accelerator context type, i.e. different accelerators will have different GUIDs. For an FPGA, the GUID is used to identify a certain instance of an FPGA, e.g. to determine whether a given bitstream would be compatible.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>guid</code> Pointer to a GUID of the slot variable </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetinterface","title":"function fpgaPropertiesGetInterface","text":"<p>Get the OPAE plugin interface implemented by a resource. <pre><code>fpga_result fpgaPropertiesGetInterface (\nconst fpga_properties prop,\nfpga_interface * interface\n) </code></pre></p> <p>Returns the plugin interface enumerator.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>interface</code> Pointer to an fpga_interface location to store the interface in </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetlocalmemorysize","title":"function fpgaPropertiesGetLocalMemorySize","text":"<p>Get the local memory size of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetLocalMemorySize (\nconst fpga_properties prop,\nuint64_t * lms\n) </code></pre></p> <p>Returns the local memory size of an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_DEVICE </li> <li><code>lms</code> Pointer to a memory size variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetmodel","title":"function fpgaPropertiesGetModel","text":"<p>Get the model of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetModel (\nconst fpga_properties prop,\nchar * model\n) </code></pre></p> <p>Returns the model of an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_DEVICE </li> <li><code>model</code> Model of the FPGA resource (string of minimum FPGA_MODEL_LENGTH length </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetnumerrors","title":"function fpgaPropertiesGetNumErrors","text":"<p>Get the number of errors that can be reported by a resource. <pre><code>fpga_result fpgaPropertiesGetNumErrors (\nconst fpga_properties prop,\nuint32_t * num_errors\n) </code></pre></p> <p>Returns the number of error registers understood by a resource.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>num_errors</code> Pointer to a 32 bit memory location to store the number of supported errors in </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetnuminterrupts","title":"function fpgaPropertiesGetNumInterrupts","text":"<p>Get the number of interrupts. <pre><code>fpga_result fpgaPropertiesGetNumInterrupts (\nconst fpga_properties prop,\nuint32_t * num_interrupts\n) </code></pre></p> <p>Returns the number of interrupts of an accelerator properties structure.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_ACCELERATOR </li> <li><code>num_interrupts</code> Pointer to a variable for number of interrupts </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetnummmio","title":"function fpgaPropertiesGetNumMMIO","text":"<p>Get the number of mmio spaces. <pre><code>fpga_result fpgaPropertiesGetNumMMIO (\nconst fpga_properties prop,\nuint32_t * mmio_spaces\n) </code></pre></p> <p>Returns the number of mmio spaces of an AFU properties structure.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_ACCELERATOR </li> <li><code>mmio_spaces</code> Pointer to a variable for number of mmio spaces </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetnumslots","title":"function fpgaPropertiesGetNumSlots","text":"<p>Get the number of slots of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetNumSlots (\nconst fpga_properties prop,\nuint32_t * num_slots\n) </code></pre></p> <p>Returns the number of slots present in an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_DEVICE </li> <li><code>num_slots</code> Pointer to number of slots variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetobjectid","title":"function fpgaPropertiesGetObjectID","text":"<p>Get the object ID of a resource. <pre><code>fpga_result fpgaPropertiesGetObjectID (\nconst fpga_properties prop,\nuint64_t * object_id\n) </code></pre></p> <p>Returns the object ID of a resource. The object ID is a 64 bit identifier that is unique within a single node or system. It represents a similar concept as the token, but can be used across processes (e.g. passed on the command line).</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>object_id</code> Pointer to a 64bit memory location to store the object ID in </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetobjecttype","title":"function fpgaPropertiesGetObjectType","text":"<p>Get the object type of a resource. <pre><code>fpga_result fpgaPropertiesGetObjectType (\nconst fpga_properties prop,\nfpga_objtype * objtype\n) </code></pre></p> <p>Returns the object type of the queried resource.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>objtype</code> Pointer to an object type variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetparent","title":"function fpgaPropertiesGetParent","text":"<p>Get the token of the parent object. <pre><code>fpga_result fpgaPropertiesGetParent (\nconst fpga_properties prop,\nfpga_token * parent\n) </code></pre></p> <p>Returns the token of the parent of the queried resource in '*parent'.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>parent</code> Pointer to a token variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>FPGA_NOT_FOUND if resource does not have a parent (e.g. an FPGA_DEVICE resource does not have parents). Also see \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetsegment","title":"function fpgaPropertiesGetSegment","text":"<p>Get the PCI segment number of a resource. <pre><code>fpga_result fpgaPropertiesGetSegment (\nconst fpga_properties prop,\nuint16_t * segment\n) </code></pre></p> <p>Returns the segment number of the queried resource.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>segment</code> Pointer to a PCI segment variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetsocketid","title":"function fpgaPropertiesGetSocketID","text":"<p>Get the socket id of a resource. <pre><code>fpga_result fpgaPropertiesGetSocketID (\nconst fpga_properties prop,\nuint8_t * socket_id\n) </code></pre></p> <p>Returns the socket id of the queried resource.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>socket_id</code> Pointer to a socket id variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetsubsystemdeviceid","title":"function fpgaPropertiesGetSubsystemDeviceID","text":"<p>Get the subsystem device id of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetSubsystemDeviceID (\nconst fpga_properties prop,\nuint16_t * subsystem_device_id\n) </code></pre></p> <p>Returns the subsystem device id of an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>subsystem_device_id</code> Pointer to a device id variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetsubsystemvendorid","title":"function fpgaPropertiesGetSubsystemVendorID","text":"<p>Get the subsystem vendor id of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetSubsystemVendorID (\nconst fpga_properties prop,\nuint16_t * subsystem_vendor_id\n) </code></pre></p> <p>Returns the subsystem vendor id of an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>subsystem_vendor_id</code> Pointer to a vendor id variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiesgetvendorid","title":"function fpgaPropertiesGetVendorID","text":"<p>Get the vendor id of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesGetVendorID (\nconst fpga_properties prop,\nuint16_t * vendor_id\n) </code></pre></p> <p>Returns the vendor id of an FPGA.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query - must be of type FPGA_DEVICE </li> <li><code>vendor_id</code> Pointer to a vendor id variable of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetacceleratorstate","title":"function fpgaPropertiesSetAcceleratorState","text":"<p>Set the state of an accelerator resource property. <pre><code>fpga_result fpgaPropertiesSetAcceleratorState (\nfpga_properties prop,\nfpga_accelerator_state state\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_ACCELERATOR </li> <li><code>state</code> accelerator state of the accelerator resource </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetbbsid","title":"function fpgaPropertiesSetBBSID","text":"<p>Set the BBS ID of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetBBSID (\nfpga_properties prop,\nuint64_t bbs_id\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_DEVICE </li> <li><code>bbs_id</code> Blue bitstream id of the FPGA resource </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetbbsversion","title":"function fpgaPropertiesSetBBSVersion","text":"<p>Set the BBS Version of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetBBSVersion (\nfpga_properties prop,\nfpga_version version\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_DEVICE </li> <li><code>version</code> Blue bitstream version of the FPGA resource </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetbus","title":"function fpgaPropertiesSetBus","text":"<p>Set the PCI bus number of a resource. <pre><code>fpga_result fpgaPropertiesSetBus (\nfpga_properties prop,\nuint8_t bus\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>bus</code> PCI bus number of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetcapabilities","title":"function fpgaPropertiesSetCapabilities","text":"<p>Set the capabilities of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetCapabilities (\nfpga_properties prop,\nuint64_t capabilities\n) </code></pre></p> <p>Capabilities is a bitfield value</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_DEVICE </li> <li><code>capabilities</code> Capabilities of the FPGA resource </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetdevice","title":"function fpgaPropertiesSetDevice","text":"<p>Set the PCI device number of a resource. <pre><code>fpga_result fpgaPropertiesSetDevice (\nfpga_properties prop,\nuint8_t device\n) </code></pre></p> <p>Enforces the limitation on the number of devices as specified in the PCI spec.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>device</code> PCI device number of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetdeviceid","title":"function fpgaPropertiesSetDeviceID","text":"<p>Set the device id of the resource. <pre><code>fpga_result fpgaPropertiesSetDeviceID (\nfpga_properties prop,\nuint16_t device_id\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>device_id</code> Device id of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetfunction","title":"function fpgaPropertiesSetFunction","text":"<p>Set the PCI function number of a resource. <pre><code>fpga_result fpgaPropertiesSetFunction (\nfpga_properties prop,\nuint8_t function\n) </code></pre></p> <p>Enforces the limitation on the number of functions as specified in the PCI spec.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>function</code> PCI function number of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetguid","title":"function fpgaPropertiesSetGUID","text":"<p>Set the GUID of a resource. <pre><code>fpga_result fpgaPropertiesSetGUID (\nfpga_properties prop,\nfpga_guid guid\n) </code></pre></p> <p>Sets the GUID of an FPGA or accelerator object.</p> <p>For an accelerator, the GUID uniquely identifies a specific accelerator context type, i.e. different accelerators will have different GUIDs. For an FPGA, the GUID is used to identify a certain instance of an FPGA, e.g. to determine whether a given bitstream would be compatible.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>guid</code> Pointer to a GUID of the slot variable </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetinterface","title":"function fpgaPropertiesSetInterface","text":"<p>Set the OPAE plugin interface implemented by a resource. <pre><code>fpga_result fpgaPropertiesSetInterface (\nconst fpga_properties prop,\nfpga_interface interface\n) </code></pre></p> <p>Set the plugin interface enumerator.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>interface</code> The interface enumerator to set </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetlocalmemorysize","title":"function fpgaPropertiesSetLocalMemorySize","text":"<p>Set the local memory size of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetLocalMemorySize (\nfpga_properties prop,\nuint64_t lms\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_DEVICE </li> <li><code>lms</code> Local memory size of the FPGA resource </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetmodel","title":"function fpgaPropertiesSetModel","text":"<p>Set the model of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetModel (\nfpga_properties prop,\nchar * model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_DEVICE </li> <li><code>model</code> Model of the FPGA resource (string of maximum FPGA_MODEL_LENGTH length </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetnumerrors","title":"function fpgaPropertiesSetNumErrors","text":"<p>Set the number of error registers. <pre><code>fpga_result fpgaPropertiesSetNumErrors (\nconst fpga_properties prop,\nuint32_t num_errors\n) </code></pre></p> <p>Set the number of error registers understood by a resource to enumerate.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>num_errors</code> Number of errors </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetnuminterrupts","title":"function fpgaPropertiesSetNumInterrupts","text":"<p>Set the number of interrupts. <pre><code>fpga_result fpgaPropertiesSetNumInterrupts (\nfpga_properties prop,\nuint32_t num_interrupts\n) </code></pre></p> <p>Sets the number of interrupts of an accelerator properties structure.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_ACCELERATOR </li> <li><code>num_interrupts</code> Number of interrupts of the accelerator </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetnummmio","title":"function fpgaPropertiesSetNumMMIO","text":"<p>Set the number of mmio spaces. <pre><code>fpga_result fpgaPropertiesSetNumMMIO (\nfpga_properties prop,\nuint32_t mmio_spaces\n) </code></pre></p> <p>Sets the number of mmio spaces of an AFU properties structure.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_ACCELERATOR </li> <li><code>mmio_spaces</code> Number of MMIO spaces of the accelerator </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetnumslots","title":"function fpgaPropertiesSetNumSlots","text":"<p>Set the number of slots of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetNumSlots (\nfpga_properties prop,\nuint32_t num_slots\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_DEVICE </li> <li><code>num_slots</code> Number of slots of the FPGA </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetobjectid","title":"function fpgaPropertiesSetObjectID","text":"<p>Set the object ID of a resource. <pre><code>fpga_result fpgaPropertiesSetObjectID (\nconst fpga_properties prop,\nuint64_t object_id\n) </code></pre></p> <p>Sets the object ID of a resource. The object ID is a 64 bit identifier that is unique within a single node or system. It represents a similar concept as the token, but can be used across processes (e.g. passed on the command line).</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to query </li> <li><code>object_id</code> A 64bit value to use as the object ID </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetobjecttype","title":"function fpgaPropertiesSetObjectType","text":"<p>Set the object type of a resource. <pre><code>fpga_result fpgaPropertiesSetObjectType (\nfpga_properties prop,\nfpga_objtype objtype\n) </code></pre></p> <p>Sets the object type of the resource. * Currently supported object types are FPGA_DEVICE and FPGA_ACCELERATOR.</p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>objtype</code> Object type of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetparent","title":"function fpgaPropertiesSetParent","text":"<p>Set the token of the parent object. <pre><code>fpga_result fpgaPropertiesSetParent (\nfpga_properties prop,\nfpga_token parent\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>parent</code> Pointer to a token variable of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetsegment","title":"function fpgaPropertiesSetSegment","text":"<p>Set the PCI segment number of a resource. <pre><code>fpga_result fpgaPropertiesSetSegment (\nfpga_properties prop,\nuint16_t segment\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>segment</code> PCI segment number of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetsocketid","title":"function fpgaPropertiesSetSocketID","text":"<p>Set the socket id of the resource. <pre><code>fpga_result fpgaPropertiesSetSocketID (\nfpga_properties prop,\nuint8_t socket_id\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>socket_id</code> Socket id of the resource 'prop' is associated with </li> </ul> <p>Returns:</p> <p>See \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetsubsystemdeviceid","title":"function fpgaPropertiesSetSubsystemDeviceID","text":"<p>Set the subsystem device id of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetSubsystemDeviceID (\nfpga_properties prop,\nuint16_t subsystem_device_id\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>subsystem_device_id</code> Subsystem Device id of the FPGA resource </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetsubsystemvendorid","title":"function fpgaPropertiesSetSubsystemVendorID","text":"<p>Set the subsystem vendor id of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetSubsystemVendorID (\nfpga_properties prop,\nuint16_t subsystem_vendor_id\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify </li> <li><code>subsystem_vendor_id</code> Subsystem Vendor id of the FPGA resource </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. See also \"Accessor Return Values\" in properties.h. </p>"},{"location":"opae-code/properties_8h/#function-fpgapropertiessetvendorid","title":"function fpgaPropertiesSetVendorID","text":"<p>Set the vendor id of an FPGA resource property. <pre><code>fpga_result fpgaPropertiesSetVendorID (\nfpga_properties prop,\nuint16_t vendor_id\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>prop</code> Properties object to modify - must be of type FPGA_DEVICE </li> <li><code>vendor_id</code> Vendor id of the FPGA resource </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also \"Accessor Return Values\" in properties.h.</p> <p>Note:</p> <p>This API is not currently supported. </p>"},{"location":"opae-code/properties_8h/#function-fpgaupdateproperties","title":"function fpgaUpdateProperties","text":"<p>Update a fpga_properties object. <pre><code>fpga_result fpgaUpdateProperties (\nfpga_token token,\nfpga_properties prop\n) </code></pre></p> <p>Populates the properties object 'prop' with properties of the resource referred to by 'token'. Unlike fpgaGetProperties(), this call will not create a new properties object or allocate memory for it, but use a previously created properties object.</p> <p>Parameters:</p> <ul> <li><code>token</code> Token to retrieve properties for </li> <li><code>prop</code> fpga_properties object to update </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if <code>token</code> or <code>prop</code> are not valid objects. FPGA_NOT_FOUND if the resource referred to by <code>token</code> was not found. FPGA_NO_DRIVER if not driver is loaded. FPGA_EXCEPTION if an internal exception occured when trying to update <code>prop</code>. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/properties.h</code></p>"},{"location":"opae-code/properties_8h_source/","title":"File properties.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; properties.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017-2021, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_PROPERTIES_H__\n#define __FPGA_PROPERTIES_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaGetPropertiesFromHandle(fpga_handle handle, fpga_properties *prop);\nfpga_result fpgaGetProperties(fpga_token token, fpga_properties *prop);\nfpga_result fpgaUpdateProperties(fpga_token token, fpga_properties prop);\nfpga_result fpgaClearProperties(fpga_properties prop);\nfpga_result fpgaCloneProperties(fpga_properties src, fpga_properties *dst);\nfpga_result fpgaDestroyProperties(fpga_properties *prop);\nfpga_result fpgaPropertiesGetParent(const fpga_properties prop,\nfpga_token *parent);\nfpga_result fpgaPropertiesSetParent(fpga_properties prop,\nfpga_token parent);\nfpga_result fpgaPropertiesGetObjectType(const fpga_properties prop,\nfpga_objtype *objtype);\nfpga_result fpgaPropertiesSetObjectType(fpga_properties prop,\nfpga_objtype objtype);\nfpga_result fpgaPropertiesGetSegment(const fpga_properties prop, uint16_t *segment);\nfpga_result fpgaPropertiesSetSegment(fpga_properties prop, uint16_t segment);\nfpga_result fpgaPropertiesGetBus(const fpga_properties prop, uint8_t *bus);\nfpga_result fpgaPropertiesSetBus(fpga_properties prop, uint8_t bus);\nfpga_result fpgaPropertiesGetDevice(const fpga_properties prop,\nuint8_t *device);\nfpga_result fpgaPropertiesSetDevice(fpga_properties prop,\nuint8_t device);\nfpga_result fpgaPropertiesGetFunction(const fpga_properties prop,\nuint8_t *function);\nfpga_result fpgaPropertiesSetFunction(fpga_properties prop,\nuint8_t function);\nfpga_result fpgaPropertiesGetSocketID(const fpga_properties prop,\nuint8_t *socket_id);\nfpga_result fpgaPropertiesSetSocketID(fpga_properties prop,\nuint8_t socket_id);\nfpga_result fpgaPropertiesGetDeviceID(const fpga_properties prop,\nuint16_t *device_id);\nfpga_result fpgaPropertiesSetDeviceID(fpga_properties prop,\nuint16_t device_id);\nfpga_result fpgaPropertiesGetNumSlots(const fpga_properties prop,\nuint32_t *num_slots);\nfpga_result fpgaPropertiesSetNumSlots(fpga_properties prop,\nuint32_t num_slots);\nfpga_result fpgaPropertiesGetBBSID(const fpga_properties prop,\nuint64_t *bbs_id);\nfpga_result fpgaPropertiesSetBBSID(fpga_properties prop,\nuint64_t bbs_id);\nfpga_result fpgaPropertiesGetBBSVersion(const fpga_properties prop,\nfpga_version *bbs_version);\nfpga_result fpgaPropertiesSetBBSVersion(fpga_properties prop,\nfpga_version version);\nfpga_result fpgaPropertiesGetVendorID(const fpga_properties prop,\nuint16_t *vendor_id);\nfpga_result fpgaPropertiesSetVendorID(fpga_properties prop,\nuint16_t vendor_id);\nfpga_result fpgaPropertiesGetModel(const fpga_properties prop,\nchar *model);\nfpga_result fpgaPropertiesSetModel(fpga_properties prop,\nchar *model);\nfpga_result fpgaPropertiesGetLocalMemorySize(const fpga_properties prop,\nuint64_t *lms);\nfpga_result fpgaPropertiesSetLocalMemorySize(fpga_properties prop,\nuint64_t lms);\nfpga_result fpgaPropertiesGetCapabilities(const fpga_properties prop,\nuint64_t *capabilities);\nfpga_result fpgaPropertiesSetCapabilities(fpga_properties prop,\nuint64_t capabilities);\nfpga_result fpgaPropertiesGetGUID(const fpga_properties prop,\nfpga_guid *guid);\nfpga_result fpgaPropertiesSetGUID(fpga_properties prop, fpga_guid guid);\nfpga_result fpgaPropertiesGetNumMMIO(const fpga_properties prop,\nuint32_t *mmio_spaces);\nfpga_result fpgaPropertiesSetNumMMIO(fpga_properties prop,\nuint32_t mmio_spaces);\nfpga_result fpgaPropertiesGetNumInterrupts(const fpga_properties prop,\nuint32_t *num_interrupts);\nfpga_result fpgaPropertiesSetNumInterrupts(fpga_properties prop,\nuint32_t num_interrupts);\nfpga_result fpgaPropertiesGetAcceleratorState(const fpga_properties prop,\nfpga_accelerator_state *state);\nfpga_result fpgaPropertiesSetAcceleratorState(fpga_properties prop,\nfpga_accelerator_state state);\nfpga_result fpgaPropertiesGetObjectID(const fpga_properties prop,\nuint64_t *object_id);\nfpga_result fpgaPropertiesSetObjectID(const fpga_properties prop,\nuint64_t object_id);\nfpga_result fpgaPropertiesGetNumErrors(const fpga_properties prop,\nuint32_t *num_errors);\nfpga_result fpgaPropertiesSetNumErrors(const fpga_properties prop,\nuint32_t num_errors);\nfpga_result fpgaPropertiesGetInterface(const fpga_properties prop,\nfpga_interface *interface);\nfpga_result fpgaPropertiesSetInterface(const fpga_properties prop,\nfpga_interface interface);\nfpga_result fpgaPropertiesGetSubsystemVendorID(const fpga_properties prop,\nuint16_t *subsystem_vendor_id);\nfpga_result fpgaPropertiesSetSubsystemVendorID(fpga_properties prop,\nuint16_t subsystem_vendor_id);\nfpga_result fpgaPropertiesGetSubsystemDeviceID(const fpga_properties prop,\nuint16_t *subsystem_device_id);\nfpga_result fpgaPropertiesSetSubsystemDeviceID(fpga_properties prop,\nuint16_t subsystem_device_id);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_PROPERTIES_H__\n</code></pre>"},{"location":"opae-code/sysobject_8h/","title":"File sysobject.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; sysobject.h</p> <p>Go to the source code of this file.</p> <p>Functions to read/write from system objects. More...</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/sysobject_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaDestroyObject (fpga_object * obj) Free memory used for the fpga_object data structure. fpga_result fpgaHandleGetObject (fpga_handle handle, const char * name, fpga_object * object, int flags) Create an <code>fpga_object</code> data structure from a handle. fpga_result fpgaObjectGetObject (fpga_object parent, const char * name, fpga_object * object, int flags) Create an <code>fpga_object</code> data structure from a parent object. fpga_result fpgaObjectGetObjectAt (fpga_object parent, size_t idx, fpga_object * object) Create an <code>fpga_object</code> data structure from a parent object using a given index. fpga_result fpgaObjectGetSize (fpga_object obj, uint32_t * value, int flags) Retrieve the size of the object. fpga_result fpgaObjectGetType (fpga_object obj, enum fpga_sysobject_type * type) Get the sysobject type (container or attribute) fpga_result fpgaObjectRead (fpga_object obj, uint8_t * buffer, size_t offset, size_t len, int flags) Read bytes from an FPGA object. fpga_result fpgaObjectRead64 (fpga_object obj, uint64_t * value, int flags) Read a 64-bit value from an FPGA object. fpga_result fpgaObjectWrite64 (fpga_object obj, uint64_t value, int flags) Write 64-bit value to an FPGA object. fpga_result fpgaTokenGetObject (fpga_token token, const char * name, fpga_object * object, int flags) Create an <code>fpga_object</code> data structures."},{"location":"opae-code/sysobject_8h/#detailed-description","title":"Detailed Description","text":"<p>On Linux systems with the OPAE kernel driver, this is used to access sysfs nodes created by the driver. </p>"},{"location":"opae-code/sysobject_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/sysobject_8h/#function-fpgadestroyobject","title":"function fpgaDestroyObject","text":"<p>Free memory used for the fpga_object data structure. <pre><code>fpga_result fpgaDestroyObject (\nfpga_object * obj\n) </code></pre></p> <p>Note:</p> <p>fpgaDestroyObject() requires the address of an fpga_object as created by fpgaTokenGetObject(), fpgaHandleGetObject(), or fpgaObjectGetObject(). Passing any other value results in undefind behavior.</p> <p>Parameters:</p> <ul> <li><code>obj</code> Pointer to the fpga_object instance to destroy</li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if the object is NULL, FPGA_EXCEPTION if an internal error is encountered. </p>"},{"location":"opae-code/sysobject_8h/#function-fpgahandlegetobject","title":"function fpgaHandleGetObject","text":"<p>Create an <code>fpga_object</code> data structure from a handle. <pre><code>fpga_result fpgaHandleGetObject (\nfpga_handle handle,\nconst char * name,\nfpga_object * object,\nint flags\n) </code></pre></p> <p>An <code>fpga_object</code> is a handle to an FPGA resource which can be an attribute, register, or container. This object has read/write access..</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle identifying a resource (accelerator or device) </li> <li><code>name</code> A key identifying an object belonging to a resource. </li> <li><code>object</code> Pointer to memory to store the object in </li> <li><code>flags</code> Control behavior of object identification and creation FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API.</p> <p>Note:</p> <p>Names that begin with '.' or '/' or contain '..' are not allowed and result in FPGA_INVALID_PARAM being returned </p>"},{"location":"opae-code/sysobject_8h/#function-fpgaobjectgetobject","title":"function fpgaObjectGetObject","text":"<p>Create an <code>fpga_object</code> data structure from a parent object. <pre><code>fpga_result fpgaObjectGetObject (\nfpga_object parent,\nconst char * name,\nfpga_object * object,\nint flags\n) </code></pre></p> <p>An <code>fpga_object</code> is a handle to an FPGA resource which can be an attribute, register, or container. If the parent object was created with a handle, then the new object will inherit the handle allowing it to have read-write access to the object data.</p> <p>Parameters:</p> <ul> <li><code>parent</code> A parent container <code>fpga_object</code>. </li> <li><code>name</code> A key identifying a sub-object of the parent container. </li> <li><code>object</code> Pointer to memory to store the object in. </li> <li><code>flags</code> Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid - this includes a parent object that is not a container object. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API.</p> <p>Note:</p> <p>Names that begin with '.' or '/' or contain '..' are not allowed and result in FPGA_INVALID_PARAM being returned </p>"},{"location":"opae-code/sysobject_8h/#function-fpgaobjectgetobjectat","title":"function fpgaObjectGetObjectAt","text":"<p>Create an <code>fpga_object</code> data structure from a parent object using a given index. <pre><code>fpga_result fpgaObjectGetObjectAt (\nfpga_object parent,\nsize_t idx,\nfpga_object * object\n) </code></pre></p> <p>An <code>fpga_object</code> is a handle to an FPGA resource which can be an attribute, register, or container. If the parent object was created with a handle, then the new object will inherit the handle allowing it to have read-write access to the object data.</p> <p>Parameters:</p> <ul> <li><code>parent</code> A parent container 'fpga_object' </li> <li><code>idx</code> A positive index less than the size reported by the parent. </li> <li><code>object</code> Pointer to memory to store the object in.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid - this includes a parent object that is not a container object. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API. </p>"},{"location":"opae-code/sysobject_8h/#function-fpgaobjectgetsize","title":"function fpgaObjectGetSize","text":"<p>Retrieve the size of the object. <pre><code>fpga_result fpgaObjectGetSize (\nfpga_object obj,\nuint32_t * value,\nint flags\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>obj</code> An fpga_object instance. </li> <li><code>value</code> Pointer to variable to store size in. </li> <li><code>flags</code> Flags that control how the object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the size.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of supplied parameters is invalid. FPGA_EXCEPTION if error occurred. </p>"},{"location":"opae-code/sysobject_8h/#function-fpgaobjectgettype","title":"function fpgaObjectGetType","text":"<p>Get the sysobject type (container or attribute) <pre><code>fpga_result fpgaObjectGetType (\nfpga_object obj,\nenum fpga_sysobject_type * type\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>obj</code> An fpga_object instance </li> <li><code>type</code> The type of object (FPGA_OBJECT_CONTAINER or FPGA_OBJECT_ATTRIBUTE)</li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters are null or invalid </p>"},{"location":"opae-code/sysobject_8h/#function-fpgaobjectread","title":"function fpgaObjectRead","text":"<p>Read bytes from an FPGA object. <pre><code>fpga_result fpgaObjectRead (\nfpga_object obj,\nuint8_t * buffer,\nsize_t offset,\nsize_t len,\nint flags\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>obj</code> An fpga_object instance. </li> <li><code>buffer</code> Pointer to a buffer to read bytes into. </li> <li><code>offset</code> Byte offset relative to objects internal buffer where to begin reading bytes from. </li> <li><code>len</code> The length, in bytes, to read from the object. </li> <li><code>flags</code> Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters is invalid </p>"},{"location":"opae-code/sysobject_8h/#function-fpgaobjectread64","title":"function fpgaObjectRead64","text":"<p>Read a 64-bit value from an FPGA object. <pre><code>fpga_result fpgaObjectRead64 (\nfpga_object obj,\nuint64_t * value,\nint flags\n) </code></pre></p> <p>The value is assumed to be in string format and will be parsed. See flags below for changing that behavior.</p> <p>Parameters:</p> <ul> <li><code>obj</code> An fpga_object instance </li> <li><code>value</code> Pointer to a 64-bit variable to store the value in </li> <li><code>flags</code> Flags that control how the object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data. If FPGA_OBJECT_RAW is used, then the data will be read as raw bytes into the uint64_t pointer variable.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters is invalid </p>"},{"location":"opae-code/sysobject_8h/#function-fpgaobjectwrite64","title":"function fpgaObjectWrite64","text":"<p>Write 64-bit value to an FPGA object. <pre><code>fpga_result fpgaObjectWrite64 (\nfpga_object obj,\nuint64_t value,\nint flags\n) </code></pre></p> <p>The value will be converted to string before writing. See flags below for changing that behavior.</p> <p>Parameters:</p> <ul> <li><code>obj</code> An fpga_object instance. </li> <li><code>value</code> The value to write to the object </li> <li><code>flags</code> Flags that control how the object is written If FPGA_OBJECT_RAW is used, then the value will be written as raw bytes.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success, FPGA_INVALID_PARAM if any of the supplied parameters is invalid</p> <p>Note:</p> <p>The object must have been created using a handle to a resource. </p>"},{"location":"opae-code/sysobject_8h/#function-fpgatokengetobject","title":"function fpgaTokenGetObject","text":"<p>Create an <code>fpga_object</code> data structures. <pre><code>fpga_result fpgaTokenGetObject (\nfpga_token token,\nconst char * name,\nfpga_object * object,\nint flags\n) </code></pre></p> <p>An <code>fpga_object</code> is a handle to an FPGA resource which can be an attribute, register or a container. This object is read-only.</p> <p>Parameters:</p> <ul> <li><code>token</code> Token identifying a resource (accelerator or device) </li> <li><code>name</code> A key identifying an object belonging to a resource. </li> <li><code>object</code> Pointer to memory to store the object in </li> <li><code>flags</code> Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.</li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if any of the supplied parameters is invalid. FPGA_NOT_FOUND if an object cannot be found with the given key. FPGA_NOT_SUPPORTED if this function is not supported by the current implementation of this API.</p> <p>Note:</p> <p>Names that begin with '.' or '/' or contain '..' are not allowed and result in FPGA_INVALID_PARAM being returned </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/sysobject.h</code></p>"},{"location":"opae-code/sysobject_8h_source/","title":"File sysobject.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; sysobject.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017-2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_SYSOBJECT_H__\n#define __FPGA_SYSOBJECT_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaTokenGetObject(fpga_token token, const char *name,\nfpga_object *object, int flags);\nfpga_result fpgaHandleGetObject(fpga_handle handle, const char *name,\nfpga_object *object, int flags);\nfpga_result fpgaObjectGetObject(fpga_object parent, const char *name,\nfpga_object *object, int flags);\nfpga_result fpgaObjectGetObjectAt(fpga_object parent, size_t idx,\nfpga_object *object);\nfpga_result fpgaObjectGetType(fpga_object obj, enum fpga_sysobject_type *type);\nfpga_result fpgaDestroyObject(fpga_object *obj);\nfpga_result fpgaObjectGetSize(fpga_object obj, uint32_t *value, int flags);\nfpga_result fpgaObjectRead(fpga_object obj, uint8_t *buffer, size_t offset,\nsize_t len, int flags);\nfpga_result fpgaObjectRead64(fpga_object obj, uint64_t *value, int flags);\nfpga_result fpgaObjectWrite64(fpga_object obj, uint64_t value, int flags);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif /* !__FPGA_SYSOBJECT_H__ */\n</code></pre>"},{"location":"opae-code/types_8h/","title":"File types.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; types.h</p> <p>Go to the source code of this file.</p> <p>Type definitions for FPGA API. More...</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;opae/types_enum.h&gt;</code></li> </ul>"},{"location":"opae-code/types_8h/#classes","title":"Classes","text":"Type Name struct _fpga_token_header Internal token type header. struct fpga_error_info struct fpga_metric Metric struct. struct fpga_metric_info Metric info struct. struct fpga_version Semantic version. struct metric_threshold struct threshold Threshold struct."},{"location":"opae-code/types_8h/#public-types","title":"Public Types","text":"Type Name typedef void * fpga_event_handle Handle to an event object. typedef uint8_t fpga_guid Globally unique identifier (GUID) typedef void * fpga_handle Handle to an FPGA resource. typedef struct fpga_metric fpga_metric Metric struct. typedef struct fpga_metric_info fpga_metric_info Metric info struct. typedef void * fpga_object Object pertaining to an FPGA resource as identified by a unique name. typedef void * fpga_properties Object for expressing FPGA resource properties. typedef void * fpga_token Token for referencing FPGA resources. typedef struct _fpga_token_header fpga_token_header Internal token type header. typedef struct metric_threshold metric_threshold union metric_value Metric value union. typedef struct threshold threshold Threshold struct."},{"location":"opae-code/types_8h/#macros","title":"Macros","text":"Type Name define FPGA_ERROR_NAME_MAX  64Information about an error register. define FPGA_METRIC_STR_SIZE  256FPGA Metric string size. define fpga_is_parent_child (__parent_hdr, __child_hdr) Determine token parent/child relationship."},{"location":"opae-code/types_8h/#detailed-description","title":"Detailed Description","text":"<p>OPAE uses the three opaque types fpga_properties, fpga_token, and fpga_handle to create a hierarchy of objects that can be used to enumerate, reference, acquire, and query FPGA resources. This object model is designed to be extensible to account for different FPGA architectures and platforms.</p>"},{"location":"opae-code/types_8h/#initialization","title":"Initialization","text":"<p>OPAEs management of the opaque types <code>fpga_properties</code>, <code>fpga_token</code>, and <code>fpga_handle</code> relies on the proper initialization of variables of these types. In other words, before doing anything with a variable of one of these opaque types, you need to first initialize them.</p> <p>The respective functions that initialize opaque types are:</p> <ul> <li>fpgaGetProperties() and fpgaCloneProperties() for <code>fpga_properties</code></li> <li>fpgaEnumerate() and fpgaCloneToken() for <code>fpga_token</code></li> <li>fpgaOpen() for <code>fpga_handle</code></li> </ul> <p>This should intuitively make sense - fpgaGetProperties() creates <code>fpga_properties</code> objects, fpgaEnumerate() creates <code>fpga_token</code> objects, fpgaOpen() creates <code>fpga_handle</code> objects, and fpgaCloneProperties() and fpgaCloneToken() clone (create) <code>fpga_properties</code> and <code>fpga_token</code> objects, respectively.</p> <p>Since these opaque types are interpreted as pointers (they are typedef'd to a <code>void *</code>), passing an uninitialized opaque type into any function except the respective initailzation function will result in undefined behaviour, because OPAE will try to follow an invalid pointer. Undefined behaviour in this case may include an unexpected error code, or an application crash. </p>"},{"location":"opae-code/types_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/types_8h/#typedef-fpga_event_handle","title":"typedef fpga_event_handle","text":"<p>Handle to an event object. <pre><code>typedef void* fpga_event_handle;\n</code></pre></p> <p>OPAE provides an interface to asynchronous events that can be generated by different FPGA resources. The event API provides functions to register for these events; associated with every event a process has registered for is an <code>fpga_event_handle</code>, which encapsulates the OS-specific data structure for event objects.</p> <p>After use, <code>fpga_event_handle</code> objects should be destroyed using fpgaDestroyEventHandle() to free backing memory used by the <code>fpga_event_handle</code> object. </p>"},{"location":"opae-code/types_8h/#typedef-fpga_guid","title":"typedef fpga_guid","text":"<p>Globally unique identifier (GUID) <pre><code>typedef uint8_t fpga_guid[16];\n</code></pre></p> <p>GUIDs are used widely within OPAE for helping identify FPGA resources. For example, every FPGA resource has a <code>guid</code> property, which can be (and in the case of FPGA_ACCELERATOR resource primarily is) used for enumerating a resource of a specific type.</p> <p><code>fpga_guid</code> is compatible with libuuid's uuid_t, so users can use libuuid functions like uuid_parse() to create and work with GUIDs. </p>"},{"location":"opae-code/types_8h/#typedef-fpga_handle","title":"typedef fpga_handle","text":"<p>Handle to an FPGA resource. <pre><code>typedef void* fpga_handle;\n</code></pre></p> <p>A valid <code>fpga_handle</code> object, as populated by fpgaOpen(), denotes ownership of an FPGA resource. Note that ownership can be exclusive or shared, depending on the flags used in fpgaOpen(). Ownership can be released by calling fpgaClose(), which will render the underlying handle invalid.</p> <p>Many OPAE C API functions require a valid token (which is synonymous with ownership of the resource). </p>"},{"location":"opae-code/types_8h/#typedef-fpga_metric","title":"typedef fpga_metric","text":"<pre><code>typedef struct fpga_metric fpga_metric;\n</code></pre>"},{"location":"opae-code/types_8h/#typedef-fpga_metric_info","title":"typedef fpga_metric_info","text":"<pre><code>typedef struct fpga_metric_info fpga_metric_info;\n</code></pre>"},{"location":"opae-code/types_8h/#typedef-fpga_object","title":"typedef fpga_object","text":"<p>Object pertaining to an FPGA resource as identified by a unique name. <pre><code>typedef void* fpga_object;\n</code></pre></p> <p>An <code>fpga_object</code> represents either a device attribute or a container of attributes. Similar to filesystems, a '/' may be used to seperate objects in an object hierarchy. Once on object is acquired, it may be used to read or write data in a resource attribute or to query sub-objects if the object is a container object. The data in an object is buffered and will be kept around until the object is destroyed. Additionally, the data in an attribute can by synchronized from the owning resource using the FPGA_OBJECT_SYNC flag during read operations. The name identifying the object is unique with respect to the resource that owns it. A parent resource may be identified by an <code>fpga_token</code> object, by an <code>fpga_handle</code> object, or another <code>fpga_object</code> object. If a handle object is used when opening the object, then the object is opened with read-write access. Otherwise, the object is read-only. </p>"},{"location":"opae-code/types_8h/#typedef-fpga_properties","title":"typedef fpga_properties","text":"<p>Object for expressing FPGA resource properties. <pre><code>typedef void* fpga_properties;\n</code></pre></p> <p><code>fpga_properties</code> objects encapsulate all enumerable information about an FPGA resources. They can be used for two purposes: selective enumeration (discovery) and querying information about existing resources.</p> <p>For selective enumeration, usually an empty <code>fpga_properties</code> object is created (using fpgaGetProperties()) and then populated with the desired criteria for enumeration. An array of <code>fpga_properties</code> can then be passed to fpgaEnumerate(), which will return a list of <code>fpga_token</code> objects matching these criteria.</p> <p>For querying properties of existing FPGA resources, fpgaGetProperties() can also take an <code>fpga_token</code> and will return an <code>fpga_properties</code> object populated with information about the resource referenced by that token.</p> <p>After use, <code>fpga_properties</code> objects should be destroyed using fpga_destroyProperties() to free backing memory used by the <code>fpga_properties</code> object. </p>"},{"location":"opae-code/types_8h/#typedef-fpga_token","title":"typedef fpga_token","text":"<p>Token for referencing FPGA resources. <pre><code>typedef void* fpga_token;\n</code></pre></p> <p>An <code>fpga_token</code> serves as a reference to a specific FPGA resource present in the system. Holding an <code>fpga_token</code> does not constitute ownership of the FPGA resource - it merely allows the user to query further information about a resource, or to use fpgaOpen() to acquire ownership.</p> <p><code>fpga_token</code>s are usually returned by fpgaEnumerate() or fpgaPropertiesGetParent(), and used by fpgaOpen() to acquire ownership and yield a handle to the resource. Some API calls also take <code>fpga_token</code>s as arguments if they don't require ownership of the resource in question. </p>"},{"location":"opae-code/types_8h/#typedef-fpga_token_header","title":"typedef fpga_token_header","text":"<p>Internal token type header. <pre><code>typedef struct _fpga_token_header fpga_token_header;\n</code></pre></p> <p>Each plugin (dfl: libxfpga.so, vfio: libopae-v.so) implements its own proprietary token type. This header must appear at offset zero within that structure.</p> <p>eg, see lib/plugins/xfpga/types_int.h:struct _fpga_token and lib/plugins/vfio/opae_vfio.h:struct _vfio_token. </p>"},{"location":"opae-code/types_8h/#typedef-metric_threshold","title":"typedef metric_threshold","text":"<pre><code>typedef struct metric_threshold metric_threshold;\n</code></pre>"},{"location":"opae-code/types_8h/#union-metric_value","title":"union metric_value","text":""},{"location":"opae-code/types_8h/#typedef-threshold","title":"typedef threshold","text":"<pre><code>typedef struct threshold threshold;\n</code></pre>"},{"location":"opae-code/types_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"opae-code/types_8h/#define-fpga_error_name_max","title":"define FPGA_ERROR_NAME_MAX","text":"<p>Information about an error register. <pre><code>#define FPGA_ERROR_NAME_MAX 64\n</code></pre></p> <p>This data structure captures information about an error register exposed by an accelerator resource. The error API provides functions to retrieve these information structures from a particular resource. </p>"},{"location":"opae-code/types_8h/#define-fpga_metric_str_size","title":"define FPGA_METRIC_STR_SIZE","text":"<pre><code>#define FPGA_METRIC_STR_SIZE 256\n</code></pre>"},{"location":"opae-code/types_8h/#define-fpga_is_parent_child","title":"define fpga_is_parent_child","text":"<p>Determine token parent/child relationship. <pre><code>#define fpga_is_parent_child (\n__parent_hdr,\n__child_hdr\n) (((__parent_hdr)-&gt;objtype == FPGA_DEVICE ) &amp;&amp; \\\n ((__child_hdr)-&gt;objtype == FPGA_ACCELERATOR ) &amp;&amp; \\\n ((__parent_hdr)-&gt;segment == (__child_hdr)-&gt;segment) &amp;&amp; \\\n ((__parent_hdr)-&gt;bus == (__child_hdr)-&gt;bus) &amp;&amp; \\\n ((__parent_hdr)-&gt;device == (__child_hdr)-&gt;device))\n</code></pre></p> <p>Given pointers to two fpga_token_header structs, determine whether the first is the parent of the second. A parent will have objtype == FPGA_DEVICE. A child will have objtype == FPGA_ACCELERATOR. The PCIe address of the two headers will match in all but the function fields. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types.h</code></p>"},{"location":"opae-code/types_8h_source/","title":"File types.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; types.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018-2022, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_TYPES_H__\n#define __FPGA_TYPES_H__\n#include &lt;stdint.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;opae/types_enum.h&gt;\ntypedef void *fpga_properties;\ntypedef void *fpga_token;\ntypedef void *fpga_handle;\ntypedef uint8_t fpga_guid[16];\ntypedef struct {\nuint8_t major;        uint8_t minor;        uint16_t patch;       } fpga_version;\ntypedef void *fpga_event_handle;\n#define FPGA_ERROR_NAME_MAX 64\nstruct fpga_error_info {\nchar name[FPGA_ERROR_NAME_MAX];   bool can_clear;                   };\ntypedef void *fpga_object;\n#define FPGA_METRIC_STR_SIZE   256\ntypedef union {\nuint64_t   ivalue;  // Metric integer value\ndouble     dvalue;  // Metric double value\nfloat      fvalue;  // Metric float value\nbool       bvalue;  // Metric bool value\n} metric_value;\ntypedef struct fpga_metric_info {\nuint64_t metric_num;                         // Metric index num\nfpga_guid metric_guid;                       // Metric guid\nchar qualifier_name[FPGA_METRIC_STR_SIZE];   // Metric full name\nchar group_name[FPGA_METRIC_STR_SIZE];       // Metric group name\nchar metric_name[FPGA_METRIC_STR_SIZE];      // Metric name\nchar metric_units[FPGA_METRIC_STR_SIZE];     // Metric units\nenum fpga_metric_datatype metric_datatype;   // Metric data type\nenum fpga_metric_type metric_type;           // Metric group type\n} fpga_metric_info;\ntypedef struct fpga_metric {\nuint64_t metric_num;    // Metric index num\nmetric_value value;     // Metric value\nbool isvalid;           // Metric value is valid\n} fpga_metric;\ntypedef struct threshold {\nchar threshold_name[FPGA_METRIC_STR_SIZE]; // Threshold name\nuint32_t is_valid;                         // Threshold is valid\ndouble value;                              // Threshold value\n} threshold;\ntypedef struct metric_threshold {\nchar metric_name[FPGA_METRIC_STR_SIZE];        // Metric Threshold name\nthreshold upper_nr_threshold;                  // Upper Non-Recoverable Threshold\nthreshold upper_c_threshold;                   // Upper Critical Threshold\nthreshold upper_nc_threshold;                  // Upper Non-Critical Threshold\nthreshold lower_nr_threshold;                  // Lower Non-Recoverable Threshold\nthreshold lower_c_threshold;                   // Lower Critical Threshold\nthreshold lower_nc_threshold;                  // Lower Non-Critical Threshold\nthreshold hysteresis;                          // Hysteresis\n} metric_threshold;\ntypedef struct _fpga_token_header {\nuint64_t magic;\nuint16_t vendor_id;\nuint16_t device_id;\nuint16_t segment;\nuint8_t bus;\nuint8_t device;\nuint8_t function;\nfpga_interface interface;\nfpga_objtype objtype;\nuint64_t object_id;\nfpga_guid guid;\nuint16_t subsystem_vendor_id;\nuint16_t subsystem_device_id;\n} fpga_token_header;\n#define fpga_is_parent_child(__parent_hdr, __child_hdr) \\\n(((__parent_hdr)-&gt;objtype == FPGA_DEVICE) &amp;&amp; \\\n ((__child_hdr)-&gt;objtype == FPGA_ACCELERATOR) &amp;&amp; \\\n ((__parent_hdr)-&gt;segment == (__child_hdr)-&gt;segment) &amp;&amp; \\\n ((__parent_hdr)-&gt;bus == (__child_hdr)-&gt;bus) &amp;&amp; \\\n ((__parent_hdr)-&gt;device == (__child_hdr)-&gt;device))\n#endif // __FPGA_TYPES_H__\n</code></pre>"},{"location":"opae-code/types__enum_8h/","title":"File types_enum.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; types_enum.h</p> <p>Go to the source code of this file.</p> <p>Definitions of enumerated types for the OPAE C API. More...</p>"},{"location":"opae-code/types__enum_8h/#public-types","title":"Public Types","text":"Type Name enum fpga_accelerator_state accelerator state enum fpga_buffer_flags Buffer flags. enum fpga_event_type FPGA events. enum fpga_interface OPAE plugin interface. enum fpga_metric_datatype Metrics data type. enum fpga_metric_type fpga metrics types opae defines power,thermal, performance counter and afu metric types enum fpga_objtype OPAE FPGA resources (objects) enum fpga_open_flags Open flags. enum fpga_reconf_flags Reconfiguration flags. enum fpga_result OPAE C API function return codes. enum fpga_sysobject_flags enum fpga_sysobject_type"},{"location":"opae-code/types__enum_8h/#detailed-description","title":"Detailed Description","text":"<p>This file defines return and error codes, event and object types, states, and flags as used or reported by OPAE C API functions. </p>"},{"location":"opae-code/types__enum_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/types__enum_8h/#enum-fpga_accelerator_state","title":"enum fpga_accelerator_state","text":"<pre><code>enum fpga_accelerator_state {\nFPGA_ACCELERATOR_ASSIGNED = 0,\nFPGA_ACCELERATOR_UNASSIGNED\n};\n</code></pre>"},{"location":"opae-code/types__enum_8h/#enum-fpga_buffer_flags","title":"enum fpga_buffer_flags","text":"<p>Buffer flags. <pre><code>enum fpga_buffer_flags {\nFPGA_BUF_PREALLOCATED = (1u &lt;&lt; 0),\nFPGA_BUF_QUIET = (1u &lt;&lt; 1),\nFPGA_BUF_READ_ONLY = (1u &lt;&lt; 2)\n};\n</code></pre></p> <p>These flags can be passed to the fpgaPrepareBuffer() function. </p>"},{"location":"opae-code/types__enum_8h/#enum-fpga_event_type","title":"enum fpga_event_type","text":"<p>FPGA events. <pre><code>enum fpga_event_type {\nFPGA_EVENT_INTERRUPT = 0,\nFPGA_EVENT_ERROR,\nFPGA_EVENT_POWER_THERMAL\n};\n</code></pre></p> <p>OPAE currently defines the following event types that applications can register for. Note that not all FPGA resources and target platforms may support all event types. </p>"},{"location":"opae-code/types__enum_8h/#enum-fpga_interface","title":"enum fpga_interface","text":"<p>OPAE plugin interface. <pre><code>enum fpga_interface {\nFPGA_IFC_DFL = 0,\nFPGA_IFC_VFIO,\nFPGA_IFC_SIM_DFL,\nFPGA_IFC_SIM_VFIO,\nFPGA_IFC_UIO\n};\n</code></pre></p> <p>These are the supported plugin interfaces. </p>"},{"location":"opae-code/types__enum_8h/#enum-fpga_metric_datatype","title":"enum fpga_metric_datatype","text":"<pre><code>enum fpga_metric_datatype {\nFPGA_METRIC_DATATYPE_INT,\nFPGA_METRIC_DATATYPE_FLOAT,\nFPGA_METRIC_DATATYPE_DOUBLE,\nFPGA_METRIC_DATATYPE_BOOL,\nFPGA_METRIC_DATATYPE_UNKNOWN\n};\n</code></pre>"},{"location":"opae-code/types__enum_8h/#enum-fpga_metric_type","title":"enum fpga_metric_type","text":"<pre><code>enum fpga_metric_type {\nFPGA_METRIC_TYPE_POWER,\nFPGA_METRIC_TYPE_THERMAL,\nFPGA_METRIC_TYPE_PERFORMANCE_CTR,\nFPGA_METRIC_TYPE_AFU,\nFPGA_METRIC_TYPE_UNKNOWN\n};\n</code></pre>"},{"location":"opae-code/types__enum_8h/#enum-fpga_objtype","title":"enum fpga_objtype","text":"<p>OPAE FPGA resources (objects) <pre><code>enum fpga_objtype {\nFPGA_DEVICE = 0,\nFPGA_ACCELERATOR\n};\n</code></pre></p> <p>These are the FPGA resources currently supported by the OPAE object model. </p>"},{"location":"opae-code/types__enum_8h/#enum-fpga_open_flags","title":"enum fpga_open_flags","text":"<p>Open flags. <pre><code>enum fpga_open_flags {\nFPGA_OPEN_SHARED = (1u &lt;&lt; 0)\n};\n</code></pre></p> <p>These flags can be passed to the fpgaOpen() function. </p>"},{"location":"opae-code/types__enum_8h/#enum-fpga_reconf_flags","title":"enum fpga_reconf_flags","text":"<p>Reconfiguration flags. <pre><code>enum fpga_reconf_flags {\nFPGA_RECONF_FORCE = (1u &lt;&lt; 0),\nFPGA_RECONF_SKIP_USRCLK = (1u &lt;&lt; 1)\n};\n</code></pre></p> <p>These flags can be passed to the fpgaReconfigureSlot() function. </p>"},{"location":"opae-code/types__enum_8h/#enum-fpga_result","title":"enum fpga_result","text":"<p>OPAE C API function return codes. <pre><code>enum fpga_result {\nFPGA_OK = 0,\nFPGA_INVALID_PARAM,\nFPGA_BUSY,\nFPGA_EXCEPTION,\nFPGA_NOT_FOUND,\nFPGA_NO_MEMORY,\nFPGA_NOT_SUPPORTED,\nFPGA_NO_DRIVER,\nFPGA_NO_DAEMON,\nFPGA_NO_ACCESS,\nFPGA_RECONF_ERROR\n};\n</code></pre></p> <p>Every public API function exported by the OPAE C library will return one of these codes. Usually, FPGA_OK denotes successful completion of the requested operation, while any return code other than FPGA_OK indicates an error or other deviation from the expected behavior. Users of the OPAE C API should always check the return codes of the APIs they call, and not use output parameters of functions that did not execute successfully.</p> <p>The fpgaErrStr() function converts error codes into printable messages.</p> <p>OPAE also has a logging mechanism that allows a developer to get more information about why a particular call failed with a specific message. If enabled, any function that returns an error code different from FPGA_OK will also print out a message with further details. This mechanism can be enabled by setting the environment variable <code>LIBOPAE_LOG</code> to 1 before running the respective application. </p>"},{"location":"opae-code/types__enum_8h/#enum-fpga_sysobject_flags","title":"enum fpga_sysobject_flags","text":"<pre><code>enum fpga_sysobject_flags {\nFPGA_OBJECT_SYNC = (1u &lt;&lt; 0),\nFPGA_OBJECT_GLOB = (1u &lt;&lt; 1),\nFPGA_OBJECT_RAW =\n(1u &lt;&lt; 2),\nFPGA_OBJECT_RECURSE_ONE =\n(1u\n&lt;&lt; 3),\nFPGA_OBJECT_RECURSE_ALL =\n(1u\n&lt;&lt; 4)\n};\n</code></pre>"},{"location":"opae-code/types__enum_8h/#enum-fpga_sysobject_type","title":"enum fpga_sysobject_type","text":"<pre><code>enum fpga_sysobject_type {\nFPGA_OBJECT_CONTAINER =\n(1u &lt;&lt; 0),\nFPGA_OBJECT_ATTRIBUTE =\n(1u &lt;&lt; 1)\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/types_enum.h</code></p>"},{"location":"opae-code/types__enum_8h_source/","title":"File types_enum.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; types_enum.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017-2022, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_TYPES_ENUM_H__\n#define __FPGA_TYPES_ENUM_H__\ntypedef enum {\nFPGA_OK = 0,         FPGA_INVALID_PARAM,  FPGA_BUSY,           FPGA_EXCEPTION,      FPGA_NOT_FOUND,      FPGA_NO_MEMORY,      FPGA_NOT_SUPPORTED,  FPGA_NO_DRIVER,      FPGA_NO_DAEMON,      FPGA_NO_ACCESS,      FPGA_RECONF_ERROR    } fpga_result;\ntypedef enum {\nFPGA_EVENT_INTERRUPT = 0,   FPGA_EVENT_ERROR,           FPGA_EVENT_POWER_THERMAL    } fpga_event_type;\n/* TODO: consider adding lifecycle events in the future\n * to help with orchestration.  Need a complete specification\n * before including them in the API.  Proposed events:\n *  FPGA_EVENT_APPEAR\n *  FPGA_EVENT_DISAPPEAR\n *  FPGA_EVENT_CHANGE\n */\ntypedef enum {\nFPGA_ACCELERATOR_ASSIGNED = 0,\nFPGA_ACCELERATOR_UNASSIGNED\n} fpga_accelerator_state;\ntypedef enum {\nFPGA_DEVICE = 0,\nFPGA_ACCELERATOR\n} fpga_objtype;\ntypedef enum {\nFPGA_IFC_DFL = 0,\nFPGA_IFC_VFIO,\nFPGA_IFC_SIM_DFL,\nFPGA_IFC_SIM_VFIO,\nFPGA_IFC_UIO,\n} fpga_interface;\nenum fpga_buffer_flags {\nFPGA_BUF_PREALLOCATED = (1u &lt;&lt; 0), FPGA_BUF_QUIET = (1u &lt;&lt; 1),        FPGA_BUF_READ_ONLY = (1u &lt;&lt; 2)     };\nenum fpga_open_flags {\nFPGA_OPEN_SHARED = (1u &lt;&lt; 0)\n};\nenum fpga_reconf_flags {\nFPGA_RECONF_FORCE = (1u &lt;&lt; 0),\nFPGA_RECONF_SKIP_USRCLK = (1u &lt;&lt; 1)\n};\nenum fpga_sysobject_flags {\nFPGA_OBJECT_SYNC = (1u &lt;&lt; 0), FPGA_OBJECT_GLOB = (1u &lt;&lt; 1), FPGA_OBJECT_RAW =\n(1u &lt;&lt; 2), FPGA_OBJECT_RECURSE_ONE =\n(1u\n&lt;&lt; 3), FPGA_OBJECT_RECURSE_ALL =\n(1u\n&lt;&lt; 4) };\nenum fpga_sysobject_type {\nFPGA_OBJECT_CONTAINER =\n(1u &lt;&lt; 0), FPGA_OBJECT_ATTRIBUTE =\n(1u &lt;&lt; 1) };\nenum fpga_metric_type {\nFPGA_METRIC_TYPE_POWER,             // Metric power\nFPGA_METRIC_TYPE_THERMAL,           // Metric Thermal\nFPGA_METRIC_TYPE_PERFORMANCE_CTR,   // Metric Performance counter\nFPGA_METRIC_TYPE_AFU,               // Metric AFU\nFPGA_METRIC_TYPE_UNKNOWN            // Unknown\n};\nenum fpga_metric_datatype {\nFPGA_METRIC_DATATYPE_INT,       // Metric datatype integer\nFPGA_METRIC_DATATYPE_FLOAT,     // Metric datatype float\nFPGA_METRIC_DATATYPE_DOUBLE,    // Metric datatype double\nFPGA_METRIC_DATATYPE_BOOL,      // Metric datatype bool\nFPGA_METRIC_DATATYPE_UNKNOWN    // Metric datatype unknown\n};\n#endif // __FPGA_TYPES_ENUM_H__\n</code></pre>"},{"location":"opae-code/uio_8h/","title":"File uio.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; uio.h</p> <p>Go to the source code of this file.</p> <p>APIs to manage a PCIe device via UIO. More...</p> <ul> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"opae-code/uio_8h/#classes","title":"Classes","text":"Type Name struct opae_uio OPAE UIO device abstraction. struct opae_uio_device_region MMIO region info."},{"location":"opae-code/uio_8h/#public-functions","title":"Public Functions","text":"Type Name void opae_uio_close (struct opae_uio * u) Release and close a UIO device. int opae_uio_open (struct opae_uio * u, const char * dfl_device) Open and populate a UIO device. int opae_uio_region_get (struct opae_uio * u, uint32_t index, uint8_t ** ptr, size_t * size) Query device MMIO region."},{"location":"opae-code/uio_8h/#macros","title":"Macros","text":"Type Name define OPAE_UIO_PATH_MAX  256"},{"location":"opae-code/uio_8h/#detailed-description","title":"Detailed Description","text":"<p>Presents a simple interface for interacting with a DFL device that is bound to its UIO driver. See https://kernel.org/doc/html/v4.14/driver-api/uio-howto.html for a description of UIO.</p> <p>Provides APIs for opening/closing the device and for querying info about the MMIO regions of the device. </p>"},{"location":"opae-code/uio_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/uio_8h/#function-opae_uio_close","title":"function opae_uio_close","text":"<p>Release and close a UIO device. <pre><code>void opae_uio_close (\nstruct opae_uio * u\n) </code></pre></p> <p>The given device pointer must have been previously initialized by opae_uio_open. Releases all data structures.</p> <p>Parameters:</p> <ul> <li><code>u</code> Storage for the device info. May be stack-resident.</li> </ul> <p>Example  struct opae_uio u;</p> <p>if (opae_uio_open(&amp;u, \"dfl_dev.10\")) {   // handle error } else {   // interact with the device   ...   // free the device   opae_uio_close(&amp;u); }</p> <p>Example  $ sudo opaeuio -r dfl_dev.10</p>"},{"location":"opae-code/uio_8h/#function-opae_uio_open","title":"function opae_uio_open","text":"<p>Open and populate a UIO device. <pre><code>int opae_uio_open (\nstruct opae_uio * u,\nconst char * dfl_device\n) </code></pre></p> <p>Opens the Device Feature List device corresponding to the device name given in dfl_device, eg \"dfl_dev.10\". The device must be bound to the dfl-uio-pdev driver prior to opening it. The data structures corresponding to the MMIO regions are initialized.</p> <p>Parameters:</p> <ul> <li><code>u</code> Storage for the device. May be stack-resident. </li> <li><code>dfl_device</code> The name of the desired DFL device. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  $ sudo opaeuio -i -u lab -g lab dfl_dev.10</p> <p>Example  struct opae_uio u;</p> <p>if (opae_uio_open(&amp;u, \"dfl_dev.10\")) {   // handle error }</p>"},{"location":"opae-code/uio_8h/#function-opae_uio_region_get","title":"function opae_uio_region_get","text":"<p>Query device MMIO region. <pre><code>int opae_uio_region_get (\nstruct opae_uio * u,\nuint32_t index,\nuint8_t ** ptr,\nsize_t * size\n) </code></pre></p> <p>Retrieves info describing the MMIO region with the given region index. The device structure u must have been previously opened by a call to opae_uio_open.</p> <p>Parameters:</p> <ul> <li><code>u</code> The open OPAE UIO device. </li> <li><code>index</code> The zero-based index of the desired MMIO region. </li> <li><code>ptr</code> Optional pointer to receive the virtual address for the region. Pass NULL to ignore. </li> <li><code>size</code> Optional pointer to receive the size of the MMIO region. Pass NULL to ignore. </li> </ul> <p>Returns:</p> <p>Non-zero on error (including index out-of-range). Zero on success.</p> <p>Example  struct opae_uio u;</p> <p>uint8_t *virt = NULL; size_t size = 0;</p> <p>if (opae_uio_open(&amp;u, \"dfl_dev.10\")) {   // handle error } else {   opae_uio_region_get(&amp;u, 0, &amp;virt, &amp;size); }</p>"},{"location":"opae-code/uio_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"opae-code/uio_8h/#define-opae_uio_path_max","title":"define OPAE_UIO_PATH_MAX","text":"<pre><code>#define OPAE_UIO_PATH_MAX 256\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/uio.h</code></p>"},{"location":"opae-code/uio_8h_source/","title":"File uio.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; uio.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2020, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __OPAE_UIO_H__\n#define __OPAE_UIO_H__\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#define OPAE_UIO_PATH_MAX 256\nstruct opae_uio_device_region {\nuint32_t region_index;\nuint8_t *region_ptr;\nsize_t region_page_offset;\nsize_t region_size;\nstruct opae_uio_device_region *next;\n};\nstruct opae_uio {\nchar device_path[OPAE_UIO_PATH_MAX];\nint device_fd;\nstruct opae_uio_device_region *regions;\n};\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nint opae_uio_open(struct opae_uio *u,\nconst char *dfl_device);\nint opae_uio_region_get(struct opae_uio *u,\nuint32_t index,\nuint8_t **ptr,\nsize_t *size);\nvoid opae_uio_close(struct opae_uio *u);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __OPAE_UIO_H__\n</code></pre>"},{"location":"opae-code/umsg_8h/","title":"File umsg.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; umsg.h</p> <p>Go to the source code of this file.</p> <p>FPGA UMsg API. </p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/umsg_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaGetNumUmsg (fpga_handle handle, uint64_t * value) Get number of Umsgs. fpga_result fpgaGetUmsgPtr (fpga_handle handle, uint64_t ** umsg_ptr) Access UMsg memory directly. fpga_result fpgaSetUmsgAttributes (fpga_handle handle, uint64_t value) Sets Umsg hint. fpga_result fpgaTriggerUmsg (fpga_handle handle, uint64_t value) Trigger Umsg."},{"location":"opae-code/umsg_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/umsg_8h/#function-fpgagetnumumsg","title":"function fpgaGetNumUmsg","text":"<p>Get number of Umsgs. <pre><code>fpga_result fpgaGetNumUmsg (\nfpga_handle handle,\nuint64_t * value\n) </code></pre></p> <p>Retuns number of umsg supported by AFU.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>value</code> Returns number of UMsgs </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. </p>"},{"location":"opae-code/umsg_8h/#function-fpgagetumsgptr","title":"function fpgaGetUmsgPtr","text":"<p>Access UMsg memory directly. <pre><code>fpga_result fpgaGetUmsgPtr (\nfpga_handle handle,\nuint64_t ** umsg_ptr\n) </code></pre></p> <p>This function will return a pointer to the memory allocated for low latency accelerator notifications (UMsgs).</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>umsg_ptr</code> Pointer to memory where a pointer to the virtual address space will be returned </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. FPGA_NO_MEMORY if memory allocation fails or system doesn't configure huge pages. </p>"},{"location":"opae-code/umsg_8h/#function-fpgasetumsgattributes","title":"function fpgaSetUmsgAttributes","text":"<p>Sets Umsg hint. <pre><code>fpga_result fpgaSetUmsgAttributes (\nfpga_handle handle,\nuint64_t value\n) </code></pre></p> <p>Writes usmg hint bit.</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>value</code> Value to use for UMsg hint, Umsg hit is N wide bitvector where N = number of Umsgs. </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. </p>"},{"location":"opae-code/umsg_8h/#function-fpgatriggerumsg","title":"function fpgaTriggerUmsg","text":"<p>Trigger Umsg. <pre><code>fpga_result fpgaTriggerUmsg (\nfpga_handle handle,\nuint64_t value\n) </code></pre></p> <p>Writes a 64-bit value to trigger low-latency accelerator notification mechanism (UMsgs).</p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource </li> <li><code>value</code> Value to use for UMsg </li> </ul> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if input parameter combination is not valid. FPGA_EXCEPTION if input parameter fpga handle is not valid. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/umsg.h</code></p>"},{"location":"opae-code/umsg_8h_source/","title":"File umsg.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; umsg.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_UMSG_H__\n#define __FPGA_UMSG_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaGetNumUmsg(fpga_handle handle, uint64_t *value);\nfpga_result fpgaSetUmsgAttributes(fpga_handle handle,\nuint64_t value);\nfpga_result fpgaTriggerUmsg(fpga_handle handle, uint64_t value);\nfpga_result fpgaGetUmsgPtr(fpga_handle handle, uint64_t **umsg_ptr);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_UMSG_H__\n</code></pre>"},{"location":"opae-code/userclk_8h/","title":"File userclk.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; userclk.h</p> <p>Go to the source code of this file.</p> <p>Functions for setting and get afu user clock. </p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/userclk_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaGetUserClock (fpga_handle handle, uint64_t * high_clk, uint64_t * low_clk, int flags) Get afu user clock high and low. fpga_result fpgaSetUserClock (fpga_handle handle, uint64_t high_clk, uint64_t low_clk, int flags) set afu user clock high and low"},{"location":"opae-code/userclk_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/userclk_8h/#function-fpgagetuserclock","title":"function fpgaGetUserClock","text":"<p>Get afu user clock high and low. <pre><code>fpga_result fpgaGetUserClock (\nfpga_handle handle,\nuint64_t * high_clk,\nuint64_t * low_clk,\nint flags\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource. </li> <li><code>high_clk</code> AFU High user clock frequency in MHz. </li> <li><code>low_clk</code> AFU Low user clock frequency in MHz. </li> <li><code>flags</code> Flags Reserved.</li> </ul> <p>.*</p> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p>"},{"location":"opae-code/userclk_8h/#function-fpgasetuserclock","title":"function fpgaSetUserClock","text":"<p>set afu user clock high and low <pre><code>fpga_result fpgaSetUserClock (\nfpga_handle handle,\nuint64_t high_clk,\nuint64_t low_clk,\nint flags\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>handle</code> Handle to previously opened accelerator resource. </li> <li><code>high_clk</code> AFU High user clock frequency in MHz. </li> <li><code>low_clk</code> AFU Low user clock frequency in MHz. </li> <li><code>flags</code> Flags Reserved.</li> </ul> <p>.*</p> <p>Returns:</p> <p>FPGA_OK on success. FPGA_INVALID_PARAM if invalid parameters were provided, or if the parameter combination is not valid. FPGA_EXCEPTION if an internal exception occurred while trying to access the handle. </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/userclk.h</code></p>"},{"location":"opae-code/userclk_8h_source/","title":"File userclk.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; userclk.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2018, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_AFU_USER_CLOCK_H__\n#define __FPGA_AFU_USER_CLOCK_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaSetUserClock(fpga_handle handle,\nuint64_t high_clk, uint64_t low_clk, int flags);\nfpga_result fpgaGetUserClock(fpga_handle handle,\nuint64_t *high_clk, uint64_t *low_clk, int flags);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_AFU_USER_CLOCK_H__\n</code></pre>"},{"location":"opae-code/utils_8h/","title":"File utils.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; utils.h</p> <p>Go to the source code of this file.</p> <p>Utility functions and macros for the FPGA API. </p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> </ul>"},{"location":"opae-code/utils_8h/#public-functions","title":"Public Functions","text":"Type Name const char * fpgaErrStr (fpga_result e) Return human-readable error message."},{"location":"opae-code/utils_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/utils_8h/#function-fpgaerrstr","title":"function fpgaErrStr","text":"<p>Return human-readable error message. <pre><code>const char * fpgaErrStr (\nfpga_result e\n) </code></pre></p> <p>Returns a pointer to a human-readable error message corresponding to the provided fpga_error error code.</p> <p>Parameters:</p> <ul> <li><code>e</code> Error code (as returned by another FPGA API function </li> </ul> <p>Returns:</p> <p>Pointer to a descriptive error message string </p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/utils.h</code></p>"},{"location":"opae-code/utils_8h_source/","title":"File utils.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; utils.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_UTILS_H__\n#define __FPGA_UTILS_H__\n#include &lt;opae/types.h&gt;\n#include &lt;stdio.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nconst char *fpgaErrStr(fpga_result e);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_UTILS_H__\n</code></pre>"},{"location":"opae-code/version_8h/","title":"File version.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; version.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;opae/types.h&gt;</code></li> </ul>"},{"location":"opae-code/version_8h/#public-functions","title":"Public Functions","text":"Type Name fpga_result fpgaGetOPAECBuildString (char * build_str, size_t len) Get build information about the OPAE library as a string. fpga_result fpgaGetOPAECVersion (fpga_version * version) Get version information about the OPAE library. fpga_result fpgaGetOPAECVersionString (char * version_str, size_t len) Get version information about the OPAE library as a string."},{"location":"opae-code/version_8h/#macros","title":"Macros","text":"Type Name define FPGA_BUILD_STR_MAX  41 define FPGA_VERSION_STR_MAX  10"},{"location":"opae-code/version_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/version_8h/#function-fpgagetopaecbuildstring","title":"function fpgaGetOPAECBuildString","text":"<p>Get build information about the OPAE library as a string. <pre><code>fpga_result fpgaGetOPAECBuildString (\nchar * build_str,\nsize_t len\n) </code></pre></p> <p>Retrieve the build identifier of the OPAE library.</p> <p>Parameters:</p> <ul> <li><code>build_str</code> String to copy build information into </li> <li><code>len</code> Length of <code>build_str</code> </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if <code>build_str</code> is NULL, FPGA_EXCEPTION if the version string cannot be copied into <code>build_str</code>, FPGA_OK otherwise. </p>"},{"location":"opae-code/version_8h/#function-fpgagetopaecversion","title":"function fpgaGetOPAECVersion","text":"<p>Get version information about the OPAE library. <pre><code>fpga_result fpgaGetOPAECVersion (\nfpga_version * version\n) </code></pre></p> <p>Retrieve major version, minor version, and revision information about the OPAE library.</p> <p>Parameters:</p> <ul> <li><code>version</code> FPGA version </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if any of the output parameters is NULL, FPGA_OK otherwise. </p>"},{"location":"opae-code/version_8h/#function-fpgagetopaecversionstring","title":"function fpgaGetOPAECVersionString","text":"<p>Get version information about the OPAE library as a string. <pre><code>fpga_result fpgaGetOPAECVersionString (\nchar * version_str,\nsize_t len\n) </code></pre></p> <p>Retrieve major version, minor version, and revision information about the OPAE library, encoded in a human-readable string (e.g. \"1.0.0\").</p> <p>Parameters:</p> <ul> <li><code>version_str</code> String to copy version information into </li> <li><code>len</code> Length of <code>version_str</code> </li> </ul> <p>Returns:</p> <p>FPGA_INVALID_PARAM if <code>version_str</code> is NULL, FPGA_EXCEPTION if the version string cannot be copied into <code>version_str</code>, FPGA_OK otherwise. </p>"},{"location":"opae-code/version_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"opae-code/version_8h/#define-fpga_build_str_max","title":"define FPGA_BUILD_STR_MAX","text":"<pre><code>#define FPGA_BUILD_STR_MAX 41\n</code></pre>"},{"location":"opae-code/version_8h/#define-fpga_version_str_max","title":"define FPGA_VERSION_STR_MAX","text":"<pre><code>#define FPGA_VERSION_STR_MAX 10\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/version.h</code></p>"},{"location":"opae-code/version_8h_source/","title":"File version.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; version.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __FPGA_VERSION_H__\n#define __FPGA_VERSION_H__\n#include &lt;opae/types.h&gt;\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nfpga_result fpgaGetOPAECVersion(fpga_version *version);\nfpga_result fpgaGetOPAECVersionString(char *version_str, size_t len);\n#define FPGA_VERSION_STR_MAX 10\nfpga_result fpgaGetOPAECBuildString(char *build_str, size_t len);\n#define FPGA_BUILD_STR_MAX 41\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __FPGA_VERSION_H__\n</code></pre>"},{"location":"opae-code/vfio_8h/","title":"File vfio.h","text":"<p>FileList &gt; docs &gt; sw &gt; include &gt; opae &gt; vfio.h</p> <p>Go to the source code of this file.</p> <p>APIs to manage a PCIe device via vfio-pci. More...</p> <ul> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;pthread.h&gt;</code></li> <li><code>#include &lt;linux/vfio.h&gt;</code></li> <li><code>#include &lt;opae/mem_alloc.h&gt;</code></li> <li><code>#include &lt;opae/hash_map.h&gt;</code></li> </ul>"},{"location":"opae-code/vfio_8h/#classes","title":"Classes","text":"Type Name struct opae_vfio OPAE VFIO device abstraction. struct opae_vfio_buffer System DMA buffer. struct opae_vfio_device VFIO device. struct opae_vfio_device_irq Interrupt info. struct opae_vfio_device_region MMIO region info. struct opae_vfio_group VFIO group. struct opae_vfio_iova_range IO Virtual Address Range. struct opae_vfio_sparse_info MMIO sparse-mappable region info."},{"location":"opae-code/vfio_8h/#public-types","title":"Public Types","text":"Type Name enum opae_vfio_buffer_flags Flags for opae_vfio_buffer_allocate_ex() ."},{"location":"opae-code/vfio_8h/#public-functions","title":"Public Functions","text":"Type Name int opae_vfio_buffer_allocate (struct opae_vfio * v, size_t * size, uint8_t ** buf, uint64_t * iova) Allocate and map system buffer. int opae_vfio_buffer_allocate_ex (struct opae_vfio * v, size_t * size, uint8_t ** buf, uint64_t * iova, int flags) Allocate and map system buffer (extended w/ flags) int opae_vfio_buffer_free (struct opae_vfio * v, uint8_t * buf) Unmap and free a system buffer. struct opae_vfio_buffer * opae_vfio_buffer_info (struct opae_vfio * v, uint8_t * vaddr) Extract the internal data structure pointer for the given vaddr. void opae_vfio_close (struct opae_vfio * v) Release and close a VFIO device. int opae_vfio_irq_disable (struct opae_vfio * v, uint32_t index, uint32_t subindex) Disable an IRQ. int opae_vfio_irq_enable (struct opae_vfio * v, uint32_t index, uint32_t subindex, int event_fd) Enable an IRQ. int opae_vfio_irq_mask (struct opae_vfio * v, uint32_t index, uint32_t subindex) Mask an IRQ. int opae_vfio_irq_unmask (struct opae_vfio * v, uint32_t index, uint32_t subindex) Unmask an IRQ. int opae_vfio_open (struct opae_vfio * v, const char * pciaddr) Open and populate a VFIO device. int opae_vfio_region_get (struct opae_vfio * v, uint32_t index, uint8_t ** ptr, size_t * size) Query device MMIO region. int opae_vfio_secure_open (struct opae_vfio * v, const char * pciaddr, const char * token) Open and populate a VFIO device."},{"location":"opae-code/vfio_8h/#detailed-description","title":"Detailed Description","text":"<p>Presents a simple interface for interacting with a PCIe device that is bound to the vfio-pci driver. See https://kernel.org/doc/Documentation/vfio.txt for a description of vfio-pci.</p> <p>Provides APIs for opening/closing the device, querying info about the MMIO regions of the device, and allocating/mapping and freeing/unmapping DMA buffers. </p>"},{"location":"opae-code/vfio_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"opae-code/vfio_8h/#enum-opae_vfio_buffer_flags","title":"enum opae_vfio_buffer_flags","text":"<pre><code>enum opae_vfio_buffer_flags {\nOPAE_VFIO_BUF_PREALLOCATED = 1\n};\n</code></pre>"},{"location":"opae-code/vfio_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/vfio_8h/#function-opae_vfio_buffer_allocate","title":"function opae_vfio_buffer_allocate","text":"<p>Allocate and map system buffer. <pre><code>int opae_vfio_buffer_allocate (\nstruct opae_vfio * v,\nsize_t * size,\nuint8_t ** buf,\nuint64_t * iova\n) </code></pre></p> <p>Allocate, map, and retrieve info for a system buffer capable of DMA. Saves an entry in the v-&gt;cont_buffers list. If the buffer is not explicitly freed by opae_vfio_buffer_free, it will be freed during opae_vfio_close.</p> <p>mmap is used for the allocation. If the size is greater than 2MB, then the allocation request is fulfilled by a 1GB huge page. Else, if the size is greater than 4096, then the request is fulfilled by a 2MB huge page. Else, the request is fulfilled by the non-huge page pool.</p> <p>Note:</p> <p>Allocations from the huge page pool require that huge pages be configured on the system. Huge pages may be configured on the kernel boot command prompt. Example default_hugepagesz=1G hugepagesz=1G hugepages=2 hugepagesz=2M hugepages=8</p> <p>Note:</p> <p>Huge pages may also be configured at runtime. Example sudo sh -c 'echo 8 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages' sudo sh -c 'echo 2 &gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages'</p> <p>Note:</p> <p>Be sure that the IOMMU is also enabled using the follow kernel boot command: intel_iommu=on</p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>size</code> A pointer to the requested size. The size may be rounded to the next page size prior to return from the function. </li> <li><code>buf</code> Optional pointer to receive the virtual address for the buffer. Pass NULL to ignore. </li> <li><code>iova</code> Optional pointer to receive the IOVA address for the buffer. Pass NULL to ignore. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  opae_vfio v;</p> <p>size_t sz; uint8_t *buf_2m_virt = NULL; uint8_t *buf_1g_virt = NULL; uint64_t buf_2m_iova = 0; uint64_t buf_1g_iova = 0;</p> <p>if (opae_vfio_open(&amp;v, \"0000:00:00.0\")) {   // handle error } else {   sz = 2 * 1024 * 1024;   if (opae_vfio_buffer_allocate(&amp;v,                                 &amp;sz,                                 &amp;buf_2m_virt,                                 &amp;buf_2m_iova)) {     // handle allocation error   }</p> <p>sz = 1024 * 1024 * 1024;   if (opae_vfio_buffer_allocate(&amp;v,                                 &amp;sz,                                 &amp;buf_1g_virt,                                 &amp;buf_1g_iova)) {     // handle allocation error   } }</p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_buffer_allocate_ex","title":"function opae_vfio_buffer_allocate_ex","text":"<p>Allocate and map system buffer (extended w/ flags) <pre><code>int opae_vfio_buffer_allocate_ex (\nstruct opae_vfio * v,\nsize_t * size,\nuint8_t ** buf,\nuint64_t * iova,\nint flags\n) </code></pre></p> <p>Allocate, map, and retrieve info for a system buffer capable of DMA. Saves an entry in the v-&gt;cont_buffers list. If the buffer is not explicitly freed by opae_vfio_buffer_free, it will be freed during opae_vfio_close, unless OPAE_VFIO_BUF_PREALLOCATED is used in which case the buffer is not freed by this library.</p> <p>When not using OPAE_VFIO_BUF_PREALLOCATED, mmap is used for the allocation. If the size is greater than 2MB, then the allocation request is fulfilled by a 1GB huge page. Else, if the size is greater than 4096, then the request is fulfilled by a 2MB huge page. Else, the request is fulfilled by the non-huge page pool.</p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>size</code> A pointer to the requested size. The size may be rounded to the next page size prior to return from the function. </li> <li><code>buf</code> Optional pointer to receive the virtual address for the buffer/input buffer pointer when using OPAE_VFIO_BUF_PREALLOCATED. Pass NULL to ignore. </li> <li><code>iova</code> Optional pointer to receive the IOVA address for the buffer. Pass NULL to ignore. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  opae_vfio v;</p> <p>size_t sz = MY_BUF_SIZE; uint8_t *prealloc_virt = NULL; uint64_t iova = 0;</p> <p>prealloc_virt = allocate_my_buffer(sz);</p> <p>if (opae_vfio_open(&amp;v, \"0000:00:00.0\")) {   // handle error } else {   if (opae_vfio_buffer_allocate_ex(&amp;v,                                    &amp;sz,                                    &amp;prealloc_virt,                                    &amp;iova,                                    OPAE_VFIO_BUF_PREALLOCATED)) {     // handle allocation error   } }</p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_buffer_free","title":"function opae_vfio_buffer_free","text":"<p>Unmap and free a system buffer. <pre><code>int opae_vfio_buffer_free (\nstruct opae_vfio * v,\nuint8_t * buf\n) </code></pre></p> <p>The buffer corresponding to buf must have been created by a previous call to opae_vfio_buffer_allocate.</p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>buf</code> The virtual address corresponding to the buffer to be freed. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  size_t sz; uint8_t *buf_2m_virt = NULL; uint64_t buf_2m_iova = 0;</p> <p>sz = 2 * 1024 * 1024; if (opae_vfio_buffer_allocate(&amp;v,                               &amp;sz,                               &amp;buf_2m_virt,                               &amp;buf_2m_iova)) {   // handle allocation error } else {   // use the buffer</p> <p>if (opae_vfio_buffer_free(&amp;v, buf_2m_virt)) {     // handle free error   } }</p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_buffer_info","title":"function opae_vfio_buffer_info","text":"<p>Extract the internal data structure pointer for the given vaddr. <pre><code>struct opae_vfio_buffer * opae_vfio_buffer_info (\nstruct opae_vfio * v,\nuint8_t * vaddr\n) </code></pre></p> <p>The virtual address vaddr must correspond to a buffer previously allocated by opae_vfio_buffer_allocate() or opae_vfio_buffer_allocate_ex().</p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>vaddr</code> The user virtual address of the desired buffer info struct. </li> </ul> <p>Returns:</p> <p>NULL on lookup error. </p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_close","title":"function opae_vfio_close","text":"<p>Release and close a VFIO device. <pre><code>void opae_vfio_close (\nstruct opae_vfio * v\n) </code></pre></p> <p>The given device pointer must have been previously initialized by opae_vfio_open. Releases all data structures, including any DMA buffer allocations that have not be explicitly freed by opae_vfio_buffer_free.</p> <p>Parameters:</p> <ul> <li><code>v</code> Storage for the device info. May be stack-resident.</li> </ul> <p>Example  opae_vfio v;</p> <p>if (opae_vfio_open(&amp;v, \"0000:00:00.0\")) {   // handle error } else {   // interact with the device   ...   // free the device   opae_vfio_close(&amp;v); }</p> <p>Example  $ sudo opaevfio -r 0000:00:00.0</p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_irq_disable","title":"function opae_vfio_irq_disable","text":"<p>Disable an IRQ. <pre><code>int opae_vfio_irq_disable (\nstruct opae_vfio * v,\nuint32_t index,\nuint32_t subindex\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>index</code> The IRQ category. For MSI-X, use VFIO_PCI_MSIX_IRQ_INDEX. </li> <li><code>subindex</code> The IRQ to disable. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success. </p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_irq_enable","title":"function opae_vfio_irq_enable","text":"<p>Enable an IRQ. <pre><code>int opae_vfio_irq_enable (\nstruct opae_vfio * v,\nuint32_t index,\nuint32_t subindex,\nint event_fd\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>index</code> The IRQ category. For MSI-X, use VFIO_PCI_MSIX_IRQ_INDEX. </li> <li><code>subindex</code> The IRQ to enable. </li> <li><code>event_fd</code> The file descriptor, created by eventfd(). Interrupts will result in this event_fd being signaled. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success. </p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_irq_mask","title":"function opae_vfio_irq_mask","text":"<p>Mask an IRQ. <pre><code>int opae_vfio_irq_mask (\nstruct opae_vfio * v,\nuint32_t index,\nuint32_t subindex\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>index</code> The IRQ category. For MSI-X, use VFIO_PCI_MSIX_IRQ_INDEX. </li> <li><code>subindex</code> The IRQ to mask. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success. </p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_irq_unmask","title":"function opae_vfio_irq_unmask","text":"<p>Unmask an IRQ. <pre><code>int opae_vfio_irq_unmask (\nstruct opae_vfio * v,\nuint32_t index,\nuint32_t subindex\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>index</code> The IRQ category. For MSI-X, use VFIO_PCI_MSIX_IRQ_INDEX. </li> <li><code>subindex</code> The IRQ to unmask. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success. </p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_open","title":"function opae_vfio_open","text":"<p>Open and populate a VFIO device. <pre><code>int opae_vfio_open (\nstruct opae_vfio * v,\nconst char * pciaddr\n) </code></pre></p> <p>Opens the PCIe device corresponding to the address given in pciaddr. The device must be bound to the vfio-pci driver prior to opening it. The data structures corresponding to IOVA space, MMIO regions, and DMA buffers are initialized.</p> <p>Parameters:</p> <ul> <li><code>v</code> Storage for the device info. May be stack-resident. </li> <li><code>pciaddr</code> The PCIe address of the requested device. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  $ sudo opaevfio -i 0000:00:00.0 -u user -g group</p> <p>Example  opae_vfio v;</p> <p>if (opae_vfio_open(&amp;v, \"0000:00:00.0\")) {   // handle error }</p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_region_get","title":"function opae_vfio_region_get","text":"<p>Query device MMIO region. <pre><code>int opae_vfio_region_get (\nstruct opae_vfio * v,\nuint32_t index,\nuint8_t ** ptr,\nsize_t * size\n) </code></pre></p> <p>Retrieves info describing the MMIO region with the given region index. The device structure v must have been previously opened by a call to opae_vfio_open.</p> <p>Parameters:</p> <ul> <li><code>v</code> The open OPAE VFIO device. </li> <li><code>index</code> The zero-based index of the desired MMIO region. </li> <li><code>ptr</code> Optional pointer to receive the virtual address for the region. Pass NULL to ignore. </li> <li><code>size</code> Optional pointer to receive the size of the MMIO region. Pass NULL to ignore. </li> </ul> <p>Returns:</p> <p>Non-zero on error (including index out-of-range). Zero on success.</p> <p>Example  opae_vfio v;</p> <p>uint8_t *fme_virt = NULL; uint8_t *port_virt = NULL; size_t fme_size = 0; size_t port_size = 0;</p> <p>if (opae_vfio_open(&amp;v, \"0000:00:00.0\")) {   // handle error } else {   opae_vfio_region_get(&amp;v, 0, &amp;fme_virt, &amp;fme_size);   opae_vfio_region_get(&amp;v, 2, &amp;port_virt, &amp;port_size); }</p>"},{"location":"opae-code/vfio_8h/#function-opae_vfio_secure_open","title":"function opae_vfio_secure_open","text":"<p>Open and populate a VFIO device. <pre><code>int opae_vfio_secure_open (\nstruct opae_vfio * v,\nconst char * pciaddr,\nconst char * token\n) </code></pre></p> <p>Opens the PCIe device corresponding to the address given in pciaddr, using the VF token (GUID) given in token. The device must be bound to the vfio-pci driver prior to opening it. The data structures corresponding to IOVA space, MMIO regions, and DMA buffers are initialized.</p> <p>Parameters:</p> <ul> <li><code>v</code> Storage for the device info. May be stack-resident. </li> <li><code>pciaddr</code> The PCIe address of the requested device. </li> <li><code>token</code> The GUID representing the VF token. </li> </ul> <p>Returns:</p> <p>Non-zero on error. Zero on success.</p> <p>Example  $ sudo opaevfio -i 0000:00:00.0 -u user -g group</p> <p>Example  opae_vfio v;</p> <p>if (opae_vfio_secure_open(&amp;v, \"0000:00:00.0\",                           \"00f5ad6b-2edd-422e-9d1e-34124c686fec\")) {   // handle error }</p> <p>The documentation for this class was generated from the following file <code>docs/sw/include/opae/vfio.h</code></p>"},{"location":"opae-code/vfio_8h_source/","title":"File vfio.h","text":"<p>File List &gt; docs &gt; sw &gt; include &gt; opae &gt; vfio.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2020-2023, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifndef __OPAE_VFIO_H__\n#define __OPAE_VFIO_H__\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;linux/vfio.h&gt;\n#include &lt;opae/mem_alloc.h&gt;\n#include &lt;opae/hash_map.h&gt;\nstruct opae_vfio_iova_range {\nuint64_t start;             uint64_t end;               struct opae_vfio_iova_range *next;  };\nstruct opae_vfio_group {\nchar *group_device; int group_fd;       };\nstruct opae_vfio_sparse_info {\nuint32_t index;             uint32_t offset;            uint32_t size;              uint8_t *ptr;               struct opae_vfio_sparse_info *next; };\nstruct opae_vfio_device_region {\nuint32_t region_index;              uint8_t *region_ptr;                size_t region_size;             struct opae_vfio_sparse_info *region_sparse;    struct opae_vfio_device_region *next;       };\nstruct opae_vfio_device_irq {\nuint32_t flags;             uint32_t index;             uint32_t count;             int32_t *event_fds;         int32_t *masks;             struct opae_vfio_device_irq *next;  };\nstruct opae_vfio_device {\nint device_fd;                  uint64_t device_config_offset;          uint32_t device_num_regions;            struct opae_vfio_device_region *regions;    uint32_t device_num_irqs;           struct opae_vfio_device_irq *irqs;      };\nstruct opae_vfio_buffer {\nuint8_t *buffer_ptr;        size_t buffer_size;     uint64_t buffer_iova;       int flags;          };\nstruct opae_vfio {\npthread_mutex_t lock;               char *cont_device;              char *cont_pciaddr;             int cont_fd;                    struct opae_vfio_iova_range *cont_ranges;   struct mem_alloc iova_alloc;            struct opae_vfio_group group;           struct opae_vfio_device device;         opae_hash_map cont_buffers;     };\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nint opae_vfio_open(struct opae_vfio *v,\nconst char *pciaddr);\nint opae_vfio_secure_open(struct opae_vfio *v,\nconst char *pciaddr,\nconst char *token);\nint opae_vfio_region_get(struct opae_vfio *v,\nuint32_t index,\nuint8_t **ptr,\nsize_t *size);\nint opae_vfio_buffer_allocate(struct opae_vfio *v,\nsize_t *size,\nuint8_t **buf,\nuint64_t *iova);\nenum opae_vfio_buffer_flags {\nOPAE_VFIO_BUF_PREALLOCATED = 1, };\nint opae_vfio_buffer_allocate_ex(struct opae_vfio *v,\nsize_t *size,\nuint8_t **buf,\nuint64_t *iova,\nint flags);\nstruct opae_vfio_buffer *opae_vfio_buffer_info(struct opae_vfio *v,\nuint8_t *vaddr);\nint opae_vfio_buffer_free(struct opae_vfio *v,\nuint8_t *buf);\nint opae_vfio_irq_enable(struct opae_vfio *v,\nuint32_t index,\nuint32_t subindex,\nint event_fd);\nint opae_vfio_irq_unmask(struct opae_vfio *v,\nuint32_t index,\nuint32_t subindex);\nint opae_vfio_irq_mask(struct opae_vfio *v,\nuint32_t index,\nuint32_t subindex);\nint opae_vfio_irq_disable(struct opae_vfio *v,\nuint32_t index,\nuint32_t subindex);\nvoid opae_vfio_close(struct opae_vfio *v);\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n#endif // __OPAE_VFIO_H__\n</code></pre>"},{"location":"opae-code/dir_9a6968a8846ef48cff617fcd6355d7b4/","title":"Dir docs/sw/samples","text":"<p>FileList &gt; docs &gt; sw &gt; samples</p>"},{"location":"opae-code/dir_9a6968a8846ef48cff617fcd6355d7b4/#directories","title":"Directories","text":"Type Name dir hello_events dir hello_fpga <p>The documentation for this class was generated from the following file <code>docs/sw/samples/</code></p>"},{"location":"opae-code/dir_d66a8e4b979fa79493bebe26e2602d2b/","title":"Dir docs/sw/samples/hello_events","text":"<p>FileList &gt; docs &gt; sw &gt; samples &gt; hello_events</p>"},{"location":"opae-code/dir_d66a8e4b979fa79493bebe26e2602d2b/#files","title":"Files","text":"Type Name file hello_events.c A code sample of using OPAE event API. <p>The documentation for this class was generated from the following file <code>docs/sw/samples/hello_events/</code></p>"},{"location":"opae-code/hello__events_8c/","title":"File hello_events.c","text":"<p>FileList &gt; docs &gt; sw &gt; samples &gt; hello_events &gt; hello_events.c</p> <p>Go to the source code of this file.</p> <p>A code sample of using OPAE event API. More...</p> <ul> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;unistd.h&gt;</code></li> <li><code>#include &lt;getopt.h&gt;</code></li> <li><code>#include &lt;poll.h&gt;</code></li> <li><code>#include &lt;errno.h&gt;</code></li> <li><code>#include &lt;sys/stat.h&gt;</code></li> <li><code>#include &lt;pthread.h&gt;</code></li> <li><code>#include &lt;opae/fpga.h&gt;</code></li> <li><code>#include &lt;argsfilter.h&gt;</code></li> <li><code>#include \"mock/opae_std.h\"</code></li> </ul>"},{"location":"opae-code/hello__events_8c/#classes","title":"Classes","text":"Type Name struct ras_inject_error"},{"location":"opae-code/hello__events_8c/#public-functions","title":"Public Functions","text":"Type Name void * error_thread (void * arg)  fpga_result find_fpga (fpga_properties device_filter, fpga_token * fpga, uint32_t * num_matches)  void help (void)  fpga_result inject_ras_fatal_error (fpga_token fme_token, uint8_t err)  int main (int argc, char * argv)  fpga_result parse_args (int argc, char * argv)  void print_err (const char * s, fpga_result res)  int usleep (unsigned)"},{"location":"opae-code/hello__events_8c/#macros","title":"Macros","text":"Type Name define FME_SYSFS_INJECT_ERROR  \"errors/inject_errors\" define GETOPT_STRING  \"hv\" define ON_ERR_GOTO (res, label, desc)"},{"location":"opae-code/hello__events_8c/#detailed-description","title":"Detailed Description","text":"<p>This sample starts two processes. One process injects an artificial fatal error to sysfs; while the other tries to asynchronously capture and handle the event. This sample code exercises all major functions of the event API, including creating and destroying event handles, register and unregister events, polling on event file descriptor, and getting the OS object associated with an event. For a full discussion of OPAE event API, refer to event.h. </p>"},{"location":"opae-code/hello__events_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/hello__events_8c/#function-error_thread","title":"function error_thread","text":"<pre><code>void * error_thread (\nvoid * arg\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#function-find_fpga","title":"function find_fpga","text":"<pre><code>fpga_result find_fpga (\nfpga_properties device_filter,\nfpga_token * fpga,\nuint32_t * num_matches\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#function-help","title":"function help","text":"<pre><code>void help (\nvoid\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#function-inject_ras_fatal_error","title":"function inject_ras_fatal_error","text":"<pre><code>fpga_result inject_ras_fatal_error (\nfpga_token fme_token,\nuint8_t err\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#function-main","title":"function main","text":"<pre><code>int main (\nint argc,\nchar * argv\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#function-parse_args","title":"function parse_args","text":"<pre><code>fpga_result parse_args (\nint argc,\nchar * argv\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#function-print_err","title":"function print_err","text":"<pre><code>void print_err (\nconst char * s,\nfpga_result res\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#function-usleep","title":"function usleep","text":"<pre><code>int usleep (\nunsigned\n) </code></pre>"},{"location":"opae-code/hello__events_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"opae-code/hello__events_8c/#define-fme_sysfs_inject_error","title":"define FME_SYSFS_INJECT_ERROR","text":"<pre><code>#define FME_SYSFS_INJECT_ERROR \"errors/inject_errors\"\n</code></pre>"},{"location":"opae-code/hello__events_8c/#define-getopt_string","title":"define GETOPT_STRING","text":"<pre><code>#define GETOPT_STRING \"hv\"\n</code></pre>"},{"location":"opae-code/hello__events_8c/#define-on_err_goto","title":"define ON_ERR_GOTO","text":"<pre><code>#define ON_ERR_GOTO (\nres,\nlabel,\ndesc\n) do {                                       \\\n        if ((res) != FPGA_OK ) {            \\ print_err ((desc), (res));  \\\n            goto label;                \\\n        }                                  \\\n    } while (0)\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/samples/hello_events/hello_events.c</code></p>"},{"location":"opae-code/hello__events_8c_source/","title":"File hello_events.c","text":"<p>File List &gt; docs &gt; sw &gt; samples &gt; hello_events &gt; hello_events.c</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017-2021, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifdef HAVE_CONFIG_H\n#include &lt;config.h&gt;\n#endif // HAVE_CONFIG_H\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;getopt.h&gt;\n#include &lt;poll.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;opae/fpga.h&gt;\n#include &lt;argsfilter.h&gt;\n#include \"mock/opae_std.h\"\nint usleep(unsigned);\n#define FME_SYSFS_INJECT_ERROR \"errors/inject_errors\"\n#define ON_ERR_GOTO(res, label, desc)              \\\n    do {                                       \\\n        if ((res) != FPGA_OK) {            \\\n            print_err((desc), (res));  \\\n            goto label;                \\\n        }                                  \\\n    } while (0)\nvoid print_err(const char *s, fpga_result res)\n{\nfprintf(stderr, \"Error %s: %s\\n\", s, fpgaErrStr(res));\n}\n// RAS Error Inject CSR\nstruct ras_inject_error {\nunion {\nuint64_t csr;\nstruct {\n/* Catastrophic  error */\nuint64_t  catastrophicr_error : 1;\n/* Fatal error */\nuint64_t  fatal_error : 1;\n/* Non-fatal error */\nuint64_t  nonfatal_error : 1;\n/* Reserved */\nuint64_t  rsvd : 61;\n};\n};\n};\nfpga_result inject_ras_fatal_error(fpga_token fme_token, uint8_t err)\n{\nfpga_result             res1       = FPGA_OK;\nfpga_result             res2       = FPGA_OK;\nfpga_handle             fme_handle = NULL;\nstruct ras_inject_error inj_error  = { {0} };\nfpga_object             inj_err_object;\nres1 = fpgaOpen(fme_token, &amp;fme_handle, FPGA_OPEN_SHARED);\nif (res1 != FPGA_OK) {\nOPAE_ERR(\"Failed to open FPGA\");\nreturn res1;\n}\nres1 = fpgaHandleGetObject(fme_handle, FME_SYSFS_INJECT_ERROR, &amp;inj_err_object, 0);\nON_ERR_GOTO(res1, out_close, \"Failed to get Handle Object\");\n// Inject fatal error\ninj_error.fatal_error = err;\nres1 = fpgaObjectWrite64(inj_err_object, inj_error.csr, 0);\nON_ERR_GOTO(res1, out_destroy_obj, \"Failed to Read Object\");\nout_destroy_obj:\nres2 = fpgaDestroyObject(&amp;inj_err_object);\nON_ERR_GOTO(res2, out_close, \"Failed to Destroy Object\");\nout_close:\nres2 = fpgaClose(fme_handle);\nif (res2 != FPGA_OK) {\nOPAE_ERR(\"Failed to close FPGA\");\n}\nreturn res1 != FPGA_OK ? res1 : res2;\n}\nvoid *error_thread(void *arg)\n{\nfpga_token token = (fpga_token) arg;\nfpga_result res;\nusleep(5000000);\nprintf(\"injecting error\\n\");\nres = inject_ras_fatal_error(token, 1);\nif (res != FPGA_OK)\nprint_err(\"setting inject error register\", res);\nusleep(5000000);\nprintf(\"clearing error\\n\");\nres = inject_ras_fatal_error(token, 0);\nif (res != FPGA_OK)\nprint_err(\"clearing inject error register\", res);\nreturn NULL;\n}\nvoid help(void)\n{\nprintf(\"\\n\"\n\"hello_events\\n\"\n\"OPAE Events API sample\\n\"\n\"\\n\"\n\"Usage:\\n\"\n\"    hello_events [-hv] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\\n\"\n\"\\n\"\n\"                -h,--help           Print this help\\n\"\n\"                -v,--version        Print version info and exit\\n\"\n\"\\n\");\n}\n/*\n * Parse command line arguments\n */\n#define GETOPT_STRING \"hv\"\nfpga_result parse_args(int argc, char *argv[])\n{\nstruct option longopts[] = {\n{ \"help\",    no_argument, NULL, 'h' },\n{ \"version\", no_argument, NULL, 'v' },\n{ NULL,      0,           NULL, 0   }\n};\nint getopt_ret;\nint option_index;\nwhile (-1 != (getopt_ret = getopt_long(argc, argv, GETOPT_STRING, longopts, &amp;option_index))) {\nconst char *tmp_optarg = optarg;\n/* checks to see if optarg is null and if not goes to value of optarg */\nif ((optarg) &amp;&amp; ('=' == *tmp_optarg)) {\n++tmp_optarg;\n}\nswitch (getopt_ret) {\ncase 'h': /* help */\nhelp();\nreturn -1;\ncase 'v': /* version */\nprintf(\"hello_events %s %s%s\\n\",\nOPAE_VERSION,\nOPAE_GIT_COMMIT_HASH,\nOPAE_GIT_SRC_TREE_DIRTY ? \"*\":\"\");\nreturn -1;\ndefault: /* invalid option */\nfprintf(stderr, \"Invalid cmdline options\\n\");\nreturn FPGA_EXCEPTION;\n}\n}\nreturn FPGA_OK;\n}\nfpga_result find_fpga(fpga_properties device_filter,\nfpga_token *fpga,\nuint32_t *num_matches)\n{\nfpga_properties filter = NULL;\nfpga_result res        = FPGA_OK;\nfpga_result dres       = FPGA_OK;\nres = fpgaCloneProperties(device_filter, &amp;filter);\nON_ERR_GOTO(res, out, \"cloning properties object\");\nres = fpgaPropertiesSetObjectType(filter, FPGA_DEVICE);\nON_ERR_GOTO(res, out_destroy, \"setting interface ID\");\nres = fpgaEnumerate(&amp;filter, 1, fpga, 1, num_matches);\nON_ERR_GOTO(res, out_destroy, \"enumerating FPGAs\");\nout_destroy:\ndres = fpgaDestroyProperties(&amp;filter);\nON_ERR_GOTO(dres, out, \"destroying properties object\");\nout:\nreturn (res == FPGA_OK) ? dres : res;\n}\nint main(int argc, char *argv[])\n{\nfpga_token         fpga_device_token = NULL;\nfpga_handle        fpga_device_handle = NULL;\nuint32_t           num_matches = 1;\nfpga_result        res1 = FPGA_OK;\nfpga_result        res2 = FPGA_OK;\nfpga_event_handle  eh;\nuint64_t           count = 0;\nint                res;\nstruct pollfd      pfd;\nint                timeout = 10000;\nint                poll_ret = 0;\nssize_t            bytes_read = 0;\npthread_t          errthr;\nfpga_properties    device_filter = NULL;\nres1 = fpgaGetProperties(NULL, &amp;device_filter);\nif (res1) {\nprint_err(\"failed to alloc properties\", res1);\nreturn res1;\n}\nif (opae_set_properties_from_args(device_filter,\n&amp;res1,\n&amp;argc,\nargv)) {\nprint_err(\"failed arg parse\", res1);\nres1 = FPGA_EXCEPTION;\ngoto out_exit;\n} else if (res1) {\nprint_err(\"failed to set properties\", res1);\ngoto out_exit;\n}\nres1 = parse_args(argc, argv);\nif ((int)res1 &lt; 0)\ngoto out_exit;\nON_ERR_GOTO(res1, out_exit, \"parsing arguments\");\nres1 = find_fpga(device_filter, &amp;fpga_device_token, &amp;num_matches);\nON_ERR_GOTO(res1, out_exit, \"finding FPGA accelerator\");\nif (num_matches &lt; 1) {\nfprintf(stderr, \"No matches for address provided.\\n\");\nres1 = FPGA_NOT_FOUND;\ngoto out_exit;\n}\nif (num_matches &gt; 1) {\nfprintf(stderr, \"Found more than one suitable slot.\\n\");\n}\nres1 = fpgaOpen(fpga_device_token, &amp;fpga_device_handle, FPGA_OPEN_SHARED);\nON_ERR_GOTO(res1, out_destroy_tok, \"opening accelerator\");\nres1 = fpgaCreateEventHandle(&amp;eh);\nON_ERR_GOTO(res1, out_close, \"creating event handle\");\nres1 = fpgaRegisterEvent(fpga_device_handle, FPGA_EVENT_ERROR, eh, 0);\nON_ERR_GOTO(res1, out_destroy_eh, \"registering an FME event\");\nprintf(\"Waiting for interrupts now...\\n\");\nres = pthread_create(&amp;errthr, NULL, error_thread, fpga_device_token);\nif (res) {\nprintf(\"Failed to create error_thread.\\n\");\nres1 = FPGA_EXCEPTION;\ngoto out_destroy_eh;\n}\nres1 = fpgaGetOSObjectFromEventHandle(eh, &amp;pfd.fd);\nON_ERR_GOTO(res1, out_join, \"getting file descriptor\");\npfd.events = POLLIN;\npoll_ret = poll(&amp;pfd, 1, timeout);\nif (poll_ret &lt; 0) {\nprintf(\"Poll error errno = %s\\n\", strerror(errno));\nres1 = FPGA_EXCEPTION;\ngoto out_join;\n} else if (poll_ret == 0) {\nprintf(\"Poll timeout occurred\\n\");\nres1 = FPGA_EXCEPTION;\ngoto out_join;\n} else {\nprintf(\"FME Interrupt occurred\\n\");\nbytes_read = opae_read(pfd.fd, &amp;count, sizeof(count));\nif (bytes_read &lt;= 0)\nprintf(\"WARNING: error reading from poll fd: %s\\n\",\nbytes_read &lt; 0 ? strerror(errno) : \"zero bytes read\");\n}\nres1 = fpgaUnregisterEvent(fpga_device_handle, FPGA_EVENT_ERROR, eh);\nON_ERR_GOTO(res1, out_join, \"unregistering an FME event\");\nprintf(\"Successfully tested Register/Unregister for FME events!\\n\");\nout_join:\npthread_join(errthr, NULL);\nout_destroy_eh:\nres2 = fpgaDestroyEventHandle(&amp;eh);\nON_ERR_GOTO(res2, out_close, \"deleting event handle\");\nout_close:\nres2 = fpgaClose(fpga_device_handle);\nON_ERR_GOTO(res2, out_destroy_tok, \"closing accelerator\");\nout_destroy_tok:\nres2 = fpgaDestroyToken(&amp;fpga_device_token);\nON_ERR_GOTO(res2, out_exit, \"destroying token\");\nout_exit:\nfpgaDestroyProperties(&amp;device_filter);\nreturn res1 != FPGA_OK ? res1 : res2;\n}\n</code></pre>"},{"location":"opae-code/dir_a3c160366dc832de1042e5d4d49ef034/","title":"Dir docs/sw/samples/hello_fpga","text":"<p>FileList &gt; docs &gt; sw &gt; samples &gt; hello_fpga</p>"},{"location":"opae-code/dir_a3c160366dc832de1042e5d4d49ef034/#files","title":"Files","text":"Type Name file hello_fpga.c A code sample illustrates the basic usage of the OPAE C API. <p>The documentation for this class was generated from the following file <code>docs/sw/samples/hello_fpga/</code></p>"},{"location":"opae-code/hello__fpga_8c/","title":"File hello_fpga.c","text":"<p>FileList &gt; docs &gt; sw &gt; samples &gt; hello_fpga &gt; hello_fpga.c</p> <p>Go to the source code of this file.</p> <p>A code sample illustrates the basic usage of the OPAE C API. More...</p> <ul> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;getopt.h&gt;</code></li> <li><code>#include &lt;unistd.h&gt;</code></li> <li><code>#include &lt;uuid/uuid.h&gt;</code></li> <li><code>#include &lt;opae/fpga.h&gt;</code></li> <li><code>#include &lt;argsfilter.h&gt;</code></li> <li><code>#include \"mock/opae_std.h\"</code></li> </ul>"},{"location":"opae-code/hello__fpga_8c/#classes","title":"Classes","text":"Type Name struct cache_line struct config"},{"location":"opae-code/hello__fpga_8c/#public-attributes","title":"Public Attributes","text":"Type Name struct config config   = = { .open_flags = 0, .run_n3000 = 0 }"},{"location":"opae-code/hello__fpga_8c/#public-functions","title":"Public Functions","text":"Type Name fpga_result find_fpga (fpga_properties device_filter, fpga_guid afu_guid, fpga_token * accelerator_token, uint32_t * num_matches_accelerators)  fpga_result find_nlb_n3000 (fpga_handle accelerator_handle, uint64_t * afu_baddr)  void help (void)  int main (int argc, char * argv)  fpga_result parse_args (int argc, char * argv)  void print_err (const char * s, fpga_result res)  bool probe_for_ase (void)  int usleep (unsigned)"},{"location":"opae-code/hello__fpga_8c/#macros","title":"Macros","text":"Type Name define CACHELINE_ALIGNED_ADDR (p) ((p) &gt;&gt; LOG2_CL) define CL (x) ((x) * 64) define CSR_AFU_DSM_BASEL  0x0110 define CSR_CFG  0x0140 define CSR_CTL  0x0138 define CSR_DST_ADDR  0x0128 define CSR_NUM_LINES  0x0130 define CSR_SRC_ADDR  0x0120 define CSR_STATUS1  0x0168 define DSM_STATUS_TEST_COMPLETE  0x40 define FPGA_NLB0_UUID_H  0xd8424dc4a4a3c413 define FPGA_NLB0_UUID_L  0xf89e433683f9040b define GETOPT_STRING  \"hscv\" define LOG2_CL  6 define LPBK1_BUFFER_ALLOCATION_SIZE MB(2) define LPBK1_BUFFER_SIZE MB(1) define LPBK1_DSM_SIZE MB(2) define MB (x) ((x) * 1024 * 1024) define N3000_AFUID  \"9AEFFE5F-8457-0612-C000-C9660D824272\" define NLB0_AFUID  \"D8424DC4-A4A3-C413-F89E-433683F9040B\" define ON_ERR_GOTO (res, label, desc)  define TEST_TIMEOUT  30000"},{"location":"opae-code/hello__fpga_8c/#detailed-description","title":"Detailed Description","text":"<p>The sample is a host application that demonstrates the basic steps of interacting with FPGA using the OPAE library. These steps include:</p> <ul> <li>FPGA enumeration</li> <li>Resource acquiring and releasing</li> <li>Managing shared memory buffer</li> <li>MMIO read and write</li> </ul> <p>The sample also demonstrates OPAE's object model, such as tokens, handles, and properties.</p> <p>The sample requires a native loopback mode (NLB) test image to be loaded on the FPGA. Refer to Quick Start Guide for full instructions on building, configuring, and running this code sample. </p>"},{"location":"opae-code/hello__fpga_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"opae-code/hello__fpga_8c/#variable-config","title":"variable config","text":"<pre><code>struct config config;\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"opae-code/hello__fpga_8c/#function-find_fpga","title":"function find_fpga","text":"<pre><code>fpga_result find_fpga (\nfpga_properties device_filter,\nfpga_guid afu_guid,\nfpga_token * accelerator_token,\nuint32_t * num_matches_accelerators\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#function-find_nlb_n3000","title":"function find_nlb_n3000","text":"<pre><code>fpga_result find_nlb_n3000 (\nfpga_handle accelerator_handle,\nuint64_t * afu_baddr\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#function-help","title":"function help","text":"<pre><code>void help (\nvoid\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#function-main","title":"function main","text":"<pre><code>int main (\nint argc,\nchar * argv\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#function-parse_args","title":"function parse_args","text":"<pre><code>fpga_result parse_args (\nint argc,\nchar * argv\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#function-print_err","title":"function print_err","text":"<pre><code>void print_err (\nconst char * s,\nfpga_result res\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#function-probe_for_ase","title":"function probe_for_ase","text":"<pre><code>bool probe_for_ase (\nvoid\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#function-usleep","title":"function usleep","text":"<pre><code>int usleep (\nunsigned\n) </code></pre>"},{"location":"opae-code/hello__fpga_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"opae-code/hello__fpga_8c/#define-cacheline_aligned_addr","title":"define CACHELINE_ALIGNED_ADDR","text":"<pre><code>#define CACHELINE_ALIGNED_ADDR (\np\n) ((p) &gt;&gt; LOG2_CL )\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-cl","title":"define CL","text":"<pre><code>#define CL (\nx\n) ((x) * 64)\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-csr_afu_dsm_basel","title":"define CSR_AFU_DSM_BASEL","text":"<pre><code>#define CSR_AFU_DSM_BASEL 0x0110\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-csr_cfg","title":"define CSR_CFG","text":"<pre><code>#define CSR_CFG 0x0140\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-csr_ctl","title":"define CSR_CTL","text":"<pre><code>#define CSR_CTL 0x0138\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-csr_dst_addr","title":"define CSR_DST_ADDR","text":"<pre><code>#define CSR_DST_ADDR 0x0128\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-csr_num_lines","title":"define CSR_NUM_LINES","text":"<pre><code>#define CSR_NUM_LINES 0x0130\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-csr_src_addr","title":"define CSR_SRC_ADDR","text":"<pre><code>#define CSR_SRC_ADDR 0x0120\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-csr_status1","title":"define CSR_STATUS1","text":"<pre><code>#define CSR_STATUS1 0x0168\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-dsm_status_test_complete","title":"define DSM_STATUS_TEST_COMPLETE","text":"<pre><code>#define DSM_STATUS_TEST_COMPLETE 0x40\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-fpga_nlb0_uuid_h","title":"define FPGA_NLB0_UUID_H","text":"<pre><code>#define FPGA_NLB0_UUID_H 0xd8424dc4a4a3c413\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-fpga_nlb0_uuid_l","title":"define FPGA_NLB0_UUID_L","text":"<pre><code>#define FPGA_NLB0_UUID_L 0xf89e433683f9040b\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-getopt_string","title":"define GETOPT_STRING","text":"<pre><code>#define GETOPT_STRING \"hscv\"\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-log2_cl","title":"define LOG2_CL","text":"<pre><code>#define LOG2_CL 6\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-lpbk1_buffer_allocation_size","title":"define LPBK1_BUFFER_ALLOCATION_SIZE","text":"<pre><code>#define LPBK1_BUFFER_ALLOCATION_SIZE MB (2)\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-lpbk1_buffer_size","title":"define LPBK1_BUFFER_SIZE","text":"<pre><code>#define LPBK1_BUFFER_SIZE MB (1)\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-lpbk1_dsm_size","title":"define LPBK1_DSM_SIZE","text":"<pre><code>#define LPBK1_DSM_SIZE MB (2)\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-mb","title":"define MB","text":"<pre><code>#define MB (\nx\n) ((x) * 1024 * 1024)\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-n3000_afuid","title":"define N3000_AFUID","text":"<pre><code>#define N3000_AFUID \"9AEFFE5F-8457-0612-C000-C9660D824272\"\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-nlb0_afuid","title":"define NLB0_AFUID","text":"<pre><code>#define NLB0_AFUID \"D8424DC4-A4A3-C413-F89E-433683F9040B\"\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-on_err_goto","title":"define ON_ERR_GOTO","text":"<pre><code>#define ON_ERR_GOTO (\nres,\nlabel,\ndesc\n) do {                                       \\\n        if ((res) != FPGA_OK ) {            \\ print_err ((desc), (res));  \\\n            goto label;                \\\n        }                                  \\\n    } while (0)\n</code></pre>"},{"location":"opae-code/hello__fpga_8c/#define-test_timeout","title":"define TEST_TIMEOUT","text":"<pre><code>#define TEST_TIMEOUT 30000\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sw/samples/hello_fpga/hello_fpga.c</code></p>"},{"location":"opae-code/hello__fpga_8c_source/","title":"File hello_fpga.c","text":"<p>File List &gt; docs &gt; sw &gt; samples &gt; hello_fpga &gt; hello_fpga.c</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright(c) 2017-2022, Intel Corporation\n//\n// Redistribution  and  use  in source  and  binary  forms,  with  or  without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of  source code  must retain the  above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name  of Intel Corporation  nor the names of its contributors\n//   may be used to  endorse or promote  products derived  from this  software\n//   without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE\n// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE\n// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR\n// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF\n// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS\n// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN\n// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n#ifdef HAVE_CONFIG_H\n#include &lt;config.h&gt;\n#endif // HAVE_CONFIG_H\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;getopt.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;uuid/uuid.h&gt;\n#include &lt;opae/fpga.h&gt;\n#include &lt;argsfilter.h&gt;\n#include \"mock/opae_std.h\"\nint usleep(unsigned);\n#ifndef TEST_TIMEOUT\n#define TEST_TIMEOUT 30000\n#endif // TEST_TIMEOUT\n#ifndef CL\n# define CL(x)                       ((x) * 64)\n#endif // CL\n#ifndef LOG2_CL\n# define LOG2_CL                     6\n#endif // LOG2_CL\n#ifndef MB\n# define MB(x)                       ((x) * 1024 * 1024)\n#endif // MB\n#define CACHELINE_ALIGNED_ADDR(p) ((p) &gt;&gt; LOG2_CL)\n#define LPBK1_BUFFER_SIZE            MB(1)\n#define LPBK1_BUFFER_ALLOCATION_SIZE MB(2)\n#define LPBK1_DSM_SIZE               MB(2)\n#define CSR_SRC_ADDR                 0x0120\n#define CSR_DST_ADDR                 0x0128\n#define CSR_CTL                      0x0138\n#define CSR_STATUS1                  0x0168\n#define CSR_CFG                      0x0140\n#define CSR_NUM_LINES                0x0130\n#define DSM_STATUS_TEST_COMPLETE     0x40\n#define CSR_AFU_DSM_BASEL            0x0110\n/* NLB0 AFU_ID */\n#define NLB0_AFUID \"D8424DC4-A4A3-C413-F89E-433683F9040B\"\n/* NLB0 AFU_ID for N3000 */\n#define N3000_AFUID \"9AEFFE5F-8457-0612-C000-C9660D824272\"\n#define FPGA_NLB0_UUID_H 0xd8424dc4a4a3c413\n#define FPGA_NLB0_UUID_L 0xf89e433683f9040b\n/*\n * macro to check return codes, print error message, and goto cleanup label\n * NOTE: this changes the program flow (uses goto)!\n */\n#define ON_ERR_GOTO(res, label, desc)              \\\n    do {                                       \\\n        if ((res) != FPGA_OK) {            \\\n            print_err((desc), (res));  \\\n            goto label;                \\\n        }                                  \\\n    } while (0)\n/* Type definitions */\ntypedef struct {\nuint32_t uint[16];\n} cache_line;\nvoid print_err(const char *s, fpga_result res)\n{\nfprintf(stderr, \"Error %s: %s\\n\", s, fpgaErrStr(res));\n}\n/*\n * Global configuration of bus, set during parse_args()\n * */\nstruct config {\nint open_flags;\nint run_n3000;\n}\nconfig = {\n.open_flags = 0,\n.run_n3000 = 0\n};\nvoid help(void)\n{\nprintf(\"\\n\"\n\"hello_fpga\\n\"\n\"OPAE Native Loopback 0 (NLB0) sample\\n\"\n\"\\n\"\n\"Usage:\\n\"\n\"        hello_fpga [-schv] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\\n\"\n\"\\n\"\n\"                -s,--shared         Open accelerator in shared mode\\n\"\n\"                -c,--n3000          Assume N3000 MMIO layout\\n\"\n\"                -h,--help           Print this help\\n\"\n\"                -v,--version        Print version info and exit\\n\"\n\"\\n\");\n}\n#define GETOPT_STRING \"hscv\"\nfpga_result parse_args(int argc, char *argv[])\n{\nstruct option longopts[] = {\n{ \"help\",    no_argument, NULL, 'h' },\n{ \"shared\",  no_argument, NULL, 's' },\n{ \"n3000\",   no_argument, NULL, 'c' },\n{ \"version\", no_argument, NULL, 'v' },\n{ NULL,      0,           NULL,  0  }\n};\nint getopt_ret;\nint option_index;\nchar version[32];\nchar build[32];\nwhile (-1 != (getopt_ret = getopt_long(argc, argv, GETOPT_STRING,\nlongopts, &amp;option_index))) {\nconst char *tmp_optarg = optarg;\n/* Checks to see if optarg is null and if not it goes to value of optarg */\nif ((optarg) &amp;&amp; ('=' == *tmp_optarg)) {\n++tmp_optarg;\n}\nswitch (getopt_ret) {\ncase 'h':\nhelp();\nreturn -1;\ncase 's':\nconfig.open_flags |= FPGA_OPEN_SHARED;\nbreak;\ncase 'c':\nconfig.run_n3000 = 1;\nbreak;\ncase 'v':\nfpgaGetOPAECVersionString(version, sizeof(version));\nfpgaGetOPAECBuildString(build, sizeof(build));\nprintf(\"hello_fpga %s %s\\n\",\nversion, build);\nreturn -1;\ndefault: /* invalid option */\nfprintf(stderr, \"Invalid cmdline option \\n\");\nreturn FPGA_EXCEPTION;\n}\n}\nreturn FPGA_OK;\n}\nfpga_result find_fpga(fpga_properties device_filter,\nfpga_guid afu_guid,\nfpga_token *accelerator_token,\nuint32_t *num_matches_accelerators)\n{\nfpga_properties filter = NULL;\nfpga_result res1;\nfpga_result res2 = FPGA_OK;\nres1 = fpgaCloneProperties(device_filter, &amp;filter);\nON_ERR_GOTO(res1, out, \"cloning properties object\");\nres1 = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\nON_ERR_GOTO(res1, out_destroy, \"setting object type\");\nres1 = fpgaPropertiesSetGUID(filter, afu_guid);\nON_ERR_GOTO(res1, out_destroy, \"setting GUID\");\nres1 = fpgaEnumerate(&amp;filter, 1, accelerator_token, 1, num_matches_accelerators);\nON_ERR_GOTO(res1, out_destroy, \"enumerating accelerators\");\nout_destroy:\nres2 = fpgaDestroyProperties(&amp;filter);\nON_ERR_GOTO(res2, out, \"destroying properties object\");\nout:\nreturn res1 != FPGA_OK ? res1 : res2;\n}\n/* Is the FPGA simulated with ASE? */\nbool probe_for_ase(void)\n{\nfpga_result r = FPGA_OK;\nuint16_t device_id = 0;\nfpga_properties filter = NULL;\nuint32_t num_matches = 1;\nfpga_token fme_token;\n/* Connect to the FPGA management engine */\nfpgaGetProperties(NULL, &amp;filter);\nfpgaPropertiesSetObjectType(filter, FPGA_DEVICE);\n/* Connecting to one is sufficient to find ASE */\nfpgaEnumerate(&amp;filter, 1, &amp;fme_token, 1, &amp;num_matches);\nif (0 != num_matches) {\n/* Retrieve the device ID of the FME */\nfpgaDestroyProperties(&amp;filter);\nfpgaGetProperties(fme_token, &amp;filter);\nr = fpgaPropertiesGetDeviceID(filter, &amp;device_id);\nfpgaDestroyToken(&amp;fme_token);\n}\nfpgaDestroyProperties(&amp;filter);\n/* ASE's device ID is 0xa5e */\nreturn ((FPGA_OK == r) &amp;&amp; (0xa5e == device_id));\n}\nfpga_result find_nlb_n3000(fpga_handle accelerator_handle,\nuint64_t *afu_baddr)\n{\nfpga_result res1 = FPGA_OK;\nint end_of_list = 0;\nint nlb0_found = 0;\nuint64_t header = 0;\nuint64_t uuid_hi = 0;\nuint64_t uuid_lo = 0;\nuint64_t next_offset = 0;\nuint64_t nlb0_offset = 0;\n/* find NLB0 in AFU */\ndo {\n// Read the next feature header\nres1 = fpgaReadMMIO64(accelerator_handle, 0, nlb0_offset, &amp;header);\nON_ERR_GOTO(res1, out_exit, \"fpgaReadMMIO64\");\nres1 = fpgaReadMMIO64(accelerator_handle, 0, nlb0_offset+8, &amp;uuid_lo);\nON_ERR_GOTO(res1, out_exit, \"fpgaReadMMIO64\");\nres1 = fpgaReadMMIO64(accelerator_handle, 0, nlb0_offset+16, &amp;uuid_hi);\nON_ERR_GOTO(res1, out_exit, \"fpgaReadMMIO64\");\n// printf(\"%zx: %zx %zx %zx\\n\", nlb0_offset, header, uuid_lo, uuid_hi);\nif ((((header &gt;&gt; 60) &amp; 0xf) == 0x1) &amp;&amp;\n(uuid_lo == FPGA_NLB0_UUID_L) &amp;&amp; (uuid_hi == FPGA_NLB0_UUID_H)) {\nnlb0_found = 1;\nbreak;\n}\n// End of the list flag\nend_of_list = (header &gt;&gt; 40) &amp; 1;\n// Move to the next feature header\nnext_offset = (header &gt;&gt; 16) &amp; 0xffffff;\nif ((next_offset == 0xffff) || (next_offset == 0)) {\nnlb0_found = 0;\nbreak;\n}\nnlb0_offset = nlb0_offset + next_offset;\n} while (!end_of_list);\nif (!nlb0_found) {\nprintf(\"AFU NLB0 not found\\n\");\nreturn FPGA_EXCEPTION;\n}\nprintf(\"AFU NLB0 found @ %zx\\n\", nlb0_offset);\n*afu_baddr = nlb0_offset;\nreturn FPGA_OK;\nout_exit:\nreturn FPGA_EXCEPTION;\n}\nint main(int argc, char *argv[])\n{\nfpga_token         accelerator_token;\nfpga_handle        accelerator_handle;\nfpga_guid          guid;\nuint32_t           num_matches_accelerators = 0;\nuint32_t           use_ase;\nvolatile uint64_t *dsm_ptr    = NULL;\nvolatile uint64_t *status_ptr = NULL;\nvolatile uint64_t *input_ptr  = NULL;\nvolatile uint64_t *output_ptr = NULL;\nuint64_t           dsm_wsid;\nuint64_t           input_wsid;\nuint64_t           output_wsid;\nuint32_t           i;\nuint32_t           timeout;\nfpga_result        res1 = FPGA_OK;\nfpga_result        res2 = FPGA_OK;\nfpga_properties    device_filter = NULL;\nres1 = fpgaGetProperties(NULL, &amp;device_filter);\nif (res1 != FPGA_OK) {\nprint_err(\"failed to allocate properties.\\n\", res1);\nreturn 1;\n}\nif (opae_set_properties_from_args(device_filter,\n&amp;res1,\n&amp;argc,\nargv)) {\nprint_err(\"failed arg parse.\\n\", res1);\nres1 = FPGA_EXCEPTION;\ngoto out_exit;\n} else if (res1) {\nprint_err(\"failed to set properties.\\n\", res1);\ngoto out_exit;\n}\nres1 = parse_args(argc, argv);\nif ((int)res1 &lt; 0)\ngoto out_exit;\nON_ERR_GOTO(res1, out_exit, \"parsing arguments\");\nif (config.run_n3000) {\nif (uuid_parse(N3000_AFUID, guid) &lt; 0)\nres1 = FPGA_EXCEPTION;\n} else {\nif (uuid_parse(NLB0_AFUID, guid) &lt; 0)\nres1 = FPGA_EXCEPTION;\n}\nON_ERR_GOTO(res1, out_exit, \"parsing guid\");\nuse_ase = probe_for_ase();\nif (use_ase) {\nprintf(\"Running in ASE mode\\n\");\n}\n/* Look for accelerator with NLB0_AFUID */\nres1 = find_fpga(device_filter,\nguid,\n&amp;accelerator_token,\n&amp;num_matches_accelerators);\nON_ERR_GOTO(res1, out_exit, \"finding FPGA accelerator\");\nif (num_matches_accelerators == 0) {\nres1 = FPGA_NOT_FOUND;\n}\nON_ERR_GOTO(res1, out_exit, \"no matching accelerator\");\nif (num_matches_accelerators &gt; 1) {\nprintf(\"Found more than one suitable accelerator. \");\n}\n/* Open accelerator and map MMIO */\nres1 = fpgaOpen(accelerator_token, &amp;accelerator_handle, config.open_flags);\nON_ERR_GOTO(res1, out_destroy_tok, \"opening accelerator\");\nres1 = fpgaMapMMIO(accelerator_handle, 0, NULL);\nON_ERR_GOTO(res1, out_close, \"mapping MMIO space\");\n/* Allocate buffers */\nres1 = fpgaPrepareBuffer(accelerator_handle, LPBK1_DSM_SIZE,\n(void **)&amp;dsm_ptr, &amp;dsm_wsid, 0);\nON_ERR_GOTO(res1, out_close, \"allocating DSM buffer\");\nres1 = fpgaPrepareBuffer(accelerator_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n(void **)&amp;input_ptr, &amp;input_wsid, 0);\nON_ERR_GOTO(res1, out_free_dsm, \"allocating input buffer\");\nres1 = fpgaPrepareBuffer(accelerator_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n(void **)&amp;output_ptr, &amp;output_wsid, 0);\nON_ERR_GOTO(res1, out_free_input, \"allocating output buffer\");\nprintf(\"Running Test\\n\");\n/* Initialize buffers */\nmemset((void *)dsm_ptr,    0,    LPBK1_DSM_SIZE);\nmemset((void *)input_ptr,  0xAF, LPBK1_BUFFER_SIZE);\nmemset((void *)output_ptr, 0xBE, LPBK1_BUFFER_SIZE);\ncache_line *cl_ptr = (cache_line *)input_ptr;\nfor (i = 0; i &lt; LPBK1_BUFFER_SIZE / CL(1); ++i) {\ncl_ptr[i].uint[15] = i+1; /* set the last uint in every cacheline */\n}\n/* Reset accelerator */\nres1 = fpgaReset(accelerator_handle);\nON_ERR_GOTO(res1, out_free_output, \"resetting accelerator\");\nuint64_t nlb_base_addr = 0;\nif (config.run_n3000) {\nres1 = find_nlb_n3000(accelerator_handle, &amp;nlb_base_addr);\nON_ERR_GOTO(res1, out_free_output, \"finding nlb in AFU\");\n}\n/* Program DMA addresses */\nuint64_t iova = 0;\nres1 = fpgaGetIOAddress(accelerator_handle, dsm_wsid, &amp;iova);\nON_ERR_GOTO(res1, out_free_output, \"getting DSM IOVA\");\nres1 = fpgaWriteMMIO64(accelerator_handle, 0, nlb_base_addr + CSR_AFU_DSM_BASEL, iova);\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_AFU_DSM_BASEL\");\nres1 = fpgaWriteMMIO32(accelerator_handle, 0, nlb_base_addr + CSR_CTL, 0);\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_CFG\");\nres1 = fpgaWriteMMIO32(accelerator_handle, 0, nlb_base_addr + CSR_CTL, 1);\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_CFG\");\nres1 = fpgaGetIOAddress(accelerator_handle, input_wsid, &amp;iova);\nON_ERR_GOTO(res1, out_free_output, \"getting input IOVA\");\nres1 = fpgaWriteMMIO64(accelerator_handle, 0, nlb_base_addr + CSR_SRC_ADDR, CACHELINE_ALIGNED_ADDR(iova));\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_SRC_ADDR\");\nres1 = fpgaGetIOAddress(accelerator_handle, output_wsid, &amp;iova);\nON_ERR_GOTO(res1, out_free_output, \"getting output IOVA\");\nres1 = fpgaWriteMMIO64(accelerator_handle, 0, nlb_base_addr + CSR_DST_ADDR, CACHELINE_ALIGNED_ADDR(iova));\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_DST_ADDR\");\nres1 = fpgaWriteMMIO32(accelerator_handle, 0, nlb_base_addr + CSR_NUM_LINES, LPBK1_BUFFER_SIZE / CL(1));\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_NUM_LINES\");\nres1 = fpgaWriteMMIO32(accelerator_handle, 0, nlb_base_addr + CSR_CFG, 0x42000);\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_CFG\");\nstatus_ptr = dsm_ptr + DSM_STATUS_TEST_COMPLETE/sizeof(uint64_t);\n/* Start the test */\nres1 = fpgaWriteMMIO32(accelerator_handle, 0, nlb_base_addr + CSR_CTL, 3);\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_CFG\");\n/* Wait for test completion */\ntimeout = TEST_TIMEOUT;\nwhile (0 == ((*status_ptr) &amp; 0x1)) {\nusleep(100);\nif (!use_ase &amp;&amp; (--timeout == 0)) {\nres1 = FPGA_EXCEPTION;\nON_ERR_GOTO(res1, out_free_output, \"test timed out\");\n}\n}\n/* Stop the device */\nres1 = fpgaWriteMMIO32(accelerator_handle, 0, nlb_base_addr + CSR_CTL, 7);\nON_ERR_GOTO(res1, out_free_output, \"writing CSR_CFG\");\n/* Wait for the AFU's read/write traffic to complete */\nuint32_t afu_traffic_trips = 0;\nwhile (afu_traffic_trips &lt; 100) {\n/*\n         * CSR_STATUS1 holds two 32 bit values: num pending reads and writes.\n         * Wait for it to be 0.\n         */\nuint64_t s1;\nres1 = fpgaReadMMIO64(accelerator_handle, 0, nlb_base_addr + CSR_STATUS1, &amp;s1);\nON_ERR_GOTO(res1, out_free_output, \"reading CSR_STATUS1\");\nif (s1 == 0) {\nbreak;\n}\nafu_traffic_trips += 1;\nusleep(1000);\n}\n/* Check output buffer contents */\nfor (i = 0; i &lt; LPBK1_BUFFER_SIZE; i++) {\nif (((uint8_t *)output_ptr)[i] != ((uint8_t *)input_ptr)[i]) {\nfprintf(stderr, \"Output does NOT match input \"\n\"at offset %i!\\n\", i);\nbreak;\n}\n}\nprintf(\"Done Running Test\\n\");\n/* Release buffers */\nout_free_output:\nres2 = fpgaReleaseBuffer(accelerator_handle, output_wsid);\nON_ERR_GOTO(res2, out_free_input, \"releasing output buffer\");\nout_free_input:\nres2 = fpgaReleaseBuffer(accelerator_handle, input_wsid);\nON_ERR_GOTO(res2, out_free_dsm, \"releasing input buffer\");\nout_free_dsm:\nres2 = fpgaReleaseBuffer(accelerator_handle, dsm_wsid);\nON_ERR_GOTO(res2, out_unmap, \"releasing DSM buffer\");\n/* Unmap MMIO space */\nout_unmap:\nres2 = fpgaUnmapMMIO(accelerator_handle, 0);\nON_ERR_GOTO(res2, out_close, \"unmapping MMIO space\");\n/* Release accelerator */\nout_close:\nres2 = fpgaClose(accelerator_handle);\nON_ERR_GOTO(res2, out_destroy_tok, \"closing accelerator\");\n/* Destroy token */\nout_destroy_tok:\nres2 = fpgaDestroyToken(&amp;accelerator_token);\nON_ERR_GOTO(res2, out_exit, \"destroying token\");\nout_exit:\nfpgaDestroyProperties(&amp;device_filter);\nreturn res1 != FPGA_OK ? res1 : res2;\n}\n</code></pre>"},{"location":"opae-code/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace opae <ul> <li>namespace fpga <ul> <li>namespace types <ul> <li>namespace detail </li> </ul> </li> </ul> </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"opae-code/classes/","title":"Class Index","text":""},{"location":"opae-code/classes/#b","title":"b","text":"<ul> <li>busy (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#c","title":"c","text":"<ul> <li>cache_line</li> <li>config</li> </ul>"},{"location":"opae-code/classes/#e","title":"e","text":"<ul> <li>error (opae::fpga::types)</li> <li>event (opae::fpga::types)</li> <li>except (opae::fpga::types)</li> <li>exception (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#f","title":"f","text":"<ul> <li>fpga_error_info</li> <li>fpga_metric</li> <li>fpga_metric_info</li> <li>fpga_version</li> </ul>"},{"location":"opae-code/classes/#g","title":"g","text":"<ul> <li>guid_t (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#h","title":"h","text":"<ul> <li>handle (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#i","title":"i","text":"<ul> <li>invalid_param (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#m","title":"m","text":"<ul> <li>mem_alloc</li> <li>mem_link</li> <li>metric_threshold</li> </ul>"},{"location":"opae-code/classes/#n","title":"n","text":"<ul> <li>no_access (opae::fpga::types)</li> <li>no_daemon (opae::fpga::types)</li> <li>no_driver (opae::fpga::types)</li> <li>no_memory (opae::fpga::types)</li> <li>not_found (opae::fpga::types)</li> <li>not_supported (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#o","title":"o","text":"<ul> <li>opae_uio</li> <li>opae_uio_device_region</li> <li>opae_vfio</li> <li>opae_vfio_buffer</li> <li>opae_vfio_device</li> <li>opae_vfio_device_irq</li> <li>opae_vfio_device_region</li> <li>opae_vfio_group</li> <li>opae_vfio_iova_range</li> <li>opae_vfio_sparse_info</li> </ul>"},{"location":"opae-code/classes/#p","title":"p","text":"<ul> <li>properties (opae::fpga::types)</li> <li>pvalue (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#r","title":"r","text":"<ul> <li>reconf_error (opae::fpga::types)</li> <li>ras_inject_error</li> </ul>"},{"location":"opae-code/classes/#s","title":"s","text":"<ul> <li>shared_buffer (opae::fpga::types)</li> <li>src_location (opae::fpga::types)</li> <li>sysobject (opae::fpga::types)</li> </ul>"},{"location":"opae-code/classes/#t","title":"t","text":"<ul> <li>token (opae::fpga::types)</li> <li>type_t (opae::fpga::types::event)</li> <li>threshold</li> </ul>"},{"location":"opae-code/classes/#v","title":"v","text":"<ul> <li>version (opae::fpga::types)</li> </ul> <p>## \\</p> <ul> <li>_fpga_token_header</li> <li>_opae_hash_map</li> <li>_opae_hash_map_item</li> </ul>"},{"location":"opae-code/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class opae::fpga::types::error An error object represents an error register for a resource. </li> <li>class opae::fpga::types::event Wraps fpga event routines in OPAE C. </li> <li>class opae::fpga::types::handle An allocated accelerator resource. </li> <li>class opae::fpga::types::properties Wraps an OPAE fpga_properties object. </li> <li>class opae::fpga::types::shared_buffer Host/AFU shared memory blocks. </li> <li>class opae::fpga::types::src_location Identify a particular line in a source file. </li> <li>class opae::fpga::types::sysobject Wraps the OPAE fpga_object primitive. </li> <li>class opae::fpga::types::token Wraps the OPAE fpga_token primitive. </li> <li>class opae::fpga::types::version </li> <li>struct _fpga_token_header Internal token type header. </li> <li>struct _opae_hash_map Hash map object. </li> <li>struct _opae_hash_map_item List link item. </li> <li>struct cache_line </li> <li>struct config </li> <li>struct fpga_error_info </li> <li>struct fpga_metric Metric struct. </li> <li>struct fpga_metric_info Metric info struct. </li> <li>struct fpga_version Semantic version. </li> <li>struct mem_alloc </li> <li>struct mem_link Provides an API for allocating/freeing a logical address space. </li> <li>struct metric_threshold </li> <li>struct opae::fpga::types::event::type_t C++ struct that is interchangeable with fpga_event_type enum. </li> <li>struct opae::fpga::types::guid_t Representation of the guid member of a properties object. </li> <li>struct opae::fpga::types::pvalue Wraps OPAE properties defined in the OPAE C API by associating an <code>fpga_properties</code> reference with the getters and setters defined for a property.</li> <li>struct opae_uio OPAE UIO device abstraction. </li> <li>struct opae_uio_device_region MMIO region info. </li> <li>struct opae_vfio OPAE VFIO device abstraction. </li> <li>struct opae_vfio_buffer System DMA buffer. </li> <li>struct opae_vfio_device VFIO device. </li> <li>struct opae_vfio_device_irq Interrupt info. </li> <li>struct opae_vfio_device_region MMIO region info. </li> <li>struct opae_vfio_group VFIO group. </li> <li>struct opae_vfio_iova_range IO Virtual Address Range. </li> <li>struct opae_vfio_sparse_info MMIO sparse-mappable region info. </li> <li>struct ras_inject_error </li> <li>struct threshold Threshold struct. </li> <li>class std::exception <ul> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> <li>class opae::fpga::types::except Generic OPAE exception. <ul> <li>class opae::fpga::types::busy busy exception </li> <li>class opae::fpga::types::exception exception exception </li> <li>class opae::fpga::types::invalid_param invalid_param exception</li> <li>class opae::fpga::types::no_access no_access exception</li> <li>class opae::fpga::types::no_daemon no_daemon exception</li> <li>class opae::fpga::types::no_driver no_driver exception</li> <li>class opae::fpga::types::no_memory no_memory exception</li> <li>class opae::fpga::types::not_found not_found exception</li> <li>class opae::fpga::types::not_supported not_supported exception</li> <li>class opae::fpga::types::reconf_error reconf_error exception</li> </ul> </li> </ul> </li> </ul>"},{"location":"opae-code/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"opae-code/todo/","title":"Todo List","text":""},{"location":"opae-code/todo/#global-fpgaregisterevent-fpga_handle-handle-fpga_event_type-event_type-fpga_event_handle-event_handle-uint32_t-flags","title":"Global fpgaRegisterEvent  (fpga_handle handle, fpga_event_type event_type, fpga_event_handle event_handle, uint32_t flags)","text":"<p>define if calling fpgaRegisterEvent multiple times with the same event_handle is an error condition or if it is silently ignored.  define if calling fpgaUnregisterEvent multiple times with the same event_handle is an error condition or if it is silently ignored.</p>"},{"location":"opae-code/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"opae-code/class_members/","title":"Class Members","text":""},{"location":"opae-code/class_members/#a","title":"a","text":"<ul> <li>allocated (mem_alloc)</li> <li>address (mem_link)</li> <li>accelerator_state (opae::fpga::types::properties)</li> <li>allocate (opae::fpga::types::shared_buffer)</li> <li>attach (opae::fpga::types::shared_buffer)</li> <li>as_string (opae::fpga::types::version)</li> <li>as_struct (opae::fpga::types::version)</li> </ul>"},{"location":"opae-code/class_members/#b","title":"b","text":"<ul> <li>bus (_fpga_token_header, opae::fpga::types::properties)</li> <li>buckets (_opae_hash_map)</li> <li>busy (opae::fpga::types::busy)</li> <li>buf_ (opae::fpga::types::except)</li> <li>bbs_id (opae::fpga::types::properties)</li> <li>bbs_version (opae::fpga::types::properties)</li> <li>bytes (opae::fpga::types::sysobject)</li> <li>build (opae::fpga::types::version)</li> <li>buffer_iova (opae_vfio_buffer)</li> <li>buffer_ptr (opae_vfio_buffer)</li> <li>buffer_size (opae_vfio_buffer)</li> </ul>"},{"location":"opae-code/class_members/#c","title":"c","text":"<ul> <li>cleanup_context (_opae_hash_map)</li> <li>can_clear (fpga_error_info, opae::fpga::types::error)</li> <li>c_type (opae::fpga::types::error, opae::fpga::types::guid_t, opae::fpga::types::handle, opae::fpga::types::properties, opae::fpga::types::shared_buffer, opae::fpga::types::sysobject, opae::fpga::types::token)</li> <li>close (opae::fpga::types::handle)</li> <li>capabilities (opae::fpga::types::properties)</li> <li>copy_ (opae::fpga::types::pvalue)</li> <li>copy_t (opae::fpga::types::pvalue)</li> <li>compare (opae::fpga::types::shared_buffer)</li> <li>cont_buffers (opae_vfio)</li> <li>cont_device (opae_vfio)</li> <li>cont_fd (opae_vfio)</li> <li>cont_pciaddr (opae_vfio)</li> <li>cont_ranges (opae_vfio)</li> <li>count (opae_vfio_device_irq)</li> <li>catastrophicr_error (ras_inject_error)</li> <li>csr (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_members/#d","title":"d","text":"<ul> <li>device (_fpga_token_header, opae::fpga::types::properties, opae_vfio)</li> <li>device_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>data_ (opae::fpga::types::guid_t)</li> <li>device_fd (opae_uio, opae_vfio_device)</li> <li>device_path (opae_uio)</li> <li>device_config_offset (opae_vfio_device)</li> <li>device_num_irqs (opae_vfio_device)</li> <li>device_num_regions (opae_vfio_device)</li> </ul>"},{"location":"opae-code/class_members/#e","title":"e","text":"<ul> <li>error (opae::fpga::types::error, opae::fpga::types::event::type_t)</li> <li>error_info_ (opae::fpga::types::error)</li> <li>error_num_ (opae::fpga::types::error)</li> <li>event (opae::fpga::types::event)</li> <li>event_handle_ (opae::fpga::types::event)</li> <li>except (opae::fpga::types::except)</li> <li>exception (opae::fpga::types::exception)</li> <li>enumerate (opae::fpga::types::token)</li> <li>event_fds (opae_vfio_device_irq)</li> <li>end (opae_vfio_iova_range)</li> </ul>"},{"location":"opae-code/class_members/#f","title":"f","text":"<ul> <li>function (_fpga_token_header, opae::fpga::types::properties)</li> <li>flags (_opae_hash_map, opae_vfio_buffer, opae_vfio_device_irq)</li> <li>free (mem_alloc)</li> <li>fill (opae::fpga::types::shared_buffer)</li> <li>file (opae::fpga::types::src_location)</li> <li>file_ (opae::fpga::types::src_location)</li> <li>fn (opae::fpga::types::src_location)</li> <li>fn_ (opae::fpga::types::src_location)</li> <li>fatal_error (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_members/#g","title":"g","text":"<ul> <li>guid (_fpga_token_header, opae::fpga::types::properties)</li> <li>group_name (fpga_metric_info)</li> <li>get (opae::fpga::types::error, opae::fpga::types::event, opae::fpga::types::properties, opae::fpga::types::sysobject)</li> <li>guid_t (opae::fpga::types::guid_t)</li> <li>get_token (opae::fpga::types::handle)</li> <li>get_ (opae::fpga::types::pvalue)</li> <li>get_value (opae::fpga::types::pvalue)</li> <li>getter_t (opae::fpga::types::pvalue)</li> <li>get_parent (opae::fpga::types::token)</li> <li>group (opae_vfio)</li> <li>group_device (opae_vfio_group)</li> <li>group_fd (opae_vfio_group)</li> </ul>"},{"location":"opae-code/class_members/#h","title":"h","text":"<ul> <li>hash_seed (_opae_hash_map)</li> <li>hysteresis (metric_threshold)</li> <li>handle_ (opae::fpga::types::event, opae::fpga::types::handle, opae::fpga::types::shared_buffer, opae::fpga::types::sysobject)</li> <li>handle (opae::fpga::types::handle)</li> </ul>"},{"location":"opae-code/class_members/#i","title":"i","text":"<ul> <li>interface (_fpga_token_header, opae::fpga::types::properties)</li> <li>isvalid (fpga_metric)</li> <li>interrupt (opae::fpga::types::event::type_t)</li> <li>invalidate (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>is_set (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>is_set_ (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>invalid_param (opae::fpga::types::invalid_param)</li> <li>io_address (opae::fpga::types::shared_buffer)</li> <li>io_address_ (opae::fpga::types::shared_buffer)</li> <li>iova_alloc (opae_vfio)</li> <li>irqs (opae_vfio_device)</li> <li>index (opae_vfio_device_irq, opae_vfio_sparse_info)</li> <li>is_valid (threshold)</li> </ul>"},{"location":"opae-code/class_members/#k","title":"k","text":"<ul> <li>key_cleanup (_opae_hash_map)</li> <li>key_compare (_opae_hash_map)</li> <li>key_hash (_opae_hash_map)</li> <li>key (_opae_hash_map_item)</li> </ul>"},{"location":"opae-code/class_members/#l","title":"l","text":"<ul> <li>lower_c_threshold (metric_threshold)</li> <li>lower_nc_threshold (metric_threshold)</li> <li>lower_nr_threshold (metric_threshold)</li> <li>loc_ (opae::fpga::types::except)</li> <li>local_memory_size (opae::fpga::types::properties)</li> <li>len_ (opae::fpga::types::shared_buffer)</li> <li>line (opae::fpga::types::src_location)</li> <li>line_ (opae::fpga::types::src_location)</li> <li>lock (opae_vfio)</li> </ul>"},{"location":"opae-code/class_members/#m","title":"m","text":"<ul> <li>magic (_fpga_token_header)</li> <li>metric_num (fpga_metric, fpga_metric_info)</li> <li>metric_datatype (fpga_metric_info)</li> <li>metric_guid (fpga_metric_info)</li> <li>metric_name (fpga_metric_info, metric_threshold)</li> <li>metric_type (fpga_metric_info)</li> <li>metric_units (fpga_metric_info)</li> <li>major (fpga_version)</li> <li>minor (fpga_version)</li> <li>MAX_EXCEPT (opae::fpga::types::except)</li> <li>msg_ (opae::fpga::types::except)</li> <li>mmio_ptr (opae::fpga::types::handle)</li> <li>model (opae::fpga::types::properties)</li> <li>masks (opae_vfio_device_irq)</li> </ul>"},{"location":"opae-code/class_members/#n","title":"n","text":"<ul> <li>num_buckets (_opae_hash_map)</li> <li>next (_opae_hash_map_item, mem_link, opae_uio_device_region, opae_vfio_device_irq, opae_vfio_device_region, opae_vfio_iova_range, opae_vfio_sparse_info)</li> <li>name (fpga_error_info, opae::fpga::types::error)</li> <li>no_access (opae::fpga::types::no_access)</li> <li>no_daemon (opae::fpga::types::no_daemon)</li> <li>no_driver (opae::fpga::types::no_driver)</li> <li>no_memory (opae::fpga::types::no_memory)</li> <li>not_found (opae::fpga::types::not_found)</li> <li>not_supported (opae::fpga::types::not_supported)</li> <li>none (opae::fpga::types::properties)</li> <li>num_errors (opae::fpga::types::properties)</li> <li>num_interrupts (opae::fpga::types::properties)</li> <li>num_mmio (opae::fpga::types::properties)</li> <li>num_slots (opae::fpga::types::properties)</li> <li>nonfatal_error (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_members/#o","title":"o","text":"<ul> <li>object_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>objtype (_fpga_token_header)</li> <li>open_flags (config)</li> <li>operator= (opae::fpga::types::error, opae::fpga::types::guid_t, opae::fpga::types::handle, opae::fpga::types::properties, opae::fpga::types::pvalue, opae::fpga::types::shared_buffer, opae::fpga::types::src_location, opae::fpga::types::sysobject)</li> <li>operator fpga_event_type (opae::fpga::types::event::type_t)</li> <li>operator fpga_event_handle (opae::fpga::types::event)</li> <li>os_object (opae::fpga::types::event)</li> <li>os_object_ (opae::fpga::types::event)</li> <li>operator fpga_result (opae::fpga::types::except)</li> <li>operator uint8_t * (opae::fpga::types::guid_t)</li> <li>operator== (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>open (opae::fpga::types::handle)</li> <li>operator fpga_handle (opae::fpga::types::handle)</li> <li>operator fpga_properties (opae::fpga::types::properties)</li> <li>operator copy_t (opae::fpga::types::pvalue)</li> <li>owner (opae::fpga::types::shared_buffer)</li> <li>operator fpga_object (opae::fpga::types::sysobject)</li> <li>operator fpga_token (opae::fpga::types::token)</li> <li>offset (opae_vfio_sparse_info)</li> </ul>"},{"location":"opae-code/class_members/#p","title":"p","text":"<ul> <li>patch (fpga_version)</li> <li>prev (mem_link)</li> <li>ptr_t (opae::fpga::types::error, opae::fpga::types::event, opae::fpga::types::handle, opae::fpga::types::properties, opae::fpga::types::shared_buffer, opae::fpga::types::sysobject, opae::fpga::types::token)</li> <li>power_thermal (opae::fpga::types::event::type_t)</li> <li>parse (opae::fpga::types::guid_t)</li> <li>props_ (opae::fpga::types::guid_t, opae::fpga::types::properties, opae::fpga::types::pvalue)</li> <li>parent (opae::fpga::types::properties)</li> <li>properties (opae::fpga::types::properties)</li> <li>pvalue (opae::fpga::types::pvalue)</li> <li>ptr (opae_vfio_sparse_info)</li> </ul>"},{"location":"opae-code/class_members/#q","title":"q","text":"<ul> <li>qualifier_name (fpga_metric_info)</li> </ul>"},{"location":"opae-code/class_members/#r","title":"r","text":"<ul> <li>run_n3000 (config)</li> <li>read_value (opae::fpga::types::error)</li> <li>register_event (opae::fpga::types::event)</li> <li>res_ (opae::fpga::types::except)</li> <li>read_csr32 (opae::fpga::types::handle)</li> <li>read_csr64 (opae::fpga::types::handle)</li> <li>reconfigure (opae::fpga::types::handle)</li> <li>reset (opae::fpga::types::handle)</li> <li>reconf_error (opae::fpga::types::reconf_error)</li> <li>read (opae::fpga::types::shared_buffer)</li> <li>release (opae::fpga::types::shared_buffer)</li> <li>read64 (opae::fpga::types::sysobject)</li> <li>regions (opae_uio, opae_vfio_device)</li> <li>region_index (opae_uio_device_region, opae_vfio_device_region)</li> <li>region_page_offset (opae_uio_device_region)</li> <li>region_ptr (opae_uio_device_region, opae_vfio_device_region)</li> <li>region_size (opae_uio_device_region, opae_vfio_device_region)</li> <li>region_sparse (opae_vfio_device_region)</li> <li>rsvd (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_members/#s","title":"s","text":"<ul> <li>segment (_fpga_token_header, opae::fpga::types::properties)</li> <li>subsystem_device_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>subsystem_vendor_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>size (mem_link, opae::fpga::types::shared_buffer, opae::fpga::types::sysobject, opae_vfio_sparse_info)</li> <li>socket_id (opae::fpga::types::properties)</li> <li>set_ (opae::fpga::types::pvalue)</li> <li>setter_t (opae::fpga::types::pvalue)</li> <li>shared_buffer (opae::fpga::types::shared_buffer)</li> <li>size_t (opae::fpga::types::shared_buffer)</li> <li>src_location (opae::fpga::types::src_location)</li> <li>sysobject (opae::fpga::types::sysobject)</li> <li>sysobject_ (opae::fpga::types::sysobject)</li> <li>start (opae_vfio_iova_range)</li> </ul>"},{"location":"opae-code/class_members/#t","title":"t","text":"<ul> <li>token_ (opae::fpga::types::error, opae::fpga::types::handle, opae::fpga::types::sysobject, opae::fpga::types::token)</li> <li>type_ (opae::fpga::types::event::type_t, opae::fpga::types::event)</li> <li>type_t (opae::fpga::types::event::type_t)</li> <li>type (opae::fpga::types::properties, opae::fpga::types::sysobject)</li> <li>token (opae::fpga::types::token)</li> <li>threshold_name (threshold)</li> </ul>"},{"location":"opae-code/class_members/#u","title":"u","text":"<ul> <li>uint (cache_line)</li> <li>upper_c_threshold (metric_threshold)</li> <li>upper_nc_threshold (metric_threshold)</li> <li>upper_nr_threshold (metric_threshold)</li> <li>update (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> </ul>"},{"location":"opae-code/class_members/#v","title":"v","text":"<ul> <li>vendor_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>value_cleanup (_opae_hash_map)</li> <li>value (_opae_hash_map_item, fpga_metric, threshold)</li> <li>virt_ (opae::fpga::types::shared_buffer)</li> </ul>"},{"location":"opae-code/class_members/#w","title":"w","text":"<ul> <li>what (opae::fpga::types::except)</li> <li>write_csr32 (opae::fpga::types::handle)</li> <li>write_csr512 (opae::fpga::types::handle)</li> <li>write_csr64 (opae::fpga::types::handle)</li> <li>write (opae::fpga::types::shared_buffer)</li> <li>wsid (opae::fpga::types::shared_buffer)</li> <li>wsid_ (opae::fpga::types::shared_buffer)</li> <li>write64 (opae::fpga::types::sysobject)</li> </ul>"},{"location":"opae-code/class_members/#_1","title":"~","text":"<ul> <li>~error (opae::fpga::types::error)</li> <li>~event (opae::fpga::types::event)</li> <li>~handle (opae::fpga::types::handle)</li> <li>~properties (opae::fpga::types::properties)</li> <li>~shared_buffer (opae::fpga::types::shared_buffer)</li> <li>~sysobject (opae::fpga::types::sysobject)</li> <li>~token (opae::fpga::types::token)</li> </ul>"},{"location":"opae-code/class_members/#_2","title":"@","text":"<ul> <li>@1 (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_member_functions/","title":"Class Member Functions","text":""},{"location":"opae-code/class_member_functions/#a","title":"a","text":"<ul> <li>allocate (opae::fpga::types::shared_buffer)</li> <li>attach (opae::fpga::types::shared_buffer)</li> <li>as_string (opae::fpga::types::version)</li> <li>as_struct (opae::fpga::types::version)</li> </ul>"},{"location":"opae-code/class_member_functions/#b","title":"b","text":"<ul> <li>busy (opae::fpga::types::busy)</li> <li>bytes (opae::fpga::types::sysobject)</li> <li>build (opae::fpga::types::version)</li> </ul>"},{"location":"opae-code/class_member_functions/#c","title":"c","text":"<ul> <li>c_type (opae::fpga::types::error, opae::fpga::types::guid_t, opae::fpga::types::handle, opae::fpga::types::properties, opae::fpga::types::shared_buffer, opae::fpga::types::sysobject, opae::fpga::types::token)</li> <li>can_clear (opae::fpga::types::error)</li> <li>close (opae::fpga::types::handle)</li> <li>compare (opae::fpga::types::shared_buffer)</li> </ul>"},{"location":"opae-code/class_member_functions/#e","title":"e","text":"<ul> <li>error (opae::fpga::types::error)</li> <li>event (opae::fpga::types::event)</li> <li>except (opae::fpga::types::except)</li> <li>exception (opae::fpga::types::exception)</li> <li>enumerate (opae::fpga::types::token)</li> </ul>"},{"location":"opae-code/class_member_functions/#f","title":"f","text":"<ul> <li>fill (opae::fpga::types::shared_buffer)</li> <li>file (opae::fpga::types::src_location)</li> <li>fn (opae::fpga::types::src_location)</li> </ul>"},{"location":"opae-code/class_member_functions/#g","title":"g","text":"<ul> <li>get (opae::fpga::types::error, opae::fpga::types::event, opae::fpga::types::properties, opae::fpga::types::sysobject)</li> <li>guid_t (opae::fpga::types::guid_t)</li> <li>get_token (opae::fpga::types::handle)</li> <li>get_value (opae::fpga::types::pvalue)</li> <li>get_parent (opae::fpga::types::token)</li> </ul>"},{"location":"opae-code/class_member_functions/#h","title":"h","text":"<ul> <li>handle (opae::fpga::types::handle)</li> </ul>"},{"location":"opae-code/class_member_functions/#i","title":"i","text":"<ul> <li>invalidate (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>is_set (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>invalid_param (opae::fpga::types::invalid_param)</li> <li>io_address (opae::fpga::types::shared_buffer)</li> </ul>"},{"location":"opae-code/class_member_functions/#l","title":"l","text":"<ul> <li>line (opae::fpga::types::src_location)</li> </ul>"},{"location":"opae-code/class_member_functions/#m","title":"m","text":"<ul> <li>mmio_ptr (opae::fpga::types::handle)</li> </ul>"},{"location":"opae-code/class_member_functions/#n","title":"n","text":"<ul> <li>name (opae::fpga::types::error)</li> <li>no_access (opae::fpga::types::no_access)</li> <li>no_daemon (opae::fpga::types::no_daemon)</li> <li>no_driver (opae::fpga::types::no_driver)</li> <li>no_memory (opae::fpga::types::no_memory)</li> <li>not_found (opae::fpga::types::not_found)</li> <li>not_supported (opae::fpga::types::not_supported)</li> </ul>"},{"location":"opae-code/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (opae::fpga::types::error, opae::fpga::types::guid_t, opae::fpga::types::handle, opae::fpga::types::properties, opae::fpga::types::pvalue, opae::fpga::types::shared_buffer, opae::fpga::types::src_location, opae::fpga::types::sysobject)</li> <li>operator fpga_event_type (opae::fpga::types::event::type_t)</li> <li>operator fpga_event_handle (opae::fpga::types::event)</li> <li>os_object (opae::fpga::types::event)</li> <li>operator fpga_result (opae::fpga::types::except)</li> <li>operator uint8_t * (opae::fpga::types::guid_t)</li> <li>operator== (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>open (opae::fpga::types::handle)</li> <li>operator fpga_handle (opae::fpga::types::handle)</li> <li>operator fpga_properties (opae::fpga::types::properties)</li> <li>operator copy_t (opae::fpga::types::pvalue)</li> <li>owner (opae::fpga::types::shared_buffer)</li> <li>operator fpga_object (opae::fpga::types::sysobject)</li> <li>operator fpga_token (opae::fpga::types::token)</li> </ul>"},{"location":"opae-code/class_member_functions/#p","title":"p","text":"<ul> <li>parse (opae::fpga::types::guid_t)</li> <li>properties (opae::fpga::types::properties)</li> <li>pvalue (opae::fpga::types::pvalue)</li> </ul>"},{"location":"opae-code/class_member_functions/#r","title":"r","text":"<ul> <li>read_value (opae::fpga::types::error)</li> <li>register_event (opae::fpga::types::event)</li> <li>read_csr32 (opae::fpga::types::handle)</li> <li>read_csr64 (opae::fpga::types::handle)</li> <li>reconfigure (opae::fpga::types::handle)</li> <li>reset (opae::fpga::types::handle)</li> <li>reconf_error (opae::fpga::types::reconf_error)</li> <li>read (opae::fpga::types::shared_buffer)</li> <li>release (opae::fpga::types::shared_buffer)</li> <li>read64 (opae::fpga::types::sysobject)</li> </ul>"},{"location":"opae-code/class_member_functions/#s","title":"s","text":"<ul> <li>shared_buffer (opae::fpga::types::shared_buffer)</li> <li>size (opae::fpga::types::shared_buffer, opae::fpga::types::sysobject)</li> <li>src_location (opae::fpga::types::src_location)</li> <li>sysobject (opae::fpga::types::sysobject)</li> </ul>"},{"location":"opae-code/class_member_functions/#t","title":"t","text":"<ul> <li>type_t (opae::fpga::types::event::type_t)</li> <li>type (opae::fpga::types::sysobject)</li> <li>token (opae::fpga::types::token)</li> </ul>"},{"location":"opae-code/class_member_functions/#u","title":"u","text":"<ul> <li>update (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> </ul>"},{"location":"opae-code/class_member_functions/#w","title":"w","text":"<ul> <li>what (opae::fpga::types::except)</li> <li>write_csr32 (opae::fpga::types::handle)</li> <li>write_csr512 (opae::fpga::types::handle)</li> <li>write_csr64 (opae::fpga::types::handle)</li> <li>write (opae::fpga::types::shared_buffer)</li> <li>wsid (opae::fpga::types::shared_buffer)</li> <li>write64 (opae::fpga::types::sysobject)</li> </ul>"},{"location":"opae-code/class_member_functions/#_1","title":"~","text":"<ul> <li>~error (opae::fpga::types::error)</li> <li>~event (opae::fpga::types::event)</li> <li>~handle (opae::fpga::types::handle)</li> <li>~properties (opae::fpga::types::properties)</li> <li>~shared_buffer (opae::fpga::types::shared_buffer)</li> <li>~sysobject (opae::fpga::types::sysobject)</li> <li>~token (opae::fpga::types::token)</li> </ul>"},{"location":"opae-code/class_member_variables/","title":"Class Member Variables","text":""},{"location":"opae-code/class_member_variables/#a","title":"a","text":"<ul> <li>allocated (mem_alloc)</li> <li>address (mem_link)</li> <li>accelerator_state (opae::fpga::types::properties)</li> </ul>"},{"location":"opae-code/class_member_variables/#b","title":"b","text":"<ul> <li>bus (_fpga_token_header, opae::fpga::types::properties)</li> <li>buckets (_opae_hash_map)</li> <li>buf_ (opae::fpga::types::except)</li> <li>bbs_id (opae::fpga::types::properties)</li> <li>bbs_version (opae::fpga::types::properties)</li> <li>buffer_iova (opae_vfio_buffer)</li> <li>buffer_ptr (opae_vfio_buffer)</li> <li>buffer_size (opae_vfio_buffer)</li> </ul>"},{"location":"opae-code/class_member_variables/#c","title":"c","text":"<ul> <li>cleanup_context (_opae_hash_map)</li> <li>can_clear (fpga_error_info)</li> <li>capabilities (opae::fpga::types::properties)</li> <li>copy_ (opae::fpga::types::pvalue)</li> <li>cont_buffers (opae_vfio)</li> <li>cont_device (opae_vfio)</li> <li>cont_fd (opae_vfio)</li> <li>cont_pciaddr (opae_vfio)</li> <li>cont_ranges (opae_vfio)</li> <li>count (opae_vfio_device_irq)</li> <li>catastrophicr_error (ras_inject_error)</li> <li>csr (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_member_variables/#d","title":"d","text":"<ul> <li>device (_fpga_token_header, opae::fpga::types::properties, opae_vfio)</li> <li>device_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>data_ (opae::fpga::types::guid_t)</li> <li>device_fd (opae_uio, opae_vfio_device)</li> <li>device_path (opae_uio)</li> <li>device_config_offset (opae_vfio_device)</li> <li>device_num_irqs (opae_vfio_device)</li> <li>device_num_regions (opae_vfio_device)</li> </ul>"},{"location":"opae-code/class_member_variables/#e","title":"e","text":"<ul> <li>error_info_ (opae::fpga::types::error)</li> <li>error_num_ (opae::fpga::types::error)</li> <li>event_handle_ (opae::fpga::types::event)</li> <li>error (opae::fpga::types::event::type_t)</li> <li>event_fds (opae_vfio_device_irq)</li> <li>end (opae_vfio_iova_range)</li> </ul>"},{"location":"opae-code/class_member_variables/#f","title":"f","text":"<ul> <li>function (_fpga_token_header, opae::fpga::types::properties)</li> <li>flags (_opae_hash_map, opae_vfio_buffer, opae_vfio_device_irq)</li> <li>free (mem_alloc)</li> <li>file_ (opae::fpga::types::src_location)</li> <li>fn_ (opae::fpga::types::src_location)</li> <li>fatal_error (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_member_variables/#g","title":"g","text":"<ul> <li>guid (_fpga_token_header, opae::fpga::types::properties)</li> <li>group_name (fpga_metric_info)</li> <li>get_ (opae::fpga::types::pvalue)</li> <li>group (opae_vfio)</li> <li>group_device (opae_vfio_group)</li> <li>group_fd (opae_vfio_group)</li> </ul>"},{"location":"opae-code/class_member_variables/#h","title":"h","text":"<ul> <li>hash_seed (_opae_hash_map)</li> <li>hysteresis (metric_threshold)</li> <li>handle_ (opae::fpga::types::event, opae::fpga::types::handle, opae::fpga::types::shared_buffer, opae::fpga::types::sysobject)</li> </ul>"},{"location":"opae-code/class_member_variables/#i","title":"i","text":"<ul> <li>interface (_fpga_token_header, opae::fpga::types::properties)</li> <li>isvalid (fpga_metric)</li> <li>interrupt (opae::fpga::types::event::type_t)</li> <li>is_set_ (opae::fpga::types::guid_t, opae::fpga::types::pvalue)</li> <li>io_address_ (opae::fpga::types::shared_buffer)</li> <li>iova_alloc (opae_vfio)</li> <li>irqs (opae_vfio_device)</li> <li>index (opae_vfio_device_irq, opae_vfio_sparse_info)</li> <li>is_valid (threshold)</li> </ul>"},{"location":"opae-code/class_member_variables/#k","title":"k","text":"<ul> <li>key_cleanup (_opae_hash_map)</li> <li>key_compare (_opae_hash_map)</li> <li>key_hash (_opae_hash_map)</li> <li>key (_opae_hash_map_item)</li> </ul>"},{"location":"opae-code/class_member_variables/#l","title":"l","text":"<ul> <li>lower_c_threshold (metric_threshold)</li> <li>lower_nc_threshold (metric_threshold)</li> <li>lower_nr_threshold (metric_threshold)</li> <li>loc_ (opae::fpga::types::except)</li> <li>local_memory_size (opae::fpga::types::properties)</li> <li>len_ (opae::fpga::types::shared_buffer)</li> <li>line_ (opae::fpga::types::src_location)</li> <li>lock (opae_vfio)</li> </ul>"},{"location":"opae-code/class_member_variables/#m","title":"m","text":"<ul> <li>magic (_fpga_token_header)</li> <li>metric_num (fpga_metric, fpga_metric_info)</li> <li>metric_datatype (fpga_metric_info)</li> <li>metric_guid (fpga_metric_info)</li> <li>metric_name (fpga_metric_info, metric_threshold)</li> <li>metric_type (fpga_metric_info)</li> <li>metric_units (fpga_metric_info)</li> <li>major (fpga_version)</li> <li>minor (fpga_version)</li> <li>MAX_EXCEPT (opae::fpga::types::except)</li> <li>msg_ (opae::fpga::types::except)</li> <li>model (opae::fpga::types::properties)</li> <li>masks (opae_vfio_device_irq)</li> </ul>"},{"location":"opae-code/class_member_variables/#n","title":"n","text":"<ul> <li>num_buckets (_opae_hash_map)</li> <li>next (_opae_hash_map_item, mem_link, opae_uio_device_region, opae_vfio_device_irq, opae_vfio_device_region, opae_vfio_iova_range, opae_vfio_sparse_info)</li> <li>name (fpga_error_info)</li> <li>none (opae::fpga::types::properties)</li> <li>num_errors (opae::fpga::types::properties)</li> <li>num_interrupts (opae::fpga::types::properties)</li> <li>num_mmio (opae::fpga::types::properties)</li> <li>num_slots (opae::fpga::types::properties)</li> <li>nonfatal_error (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_member_variables/#o","title":"o","text":"<ul> <li>object_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>objtype (_fpga_token_header)</li> <li>open_flags (config)</li> <li>os_object_ (opae::fpga::types::event)</li> <li>offset (opae_vfio_sparse_info)</li> </ul>"},{"location":"opae-code/class_member_variables/#p","title":"p","text":"<ul> <li>patch (fpga_version)</li> <li>prev (mem_link)</li> <li>power_thermal (opae::fpga::types::event::type_t)</li> <li>props_ (opae::fpga::types::guid_t, opae::fpga::types::properties, opae::fpga::types::pvalue)</li> <li>parent (opae::fpga::types::properties)</li> <li>ptr (opae_vfio_sparse_info)</li> </ul>"},{"location":"opae-code/class_member_variables/#q","title":"q","text":"<ul> <li>qualifier_name (fpga_metric_info)</li> </ul>"},{"location":"opae-code/class_member_variables/#r","title":"r","text":"<ul> <li>run_n3000 (config)</li> <li>res_ (opae::fpga::types::except)</li> <li>regions (opae_uio, opae_vfio_device)</li> <li>region_index (opae_uio_device_region, opae_vfio_device_region)</li> <li>region_page_offset (opae_uio_device_region)</li> <li>region_ptr (opae_uio_device_region, opae_vfio_device_region)</li> <li>region_size (opae_uio_device_region, opae_vfio_device_region)</li> <li>region_sparse (opae_vfio_device_region)</li> <li>rsvd (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_member_variables/#s","title":"s","text":"<ul> <li>segment (_fpga_token_header, opae::fpga::types::properties)</li> <li>subsystem_device_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>subsystem_vendor_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>size (mem_link, opae_vfio_sparse_info)</li> <li>socket_id (opae::fpga::types::properties)</li> <li>set_ (opae::fpga::types::pvalue)</li> <li>sysobject_ (opae::fpga::types::sysobject)</li> <li>start (opae_vfio_iova_range)</li> </ul>"},{"location":"opae-code/class_member_variables/#t","title":"t","text":"<ul> <li>token_ (opae::fpga::types::error, opae::fpga::types::handle, opae::fpga::types::sysobject, opae::fpga::types::token)</li> <li>type_ (opae::fpga::types::event::type_t, opae::fpga::types::event)</li> <li>type (opae::fpga::types::properties)</li> <li>threshold_name (threshold)</li> </ul>"},{"location":"opae-code/class_member_variables/#u","title":"u","text":"<ul> <li>uint (cache_line)</li> <li>upper_c_threshold (metric_threshold)</li> <li>upper_nc_threshold (metric_threshold)</li> <li>upper_nr_threshold (metric_threshold)</li> </ul>"},{"location":"opae-code/class_member_variables/#v","title":"v","text":"<ul> <li>vendor_id (_fpga_token_header, opae::fpga::types::properties)</li> <li>value_cleanup (_opae_hash_map)</li> <li>value (_opae_hash_map_item, fpga_metric, threshold)</li> <li>virt_ (opae::fpga::types::shared_buffer)</li> </ul>"},{"location":"opae-code/class_member_variables/#w","title":"w","text":"<ul> <li>wsid_ (opae::fpga::types::shared_buffer)</li> </ul>"},{"location":"opae-code/class_member_variables/#_1","title":"@","text":"<ul> <li>@1 (ras_inject_error)</li> </ul>"},{"location":"opae-code/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"opae-code/class_member_typedefs/#c","title":"c","text":"<ul> <li>copy_t (opae::fpga::types::pvalue)</li> </ul>"},{"location":"opae-code/class_member_typedefs/#g","title":"g","text":"<ul> <li>getter_t (opae::fpga::types::pvalue)</li> </ul>"},{"location":"opae-code/class_member_typedefs/#p","title":"p","text":"<ul> <li>ptr_t (opae::fpga::types::error, opae::fpga::types::event, opae::fpga::types::handle, opae::fpga::types::properties, opae::fpga::types::shared_buffer, opae::fpga::types::sysobject, opae::fpga::types::token)</li> </ul>"},{"location":"opae-code/class_member_typedefs/#s","title":"s","text":"<ul> <li>setter_t (opae::fpga::types::pvalue)</li> <li>size_t (opae::fpga::types::shared_buffer)</li> </ul>"},{"location":"opae-code/class_member_enums/","title":"Class Member Enums","text":""},{"location":"opae-code/namespace_members/","title":"Namespace Members","text":""},{"location":"opae-code/namespace_members/#a","title":"a","text":"<ul> <li>assert_fpga_ok (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_members/#e","title":"e","text":"<ul> <li>exception_fn (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_members/#i","title":"i","text":"<ul> <li>is_ok (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_members/#o","title":"o","text":"<ul> <li>opae_exceptions (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"opae-code/namespace_member_functions/#a","title":"a","text":"<ul> <li>assert_fpga_ok (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_member_functions/#i","title":"i","text":"<ul> <li>is_ok (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"opae-code/namespace_member_variables/#o","title":"o","text":"<ul> <li>opae_exceptions (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"opae-code/namespace_member_typedefs/#e","title":"e","text":"<ul> <li>exception_fn (opae::fpga::types::detail)</li> </ul>"},{"location":"opae-code/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"opae-code/functions/","title":"Functions","text":""},{"location":"opae-code/functions/#e","title":"e","text":"<ul> <li>error_thread (hello_events.c)</li> </ul>"},{"location":"opae-code/functions/#f","title":"f","text":"<ul> <li>fpgaClose (access.h)</li> <li>fpgaOpen (access.h)</li> <li>fpgaReset (access.h)</li> <li>fpgaGetIOAddress (buffer.h)</li> <li>fpgaPrepareBuffer (buffer.h)</li> <li>fpgaReleaseBuffer (buffer.h)</li> <li>fpgaCloneToken (enum.h)</li> <li>fpgaDestroyToken (enum.h)</li> <li>fpgaEnumerate (enum.h)</li> <li>fpgaClearAllErrors (error.h)</li> <li>fpgaClearError (error.h)</li> <li>fpgaGetErrorInfo (error.h)</li> <li>fpgaReadError (error.h)</li> <li>fpgaCreateEventHandle (event.h)</li> <li>fpgaDestroyEventHandle (event.h)</li> <li>fpgaGetOSObjectFromEventHandle (event.h)</li> <li>fpgaRegisterEvent (event.h)</li> <li>fpgaUnregisterEvent (event.h)</li> <li>fpgaFinalize (init.h)</li> <li>fpgaInitialize (init.h)</li> <li>fpgaAssignPortToInterface (manage.h)</li> <li>fpgaAssignToInterface (manage.h)</li> <li>fpgaReconfigureSlot (manage.h)</li> <li>fpgaReleaseFromInterface (manage.h)</li> <li>fpgaGetMetricsByIndex (metrics.h)</li> <li>fpgaGetMetricsByName (metrics.h)</li> <li>fpgaGetMetricsInfo (metrics.h)</li> <li>fpgaGetMetricsThresholdInfo (metrics.h)</li> <li>fpgaGetNumMetrics (metrics.h)</li> <li>fpgaMapMMIO (mmio.h)</li> <li>fpgaReadMMIO32 (mmio.h)</li> <li>fpgaReadMMIO64 (mmio.h)</li> <li>fpgaUnmapMMIO (mmio.h)</li> <li>fpgaWriteMMIO32 (mmio.h)</li> <li>fpgaWriteMMIO512 (mmio.h)</li> <li>fpgaWriteMMIO64 (mmio.h)</li> <li>fpgaClearProperties (properties.h)</li> <li>fpgaCloneProperties (properties.h)</li> <li>fpgaDestroyProperties (properties.h)</li> <li>fpgaGetProperties (properties.h)</li> <li>fpgaGetPropertiesFromHandle (properties.h)</li> <li>fpgaPropertiesGetAcceleratorState (properties.h)</li> <li>fpgaPropertiesGetBBSID (properties.h)</li> <li>fpgaPropertiesGetBBSVersion (properties.h)</li> <li>fpgaPropertiesGetBus (properties.h)</li> <li>fpgaPropertiesGetCapabilities (properties.h)</li> <li>fpgaPropertiesGetDevice (properties.h)</li> <li>fpgaPropertiesGetDeviceID (properties.h)</li> <li>fpgaPropertiesGetFunction (properties.h)</li> <li>fpgaPropertiesGetGUID (properties.h)</li> <li>fpgaPropertiesGetInterface (properties.h)</li> <li>fpgaPropertiesGetLocalMemorySize (properties.h)</li> <li>fpgaPropertiesGetModel (properties.h)</li> <li>fpgaPropertiesGetNumErrors (properties.h)</li> <li>fpgaPropertiesGetNumInterrupts (properties.h)</li> <li>fpgaPropertiesGetNumMMIO (properties.h)</li> <li>fpgaPropertiesGetNumSlots (properties.h)</li> <li>fpgaPropertiesGetObjectID (properties.h)</li> <li>fpgaPropertiesGetObjectType (properties.h)</li> <li>fpgaPropertiesGetParent (properties.h)</li> <li>fpgaPropertiesGetSegment (properties.h)</li> <li>fpgaPropertiesGetSocketID (properties.h)</li> <li>fpgaPropertiesGetSubsystemDeviceID (properties.h)</li> <li>fpgaPropertiesGetSubsystemVendorID (properties.h)</li> <li>fpgaPropertiesGetVendorID (properties.h)</li> <li>fpgaPropertiesSetAcceleratorState (properties.h)</li> <li>fpgaPropertiesSetBBSID (properties.h)</li> <li>fpgaPropertiesSetBBSVersion (properties.h)</li> <li>fpgaPropertiesSetBus (properties.h)</li> <li>fpgaPropertiesSetCapabilities (properties.h)</li> <li>fpgaPropertiesSetDevice (properties.h)</li> <li>fpgaPropertiesSetDeviceID (properties.h)</li> <li>fpgaPropertiesSetFunction (properties.h)</li> <li>fpgaPropertiesSetGUID (properties.h)</li> <li>fpgaPropertiesSetInterface (properties.h)</li> <li>fpgaPropertiesSetLocalMemorySize (properties.h)</li> <li>fpgaPropertiesSetModel (properties.h)</li> <li>fpgaPropertiesSetNumErrors (properties.h)</li> <li>fpgaPropertiesSetNumInterrupts (properties.h)</li> <li>fpgaPropertiesSetNumMMIO (properties.h)</li> <li>fpgaPropertiesSetNumSlots (properties.h)</li> <li>fpgaPropertiesSetObjectID (properties.h)</li> <li>fpgaPropertiesSetObjectType (properties.h)</li> <li>fpgaPropertiesSetParent (properties.h)</li> <li>fpgaPropertiesSetSegment (properties.h)</li> <li>fpgaPropertiesSetSocketID (properties.h)</li> <li>fpgaPropertiesSetSubsystemDeviceID (properties.h)</li> <li>fpgaPropertiesSetSubsystemVendorID (properties.h)</li> <li>fpgaPropertiesSetVendorID (properties.h)</li> <li>fpgaUpdateProperties (properties.h)</li> <li>fpgaDestroyObject (sysobject.h)</li> <li>fpgaHandleGetObject (sysobject.h)</li> <li>fpgaObjectGetObject (sysobject.h)</li> <li>fpgaObjectGetObjectAt (sysobject.h)</li> <li>fpgaObjectGetSize (sysobject.h)</li> <li>fpgaObjectGetType (sysobject.h)</li> <li>fpgaObjectRead (sysobject.h)</li> <li>fpgaObjectRead64 (sysobject.h)</li> <li>fpgaObjectWrite64 (sysobject.h)</li> <li>fpgaTokenGetObject (sysobject.h)</li> <li>fpgaGetNumUmsg (umsg.h)</li> <li>fpgaGetUmsgPtr (umsg.h)</li> <li>fpgaSetUmsgAttributes (umsg.h)</li> <li>fpgaTriggerUmsg (umsg.h)</li> <li>fpgaGetUserClock (userclk.h)</li> <li>fpgaSetUserClock (userclk.h)</li> <li>fpgaErrStr (utils.h)</li> <li>fpgaGetOPAECBuildString (version.h)</li> <li>fpgaGetOPAECVersion (version.h)</li> <li>fpgaGetOPAECVersionString (version.h)</li> <li>find_fpga (hello_events.c, hello_fpga.c)</li> <li>find_nlb_n3000 (hello_fpga.c)</li> </ul>"},{"location":"opae-code/functions/#h","title":"h","text":"<ul> <li>help (hello_events.c, hello_fpga.c)</li> </ul>"},{"location":"opae-code/functions/#i","title":"i","text":"<ul> <li>inject_ras_fatal_error (hello_events.c)</li> </ul>"},{"location":"opae-code/functions/#m","title":"m","text":"<ul> <li>mem_alloc_add_free (mem_alloc.h)</li> <li>mem_alloc_destroy (mem_alloc.h)</li> <li>mem_alloc_get (mem_alloc.h)</li> <li>mem_alloc_init (mem_alloc.h)</li> <li>mem_alloc_put (mem_alloc.h)</li> <li>main (hello_events.c, hello_fpga.c)</li> </ul>"},{"location":"opae-code/functions/#o","title":"o","text":"<ul> <li>opae_hash_map_add (hash_map.h)</li> <li>opae_hash_map_destroy (hash_map.h)</li> <li>opae_hash_map_find (hash_map.h)</li> <li>opae_hash_map_init (hash_map.h)</li> <li>opae_hash_map_is_empty (hash_map.h)</li> <li>opae_hash_map_remove (hash_map.h)</li> <li>opae_u64_key_compare (hash_map.h)</li> <li>opae_u64_key_hash (hash_map.h)</li> <li>opae_print (log.h)</li> <li>opae_uio_close (uio.h)</li> <li>opae_uio_open (uio.h)</li> <li>opae_uio_region_get (uio.h)</li> <li>opae_vfio_buffer_allocate (vfio.h)</li> <li>opae_vfio_buffer_allocate_ex (vfio.h)</li> <li>opae_vfio_buffer_free (vfio.h)</li> <li>opae_vfio_buffer_info (vfio.h)</li> <li>opae_vfio_close (vfio.h)</li> <li>opae_vfio_irq_disable (vfio.h)</li> <li>opae_vfio_irq_enable (vfio.h)</li> <li>opae_vfio_irq_mask (vfio.h)</li> <li>opae_vfio_irq_unmask (vfio.h)</li> <li>opae_vfio_open (vfio.h)</li> <li>opae_vfio_region_get (vfio.h)</li> <li>opae_vfio_secure_open (vfio.h)</li> </ul>"},{"location":"opae-code/functions/#p","title":"p","text":"<ul> <li>parse_args (hello_events.c, hello_fpga.c)</li> <li>print_err (hello_events.c, hello_fpga.c)</li> <li>probe_for_ase (hello_fpga.c)</li> </ul>"},{"location":"opae-code/functions/#u","title":"u","text":"<ul> <li>usleep (hello_events.c, hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/","title":"Macros","text":""},{"location":"opae-code/macros/#a","title":"a","text":"<ul> <li>ASSERT_FPGA_OK (except.h)</li> </ul>"},{"location":"opae-code/macros/#c","title":"c","text":"<ul> <li>CACHELINE_ALIGNED_ADDR (hello_fpga.c)</li> <li>CL (hello_fpga.c)</li> <li>CSR_AFU_DSM_BASEL (hello_fpga.c)</li> <li>CSR_CFG (hello_fpga.c)</li> <li>CSR_CTL (hello_fpga.c)</li> <li>CSR_DST_ADDR (hello_fpga.c)</li> <li>CSR_NUM_LINES (hello_fpga.c)</li> <li>CSR_SRC_ADDR (hello_fpga.c)</li> <li>CSR_STATUS1 (hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#d","title":"d","text":"<ul> <li>DSM_STATUS_TEST_COMPLETE (hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#f","title":"f","text":"<ul> <li>FPGA_ERROR_NAME_MAX (types.h)</li> <li>FPGA_METRIC_STR_SIZE (types.h)</li> <li>fpga_is_parent_child (types.h)</li> <li>FPGA_BUILD_STR_MAX (version.h)</li> <li>FPGA_VERSION_STR_MAX (version.h)</li> <li>FME_SYSFS_INJECT_ERROR (hello_events.c)</li> <li>FPGA_NLB0_UUID_H (hello_fpga.c)</li> <li>FPGA_NLB0_UUID_L (hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#g","title":"g","text":"<ul> <li>GETOPT_STRING (hello_events.c, hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#l","title":"l","text":"<ul> <li>LOG2_CL (hello_fpga.c)</li> <li>LPBK1_BUFFER_ALLOCATION_SIZE (hello_fpga.c)</li> <li>LPBK1_BUFFER_SIZE (hello_fpga.c)</li> <li>LPBK1_DSM_SIZE (hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#m","title":"m","text":"<ul> <li>MB (hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#n","title":"n","text":"<ul> <li>N3000_AFUID (hello_fpga.c)</li> <li>NLB0_AFUID (hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#o","title":"o","text":"<ul> <li>OPAECXX_HERE (except.h)</li> <li>OPAE_DBG (log.h)</li> <li>OPAE_DEFAULT_LOGLEVEL (log.h)</li> <li>OPAE_ERR (log.h)</li> <li>OPAE_MSG (log.h)</li> <li>OPAE_UIO_PATH_MAX (uio.h)</li> <li>ON_ERR_GOTO (hello_events.c, hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#t","title":"t","text":"<ul> <li>TEST_TIMEOUT (hello_fpga.c)</li> </ul>"},{"location":"opae-code/macros/#_","title":"_","text":"<ul> <li>__SHORT_FILE__ (log.h)</li> </ul>"},{"location":"opae-code/variables/","title":"Variables","text":""},{"location":"opae-code/variables/#c","title":"c","text":"<ul> <li>config (hello_fpga.c)</li> </ul>"},{"location":"opae-code/variables/#f","title":"f","text":"<ul> <li>fpga_event_handle (types.h)</li> <li>fpga_guid (types.h)</li> <li>fpga_handle (types.h)</li> <li>fpga_metric (types.h)</li> <li>fpga_metric_info (types.h)</li> <li>fpga_object (types.h)</li> <li>fpga_properties (types.h)</li> <li>fpga_token (types.h)</li> <li>fpga_token_header (types.h)</li> <li>fpga_accelerator_state (types_enum.h)</li> <li>fpga_buffer_flags (types_enum.h)</li> <li>fpga_event_type (types_enum.h)</li> <li>fpga_interface (types_enum.h)</li> <li>fpga_metric_datatype (types_enum.h)</li> <li>fpga_metric_type (types_enum.h)</li> <li>fpga_objtype (types_enum.h)</li> <li>fpga_open_flags (types_enum.h)</li> <li>fpga_reconf_flags (types_enum.h)</li> <li>fpga_result (types_enum.h)</li> <li>fpga_sysobject_flags (types_enum.h)</li> <li>fpga_sysobject_type (types_enum.h)</li> </ul>"},{"location":"opae-code/variables/#m","title":"m","text":"<ul> <li>metric_threshold (types.h)</li> </ul>"},{"location":"opae-code/variables/#o","title":"o","text":"<ul> <li>opae_hash_map (hash_map.h)</li> <li>opae_hash_map_flags (hash_map.h)</li> <li>opae_hash_map_item (hash_map.h)</li> <li>opae_loglevel (log.h)</li> <li>opae_vfio_buffer_flags (vfio.h)</li> </ul>"},{"location":"opae-code/variables/#t","title":"t","text":"<ul> <li>threshold (types.h)</li> </ul>"},{"location":"opae-code/variables/#_","title":"_","text":"<ul> <li>_opae_hash_map_flags (hash_map.h)</li> </ul>"},{"location":"opae-code/links/","title":"Links","text":"<p>* Related Pages     * Todo List   * Modules   * Class List     * struct _fpga_token_header     * struct _opae_hash_map     * struct _opae_hash_map_item     * struct cache_line     * struct config     * struct fpga_error_info     * struct fpga_metric     * struct fpga_metric_info     * struct fpga_version     * struct mem_alloc     * struct mem_link     * struct metric_threshold     * union metric_value     * namespace opae       * namespace opae::fpga         * namespace opae::fpga::types           * class opae::fpga::types::busy           * namespace opae::fpga::types::detail           * class opae::fpga::types::error           * class opae::fpga::types::event             * struct opae::fpga::types::event::type_t           * class opae::fpga::types::except           * class opae::fpga::types::exception           * struct opae::fpga::types::guid_t           * class opae::fpga::types::handle           * class opae::fpga::types::invalid_param           * class opae::fpga::types::no_access           * class opae::fpga::types::no_daemon           * class opae::fpga::types::no_driver           * class opae::fpga::types::no_memory           * class opae::fpga::types::not_found           * class opae::fpga::types::not_supported           * class opae::fpga::types::properties           * struct opae::fpga::types::pvalue           * class opae::fpga::types::reconf_error           * class opae::fpga::types::shared_buffer           * class opae::fpga::types::src_location           * class opae::fpga::types::sysobject           * class opae::fpga::types::token           * class opae::fpga::types::version     * struct opae_uio     * struct opae_uio_device_region     * struct opae_vfio     * struct opae_vfio_buffer     * struct opae_vfio_device     * struct opae_vfio_device_irq     * struct opae_vfio_device_region     * struct opae_vfio_group     * struct opae_vfio_iova_range     * struct opae_vfio_sparse_info     * struct ras_inject_error     * namespace std     * struct threshold   * Namespace ListNamespace List   * Namespace Members   * Namespace Member Functions   * Namespace Member Variables   * Namespace Member Typedefs   * Namespace Member Enumerations   * Class Index   * Class Hierarchy   * Class Members   * Class Member Functions   * Class Member Variables   * Class Member Typedefs   * Class Member Enumerations   * Files     * docs       * docs/sw         * docs/sw/include           * docs/sw/include/opae             * access.h             * access.h source             * buffer.h             * buffer.h source             * docs/sw/include/opae/cxx               * core.h               * core.h source               * docs/sw/include/opae/cxx/core                 * errors.h                 * errors.h source                 * events.h                 * events.h source                 * except.h                 * except.h source                 * handle.h                 * handle.h source                 * properties.h                 * properties.h source                 * pvalue.h                 * pvalue.h source                 * shared_buffer.h                 * shared_buffer.h source                 * sysobject.h                 * sysobject.h source                 * token.h                 * token.h source                 * version.h                 * version.h source             * enum.h             * enum.h source             * error.h             * error.h source             * event.h             * event.h source             * fpga.h             * fpga.h source             * hash_map.h             * hash_map.h source             * init.h             * init.h source             * log.h             * log.h source             * manage.h             * manage.h source             * mem_alloc.h             * mem_alloc.h source             * metrics.h             * metrics.h source             * mmio.h             * mmio.h source             * properties.h             * properties.h source             * sysobject.h             * sysobject.h source             * types.h             * types.h source             * types_enum.h             * types_enum.h source             * uio.h             * uio.h source             * umsg.h             * umsg.h source             * userclk.h             * userclk.h source             * utils.h             * utils.h source             * version.h             * version.h source             * vfio.h             * vfio.h source         * docs/sw/samples           * docs/sw/samples/hello_events             * hello_events.c             * hello_events.c source           * docs/sw/samples/hello_fpga             * hello_fpga.c             * hello_fpga.c source   * File Variables   * File Functions   * File Macros</p>"}]}