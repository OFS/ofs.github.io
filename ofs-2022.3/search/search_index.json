{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open FPGA Stack Overview","text":"<p>  Open FPGA Stack (OFS): OFS is an open-source solution that provides a hardware and software framework for building your shell design and subsequently your workload. OFS provides reference shell designs targeting different Intel\u00ae FPGA devices with upstreamed drivers and management software tools.   <p>The reference shells, called FPGA Interface Manager, provide an integrated, timing closed I/O ring with the most common interfaces for applications. You can add or subtract interfaces to the I/O ring depending on your application requirements. You can leverage the build scripts, RTL, unit tests software and drivers targeting this reference shell as a starting point for your own FPGA platform solution.</p> <p>OFS targets Intel Stratix\u00ae 10 and Intel Agilex\u2122 FPGA Device Families. To find out more about Intel FPGAs, visit the Intel Stratix 10 and Intel Agilex pages at Intel.com</p> <p>"},{"location":"#open-fpga-stack-repositories","title":"Open FPGA Stack Repositories","text":"<p>Accessing OFS ingredients to use within the development framework is easy.  The github.com/OFS site provides all the hardware and software repositories in one location.</p> <p> <p></p> Repository Folder Description Hardware or Software Repository linux-dfl This repository is a mirror of the linux.org Git site and contains the most up-to-date drivers that are being developed and upstreamed for OFS platforms. Software opae-sdk Contains the ingredients to build the OFS Open Programmable Acceleration Engine (OPAE) Software Development Kit which provides APIs and userspace tools for OFS FPGA management. Software ofs.github.io Contains the hardware and software collateral that surfaces on the OFS website: https://ofs.github.io Markdown/HTML ofs-d5005 Provides RTL, unit tests, and build scripts to create Intel Stratix 10 FIM and is leveraged as a starting point for a custom design.  The reference FIM targets an Intel FPGA PAC D5005 development board. Hardware ofs-fim-common Provides RTL components that are shared among all new platforms that are introduced in OFS.  This folder is a subumodule in each platform repository folder. Hardware ofs-platform-afu-bbb Contains the hardware and software code used to build the host interface for the FIM and provides test examples. Hardware/Software linux-dfl-backport A place for finding and leveraging out-of-tree backported drivers for older OS versions . Software examples-afu Provides standard AFU examples you can use as a template for starting your own workload design. Software opae-legacy Supports OFS platforms built on the legacy version of OPAE software.  Not used in current OFS designs Software opae-sim This repository is used to build the AFU Hardware/Software Co-Simulation Environment workload developers can use to ensure their AFU can work with the OFS software stack. Hardrware/Software <p></p>"},{"location":"#rtl-repository","title":"RTL Repository","text":"<p>Every FPGA RTL development repository is named after the platform it targets.  This platform target is a starting point for development and can be considered a best known configuration for debugging.</p> <p>The structure of the RTL repository remains the same regardless of which device platform you decide to use.  The advantage of this is you will quickly become familiar with the hierarchy as you consider new FPGA application development.</p> <p> <p></p> Directory Description eval_scripts Provides resources to setup, compile, simulate and test the reference FIM that can be built in the repository. ipss Contains the code and supporting files that configure and build the default configuration of the key subsystems license Contains license required to build the IP in Quartus\u00ae.  Note you still utilize an evaluation license or purchase a license to use Quartus Prime Pro Software. ofs-common@commit# Contains scripts and source code that are common to all of the platform RTL repositories and to your own FPGA design.  This directory is referenced through a specific commit and you have the option to update to the latest ofs-common as your design evolves. sim Provides test benches and supporting code for unit tests. src Contains all structural and behavioral code for FIM including top-level RTL for synthesis and AFU infrastructure code. syn Provides scripts, settings and setup files for running FIM synthesis. <p></p>"},{"location":"#how-can-i-start-using-ofs","title":"How Can I Start Using OFS?","text":"<p>The best way to start using OFS is to evaluate the reference FIM that can be built in the platform repository by leveraging our eval_scripts to run through the hardware and software build flow and test the design in simulation and optionally hardware as well.</p> <p>The reference FIM in the platform repository currently targets PCIe attach applications and can be used as-is or can be used as a starting point for modification, greatly reducing development time. The ofs-d5005 repository provides capability to build an Intel Stratix 10 OFS reference FIM.  Additional repositories that support Intel Agilex FPGA will be added in a future OFS GitHub release.  For more information about the upcoming Intel Agilex offering, visit the OFS webpage on intel.com and submit the available questionnaire.</p> <p> <p></p> <p>OFS FIM Targeting Intel Stratix 10 FPGA</p> Key Feature Intel Stratix 10 Reference FIM FPGA Intel Stratix 10 SX FPGA Ethernet Configuration 1x10GbE example with 2x100GbE capability PCIe Gen3x16 EMIF Up to four DDR channels PF/VF 1 PF/3 VFs Management FPGA Management Engine (FME) with FIM management registers Interface Arm\u00ae AMBA\u00ae4 AXI Interface HLD support oneAPI Software Kernel code upstreamed to Linux.org <p>Note: Source code for BMC RTL/Firmware that works with this reference FIM can be obtained by contacting your Intel Sales Representative.</p> <p>Click here for the Intel Stratix 10 OFS Collateral.</p> <p>To find information on the latest releases, go to the Discussions Tab in the OFS GitHub repository.</p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/","title":"Software Reference Manual:  Open FPGA Stack","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#10-introduction","title":"1.0 Introduction","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#11-audience","title":"1.1 Audience","text":"<p>The information presented in this document is intended to be used by software developers looking to increase their knowledge of the OPAE SDK user-space software stack and the kernel-space linux-dfl drivers. This information is intended as a starting point, with links to where users can deep dive on specific topics. </p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#12-terminology","title":"1.2 Terminology","text":"Term Abbreviation Description Open FPGA Stack OFS A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. Accelerator Functional Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.  Note: An AFU region is the part of the design where an AFU may reside.  This AFU may or may not be a partial reconfiguration region. Board Management Controller BMC Supports features such as power sequence management and board monitoring through on-board sensors. FPGA Interface Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs.  The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. Platform Interface Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Intel Virtualization Technology for Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Single-Root Input-Output Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. Host Exerciser Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Device Feature List DFL A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. (link) Best Known Configuration BKC The exact hardware configuration Intel has optimized and validated the solution against. Open Programmable Acceleration Engine OPAE The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Memory Mapped Input/Output MMIO Users may map and access both control registers and system memory buffers with accelerators. FPGA Management Engine FME Performs reconfiguration and other infrastructure functions. Each FPGA device only has one FME. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Virtual Function Input/Output VFIO An IOMMU/device agnostic framework for exposing direct device access to userspace. (link) Configuration and Status Register CSR Communication with the AFU is achieved by reading/writing CSRs and reading/writing shared memory buffers. Port N/A Represents the interface between the static FPGA fabric and a PR region containing an AFU. Advanced Error Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link)"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#20-opae-software-development-kit-sdk","title":"2.0 OPAE Software Development Kit (SDK)","text":"<p>The OPAE C library is a lightweight user-space library that provides abstraction for FPGA resources in a compute environment. Built on top of the OPAE Intel\u00ae FPGA driver stack that supports Intel\u00ae FPGA platforms, the library abstracts away hardware specific and OS specific details and exposes the underlying FPGA resources as a set of features accessible from within software programs running on the host. The OPAE source code is available on the OPAE SDK repository, under the opae-sdk tag.</p> <p>These features include the acceleration logic configured on the device, as well as functions to manage and reconfigure the device. The library enables user applications to transparently and seamlessly leverage FPGA-based acceleration.</p> <p>Most of the information related to OPAE can be found on the official OFS Site page. The following is a summary of the information present on this web page:</p> <ul> <li>Configuration options present in the OPAE SDK build and installation flow</li> <li>The steps required to build a sample OPAE application</li> <li>An explanation of the basic application flow</li> <li>A reference for the C, C++, and Python APIs</li> <li>An explanation of the OPAE Linux Device Driver Architecture</li> <li>Definitions for the various user-facing OPAE SDK tools</li> </ul> <p>The remaining sections on OPAE in this document are unique and build on basic principles explained in opae.github.io.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#table-additional-websites-and-links","title":"Table : Additional Websites and Links","text":"Document Link OPAE SDK on github OPAE SDK repository OPAE Documents OFS Site pybind11 https://pybind11.readthedocs.io/en/stable/ CLI11 https://github.com/CLIUtils/CLI11 spdlog https://github.com/gabime/spdlog"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#20-opae-c-api","title":"2.0 OPAE C API","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21-libopae-c","title":"2.1 libopae-c","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#211-device-abstraction","title":"2.1.1 Device Abstraction","text":"<p>The OPAE C API relies on two base abstractions concerning how the FIM and accelerator are presented to and manipulated by the user. The FIM is concerned with management functionality. Access to the FIM and its interfaces is typically restricted to privileged (root) users. The accelerator contains the user-defined logic in its reconfigurable region. Most OPAE end-user applications are concerned with querying and opening the accelerator device, then interacting with the AFU via MMIO and shared memory.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2111-device-types","title":"2.1.1.1 Device types","text":"<p>The C enum fpga_objtype defines two variants. The FPGA_DEVICE variant corresponds to the FIM portion of the device, and the FPGA_ACCELERATOR refers to the accelerator, also known as the AFU.</p> <p>An FPGA_DEVICE refers loosely to the sysfs tree rooted at the dfl-fme.X directory, for example /sys/class/fpga_region/region0/dfl-fme.0, and its associated device file /dev/dfl-fme.0.</p> <p>An FPGA_ACCELERATOR refers loosely to the sysfs tree rooted at the dfl-port.X directory, for example /sys/class/fpga_region/region0/dfl-port.0, and its associated device file /dev/dfl-port.0.</p> <p>The number X in dfl-fme.X and dfl-port.X refers to a numeric ID that is assigned by the DFL device driver to uniquely identify an instance of the FIM/Accelerator. Systems with multiple FPGA acceleration devices will have multiple dfl-fme.X\u2019s and matching dfl-port.X\u2019s.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2112-tokens-and-handles","title":"2.1.1.2 Tokens and Handles","text":"<p>An fpga_token is an opaque data structure that uniquely represents an FPGA_DEVICE or an FPGA_ACCELERATOR. Tokens convey existence, but not ownership. Tokens are retrieved via the OPAE enumeration process described below using the fpgaEnumerate() call.</p> <p>An fpga_handle is an opaque data structure that corresponds to an opened device instance, whether FPGA_DEVICE or FPGA_ACCELERATOR. A Handle is obtained from a token via the fpgaOpen() call. A handle conveys that the /dev/dfl-fme.X or /dev/dfl-port.X device file has been opened and is ready for interaction via its IOCTL interface.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#212-enumeration","title":"2.1.2 Enumeration","text":"<p>Enumeration is the process by which an OPAE application becomes aware of the existence of FPGA_DEVICE\u2019s and FPGA_ACCELERATOR\u2019s. Refer to the signature of the fpgaEnumerate() call:</p> <pre><code>fpga_result fpgaEnumerate(const fpga_properties *filters,\nuint32_t num_filters,\nfpaa_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n</code></pre> <p>Figure 1 fpgaEnumerate()</p> <p></p> <p>The typical enumeration flow involves an initial call to fpgaEnumerate() to discover the number of available tokens.</p> <pre><code>uint32_t num_matches = 0;\nfpgaEnumerate(NULL, 0, NULL, 0, &amp;num_matches);\n</code></pre> <p>Figure 2 Discovering Number of Tokens</p> <p></p> <p>Once the number of available tokens is known, the application can allocate the correct amount of space to hold the tokens:</p> <pre><code>fpga_token *tokens;\nuint32_t num_tokens = num_matches;\ntokens = (fpga_token *)calloc(num_tokens, sizeof(fpga_token));\nfpgaEnumerate(NULL, 0, tokens, num_tokens, &amp;num_matches);\n</code></pre> <p>Figure 3 Enumerating All Tokens</p> <p></p> <p>Note that parameters filters and num_filters were not used in the preceding example, as they were NULL and 0. When no filtering criteria are provided, fpgaEnumerate() returns all tokens that can be enumerated.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2121-fpga_properties-and-filtering","title":"2.1.2.1 fpga_properties and Filtering","text":"<p>An fpga_properties is an opaque data structure used to retrieve all of the properties concerning an FPGA_DEVICE or FPGA_ACCELERATOR. These properties can be included in the filters parameter to fpgaEnumerate() to select tokens by specific criteria.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21211-common-properties","title":"2.1.2.1.1 Common Properties","text":"<p>Table 3 lists the set of properties that are common to FPGA_DEVICE and FPGA_ACCELERATOR:</p> <p></p>  Property  Description fpga_guid guid; FPGA_DEVICE: PR Interface ID FPGA_ACCELERATOR: AFU ID fpga_token parent; FPGA_DEVICE: always NULL FPGA_ACCELERATOR: the token of the corresponding FPGA_DEVICE, if any. Otherwise, NULL. fpga_objtype objtype; FPGA_DEVICE or FPGA_ACCELERATOR uint16_t segment; The segment portion of the PCIe address: ssss:bb:dd.f uint8_t bus; <p>The bus portion of the PCIe address:</p> <p>ssss:bb:dd.f</p> uint8_t device; <p>The device portion of the PCIe address:</p> <p>ssss:bb:dd.f</p> uint8_t function; The function portion of the PCIe address: ssss:bb:dd.f uint64_t object_id; A unique 64-bit value that identifies this token on the system. uint16_t vendor_id; The PCIe Vendor ID uint16_t device_id; The PCIe Device ID uint32_t num_errors; The number of error sysfs nodes available for this token. fpga_interface interface; An identifier for the underlying plugin-based access method. <p>Table 3 Common Properties</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21212-fpga_device-properties","title":"2.1.2.1.2 FPGA_DEVICE Properties","text":"<p>Table 4 lists the set of properties that are specific to FPGA_DEVICE token types.</p> <p></p> Property Description uint64_t bbs_id; FIM-specific Blue Bitstream ID fpga_version bbs_version; BBS version <p></p> <p>Table 4 FPGA_DEVICE Properties</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#21213-fpga_accelerator-properties","title":"2.1.2.1.3 FPGA_ACCELERATOR Properties","text":"<p>Table 5 lists the set of properties that are specific to FPGA_ACCELERATOR token types.</p> <p></p> Property Description fpga_accelerator_state state; Whether the Accelerator is currently open uint32_t num_mmio; The number of MMIO regions available uint32_t num_interrupts; The number of interrupts available <p>Table 5 FPGA_ACCELERATOR Properties</p> <p>Following is an example of using fpga_properties to enumerate a specific AFU:</p> <p><pre><code>#define NLB0_AFU \"D8424DC4-A4A3-C413-F89E-433683F9040B\"\nfpga_properties filter = NULL;\nfpga_guid afu_id;\nfpgaGetProperties(NULL, &amp;filter); // NULL: a new empty properties\nfpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\nuuid_parse(NLB0_AFU, afu_id);\nfpgaPropertiesSetGuid(filter, afu_id);\nfpgaEnumerate(&amp;filter, 1, tokens, num_tokens, &amp;num_matches);\n</code></pre> Relevant Links:  - fpga_guid - fpgaGetProperties - fpgaPropertiesSetObjectType - fpgaPropertiesSetGUID</p> <p>Figure 4 Filtering During Enumeration</p> <p></p> <p>Note that fpga_properties and fpga_token\u2019s are allocated resources that must be freed by their respective API calls, ie fpgaDestroyProperties() and fpgaDestroyToken().</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#213-access","title":"2.1.3 Access","text":"<p>Once a token is discovered and returned to the caller by fpgaEnumerate(), the token can be converted into a handle by fpgaOpen(). Upon a successful call to fpgaOpen(), the associated /dev/dfl-fme.X (FPGA_DEVICE) or /dev/dfl-port.X (FPGA_ACCELERATOR) is opened and ready for use. Having acquired an fpga_handle, the application can then use the handle with any of the OPAE APIs that require an fpga_handle as an input parameter.</p> <p>Like tokens and properties, handles are allocated resources. When a handle is no longer needed, it should be closed and released by calling fpgaClose().</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#214-events","title":"2.1.4 Events","text":"<p>Event registration in OPAE is a two-step process. First, the type of event must be identified. The following fpga_event_type variants are defined:</p> <p></p> Event Description FPGA_EVENT_INTERRUPT AFU interrupt FPGA_EVENT_ERROR Infrastructure error event (FME/Port Error) <p>Table 6 FPGA Event Types</p> <p>Once the desired event type is known, an fpga_event_handle is created via fpgaCreateEventHandle(). Once the event handle is available, the event notification is registered using fpgaRegisterEvent(). In the example below, note the use of the flags field for passing the desired IRQ vector when the event type is FPGA_EVENT_INTERRUPT. With the event registered, the application can then use fpgaGetOSObjectFromEventHandle() to obtain a file descriptor for use with the poll() system call. When the interrupt occurs, the file descriptor will be set to the signaled state by the DFL driver.</p> <pre><code>fpga_event_handle event_handle = NULL;\nint fd = -1;\nfpgaCreateEventHandle(&amp;event_handle);\nfpgaRegisterEvent(fpga_handle, FPGA_EVENT_INTERRUPT,\nevent_handle, irq_vector);\nfpgaGetOSObjectFromEventHandle(event_handle, &amp;fd);\n</code></pre> <p>Figure 5 Creating and Registering Events</p> <p></p> <p>When an event notification is no longer needed, it should be released by calling fpgaUnregisterEvent(). Like device handles, event handles are allocated resources that must be freed when no longer used. To free an event handle, use the fpgaDestroyEventHandle() call.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#215-mmio-and-shared-memory","title":"2.1.5 MMIO and Shared Memory","text":"<p>Communication with the AFU is achieved via reading and writing CSRs and by reading and writing to AFU/host shared memory buffers. An AFU\u2019s CSRs are memory-mapped into the application process address space by way of the fpgaMapMMIO() call.</p> <pre><code>uint32_t mmio_num = 0;\nfpgaMapMMIO(fpga_handle, mmio_num, NULL);\nfpgaWriteMMIO64(fpga_handle, mmio_num, MY_CSR, 0xa);\n</code></pre> <p>Figure 6 Mapping and Accessing CSRs</p> <p></p> <p>The second parameter, mmio_num, is the zero-based index identifying the desired MMIO region. The maximum number of MMIO regions for a particular handle is found by accessing the num_mmio property. Refer to the fpgaPropertiesGetNumMMIO() call.</p> <p>Once the AFU CSRs are mapped into the process address space, the application can use the fpgaReadMMIOXX() and fpgaWriteMMIOXX() family of functions, eg fpgaReadMMIO64() and fpgaWriteMMIO64(). When an MMIO region is no longer needed, it should be unmapped from the process address space using the fpgaUnmapMMIO() call.</p> <p>Shared memory buffers are allocated by way of the fpgaPrepareBuffer() call.</p> <pre><code>fpga_result fpgaPrepareBuffer(fpga_handle handle,\nuint64_t len,\nvoid **buf_addr,\nuint64_t *wsid,\nint flags);\n</code></pre> <p>Figure 7 fpgaPrepareBuffer()</p> <p></p> <p>Three buffer lengths are supported by this allocation method:</p> <p></p> Length Description 4096 (4KiB) No memory configuration needed. 2097152 (2MiB) Requires 2MiB huge pages to be allocated. 1073741824 (1GiB) Requires 1GiB huge pages to be allocated. <p>Table 7 fpgaPrepareBuffer() Lengths</p> <p></p> <pre><code>echo 8 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages\necho 2 &gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages\n</code></pre> <p>Figure 8 Configuring Huge Pages</p> <p></p> <p>The buf_addr parameter to fpgaPrepareBuffer() is a pointer to a void * that accepts the user virtual base address of the newly-created buffer. The wsid parameter is a pointer to a uint64_t that receives a unique workspace ID for the buffer allocation. This workspace ID is used in subsequent calls to fpgaReleaseBuffer(), which should be called when the buffer is no longer needed and in calls to fpgaGetIOAddress() which is used to query the IO base address of the buffer. The IO base address can be programmed into the AFU by means of the AFU CSR space. For example, here is a code snippet from the hello_fpga sample that demonstrates programming a shared buffer\u2019s IO base address into an AFU CSR in MMIO region 0:</p> <pre><code>#define LOG2_CL 6\n#define CACHELINE_ALIGNED_ADDR(p) ((p) &gt;&gt; LOG2_CL)\nfpgaGetIOAddress(accelerator_handle, input_wsid, &amp;iova);\nfpgaWriteMMIO64(accelerator_handle, 0, nlb_base_addr + CSR_SRC_ADDR,\nCACHELINE_ALIGNED_ADDR(iova));\n</code></pre> <p>Figure 9 Programming Shared Memory</p> <p></p> <p>If applications need to map a shared buffer that has been allocated by some other means than fpgaPrepareBuffer(), then the flags parameter can be set to FPGA_BUF_PREALLOCATED. This causes fpgaPrepareBuffer() to skip the allocation portion of the call and to only memory map the given buf_addr into the application process address space.</p> <p>Buffers can also be allocated and mapped as read-only by specifying FPGA_BUF_READ_ONLY.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#216-management","title":"2.1.6 Management","text":"<p>The management feature in OPAE concerns re-programming the programmable region of the Port. To program the Port bitstream, pass a handle to the FPGA_DEVICE associated with the desired Port. The slot parameter identifies which Port to program in the case of multi-port implementations. Most designs will only pass zero as the slot parameter. The bitstream parameter is a buffer that contains the entire bitstream contents, including the JSON bitstream header information. The bitstream_len field gives the length of bitstream in bytes.</p> <p>fpgaReconfigureSlot() first checks whether the FPGA_ACCELERATOR corresponding to the FPGA_DEVICE in fme_handle is open. If it is open, then the programming request is aborted with an error code. The application may pass FPGA_RECONF_FORCE in the flags parameter in order to avoid this open check and forcefully program the bitstream.</p> <pre><code>fpga_result fpgaReconfigureSlot(fpga_handle fme_handle,\nuint32_t slot,\nconst uint8_t *bitstream,\nsize_t bitstream_len,\nint flags);\n</code></pre> <p>Figure 10 fpgaReconfigureSlot()</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#217-errors","title":"2.1.7 Errors","text":"<p>The OPAE errors API provides a means to query and clear both FPGA_DEVICE and FPGA_ACCELERATOR errors. Each FPGA device exports a collection of error registers via the DFL drivers\u2019 sysfs tree, for both the FME and the Port. Each register is typically an unsigned 64-bit mask of the current errors, where each bit or some collection of bits specifies an error type. An error is signaled if its bit or collection of bits is non-zero. Note that the 32-bit error index may vary from one process execution to the next. Applications should use fpgaGetErrorInfo() and examine the error name returned in the struct fpga_error_info to identify the desired 64-bit error mask.</p> <pre><code>struct fpga_error_info {\nchar name[FPGA_ERROR_NAME_MAX];\nbool can_clear;\n};\n</code></pre> <p>Figure 11 struct fpga_error_info</p> <p></p> <p>Each 64-bit mask of errors is assigned a unique 32-bit integer index and a unique name. Given an fpga_token and an error index, fpgaGetErrorInfo() retrieves the struct fpga_error_info corresponding to the error.</p> <pre><code>fpga_result fpgaGetErrorInfo(fpga_token token,\nuint32_t error_num,\nstruct fpga_error_info *error_info);\n</code></pre> <p>Figure 12 fpgaGetErrorInfo()</p> <p></p> <p>fpgaReadError() provides access to the raw 64-bit error mask, given the unique error index. fpgaClearError() clears the errors for a particular index. fpgaClearAllErrors() clears all the errors for the given fpga_token.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#218-metrics","title":"2.1.8 Metrics","text":"<p>The OPAE metrics API refers to a group of functions and data structures that allow querying the various device metrics from the Board Management Controller component of the FPGA device. A metric is described by an instance of struct fpga_metric_info.</p> <p><pre><code>typedef struct fpga_metric_info {\nuint64_t metric_num;\nfpga_guid metric_guid;\nchar qualifier_name[FPGA_METRIC_STR_SIZE];\nchar group_name[FPGA_METRIC_STR_SIZE];\nchar metric_name[FPGA_METRIC_STR_SIZE];\nchar metric_units[FPGA_METRIC_STR_SIZE];\nenum fpga_metric_datatype metric_datatype;\nenum fpga_metric_type metric_type;\n} fpga_metric_info;\n</code></pre> Relevant Links:  - fpga_metric_datatype - fpga_metric_type</p> <p>Figure 13 fpga_metric_info</p> <p></p> <p>The group_name field holds a string describing the broad categorization of the metric. Some sample values for group_name are \u201cthermal_mgmt\u201d and \u201cpower_mgmt\u201d. The metric_name field contains the metric\u2019s name. The number and names of metrics may vary from one FPGA platform to the next. The qualifier_name field is a concatenation of group_name and metric_name, with a colon character in between. The metric_units field contains the string name of the unit of measurement for the specific metric. Some examples for metric_units are \u201cVolts\u201d, \u201cAmps\u201d, and \u201cCelsius\u201d.</p> <p>The metric_datatype field uniquely identifies the underlying C data type for the metric\u2019s value:</p> <pre><code>enum fpga_metric_datatype {\nFPGA_METRIC_DATATYPE_INT,\nFPGA_METRIC_DATATYPE_FLOAT,\nFPGA_METRIC_DATATYPE_DOUBLE,\nFPGA_METRIC_DATATYPE_BOOL,\nFPGA_METRIC_DATATYPE_UNKNOWN\n};\n</code></pre> <p>Figure 14 enum fpga_metric_datatype</p> <p></p> <p>The metric_type field classifies the metric into a broad category. This information is redundant with the group_name field.</p> <pre><code>enum fpga_metric_type {\nFPGA_METRIC_TYPE_POWER,\nFPGA_METRIC_TYPE_THERMAL,\nFPGA_METRIC_TYPE_PERFORMANCE_CTR,\nFPGA_METRIC_TYPE_AFU,\nFPGA_METRIC_TYPE_UNKNOWN\n};\n</code></pre> <p>Figure 15 enum fpga_metric_type</p> <p></p> <p>In order to enumerate the information for each of the metrics available from the FPGA device, determine the number of metrics using fpgaGetNumMetrics().</p> <pre><code>uint64_t num_metrics = 0;\nfpgaGetNumMetrics(handle, &amp;num_metrics);\n</code></pre> <p>Figure 16 Determining Number of Metrics</p> <p></p> <p>This call retrieves the number of available metrics for the FPGA_DEVICE that is opened behind the handle parameter to the call. Refer to 2.1.3 Access for information about the fpgaOpen() call. When the number of available metrics is known, allocate a buffer large enough to hold that many fpga_metric_info data structures, and call fpgaGetMetricsInfo() to populate the entries:</p> <pre><code>fpga_metric_info *metric_info;\nuint64_t metric_infos = num_metrics;\nmetric_info = calloc(num_metrics, sizeof(fpga_metric_info));\nfpgaGetMetricsInfo(handle, metric_info, &amp;metric_infos);\n</code></pre> <p>Figure 17 Querying Metrics Info</p> <p></p> <p>The fpga_metric structure is the representation of a metric\u2019s value:</p> <p><pre><code>typedef struct fpga_metric {\nuint64_t metric_num;\nmetric_value value;\nbool isvalid;\n} fpga_metric;\n</code></pre> Relevant Links: - metric_value</p> <p>Figure 18 struct fpga_metric</p> <p></p> <p>The metric_num field matches the metric_num field of the fpga_metric_info structure. value contains the metric value, which is encoded in the C data type identified by the metric_datatype field of fpga_metric_info. Finally, the isvalid field denotes whether the metric value is valid.</p> <p>There are two methods of obtaining a metric\u2019s value, given the information in the fpga_metric_info structure:</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2181-querying-metric-values-by-index","title":"2.1.8.1 Querying Metric Values by Index","text":"<p>fpgaGetMetricsByIndex() retrieves a metric value using the metric_num field of the metric info:</p> <pre><code>uint64_t metric_num = metric_info[0]-&gt;metric_num;\nfpga_metric metric0;\nfpgaGetMetricsByIndex(handle, &amp;metric_num, 1, &amp;metric0);\n</code></pre> <p>Figure 19 Retrieve Metric by Index</p> <p></p> <p>This call allows retrieving one or more metric values, each identified by their unique metric_num. The second and fourth parameters allow passing arrays so that multiple values can be fetched in a single call.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2182-querying-metric-values-by-name","title":"2.1.8.2 Querying Metric Values by Name","text":"<p>fpgaGetMetricsByName() retrieves a metric value using the metric_name field of the metric info:</p> <pre><code>char *metric_name = metric_info[1]-&gt;metric_name;\nfpga_metric metric1;\nfpgaGetMetricsByName(handle, &amp;metric_name, 1, &amp;metric1);\n</code></pre> <p>This call also allows retrieving one or more metric values, each identified by their unique metric_name. The second and fourth parameters allow passing arrays so that multiple values can be fetched in a single call.</p> <p>The fpgaGetMetricsThresholdInfo() call is provided for legacy implementations only. It should be considered deprecated for current and future FPGA designs.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#219-sysobject","title":"2.1.9 SysObject","text":"<p>When the hardware access method in use is the DFL drivers (see 2.3.2 libxfpga Plugin), the sysfs tree rooted at the struct _fpga_token\u2019s sysfspath member is accessible via the OPAE SDK SysObject API. The SysObject API provides an abstraction to search, traverse, read, and write sysfs entities. These sysfs entities may take the form of directories, which are referred to as containers, or files, which are referred to as attributes. Figure 20 enum fpga_sysobject_type shows the API\u2019s means of distinguishing between the two types.</p> <pre><code>enum fpga_sysobject_type {\nFPGA_OBJECT_CONTAINER = (1u &lt;&lt; 0),\nFPGA_OBJECT_ATTRIBUTE = (1u &lt;&lt; 1)\n};\n</code></pre> <p>Figure 20 enum fpga_sysobject_type</p> <p></p> <p>The SysObject API introduces another opaque structure type, fpga_object. An fpga_object can be queried from an fpga_token or an fpga_handle by way of the fpgaTokenGetObject() and fpgaHandleGetObject() API\u2019s.</p> <pre><code>fpga_result fpgaTokenGetObject(fpga_token token, const char *name,\nfpga_object *object, int flags);\nfpga_result fpgaHandleGetObject(fpga_handle handle, const char *name,\nfpga_object *object, int flags);\n</code></pre> <p>Figure 21 fpgaTokenGetObject() / fpgaHandleGetObject()</p> <p></p> <p>The remainder of the SysObject API is broken into two categories of calls, depending on the fpga_object\u2019s type. The type of an fpga_object is learned via fpgaObjectGetType().</p> <pre><code>fpga_result fpgaObjectGetType(fpga_object obj,\nenum fpga_sysobject_type *type);\n</code></pre> <p>Figure 22 fpgaObjectGetType()</p> <p></p> <p>When an fpga_object is no longer needed, it should be freed via fpgaDestroyObject().</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2191-fpga_object_container-apis","title":"2.1.9.1 FPGA_OBJECT_CONTAINER API\u2019s","text":"<p>For directory sysfs entities, passing a value of FPGA_OBJECT_RECURSE_ONE or FPGA_OBJECT_RECURSE_ALL in the flags parameter to fpgaTokenGetObject() or fpgaHandleGetObject() causes these two API\u2019s to treat the target object as either a single-layer or multi-layer directory structure, making its child entities available for query via fpgaObjectGetObject() and fpgaObjectGetObjectAt().</p> <pre><code>fpga_result fpgaObjectGetObject(fpga_object parent, const char *name,\nfpga_object *object, int flags);\nfpga_result fpgaObjectGetObjectAt(fpga_object parent, size_t idx,\nfpga_object *object);\n</code></pre> <p>Figure 23 fpgaObjectGetObject() / fpgaObjectGetObjectAt()</p> <p></p> <p>Any child object resulting from fpgaObjectGetObject() or fpgaObjectGetObjectAt() must be freed via fpgaDestroyObject() when it is no longer needed.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2192-fpga_object_attribute-apis","title":"2.1.9.2 FPGA_OBJECT_ATTRIBUTE API\u2019s","text":"<p>Attribute sysfs entities may be queried for their size and read from or written to. In order to determine the size of an attribute\u2019s data, use fpgaObjectGetSize().</p> <pre><code>fpga_result fpgaObjectGetSize(fpga_object obj,\nuint32_t *value, int flags);\n</code></pre> <p>Figure 24 fpgaObjectGetSize()</p> <p></p> <p>Attributes containing arbitrary string data can be read with fpgaObjectRead().</p> <pre><code>fpga_result fpgaObjectRead(fpga_object obj, uint8_t *buffer,\nsize_t offset, size_t len, int flags);\n</code></pre> <p>Figure 25 fpgaObjectRead()</p> <p></p> <p>If an attribute contains an unsigned integer value, its value can be read with fpgaObjectRead64() and written with fpgaObjectWrite64().</p> <pre><code>fpga_result fpgaObjectRead64(fpga_object obj,\nuint64_t *value, int flags);\nfpga_result fpgaObjectWrite64(fpga_object obj,\nuint64_t value, int flags);\n</code></pre> <p>Figure 26 fpgaObjectRead64() / fpgaObjectWrite64()</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2110-utilities","title":"2.1.10 Utilities","text":"<p>The fpga_result enumeration defines a set of error codes used throughout OPAE. In order to convert an fpga_result error code into a printable string, the application can use the fpgaErrStr() call.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#22-dfl-driver-ioctl-interfaces","title":"2.2 DFL Driver IOCTL Interfaces","text":"<p>The DFL drivers export an IOCTL interface which the libxfpga.so plugin consumes in order to query and configure aspects of the FME and Port. These interfaces are used only internally by the SDK; they are not customer-facing. The description here is provided for completeness only.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#221-port-reset","title":"2.2.1 Port Reset","text":"<p>The DFL_FPGA_PORT_RESET ioctl is used by the fpgaReset() call in order to perform a Port reset. The fpga_handle passed to fpgaReset() must be a valid open handle to an FPGA_ACCELERATOR. The ioctl requires no input/output parameters.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#222-port-information","title":"2.2.2 Port Information","text":"<p>The DFL_FPGA_PORT_GET_INFO ioctl is used to query properties of the Port, notably the number of associated MMIO regions. The ioctl requires a pointer to a struct dfl_fpga_port_info.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#223-mmio-region-information","title":"2.2.3 MMIO Region Information","text":"<p>The DFL_FPGA_PORT_GET_REGION_INFO ioctl is used to query the details of an MMIO region. The ioctl requires a pointer to a struct dfl_fpga_port_region_info. The index field of the struct is populated by the caller, and the padding, size, and offset values are populated by the DFL driver.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#224-shared-memory-mapping-and-unmapping","title":"2.2.4 Shared Memory Mapping and Unmapping","text":"<p>The DFL_FPGA_PORT_DMA_MAP ioctl is used to map a memory buffer into the application\u2019s process address space. The ioctl requires a pointer to a struct dfl_fpga_port_dma_map.</p> <p>The DFL_FPGA_PORT_DMA_UNMAP ioctl is used to unmap a memory buffer from the application\u2019s process address space. The ioctl requires a pointer to a struct dfl_fpga_port_dma_unmap.</p> <p>These ioctls provide the underpinnings of the fpgaPrepareBuffer() and fpgaReleaseBuffer() calls.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#225-number-of-port-error-irqs","title":"2.2.5 Number of Port Error IRQs","text":"<p>The DFL_FPGA_PORT_ERR_GET_IRQ_NUM ioctl is used to query the number of Port error interrupt vectors available. The ioctl requires a pointer to a uint32_t that receives the Port error interrupt count.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#226-port-error-interrupt-configuration","title":"2.2.6 Port Error Interrupt Configuration","text":"<p>The DFL_FPGA_PORT_ERR_SET_IRQ ioctl is used to configure one or more file descriptors for the Port Error interrupt. The ioctl requires a pointer to a struct dfl_fpga_irq_set. The values stored in the evtfds field of this struct should be populated with the event file descriptors for the interrupt, as returned by the eventfd() C standard library API.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#227-number-of-afu-interrupts","title":"2.2.7 Number of AFU Interrupts","text":"<p>The DFL_FPGA_PORT_UINT_GET_IRQ_NUM ioctl is used to query the number of AFU interrupt vectors available. The ioctl requires a pointer to a uint32_t that receives the AFU interrupt count.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#228-user-afu-interrupt-configuration","title":"2.2.8 User AFU Interrupt Configuration","text":"<p>The DFL_FPGA_PORT_UINT_SET_IRQ ioctl is used to configure one or more file descriptors for the AFU interrupt. The ioctl requires a pointer to a struct dfl_fpga_irq_set. The values stored in the evtfds field of this struct should be populated with the event file descriptors for the interrupt, as returned by the eventfd() C standard library API.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#229-partial-reconfiguration","title":"2.2.9 Partial Reconfiguration","text":"<p>The DFL_FPGA_FME_PORT_PR ioctl is used to update the logic stored in the Port\u2019s programmable region. This ioctl must be issued on the device file descriptor corresponding to the FPGA_DEVICE (/dev/dfl-fme.X). The ioctl requires a pointer to a struct dfl_fpga_fme_port_pr with each of the fields populated.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2210-number-of-fme-error-irqs","title":"2.2.10 Number of FME Error IRQs","text":"<p>The DFL_FPGA_FME_ERR_GET_IRQ_NUM ioctl is used to query the number of FME error interrupt vectors available. The ioctl requires a pointer to a uint32_t that receives the FME error interrupt count.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2211-fme-error-interrupt-configuration","title":"2.2.11 FME Error Interrupt Configuration","text":"<p>The DFL_FPGA_FME_ERR_SET_IRQ ioctl is used to configure one or more file descriptors for the FME Error interrupt. The ioctl requires a pointer to a struct dfl_fpga_irq_set. The values stored in the evtfds field of this struct should be populated with the event file descriptors for the interrupt, as returned by the eventfd() C standard library API. as returned by the eventfd() C standard library API.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#23-plugin-manager","title":"2.3 Plugin Manager","text":"<p>The OPAE Plugin Manager refers to initialization code in libopae-c that examines an FPGA device\u2019s PCIe Vendor and Device ID and makes an association between a particular FPGA device and its access method. OPAE currently supports three device access methods:</p> <p>Access Method</p> <p>Plugin Module</p> Device Feature List drivers libxfpga.so Virtual Function I/O libopae-v.so AFU Simulation Environment libase.so <p>Table 9 Plugin Device Access Methods</p> <p></p> <p>The Plugin Manager allows code that is written to a specific API signature to access FPGA hardware via different mechanisms. In other words, the end user codes to the OPAE API; and the OPAE API, based on configuration data, routes the hardware access to the device via different means.</p> <p>As an example, consider an API configuration that accesses FPGA device_A via the Device Feature List drivers and that accesses FPGA device_B via VFIO. The application is coded against the OPAE API.</p> <p>As part of its initialization process, the application enumerates and discovers an fpga_token corresponding to device_A. That fpga_token is opened and its MMIO region 0 is mapped via a call to fpgaMapMMIO().</p> <p>The API configuration for device_A is such that the fpga_handle corresponding to device_A routes its hardware access calls through libxfpga.so. The call to fpgaMapMMIO() is redirected to libxfpga.so\u2019s implementation of the MMIO mapping function, xfpga_fpgaMapMMIO(). As a result, the call to xfpga_fpgaMapMMIO() uses its AFU file descriptor to communicate with the DFL driver to map the MMIO region.</p> <p>Subsequently, the application enumerates and discovers an fpga_token corresponding to device_B. That fpga_token is opened and its MMIO region 0 is mapped via a call to fpgaMapMMIO().</p> <p>The API configuration for device_B is such that the fpga_handle corresponding to device_B routes its hardware access calls through libopae-v.so. The call to fpgaMapMMIO() is redirected to libopae-v.so\u2019s implementation of the MMIO mapping function, vfio_fpgaMapMMIO(). As a result, the call to vfio_fpgaMapMMIO() uses the MMIO mapping performed by libopaevfio.so during initialization of the VFIO session.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#231-plugin-model","title":"2.3.1 Plugin Model","text":"<p>The OPAE SDK plugin model is facilitated by its use of opaque C structures for fpga_token and fpga_handle. These types are both declared as void *; and this allows the parameters to the OPAE SDK functions to take different forms, depending on the layer of the SDK being used.</p> <p>At the topmost layer, for example when calling fpgaEnumerate(), the output fpga_token parameter array is actually an array of pointers to opae_wrapped_token struct\u2019s.</p> <pre><code>typedef struct _opae_wrapped_token {\nuint32_t magic;\nfpga_token opae_token;\nuint32_t ref_count;\nstruct _opae_wrapped_token *prev;\nstruct _opae_wrapped_token *next;\nopae_api_adapter_table *adapter_table;\n} opae_wrapped_token;\n</code></pre> <p>Figure 27 opae_wrapped_token</p> <p></p> <p>An opae_wrapped_token, as the name suggests, is a thin wrapper around the lower-layer token which is stored in struct member opae_token. The adapter_table struct member is a pointer to a plugin-specific adapter table. The adapter table provides a mapping between the top-layer opae_wrapped_token and its underlying plugin-specific API entry points, which are called using the opae_token struct member (the lower-level token).</p> <pre><code>typedef struct _opae_api_adapter_table {\nstruct _opae_api_adapter_table *next;\nopae_plugin plugin;\n...\nfpga_result (*fpgaEnumerate)(const fpga_properties *filters,\nuint32_t num_filters,\nfpga_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n...\nint (*initialize)(void);\nint (*finalize)(void);\n} opae_api_adapter_table;\n</code></pre> <p>Figure 28 opae_api_adapter_table</p> <p></p> <p>When libopae-c loads, the plugin manager uses the plugin configuration data to open and configure a session to each of the required plugin libraries. During this configuration process, each plugin is passed an empty adapter table struct. The purpose of the plugin configuration is to populate this adapter table struct with each of the plugin-specific API entry points.</p> <p>When the top-level fpgaEnumerate() is called, each adapter table\u2019s plugin-specific fpgaEnumerate() struct member is called; and the output fpga_token\u2019s are collected. At this point, these fpga_token\u2019s are the lower-level token structure types. Before the top-level fpgaEnumerate() returns, these plugin-specific tokens are wrapped inside opae_wrapped_token structures, along with a pointer to the respective adapter table.</p> <p>After enumeration is complete, the application goes on to call other top-level OPAE SDK functions with the wrapped tokens. Each top-level entry point which accepts an fpga_token knows that it is actually being passed an opae_wrapped_token. With this knowledge, the entry point peeks inside the wrapped token and calls through to the plugin-specific API entry point using the adapter table, passing the lower-level opae_token struct member.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#232-libxfpga-plugin","title":"2.3.2 libxfpga Plugin","text":"<p>2.3.1 Plugin Model introduced the concept of an opae_wrapped_token and a corresponding plugin-specific token structure. libxfpga.so is the plugin library that implements the DFL driver hardware access method. Its plugin-specific token data structure is struct _fpga_token.</p> <p><pre><code>struct _fpga_token {\nfpga_token_header hdr;\nuint32_t device_instance;\nuint32_t subdev_instance;\nchar sysfspath[SYSFS_PATH_MAX];\nchar devpath[DEV_PATH_MAX];\nstruct error_list *errors;\n};\n</code></pre> Relevant Links: - fpga_token_header - error_list</p> <p>Figure 29 struct _fpga_token</p> <p></p> <p>A struct _fpga_token corresponding to the Port will have sysfspath and devpath members that contain strings like the following example paths:</p> <pre><code>sysfspath: \u201c/sys/class/fpga_region/region0/dfl-port.0\u201d\ndevpath: \u201c/dev/dfl-port.0\u201d\n</code></pre> <p>Figure 30 libxfpga Port Token</p> <p></p> <p>Likewise, a struct _fpga_token corresponding to the FME will have sysfspath and devpath members that contain strings like the following example paths:</p> <pre><code>sysfspath: \u201c/sys/class/fpga_region/region0/dfl-fme.0\u201d\ndevpath: \u201c/dev/dfl-fme.0\u201d\n</code></pre> <p>Figure 31 libxfpga FME Token</p> <p></p> <p>When a call to the top-level fpgaOpen() is made, the lower-level token is unwrapped and passed to xfpga_fpgaOpen(). In return, xfpga_fpgaOpen() opens the character device file identified by the devpath member of the struct _fpga_token. It then allocates and initializes an instance of libxfpga.so\u2019s plugin-specific handle data structure, struct _fpga_handle.</p> <p><pre><code>struct _fpga_handle {\npthread_mutex_t lock;\nuint64_t magic;\nfpga_token token;\nint fddev;\nint fdfpgad;\nuint32_t num_irqs;\nuint32_t irq_set;\nstruct wsid_tracker *wsid_root;\nstruct wsid_tracker *mmio_root;\nvoid *umsg_virt;\nuint64_t umsg_size;\nuint64_t *umsg_iova;\nbool metric_enum_status;\nfpga_metric_vector fpga_enum_metric_vector;\nvoid *bmc_handle;\nstruct _fpga_bmc_metric *_bmc_metric_cache_value;\nuint64_t num_bmc_metric;\nuint32_t flags;\n};\n</code></pre> Relevant Links: - wsid_tracker - fpga_metric_vector - _fpga_bmc_metric</p> <p>Figure 32 struct _fpga_handle</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#233-libopae-v-plugin","title":"2.3.3 libopae-v Plugin","text":"<p>libopae-v.so is the plugin library that implements the VFIO hardware access method. Its plugin-specific token data structure is vfio_token.</p> <p><pre><code>#define USER_MMIO_MAX 8\ntypedef struct _vfio_token {\nfpga_token_header hdr;\nfpga_guid compat_id;\npci_device_t *device;\nuint32_t region;\nuint32_t offset;\nuint32_t mmio_size;\nuint32_t pr_control;\nuint32_t user_mmio_count;\nuint32_t user_mmio[USER_MMIO_MAX];\nuint64_t bitstream_id;\nuint64_t bitstream_mdata;\nuint8_t num_ports;\nstruct _vfio_token *parent;\nstruct _vfio_token *next;\nvfio_ops ops;\n} vfio_token;\n</code></pre> Relevant Links: - fpga_token_header - pci_device_t - vfio_ops</p> <p>Figure 33 vfio_token</p> <p></p> <p>When a call to the top-level fpgaOpen() is made, the lower-level token is unwrapped and passed to vfio_fpgaOpen(). In return, vfio_fpgaOpen() opens the VFIO device matching the device address found in the input vfio_token. It then allocates and initializes an instance of libopae-v.so\u2019s plugin-specific handle data structure, vfio_handle.</p> <p><pre><code>typedef struct _vfio_handle {\nuint32_t magic;\nstruct _vfio_token *token;\nvfio_pair_t *vfio_pair;\nvolatile uint8_t *mmio_base;\nsize_t mmio_size;\npthread_mutex_t lock;\n#define OPAE_FLAG_HAS_AVX512 (1u &lt;&lt; 0)\nuint32_t flags;\n} vfio_handle;\n</code></pre> Relevant Links: - vfio_token - vfio_pair_t</p> <p>Figure 34 vfio_handle</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2331-supporting-libraries","title":"2.3.3.1 Supporting Libraries","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#23311-libopaevfio","title":"2.3.3.1.1 libopaevfio","text":"<p>libopaevfio.so is OPAE\u2019s implementation of the Linux kernel\u2019s Virtual Function I/O interface. This VFIO interface presents a generic means of configuring and accessing PCIe endpoints from a user-space process via a supporting Linux kernel device driver, vfio-pci.</p> <p>libopaevfio.so provides APIs for opening/closing a VFIO device instance, for mapping/unmapping MMIO spaces, for allocating/freeing DMA buffers, and for configuring interrupts for the device.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#23312-libopaemem","title":"2.3.3.1.2 libopaemem","text":"<p>Each DMA buffer allocation made by libopaevfio.so\u2019s opae_vfio_buffer_allocate() and opae_vfio_buffer_allocate_ex() APIs requires a backing I/O Virtual Address range. These address ranges are discovered at VFIO device open time by way of the VFIO_IOMMU_GET_INFO ioctl.</p> <p>Each range specifies a large contiguous block of I/O Virtual Address space. The typical DMA buffer allocation size is significantly less than one of these IOVA blocks, so the division of each block into allocatable segments must be managed so that multiple DMA buffer allocations can be made from a single block. In other words, the IOVA blocks must be memory-managed in order to make efficient use of them.</p> <p>libopaemem.so provides a generic means of managing a large memory space, consisting of individual large memory blocks of contiguous address space. When a DMA buffer allocation is requested, libopaevfio.so uses this generic memory manager to carve out a small chunk of contiguous IOVA address space in order for the DMA mapping to be made. The IOVA space corresponding to the allocation is marked as allocated, and the rest of the large block remains as allocatable space within the memory manager. Subsequent de-allocation returns a chunk of IOVA space to the free state, coalescing contiguous chunks as they are freed. The allocations and de-allocations of the IOVA space can occur in any order with respect to each other. libopaemem.so tracks both the allocated and free block space, carving out small chunks from the large IOVA blocks on allocations, and coalescing small chunks back into larger ones on frees.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2332-configuring-pcie-virtual-functions","title":"2.3.3.2 Configuring PCIe Virtual Functions","text":"<p>Before an AFU can be accessed with VFIO, the FPGA Physical Function must be configured to enable its Virtual Functions. Then, each VF must be bound to the vfio-pci Linux kernel driver.</p> <p>As of the Arrow Creek program, the FPGA hardware allows multiple AFU\u2019s to co-exist by placing each AFU in its own PCIe Virtual Function. Upon system startup, no PCIe VF\u2019s exist. The pci_device command can be used to enable the VF\u2019s and their AFU\u2019s. First, use the lspci command to examine the current device topology:</p> <pre><code># lspci | grep cel\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\nb1:00.2 Processing accelerators: Intel Corporation Device bcce\nb1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device\nb1:00.4 Processing accelerators: Intel Corporation Device bcce\n</code></pre> <p>Figure 35 lspci Device Topology</p> <p></p> <p>In this example, VF\u2019s are controlled by PF 0, as highlighted in Figure 35 lspci Device Topology. In the figure, each PF is shown as having the Arrow Creek PF PCIe device ID of bcce.</p> <p>Now, use the pci_device command to enable three VF\u2019s for PF0:</p> <pre><code># pci_device 0000:b1:00.0 vf 3\n# lspci | grep cel\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\nb1:00.2 Processing accelerators: Intel Corporation Device bcce\nb1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device\nb1:00.4 Processing accelerators: Intel Corporation Device bcce\nb1:00.5 Processing accelerators: Intel Corporation Device bccf\nb1:00.6 Processing accelerators: Intel Corporation Device bccf\nb1:00.7 Processing accelerators: Intel Corporation Device bccf\n</code></pre> <p>Figure 36 Enable Virtual Functions</p> <p></p> <p>Figure 20 Enable Virtual Functions shows that three VF\u2019s were created. Each VF is shown as having the Arrow Creek VF PCIe device ID of bccf.</p> <p>Now, each Virtual Function must be bound to the vfio-pci Linux kernel driver so that it can be accessed via VFIO:</p> <pre><code># opaevfio -i -u myuser -g mygroup 0000:b1:00.5\nBinding (0x8086,0xbccf) at 0000:b1:00.5 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:b1:00.5 is 318\n</code></pre> <p>Figure 37 Bind VF's to vfio-pci</p> <p></p> <p>Here, myuser and mygroup identify the unprivileged user/group that requires access to the device. The opaevfio command will change the ownership of the device per the values given.</p> <p>Once the VF\u2019s are bound to vfio-pci, the OPAE SDK will find and enumerate them with libopae-v.so:</p> <pre><code># fpgainfo port\n//****** PORT ******//\nObject Id : 0xEF00000\nPCIe s:b:d.f : 0000:B1:00.0\nDevice Id : 0xBCCE\nSocket Id : 0x00\n//****** PORT ******//\nObject Id : 0xE0B1000000000000\nPCIe s:b:d.f : 0000:B1:00.7\nDevice Id : 0xBCCF\nSocket Id : 0x01\nAccelerator GUID : 4dadea34-2c78-48cb-a3dc-5b831f5cecbb\n//****** PORT ******//\nObject Id : 0xC0B1000000000000\nPCIe s:b:d.f : 0000:B1:00.6\nDevice Id : 0xBCCF\nSocket Id : 0x01\nAccelerator GUID : 823c334c-98bf-11ea-bb37-0242ac130002\n//****** PORT ******//\nObject Id : 0xA0B1000000000000\nPCIe s:b:d.f : 0000:B1:00.5\nDevice Id : 0xBCCF\nSocket Id : 0x01\nAccelerator GUID : 8568ab4e-6ba5-4616-bb65-2a578330a8eb\n</code></pre> <p>Figure 38 List VF's with fpgainfo</p> <p></p> <p>When the VF\u2019s are no longer needed, they can be unbound from the vfio-pci driver:</p> <pre><code># opaevfio -r 0000:b1:00.5\nReleasing (0x8086,0xbccf) at 0000:b1:00.5 from vfio-pci\n# opaevfio -r 0000:b1:00.6\nReleasing (0x8086,0xbccf) at 0000:b1:00.6 from vfio-pci\n# opaevfio -r 0000:b1:00.7\nReleasing (0x8086,0xbccf) at 0000:b1:00.7 from vfio-pci\n</code></pre> <p>Figure 39 Unbind VF's from vfio-pci</p> <p></p> <p>Finally, the VF\u2019s can be disabled:</p> <pre><code># pci_device 0000:b1:00.0 vf 0\n# lspci | grep cel\nb1:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\nb1:00.1 Processing accelerators: Intel Corporation Device bcce\nb1:00.2 Processing accelerators: Intel Corporation Device bcce\nb1:00.3 Processing accelerators: Red Hat, Inc. Virtio network device\nb1:00.4 Processing accelerators: Intel Corporation Device bcce\n</code></pre> <p>Figure 40 Disable Virtual Functions</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#24-application-flow","title":"2.4 Application Flow","text":"<p>A typical OPAE application that interacts with an AFU via MMIO and shared memory will have a flow similar to the one described in this section.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#241-create-filter-criteria","title":"2.4.1 Create Filter Criteria","text":"<p>Refer to 2.1.2 Enumeration. When enumerating AFU\u2019s, if no filtering criteria is specified, then fpgaEnumerate() returns fpga_token\u2019s for each AFU that is present in the system. In order to limit the enumeration search to a specific AFU, create an fpga_properties object and set its guid to that of the desired AFU:</p> <pre><code>#define MY_AFU_GUID \u201c57fa0b03-ab4f-4b02-b4eb-d3fe1ec18518\u201d\nfpga_properties filter = NULL;\nfpga_guid guid;\nfpgaGetProperties(NULL, &amp;filter);\nuuid_parse(MY_AFU_GUID, guid);\nfpgaPropertiesSetGUID(filter, guid);\n</code></pre> <p>Figure 41 Flow: Create Filter Criteria</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#242-enumerate-the-afu","title":"2.4.2 Enumerate the AFU","text":"<p>With the filtering criteria in place, enumerate to obtain an fpga_token for the AFU:</p> <pre><code>fpga_token afu_token = NULL;\nuint32_t num_matches = 0;\nfpgaEnumerate(&amp;filter, 1, &amp;afu_token, 1, &amp;num_matches);\n</code></pre> <p>Figure 42 Flow: Enumerate the AFU</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#243-open-the-afu","title":"2.4.3 Open the AFU","text":"<p>After finding an fpga_token for the AFU using fpgaEnumerate(), the token must be opened with fpgaOpen() to establish a session with the AFU. The process of opening an fpga_token creates an fpga_handle:</p> <pre><code>fpga_handle afu_handle = NULL;\nfpgaOpen(afu_token, &amp;afu_handle, 0);\n</code></pre> <p>Figure 43 Flow: Open the AFU</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#244-map-mmio-region","title":"2.4.4 Map MMIO Region","text":"<p>In order to access the MMIO region of the AFU to program its CSR\u2019s, the region must first be mapped into the application\u2019s process address space. This is accomplished using fpgaMapMMIO():</p> <pre><code>uint32_t region = 0;\nfpgaMapMMIO(afu_handle, region, NULL);\n</code></pre> <p>Figure 44 Flow: Map MMIO Region</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#245-allocate-dma-buffers","title":"2.4.5 Allocate DMA Buffers","text":"<p>If the AFU is DMA-capable, shared memory buffers can be allocated and mapped into the process address space and the IOMMU with fpgaPrepareBuffer(). Refer to Figure 8 Configuring Huge Pages for instructions on configuring 2MiB and 1GiB huge pages.</p> <pre><code>#define BUF_SIZE (2 * 1024 * 1024)\nvolatile uint64_t *src_ptr = NULL;\nuint64_t src_wsid = 0;\nvolatile uint64_t *dest_ptr = NULL;\nuint64_t dest_wsid = 0;\nfpgaPrepareBuffer(afu_handle, BUF_SIZE, (void **)&amp;src_ptr,\n&amp;src_wsid, 0);\nfpgaPrepareBuffer(afu_handle, BUF_SIZE, (void **)&amp;dest_ptr,\n&amp;dest_wsid, 0);\nmemset(src_ptr, 0xaf, BUF_SIZE);\nmemset(dest_ptr, 0xbe, BUF_SIZE);\n</code></pre> <p>Figure 45 Flow: Allocate DMA Buffers</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#246-make-afu-aware-of-dma-buffers","title":"2.4.6 Make AFU Aware of DMA Buffers","text":"<p>The process by which locations of shared memory buffers and their sizes are made known to the AFU is entirely AFU-specific. This example shows the method used by the Native Loopback AFU. Each buffer I/O virtual address is cacheline-aligned and programmed into a unique AFU CSR; then the buffer size in lines is programmed into a length CSR:</p> <pre><code>#define CSR_SRC_ADDR 0x000A // AFU-specific\n#define CSR_DEST_ADDR 0x000B // AFU-specific\n#define CSR_NUM_LINES 0x000C // AFU-specific\nuint64_t src_iova = 0;\nuint64_t dest_iova = 0;\nfpgaGetIOAddress(afu_handle, src_wsid, &amp;src_iova);\nfpgaGetIOAddress(afu_handle, dest_wsid, &amp;dest_iova);\nfpgaWriteMMIO64(afu_handle, 0, CSR_SRC_ADDR, src_iova &gt;&gt; 6);\nfpgaWriteMMIO64(afu_handle, 0, CSR_DEST_ADDR, dest_iova &gt;&gt; 6);\nfpgaWriteMMIO32(afu_handle, 0, CSR_NUM_LINES, BUF_SIZE / 64);\n</code></pre> <p>Figure 46 Flow: Make AFU Aware of DMA Buffers</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#247-initiate-an-acceleration-task","title":"2.4.7 Initiate an Acceleration Task","text":"<p>With the shared buffer configuration complete, the AFU can be told to initiate the acceleration task. This process is AFU-specific. The Native Loopback AFU starts the acceleration task by writing a value to its control CSR:</p> <pre><code>#define CSR_CTRL 0x000D // AFU-specific\nfpgaWriteMMIO32(afu_handle, 0, CSR_CTRL, 3);\n</code></pre> <p>Figure 47 Initiate an Acceleration Task</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#248-wait-for-task-completion","title":"2.4.8 Wait for Task Completion","text":"<p>Once the acceleration task is initiated, the application may poll the AFU for a completion status. This process is AFU-specific. The AFU may provide a status CSR for the application to poll; or the AFU may communicate status to the application by means of a result code written to a shared buffer.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#249-free-dma-buffers","title":"2.4.9 Free DMA Buffers","text":"<p>When the acceleration task completes and the AFU is quiesced such that there are no outstanding memory transactions targeted for the shared memory, the DMA buffers can be unmapped and freed using fpgaReleaseBuffer():</p> <pre><code>fpgaReleaseBuffer(afu_handle, src_wsid);\nfpgaReleaseBuffer(afu_handle, dest_wsid);\n</code></pre> <p>Figure 48 Flow: Free DMA Buffers</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2410-unmap-mmio-region","title":"2.4.10 Unmap MMIO Region","text":"<p>The MMIO regions should also be unmapped using fpgaUnmapMMIO():</p> <p><pre><code>fpgaUnmapMMIO(afu_handle, region);\n</code></pre> </p> <p>Figure 49 Flow: Unmap MMIO Region</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2411-close-the-afu","title":"2.4.11 Close the AFU","text":"<p>The AFU handle should be closed via fpgaClose() to release its resources:</p> <p></p> <pre><code>fpgaClose(afu_handle);\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#2412-release-the-tokens-and-properties","title":"2.4.12 Release the Tokens and Properties","text":"<p>The fpga_token\u2019s returned by fpgaEnumerate() should be destroyed using the fpgaDestroyToken() API. The fpga_properties objects should be destroyed using the fpgaDestroyProperties() API:</p> <pre><code>fpgaDestroyToken(&amp;afu_token);\nfpgaDestroyProperties(&amp;filter);\n</code></pre> <p>Figure 51 Flow: Release the Tokens and Properties</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#30-opae-c-api","title":"3.0 OPAE C++ API","text":"<p>The OPAE C++ API refers to a C++ layer that sits on top of the OPAE C API, providing object-oriented implementations of the main OPAE C API abstractions: properties, tokens, handles, dma buffers, etc. Like the OPAE C API, the C++ API headers contain Doxygen markup for each of the provided classes.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#31-libopae-cxx-core","title":"3.1 libopae-cxx-core","text":"<p>The implementation files for the C++ API are compiled into libopae-cxx-core.so. A convenience header, core.h, provides a quick means of including each of the C++ API headers. Each of the types comprising the C++ API is located within the opae::fpga::types C++ namespace.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#311-properties","title":"3.1.1 Properties","text":"<p>Class properties provides the C++ implementation of the fpga_properties type and its associated APIs.</p> <pre><code>properties::ptr_t filter = properties::get();\n</code></pre> <p>Figure 52 C++ Create New Empty Properties</p> <p></p> <p>Class properties provides member variables for each fpga_properties item that can be manipulated with fpgaPropertiesGet\u2026() and fpgaPropertiesSet\u2026(). For example, to set the AFU ID in a properties instance and to set that instance\u2019s type to FPGA_ACCELERATOR:</p> <pre><code>#define MY_AFU_ID \u201c8ad74241-d13b-48eb-b428-7986dcbcab14\u201d\nfilter-&gt;guid.parse(MY_AFU_ID);\nfilter-&gt;type = FPGA_ACCELERATOR;\n</code></pre> <p>Figure 53 C++ Properties Set GUID and Type</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#312-tokens","title":"3.1.2 Tokens","text":"<p>Class token provides the C++ implementation of the fpga_token type and its associated APIs. Class token also provides the enumerate() static member function:</p> <pre><code>std::vector&lt;token::ptr_t&gt; tokens = token::enumerate({filter});\nif (tokens.size() &lt; 1) {\n// flag error and return\n}\ntoken::ptr_t tok = tokens[0];\n</code></pre> <p>Figure 54 C++ Enumeration</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#313-handles","title":"3.1.3 Handles","text":"<p>Class handle provides the C++ implementation of the fpga_handle type and its associated APIs. The handle class provides member functions for opening and closing a token, for reading and writing to MMIO space, and for reconfiguring the FPGA\u2019s Programmable Region.</p> <pre><code>handle::ptr_t accel = handle::open(tok, 0);\n</code></pre> <p>Figure 55 C++ Opening a Handle</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#314-shared-memory","title":"3.1.4 Shared Memory","text":"<p>The shared_buffer class provides member functions for allocating and releasing DMA buffers, for querying buffer attributes, and for reading and writing buffers.</p> <pre><code>#define BUF_SIZE (2 * 1024 * 1024)\nshared_buffer::ptr_t input = shared_buffer::allocate(accel, BUF_SIZE);\nshared_buffer::ptr_t output = shared_buffer::allocate(accel, BUF_SIZE);\nstd::fill_n(input-&gt;c_type(), BUF_SIZE, 0xaf);\nstd::fill_n(output-&gt;c_type(), BUF_SIZE, 0xbe);\n</code></pre> <p>Figure 56 C++ Allocate and Init Buffers</p> <p></p> <p>Once DMA buffers have been allocated, their IO addresses are programmed into AFU-specific CSRs to enable the DMA. Here, the IO address of each buffer is aligned to the nearest cache line before programming it into the AFU CSR space. The number of cache lines is then programmed into the appropriate AFU CSR.</p> <pre><code>#define CSR_SRC_ADDR 0x000A // AFU-specific\n#define CSR_DEST_ADDR 0x000B // AFU-specific\n#define CSR_NUM_LINES 0x000C // AFU-specific\n#define LOG2_CL 6\naccel-&gt;write_csr64(CSR_SRC_ADDR, input-&gt;io_address() &gt;&gt; LOG2_CL);\naccel-&gt;write_csr64(CSR_DEST_ADDR, output-&gt;io_address() &gt;&gt; LOG2_CL);\naccel-&gt;write_csr32(CSR_NUM_LINES, BUF_SIZE / 64);\n</code></pre> <p>Figure 57 C++ Make the AFU Aware of DMA Buffers</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#315-events","title":"3.1.5 Events","text":"<p>The event class provides member functions for event registration. In order to register an event, provide the handle::ptr_t for the desired device, along with the event type and optional flags.</p> <pre><code>int vect = 2;\nevent::ptr_t evt = event::register_event(accel,\nFPGA_EVENT_INTERRUPT,\nvect);\nint evt_fd = evt.os_object();\n</code></pre> <p>Figure 58 C++ Event Registration</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#316-errors","title":"3.1.6 Errors","text":"<p>Class error provides a means of querying the device errors given a token::ptr_t. The token and integer ID provided to the error::get() static member function uniquely identify one of the 64-bit error masks associated with the token.</p> <pre><code>error::ptr_t err = error::get(tok, 0); </code></pre> <p>Figure 59 C++ Query Device Errors</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#317-sysobject","title":"3.1.7 SysObject","text":"<p>Class sysobject is the C++ implementation of the OPAE SysObject API. sysobject provides a means of creating class instances via its two sysobject::get() static member functions. A third non-static sysobject::get() enables creating a sysobject instance given a parent sysobject instance. The read64() and write64() member functions allow reading and writing the sysobject\u2019s value as a 64-bit unsigned integer. The bytes() member functions allow reading a sysobject\u2019s value as a raw byte stream.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#40-opae-python-api","title":"4.0 OPAE Python API","text":"<p>The OPAE Python API refers to a Python layer that sits on top of the OPAE C++ API, providing Python implementations of the OPAE C++ API abstractions: properties, tokens, handles, dma buffers, etc.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#41-_opae","title":"4.1 _opae","text":"<p>The Python API is coded as a pybind11 project, which allows C++ code to directly interface with Python internals. Each C++ API concept is encoded into a Python equivalent. The functionality exists as a Python extension module, compiled into _opae.so.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#411-enumeration","title":"4.1.1 Enumeration","text":"<p>Enumeration is somewhat simplified as compared to the OPAE C/C++ APIs. The fpga.enumerate() function accepts keyword arguments for each of the property names that are defined in the C++ API. As an example, to enumerate for an FPGA_ACCELERATOR by its GUID:</p> <pre><code>from opae import fpga\nMY_ACCEL = \u201cd573b29e-176f-4cb7-b810-efbf7be34cc9\u201d\ntokens = fpga.enumerate(type=fpga.ACCELERATOR, guid=MY_ACCEL)\nassert tokens, \u201cNo accelerator matches {}\u201d.format(MY_ACCEL)\n</code></pre> <p>Figure 60 Python Enumeration</p> <p></p> <p>The return value from the fpga.enumerate() function is a list of all the token objects matching the search criteria.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#412-properties","title":"4.1.2 Properties","text":"<p>Querying properties for a token or handle is also a bit different in the Python API. In order to query properties for one of these objects, pass the object to the fpga.properties() constructor. The return value is a properties object with each of the property names defined as instance attributes.</p> <pre><code>prop = fpga.properties(tokens[0])\nprint(f'0x{prop.vendor_id:04x} 0x{prop.device_id:04x}')\n</code></pre> <p>Figure 61 Python Get Token Properties</p> <p></p> <p>Properties objects may also be created by invoking the fpga.properties() constructor, passing the same keyword arguments as those to fpga.enumerate(). Properties objects created in this way are also useful for enumeration purposes:</p> <pre><code>props = fpga.properties(type=fpga.ACCELERATOR)\ntokens = fpga.enumerate([props])\n</code></pre> <p>Figure 62 Python Properties Constructor</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#413-tokens","title":"4.1.3 Tokens","text":"<p>Tokens overload both the __getitem__ and __getattr__ methods to enable the SysObject API. Both of the following are valid forms of accessing the \u2018errors/first_error\u2019 sysfs attribute, given a token object:</p> <pre><code>tok = tokens[0]\nferr = tok['errors/first_error']\nprint(f'first error: 0x{ferr.read64():0x}')\nprint('0x{:0x}'.format(tok.errors.first_error.read64()))\n</code></pre> <p>Figure 63 Python Tokens and SysObject API</p> <p></p> <p>Tokens also implement a find() method, which accepts a glob expression in order to search sysfs. The following example finds the \u201cid\u201d sysfs entry in the given token\u2019s sysfs tree.</p> <pre><code>my_id = tok.find(\u2018i?\u2019)\nprint(f'{my_id.read64()}')\n</code></pre> <p>Figure 64 Python Token Find</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#414-handles","title":"4.1.4 Handles","text":"<p>Tokens are converted to handles by way of the fpga.open() function. The flags (second) parameter to fpga.open() may be zero or fpga.OPEN_SHARED.</p> <pre><code>with fpga.open(tok, fpga.OPEN_SHARED) as handle:\nuse_the_handle(handle)\n</code></pre> <p>Figure 65 Python Open Handle</p> <p></p> <p>Like token objects, handle objects overload __getitem__ and __getattr__ methods to enable the SysObject API. handle also provides a find() method similar to token\u2019s find().</p> <pre><code>err = handle['errors/errors']\nprint(f'errors: 0x{err.read64():0x}')\nprint('first error: 0x{:0x}'.format(\nhandle.errors.first_error.read64()))\nmy_id = handle.find('i?')\nprint(f'{my_id.read64()}')\n</code></pre> <p>Figure 66 Python Handles and SysObject API</p> <p></p> <p>Partial reconfiguration is provided by class handle\u2019s reconfigure() method. The first parameter, slot, will be zero in most designs. The second parameter is an opened file descriptor to the file containing the GBS image. The third parameter, flags, defaults to zero.</p> <pre><code>with open(\u2018my.gbs\u2019, \u2018rb\u2019) as fd:\nhandle.reconfigure(0, fd)\n</code></pre> <p>Figure 67 Python Partial Reconfiguration</p> <p></p> <p>Device reset is accomplished by means of handle\u2019s reset() method, which takes no parameters.</p> <p>Finally for handles, CSR space reads are accomplished via read_csr32() and read_csr64(). Both methods accept the register offset as the first parameter and an optional csr_space index, which defaults to zero, as the second parameter. CSR space writes are accomplished via write_csr32() and write_csr64(). Both methods accept the register offset as the first parameter, the value to write as the second, and an optional csr_space index, which defaults to zero, as the third.</p> <pre><code>print(\u20190x{:0x}\u2019.format(handle.read_csr32(0x000a)))\nprint(\u20180x{:0x}\u2019.format(handle.read_csr64(0x000c)))\nhandle.write_csr32(0x000b, 0xdecafbad, 2)\nhandle.write_csr64(0x000e, 0xc0cac01adecafbad, 2)\n</code></pre> <p>Figure 68 Python Read/Write CSR</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#415-shared-memory","title":"4.1.5 Shared Memory","text":"<p>The fpga.allocate_shared_buffer() function provides access to the OPAE memory allocator. The allocation sizes and required huge page configurations are the same as those noted in 2.1.5 MMIO and Shared Memory.</p> <p>The fpga.allocate_shared_buffer() function returns an object instance of type shared_buffer. The shared_buffer class implements methods size(), wsid(), and io_address(), which return the buffer size in bytes, the unique workspace ID, and the IO address respectively:</p> <pre><code>buf = fpga.allocate_shared_buffer(handle, 4096)\nprint(f\u2019size: {buf.size()}\u2019)\nprint(f\u2019wsid: 0x{buf.wsid():0x}\u2019)\nprint(f\u2019io_address: 0x{buf.io_address():0x}\u2019)\n</code></pre> <p>Figure 69 Python Allocate Shared Memory</p> <p></p> <p>The shared_buffer class implements a fill() method which takes an integer parameter which is applied to each byte of the buffer (similar to C standard library\u2019s memset()). The compare() method compares the contents of the first size bytes of one buffer to another. The value returned from compare() is the same as the C standard library\u2019s memcmp(). The copy() method copies the first size bytes of the calling buffer into the argument buffer.</p> <pre><code>b0 = fpga.allocate_shared_buffer(handle, 4096)\nb1 = fpga.allocate_shared_buffer(handle, 4096)\nb0.fill(0xa5)\nb1.fill(0xa5)\nprint(f'compare: {b0.compare(b1, 4096)}')\nb1.fill(0xa0)\nb0.copy(b1, 4096)\nprint(f'compare: {b0.compare(b1, 4096)}')\n</code></pre> <p>Figure 70 Python Buffer Fill, Copy, Compare</p> <p></p> <p>shared_buffer\u2019s read32() and read64() methods read a 32- or 64-bit value from the given offset. The write32() and write64() methods write a 32- or 64-bit value to the given offset.</p> <pre><code>print(f'value at 0: 0x{b0.read32(0):0x}')\nprint(f'value at 4: 0x{b0.read64(4):0x}')\nb0.write32(0xabadbeef, 0)\nb0.write64(0xdecafbadabadbeef, 4)\nprint(f'value at 0: 0x{b0.read32(0):0x}')\nprint(f'value at 4: 0x{b0.read64(4):0x}')\n</code></pre> <p>Figure 71 Python Buffer Read and Write</p> <p></p> <p>The shared_buffer class provides three polling methods: poll(), poll32(), and poll64(). Each method takes an offset as its first parameter. The second parameter is a value and the third is a mask. The value and mask parameters are 8 bits wide for poll(), 32 bits wide for poll32(), and 64 bits wide for poll64(). The fourth and last parameter is a timeout value which defaults to 1000 microseconds.</p> <p>Each polling method reads the n-bit wide item at offset and applies (logical AND) the mask to that value. The masked value created in the previous step is then compared to the second parameter, value. If the two values are equal, then the method returns true immediately. Otherwise, the method continues to loop, attempting the same comparison over and over without sleeping. Finally, if the elapsed time from the beginning of the call to the current time is greater than or equal to the timeout value, then the method times out and returns false.</p> <pre><code>if b0.poll32(0, 0xbebebebe, 0xffffffff, 250):\nprint(\u2018Got it!\u2019)\n</code></pre> <p>Figure 72 Python Buffer Poll</p> <p></p> <p>The shared_buffer split() method allows creating two or more buffer objects from one larger buffer object. The return value is a list of shared_buffer instances whose sizes match the arguments given to split().</p> <pre><code>b1, b2 = b1.split(2048, 2048)\nprint(f'b1 io_address: 0x{b1.io_address():0x}')\nprint(f'b2 io_address: 0x{b2.io_address():0x}')\n</code></pre> <p>Figure 73 Python Splitting Buffer</p> <p></p> <p>Finally, the shared_buffer class implements the Python buffer protocol to support memoryview objects. The Python buffer protocol allows access to an object\u2019s underlying memory without copying that memory. As a brief example:</p> <pre><code>mv = memoryview(b1)\nassert mv\nassert mv[0] == 0xbe\nb1[15] = int(65536)\nassert struct.unpack('&lt;L', bytearray(b1[15:19]))[0] == 65536\n</code></pre> <p>Figure 74 Python memoryview</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#416-events","title":"4.1.6 Events","text":"<p>Given a handle and an event type, the fpga.register_event() function returns an object of type event. The event class implements one method, os_object(), which returns the underlying file descriptor that can be used to poll for the event:</p> <pre><code>import select\nevt = fpga.register_event(handle, fpga.EVENT_ERROR)\nos_object = evt.os_object()\nreceived_event = False\nepoll = select.epoll()\nepoll.register(os_object, select.EPOLLIN)\nfor fileno, ev in epoll.poll(1):\nif fileno == os_object:\nreceived_event = True\nprint(f'received: {received_event}')\n</code></pre> <p>Figure 75 Python Events</p> <p></p> <p>In addition to fpga.EVENT_ERROR, fpga.EVENT_INTERRUPT, and fpga.EVENT_POWER_THERMAL are also supported.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#417-errors","title":"4.1.7 Errors","text":"<p>Given a token, the fpga.errors() function returns a list of objects of type error. Each error instance represents a 64-bit mask of error values. The error bit masks are platform-dependent. Each error instance has two attributes: name and can_clear and one method: read_value() which returns the 64-bit error mask.</p> <pre><code>for e in fpga.errors(tok):\nprint(f\u2019name: \"{e.name}\"\u2019)\nprint(f\u2019can_clear: {e.can_clear}\u2019)\nprint(f\u2019value: {e.read_value()}\u2019)\n</code></pre> <p>Figure 76 Python Get Errors</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#418-sysobject","title":"4.1.8 SysObject","text":"<p>The Python API\u2019s SysObject implementation is introduced in 4.1.3 Tokens and 4.1.4 Handles. When the index operator (__getitem__) or attribute reference (__getattr__) is used and the referenced string or attribute name corresponds to a sysfs entry in the sysfs path of either a token or a handle, then an object of type sysobject is returned.</p> <p>The size() method returns the length of the sysfs entry in bytes. Note that a typical sysfs entry is terminated with a \u2018\\n\u2019 followed by the \u2018\\0\u2019 NULL terminator. The bytes() method returns the sysfs entry\u2019s value as a string.</p> <pre><code>afu_id = tok['afu_id']\nassert afu_id\nprint(f'size: {afu_id.size()} bytes: {afu_id.bytes().rstrip()}')\n</code></pre> <p>Figure 77 Python sysobject as Bytes</p> <p></p> <p>The sysobject read64() and write64() methods provide a means to read and write a sysfs entry\u2019s value as an unsigned 64-bit integer. The sysobject class itself also implements the __getitem__ and __getattr__ methods so that a sysobject of type FPGA_OBJECT_CONTAINER can retrieve sysobject instances for child sysfs entries.</p> <pre><code>errs = tok['errors']\nfirst = errs['first_error']\nassert first\nprint(f'first 0x{first.read64():0x}')\n</code></pre> <p>Figure 78 Python sysobject Container</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#50-management-interfaces-opaeadmin","title":"5.0 Management Interfaces - opae.admin","text":"<p>While the OPAE SDK C, C++, and Python APIs focus on presenting the AFU and all its related functionality to the end user, there is also a need for a maintenance functionality to aid in configuring the platform and performing secure firmware updates for the FPGA device and its components.  opae.admin is a Python framework which provides abstractions for performing these types of maintenance tasks on FPGA devices.  opae.admin provides Python classes which model the FPGA and the sysfs interfaces provided by the DFL drivers.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#51-sysfs","title":"5.1 sysfs","text":"<p>opae.admin\u2019s sysfs module provides abstractions for interacting with sysfs nodes, which comprise the base entity abstraction of opae.admin.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#511-sysfs_node","title":"5.1.1 sysfs_node","text":"<p>A sysfs_node is an object that tracks a unique path within a sysfs directory tree.  sysfs_node provides methods for finding and constructing other sysfs_node objects, based on the root path of the parent sysfs_node object.  sysfs_node also provides a mechanism to read and write sysfs file contents.  sysfs_node serves as the base class for many of the sysfs module\u2019s other classes.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#512-pci_node","title":"5.1.2 pci_node","text":"<p>A pci_node is a sysfs_node that is rooted at /sys/bus/pci/devices.  Each pci_node has a unique PCIe address corresponding to the PCIe device it represents.  Methods for finding the pci_node\u2019s children, for determining the PCIe device tree rooted at the node, for manipulating the node\u2019s PCIe address, for determining the vendor and device ID\u2019s, and for removing, unbinding, and rescanning the device are provided.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#513-sysfs_driver","title":"5.1.3 sysfs_driver","text":"<p>A sysfs_driver is a sysfs_node that provides a method for unbinding a sysfs_device object.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#514-sysfs_device","title":"5.1.4 sysfs_device","text":"<p>A sysfs_device is a sysfs_node that is located under /sys/class or /sys/bus.  sysfs_device provides the basis for opae.admin\u2019s FPGA enumeration capability.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#515-pcie_device","title":"5.1.5 pcie_device","text":"<p>A pcie_device is a sysfs_device that is rooted at /sys/bus/pci/devices.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#52-fpga","title":"5.2 fpga","text":"<p>opae.admin\u2019s fpga module provides classes which abstract an FPGA and its components.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#521-region","title":"5.2.1 region","text":"<p>A region is a sysfs_node that has an associated Linux character device, rooted at /dev.  Methods for opening the region\u2019s character device file and for interacting with the character device via its IOCTL interface are provided.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#522-fme","title":"5.2.2 fme","text":"<p>An fme is a region that represents an FPGA device\u2019s FME component.  An fme provides accessors for the PR interface ID, the various bus paths that may exist under an FME, and the BMC firmware revision information.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#523-port","title":"5.2.3 port","text":"<p>A port is a region that represents an FPGA device\u2019s Port component.  A port provides an accessor for the Port AFU ID.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#524-fpga_base","title":"5.2.4 fpga_base","text":"<p>An fpga_base is a sysfs_device that provides accessors for the FPGA device\u2019s FME, for the FPGA device\u2019s Port, and for the secure update sysfs controls.  fpga_base provides routines for enabling and disabling AER and for performing device RSU.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#525-fpga","title":"5.2.5 fpga","text":"<p>An fpga (derived from fpga_base) is the basis for representing the FPGA device in opae.admin.  Utilities such as fpgasupdate rely on fpga\u2019s enum classmethod to enumerate all of the FPGA devices in the system.  In order for a device to enumerate via this mechanism, it must be bound to the dfl-pci driver at the time of enumeration.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#53-opaeadmin-utilities","title":"5.3 opae.admin Utilities","text":"<p>Several utilities are written on top of opae.admin\u2019s class abstractions.  The following sections highlight some of the most commonly-used utilities.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#531-fpgasupdate","title":"5.3.1 fpgasupdate","text":"<p>fpgasupdate, or FPGA Secure Update, is used to apply firmware updates to the components of the FPGA.  As the name implies, these updates target a secure FPGA device, one that has the ability to implement a secure root of trust. The command-line interface to fpgasupdate was designed to be as simple as possible for the end user.  The command simply takes a path to the firmware update file to be applied and the PCIe address of the targeted FPGA device.</p> <pre><code># fpgasupdate update-file.bin 0000:b2:00.0\n</code></pre> <p>Figure 79 fpgasupdate Interface</p> <p></p> <p>fpgasupdate can apply a variety of firmware image updates. | Image| Description| | -----| -----| |Programmable Region Image| .gbs or Green BitStream| |SR Root Key Hash|  Static Region RKH| |PR Root Key Hash|  Programmable Region RKH| |FPGA Firmware Image|   Static Region Device Firmware| |PR Authentication Certificate| Programmable Region Auth Cert| |BMC Firmware Image|    Board Management Controller Firmware| |SR Thermal Image|  Static Region Thermal Sensor Thresholds| |PR Thermal Image|  Programmable Region Thermal Sensor Thresholds| |CSK Cancelation|   Code Signing Key Cancelation Request| |SDM Image| Secure Device Manager Firmware|</p> <p>Table 10 fpgasupdate Image Types</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#532-pci_device","title":"5.3.2 pci_device","text":"<p>pci_device is a utility that provides a convenient interface to some of the Linux Kernel\u2019s standard PCIe device capabilities.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5321-pci_device-aer-subcommand","title":"5.3.2.1 pci_device aer subcommand","text":"<p>The aer dump subcommand displays the Correctable, Fatal, and NonFatal device errors.</p> <pre><code># pci_device 0000:b2:00.0 aer dump\n</code></pre> <p>Figure 80 pci_device aer dump</p> <p></p> <p>The aer mask subcommand displays, masks, or unmasks errors using the syntax of the setpci command.</p> <pre><code># pci_device 0000:b2:00.0 aer mask show\n0x00010000 0x000031c1\n# pci_device 0000:b2:00.0 aer mask all\n# pci_device 0000:b2:00.0 aer mask off\n# pci_device 0000:b2:00.0 aer mask 0x01010101 0x10101010\n</code></pre> <p>Figure 81 pci_device aer mask</p> <p></p> <p>The aer clear subcommand clears the current errors.</p> <pre><code># pci_device 0000:b2:00.0 aer clear\naer clear errors: 00000000\n</code></pre> <p>Figure 82 pci_device aer clear</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5322-pci_device-unbind-subcommand","title":"5.3.2.2 pci_device unbind subcommand","text":"<p>The unbind subcommand unbinds the target device from the currently-bound device driver.</p> <pre><code># pci_device 0000:b2:00.0 unbind\n</code></pre> <p>Figure 83 pci_device unbind</p> <p></p> <p>In order to re-bind the device to a driver, eg dfl-pci, use the following commands:</p> <pre><code># cd /sys/bus/pci/drivers/dfl-pci\n# echo 0000:b2:00.0 &gt; bind\n</code></pre> <p>Figure 84 Re-binding a Driver</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5323-pci_device-rescan-subcommand","title":"5.3.2.3 pci_device rescan subcommand","text":"<p>The rescan subcommand triggers a PCIe bus rescan of all PCIe devices.</p> <pre><code># pci_device 0000:b2:00.0 rescan\n</code></pre> <p>Figure 85 pci_device rescan</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5324-pci_device-remove-subcommand","title":"5.3.2.4 pci_device remove subcommand","text":"<p>The remove subcommand removes the target device from Linux kernel management.</p> <pre><code># pci_device 0000:b2:00.0 remove\n</code></pre> <p>Figure 86 pci_device remove</p> <p></p> <p>Note: a reboot may be required in order to re-establish the Linux kernel management for the device.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5325-pci_device-topology-subcommand","title":"5.3.2.5 pci_device topology subcommand","text":"<p>The topology subcommand shows a tab-delimited depiction of the target device as it exists in the PCIe device tree in the Linux kernel.</p> <pre><code># pci_device 0000:b2:00.0 topology\n[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)\n[pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:b2:00.0), pci_id(0x8086, 0x0b30)] (dfl-pci)\n[pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)\n[pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n[pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n[pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)\n[pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n[pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n</code></pre> <p>Figure 87 pci_device topology</p> <p></p> <p>The green output indicates the target device.  The other endpoint devices are shown in blue.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5326-pci_device-vf-subcommand","title":"5.3.2.6 pci_device vf subcommand","text":"<p>The vf subcommand allows setting the value of the sriov_numvfs sysfs node of the target device.  This is useful in scenarios where device functionality is presented in the form of one or more PCIe Virtual Functions.</p> <pre><code># pci_device 0000:b2:00.0 vf 3\n# pci_device 0000:b2:00.0 vf 0\n</code></pre> <p>Figure 88 pci_device vf</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#533-rsu","title":"5.3.3 rsu","text":"<p>rsu is a utility that performs Remote System Update.  rsu is used subsequent to programming a firmware update or other supported file type with fpgasupdate, in order to reset the targeted FPGA entity so that a newly-loaded firmware image becomes active.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5331-rsu-bmc-subcommand","title":"5.3.3.1 rsu bmc subcommand","text":"<p>The bmc subcommand causes a Board Management Controller reset.  This command is used to apply a previous fpgasupdate of a BMC firmware image.  The --page argument selects the desired boot image.  Valid values for --page are \u2018user\u2019 and \u2018factory\u2019.</p> <pre><code># rsu bmc --page user 0000:b2:00.0\n# rsu bmc --page factory 0000:b2:00.0\n</code></pre> <p>Figure 89 rsu bmc</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5332-rsu-retimer-subcommand","title":"5.3.3.2 rsu retimer subcommand","text":"<p>The retimer subcommand causes a Parkvale reset (specific to Vista Creek).  This command is used to apply a previous fpgasupdate of a BMC firmware image (the Parkvale firmware is contained within the BMC firmware image).  The retimer subcommand causes only the Parkvale to reset.</p> <pre><code># rsu retimer 0000:b2:00.0\n</code></pre> <p>Figure 90 rsu retimer</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5333-rsu-fpga-subcommand","title":"5.3.3.3 rsu fpga subcommand","text":"<p>The fpga subcommand causes a reconfiguration of the FPGA Static Region.  This command is used to apply a previous fpgasupdate of the Static Region image.  The --page argument selects the desired boot image.  Valid values for --page are \u2018user1\u2019, \u2018user2\u2019, and \u2018factory\u2019.</p> <pre><code># rsu fpga --page user1 0000:b2:00.0\n# rsu fpga --page user2 0000:b2:00.0\n# rsu fpga --page factory 0000:b2:00.0\n</code></pre> <p>Figure 91 rsu fpga</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5334-rsu-sdm-subcommand","title":"5.3.3.4 rsu sdm subcommand","text":"<p>The sdm subcommand causes a reset of the Secure Device Manager.  This command is used to apply a previous fpgasupdate of the SDM image.</p> <pre><code># rsu sdm 0000:b2:00.0\n</code></pre> <p>Figure 92 rsu sdm</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#5335-rsu-fpgadefault-subcommand","title":"5.3.3.5 rsu fpgadefault subcommand","text":"<p>The fpgadefault subcommand can be used to display the default FPGA boot sequence; and it can be used to select the image to boot on the next reset of the FPGA. When given without additional parameters, the fpgadefault subcommand displays the default FPGA boot sequence:</p> <pre><code># rsu fpgadefault 0000:b2:00.0\n</code></pre> <p>Figure 93 rsu Displaying FPGA Boot Sequence</p> <p></p> <p>The parameters to the fpgadefault subcommand are --page and --fallback.  The --page parameter accepts \u2018user1\u2019, \u2018user2\u2019, or \u2018factory\u2019, specifying the desired page to boot the FPGA from on the next reset.  Note that this subcommand does not actually cause the reset to occur.  Please refer to rsu fpga subcommand for an example of resetting the FPGA using the rsu command.</p> <pre><code># rsu fpgadefault --page user1 0000:b2:00.0\n# rsu fpgadefault --page user2 0000:b2:00.0\n# rsu fpgadefault --page factory 0000:b2:00.0\n</code></pre> <p>Figure 94 rsu Select FPGA Boot Image</p> <p></p> <p>The --fallback parameter accepts a comma-separated list of the keywords \u2018user1\u2019, \u2018user2\u2019, and \u2018factory\u2019.  These keywords, in conjunction with the --page value are used to determine a fallback boot sequence for the FPGA. The fallback boot sequence is used to determine which FPGA image to load in the case of a boot failure.  For example, given the following command, the FPGA would attempt to boot in the order \u2018factory\u2019, \u2018user1\u2019, \u2018user2\u2019.  That is to say, if the \u2018factory\u2019 image failed to boot, then the \u2018user1\u2019 image would be tried.  Failing to boot \u2018user1\u2019, the \u2018user2\u2019 image would be tried.</p> <pre><code># rsu fpgadefault --page factory --fallback user1,user2 0000:b2:00.0\n</code></pre> <p>Figure 95 rsu Select FPGA Boot Image and Fallback</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#60-sample-applications","title":"6.0 Sample Applications","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#61-afu-test-framework","title":"6.1 afu-test Framework","text":"<p>afu-test refers to a test-writing framework that exists as a set of C++ classes written on top of the OPAE C++ bindings. The first class, afu, serves as the base class for the test application abstraction. Class afu provides integration with CLI11, a C++ \u201911 command-line parsing framework, and with spdlog, a C++ logging library. The second class, command represents a unique test sequence that is called by the afu object. Instances of the command class implement the test-specific workload.</p> <pre><code>class afu {\npublic:\nafu(const char *name,\nconst char *afu_id = nullptr,\nconst char *log_level = nullptr);\nint open_handle(const char *afu_id);\nint main(int argc, char *argv[]);\nvirtual int run(CLI::App *app, command::ptr_t test);\ntemplate&lt;class T&gt;\nCLI::App *register_command();\n};\n</code></pre> <p>Figure 96 C++ class afu</p> <p></p> <p>The afu class constructor initializes the CLI11 command parser with some general, application-wide parameters.</p> Subcommand Description -g,--guid Accelerator AFU ID. -p,--pci-address Address of the accelerator device. -l,--log-level Requested spdlog output level. -s,--shared Open the AFU in shared mode? -t,--timeout Application timeout in milliseconds. <p>Figure 97 class afu Application Parameters</p> <p></p> <p>The register_command() member function adds a test command instance to the afu object. Each test command that an afu object is capable of executing is registered during the test\u2019s startup code. For instance, here is the hssi application\u2019s use of register_command():</p> <pre><code>hssi_afu app;\nint main(int argc, char *argv[])\n{\napp.register_command&lt;hssi_10g_cmd&gt;();\napp.register_command&lt;hssi_100g_cmd&gt;();\napp.register_command&lt;hssi_pkt_filt_10g_cmd&gt;();\napp.register_command&lt;hssi_pkt_filt_100g_cmd&gt;();\n\u2026\napp.main(argc, argv);\n}\n</code></pre> <p>Figure 98 hssi's app.register_command()</p> <p></p> <p>Next, the afu instance\u2019s main() member function is called. main() initializes the spdlog instance, searches its database of registered commands to find the command matching the test requested from the command prompt, uses the open_handle() member function to enumerate for the requested AFU ID, and calls its run() member function, passing the CLI::App and the test command variables. The run() member function initializes a test timeout mechanism, then calls the command parameter\u2019s run() to invoke the test-specific logic.</p> <p>With all the boiler-plate of application startup, configuration, and running handled by the afu class, the test-specific command class is left to implement only a minimum number of member functions:</p> <pre><code>class command {\npublic:\nvirtual const char *name() const = 0;\nvirtual const char *description() const = 0;\nvirtual int run(afu *afu, CLI::App *app) = 0;\nvirtual void add_options(CLI::App *app) { }\nvirtual const char *afu_id() const { return nullptr; }\n};\n</code></pre> <p>Figure 99 class command</p> <p></p> <p>The name() member function gives the unique command name. Some examples of names from the hssi app are hssi_10g, hssi_100g, pkt_filt_10g, and pkt_filt_100g. The description() member function gives a brief description that is included in the command-specific help output. add_options() adds command-specific command-line options. afu_id() gives the AFU ID for the command, in string form. Finally, run() implements the command-specific test functionality.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#62-afu-test-based-samples","title":"6.2 afu-test Based Samples","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#621-dummy_afu","title":"6.2.1 dummy_afu","text":"<p>The dummy_afu application is a afu-test based application that implements three commands: mmio, ddr, and lpbk.</p> Target Description # dummy_afu mmio Targets special scratchpad area implemented by the AFU. # dummy_afu ddr Execute dummy_afu-specific DDR test. # dummy_afu lpbk Execute a simple loopback test. <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#622-host_exerciser","title":"6.2.2 host_exerciser","text":"<p>host_exerciser markdown document.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#623-hssi","title":"6.2.3 hssi","text":"<p>hssi markdown document.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#70-other-utilities","title":"7.0 Other Utilities","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#71-opaeio","title":"7.1 opae.io","text":"<p>opae.io markdown document.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#72-bitstreaminfo","title":"7.2 bitstreaminfo","text":"<p>The bitstreaminfo command prints diagnostic information about firmware image files that have been passed through the PACSign utility. PACSign prepends secure block 0 and secure block 1 data headers to the images that it processes. These headers contain signature hashes and other metadata that are consumed by the BMC firmware during a secure update.</p> <p>To run bitstreaminfo, pass the path to the desired firmware image file:</p> <pre><code># bitstreaminfo my_file.bin \n</code></pre> <p>Figure 100 Running bitstreaminfo</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#73-fpgareg","title":"7.3 fpgareg","text":"<p>The fpgareg command prints the register spaces for the following fpga device components:</p> Command Description # fpgareg 0000:b1:00.0 pcie Walks and prints the DFL for the device. # fpgareg 0000:b1:00.0 bmc Prints the BMC registers for the device. # fpgareg 0000:b1:00.0 hssi Prints the HSSI registers for the device. # fpgareg 0000:b1:00.0 acc Prints the AFU register spaces. <p>Figure 101 fpgareg Commands</p> <p></p> <p>Note that fpgareg is only available as of Arrow Creek ADP and forward. It will not work with prior platforms, eg N3000.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#74-opaevfio","title":"7.4 opaevfio","text":"<p>opaevfio markdown document.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#80-building-opae","title":"8.0 Building OPAE","text":"<p>The OPAE SDK uses the cmake build and configuration system, version &gt;= 3.10. The basic steps required to build the SDK from source are:</p> <p>Install prerequisite packages.</p> <pre><code>$ git clone &lt;https://github.com/OFS/opae-sdk.git&gt;\n$ cd opae-sdk\n$ mkdir build\n$ cd build\n$ cmake .. &lt;cmake options&gt;\n$ make\n</code></pre> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#81-installing-prerequisite-packages","title":"8.1 Installing Prerequisite Packages","text":"<p>The OPAE SDK is intended to build and run on modern Linux distributions. The SDK contains a set of system configuration scripts to aid the system configuration process.</p> Script Target Operating System centos.sh CentOS 8.x fedora.sh Fedora 33/34 ubuntu.sh Ubuntu 20.04 LTS <p>Table 11 System Configuration Scripts</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#82-cloning-the-sdk-repository","title":"8.2 Cloning the SDK repository","text":"<pre><code>$ git clone https://github.com/OFS/opae-sdk.git\n</code></pre>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#83-cmake-options","title":"8.3 CMake Options","text":"Option Description Values Default -DCMAKE_BUILD_TYPE Configure debugging info <p>Debug</p> <p>Release</p> <p>Coverage</p> <p>RelWithDebInfo</p> RelWithDebInfo -DCMAKE_INSTALL_PREFIX Root install path /usr/local -DOPAE_BUILD_SPHINX_DOC Enable/Disable docs ON/OFF OFF -DOPAE_BUILD_TESTS Enable/Disable unit tests ON/OFF OFF -DOPAE_ENABLE_MOCK Enable/Disable mock driver for unit tests ON/OFF OFF -DOPAE_INSTALL_RPATH Enable/Disable rpath for install ON/OFF OFF -DOPAE_VERSION_LOCAL Local version string -DOPAE_PRESERVE_REPOS Preserve local changes to external repos? ON/OFF OFF -D OPAE_BUILD_LIBOPAE_CXX Enable C++ bindings ON/OFF ON -DOPAE_WITH_PYBIND11 Enable pybind11 ON/OFF ON -D OPAE_BUILD_PYTHON_DIST Enable Python bindings ON/OFF OFF -DOPAE_BUILD_LIBOPAEVFIO Build libopaevfio.so ON/OFF ON -D OPAE_BUILD_PLUGIN_VFIO Build libopae-v.so ON/OFF ON -DOPAE_BUILD_LIBOPAEUIO Build libopaeuio.so ON/OFF ON -DOPAE_BUILD_LIBOFS Build OFS Copy Engine ON/OFF ON -DOPAE_BUILD_SAMPLES Build Samples ON/OFF ON -DOPAE_BUILD_LEGACY Build legacy repo ON/OFF OFF -DOPAE_LEGACY_TAG Specify legacy build tag master -DOPAE_WITH_CLI11 Enable apps which use CLI11 ON/OFF ON -DOPAE_WITH_SPDLOG Enable apps which use spdlog ON/OFF ON -DOPAE_WITH_LIBEDIT Enable apps which use libedit ON/OFF ON -DOPAE_WITH_HWLOC Enable apps which use hwloc ON/OFF ON -DOPAE_WITH_TBB Enable apps which use Thread Building Blocks ON/OFF ON -DOPAE_MINIMAL_BUILD Enable/Disable minimal build. When set to ON, disable CLI11, spdlog, libedit, hwloc, tbb ON/OFF OFF <p>Table 12 CMake Options</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#84-building-opae-for-debug","title":"8.4 Building OPAE for Debug","text":"<pre><code>$ cmake .. -DCMAKE_BUILD_TYPE=Debug\n</code></pre>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#85-creating-rpms","title":"8.5 Creating RPMs","text":"<p>To ease the RPM creation process, the OPAE SDK provides a simple RPM creation script. The parameters to the RPM create script are fedora or rhel, depending on which distribution is targeted. For rhel, the build flag -DOPAE_MINIMAL_BUILD is set to ON, omitting the binaries which have dependencies on external components that RHEL does not include in its base repositories.</p> <p>In order to create RPMs for Fedora, run the create script on a system loaded with all the Fedora build prerequisites. If prerequisites are missing, the create script will complain until they are resolved.</p> <p>In order to create RPMs for RHEL, run the create script on a system loaded with all the RHEL build prerequisites. If prerequisites are missing, the create script will complain until they are resolved.</p> <pre><code>$ cd opae-sdk\n$ ./packaging/opae/rpm/create fedora\n-OR-\n$ ./packaging/opae/rpm/create rhel\n</code></pre> <p> Figure 102 RPM Creation</p> <p></p> <p>After running the create script, the RPM files will be located in the packaging/opae/rpm directory.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#851-updating-the-rpm-version-information","title":"8.5.1 Updating the RPM Version Information","text":"<p>The RPMs will be versioned according to the information found in the file packaging/opae/version. Edit this file to update the version information, then re-run the create script to create the RPMs.</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#90-debugging-opae","title":"9.0 Debugging OPAE","text":""},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#91-enabling-debug-logging","title":"9.1  Enabling Debug Logging","text":"<p>The OPAE SDK has a built-in debug logging facility.  To enable it, set the cmake flag <code>-DCMAKE_BUILD_TYPE=Debug</code> and then use the following environment variables: | Variable| Description| | ----- | ----- | |LIBOPAE_LOG=1| Enable debug logging output.  When not set, only critical error messages are displayed.| |LIBOPAE_LOGFILE=file.log|  Capture debug log output to file.log.  When not set, the logging appears on stdout and stderr.  The file must appear in a relative path or it can be rooted at /tmp.|</p> <p> Table 13 Logging Environment Variables</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#92-gdb","title":"9.2 GDB","text":"<p>To enable gdb-based debugging, the cmake configuration step must specify a value for -DCMAKE_BUILD_TYPE of either Debug or RelWithDebInfo so that debug symbols are included in the output binaries. The OPAE SDK makes use of dynamically-loaded library modules.  When debugging with gdb, the best practice is to remove all OPAE SDK libraries from the system installation paths to ensure that library modules are only loaded from the local build tree:</p> <pre><code>$ cd opae-sdk/build\n$ LD_LIBRARY_PATH=$PWD/lib gdb --args &lt;some_opae_executable&gt; &lt;args&gt;\n</code></pre> <p>Figure 103 Debugging with GDB</p> <p></p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#100-adding-new-device-support","title":"10.0 Adding New Device Support","text":"<p>As of OPAE 2.2.0 the SDK has transitioned to a single configuration file model.  The libraries, plugins, and applications obtain their runtime configuration during startup by examining a single JSON configuration file.  In doing so, the original configuration file formats for libopae-c and fpgad have been deprecated in favor of the respective sections in the new configuration file. </p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#101-configuration-file-search-order","title":"10.1 Configuration File Search Order","text":"<p>By default the OPAE SDK will install its configuration file to /etc/opae/opae.cfg. </p> <pre><code>/etc/opae/opae.cfg </code></pre> <p>Figure 104 Default Configuration File</p> <p></p> <p>The SDK searches for the configuration file during startup by employing the following search algorithm: </p> <p>First, the environment variable LIBOPAE_CFGFILE is examined.  If it is set to a path that represents a valid path to a configuration file, then that configuration file path is used, and the search is complete. </p> <p>Next, the HOME environment variable is examined.  If its value is valid, then it is prepended to the following set of relative paths.  If HOME is not set, then the search continues with the value of the current user\u2019s home path as determined by getpwuid().  The home path, if any, determined by getpwuid() is prepended to the following set of relative paths.  Searching completes successfully if any of these home-relative search paths is valid. </p> <pre><code>/.local/opae.cfg /.local/opae/opae.cfg /.config/opae/opae.cfg </code></pre> <p>Figure 105 HOME Relative Search Paths</p> <p></p> <p>Finally, the configuration file search continues with the following system-wide paths.  If any of these paths is found to contain a configuration file, then searching completes successfully. </p> <pre><code>usr/local/etc/opae/opae.cfg /etc/opae/opae.cfg </code></pre> <p>Figure 106 System Search Paths</p> <p></p> <p>If the search exhausts all of the possible configuration file locations without finding a configuration file, then an internal default configuration is used.  This internal default configuration matches that of the opae.cfg file shipped with the OPAE SDK. </p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#102-configuration-file-format","title":"10.2 Configuration File Format","text":"<p>The OPAE SDK configuration file is stored in JSON formatted text.  The file has two main sections: \u201cconfigs\u201d and \u201cconfigurations\u201d.  The \u201cconfigs\u201d section is an array of strings.  Each value in the \u201cconfigs\u201d array is a key into the data stored in the \u201cconfigurations\u201d section.  If a key is present in \u201cconfigs\u201d, then that key is searched for and processed in \u201cconfigurations\u201d.  If the key is not found in \u201cconfigs\u201d, then that section of \u201cconfigurations\u201d will not be processed, irrespective of whether it exists in \u201cconfigurations\u201d. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... } }, \u201cconfigs\u201d: [ \u201cc6100\u201d ] } </code></pre> <p>Figure 107 Keyed Configurations</p> <p></p> <p>Each keyed section in \u201cconfigurations\u201d has four top-level entries: \u201cenabled\u201d, \u201cplatform\u201d, \u201cdevices\u201d, \u201copae\u201d. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { \u201cenabled\u201d: true, \u201cplatform\u201d: \u201cIntel Acceleration Development Platform C6100\u201d, \u201cdevices\u201d: [ { \u201cname\u201d: \u201cc6100_pf\u201d, \u201cid\u201d: [ ... ] }, { \u201cname\u201d: \u201cc6100_vf\u201d, \u201cid\u201d: [ ... ] } ], \u201copae\u201d: { ... } } }, } </code></pre> <p>Figure 108 Configurations Format</p> <p></p> <p>The \u201cenabled\u201d key holds a Boolean value.  If the value is false or if the \u201cenabled\u201d key is omitted, then that configuration is skipped when parsing the file.  The \u201cplatform\u201d key holds a string that identifies the current configuration item as a product family.  The \u201cdevices\u201d key contains the device descriptions. </p> <p>\u201cdevices\u201d is an array of objects that contain a \u201cname\u201d and an \u201cid\u201d key.  The \u201cname\u201d is a shorthand descriptor for a device PF or VF.  The value of \u201cname\u201d appears elsewhere in the current \u201cconfigurations\u201d section in order to uniquely identify the device.  \u201cid\u201d is an array of four strings, corresponding to the PCIe Vendor ID, Device ID, Subsystem Vendor ID, and Subsystem Device ID of the device.  The entries corresponding to Vendor ID and Device ID must contain valid 16-bit hex integers.  The entries corresponding to Subsystem Vendor ID and Subsystem Device ID may be 16-bit hex integers or the special wildcard string \u201c*\u201d, which indicates a don\u2019t care condition. </p> <p>The remaining sections in this chapter outline the format of the \u201copae\u201d configurations key. </p> <p>\u201cplugin\u201d: libopae-c and libopae-v </p> <p>The \u201cplugin\u201d key in the \u201copae\u201d section of a configuration is an array of OPAE SDK plugin configuration data.  Each item in the array matches one or more PF or VF devices to a plugin library module. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201cplugin\u201d: [ { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibxfpga.so\u201d, \u201cdevices\u201d: [ \u201cc6100_pf\u201d ], \u201cconfiguration\u201d: {} }, { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibopae-v.so\u201d, \u201cdevices\u201d: [ \u201cc6100_pf\u201d, \u201cc6100_vf\u201d ], \u201cconfiguration\u201d: {} } ], } } }, } </code></pre> <p>Figure 109 \"opae\" / \"plugin\" key/</p> <p></p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cplugin\u201d array entry is skipped, and parsing continues.  The \u201cmodule\u201d key is a string that identifies the desired plugin module library for the entry.  The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.  The \u201cconfiguration\u201d key of the \u201cplugin\u201d section specifies a unique plugin-specific configuration.  Currently, libopae-c and libopae-v use no plugin-specific config, so these keys are left empty. </p> <p>\u201cfpgainfo\u201d: fpgainfo application </p> <p>The \u201cfpgainfo\u201d key in the \u201copae\u201d section of a configuration is an array of fpgainfo plugin configuration data.  Each item in the array matches one or more PF or VF devices to an fpgainfo plugin library module. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201cfpgainfo\u201d: [ { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibboard_c6100.so\u201d, \u201cdevices\u201d: [ { \u201cdevice\u201d: \u201cc6100_pf\u201d, \u201cfeature_id\u201d: \u201c0x12\u201d }, { \u201cdevice\u201d: \u201cc6100_vf\u201d, \u201cfeature_id\u201d: \u201c0x12\u201d } ] } ], } } }, } </code></pre> <p>Figure 110 \"opae\" / \"fpgainfo\" key</p> <p></p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cfpgainfo\u201d array entry is skipped, and parsing continues.  The \u201cmodule\u201d key is a string that identifies the desired fpgainfo module library for the entry.  Each \u201cdevices\u201d array entry gives a PF/VF identifier in its \u201cdevice\u201d key and a DFL feature ID in its \u201cfeature_id\u201d key. </p> <p>\u201cfpgad\u201d: fpgad daemon process </p> <p>The \u201cfpgad\u201d key in the \u201copae\u201d section of a configuration is an array of fpgad plugin configuration data.  Each item in the array matches one or more PF or VF devices to an fpgad plugin library module. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201cfpgad\u201d: [ { \u201cenabled\u201d: true, \u201cmodule\u201d: \u201clibfpgad-vc.so\u201d, \u201cdevices\u201d: [ \u201cc6100_pf\u201d ], \u201cconfiguration\u201d: { ... } } ], } } }, } </code></pre> <p>Figure 111 \"opae\" / \"fpgad\" key </p> <p></p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cfpgad\u201d array entry is skipped, and parsing continues.  The \u201cmodule\u201d key is a string that identifies the desired fpgad plugin module library for the entry.  The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.  The \u201cconfiguration\u201d key of the \u201cfpgad\u201d section specifies a unique plugin-specific configuration. </p> <p>\u201crsu\u201d: rsu script </p> <p>The \u201crsu\u201d key in the \u201copae\u201d section of a configuration is an array of rsu script configuration data.  Each item in the array matches one or more PF devices to an rsu configuration. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201crsu\u201d: [ { \u201cenabled\u201d: true, \u201cdevices\u201d: [ \u201cc6100_pf\u201d ], \u201cfpga_default_sequences\u201d: \u201ccommon_rsu_sequences\u201d } ], } } }, \u201ccommon_rsu_sequences\u201d: [ ... ] } </code></pre> <p>Figure 112 \"opae\" / \"rsu\" key  </p> <p></p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201crsu\u201d array entry is skipped, and parsing continues.  When disabled, the device(s) mentioned in that array entry will not be available for the rsu command. The \u201cdevices\u201d array lists one or more PF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.  The \u201cfpga_default_sequences\u201d key of the \u201crsu\u201d section specifies a JSON key.  The configuration searches for that JSON key at the global level of the configuration file, and when found applies its value as the valid set of fpga boot sequences that can be used with the rsu fpgadefault subcommand. </p> <p><code>C \u201cfpgareg\u201d: fpgareg script</code></p> <p>The \u201cfpgareg\u201d key in the \u201copae\u201d section of a configuration is an array of fpgareg script configuration data.  Each item in the array matches one or more PF/VF devices to an fpgareg configuration. </p> <p>```C { </p> <p>\u201cconfigurations\u201d: { </p> <pre><code>\u201cc6100\u201d: {\n\n  ...\n\n  \u201copae\u201d: {\n\n    \u201cfpgareg\u201d: [\n\n      {\n\n        \u201cenabled\u201d: true,\n\n        \u201cdevices\u201d: [ \u201cc6100_pf\u201d, \u201cc6100_vf\u201d ]\n\n      }\n\n    ],\n\n  }\n\n}\n</code></pre> <p>}, </p> <p>}   ```</p> <p>Figure 113 \"opae\" / \"fpgareg\" key   </p> <p></p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201cfpgareg\u201d array entry is skipped, and parsing continues.  When disabled, the device(s) mentioned in that array entry will not be available for the fpgareg command. The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.   </p> <pre><code>\u201copae.io\u201d: opae.io application </code></pre> <p>The \u201copae.io\u201d key in the \u201copae\u201d section of a configuration is an array of opae.io configuration data.  Each item in the array matches one or more PF/VF devices to an opae.io platform string. </p> <pre><code>{ \u201cconfigurations\u201d: { \u201cc6100\u201d: { ... \u201copae\u201d: { \u201copae.io\u201d: [ { \u201cenabled\u201d: true, \u201cdevices\u201d: [ \u201cc6100_pf\u201d, \u201cc6100_vf\u201d ] } ], } } }, } </code></pre> <p>Figure 114 \"opae\" / \"opae.io\" key    </p> <p></p> <p>If the \u201cenabled\u201d key is false or if it is omitted, then that \u201copae.io\u201d array entry is skipped, and parsing continues.  When disabled, the device(s) mentioned in that array entry will continue to be available for the opae.io command.  The device(s) platform string will not be shown in the <code>opae.io ls</code> command.  The \u201cdevices\u201d array lists one or more PF/VF identifiers.  Each array value must be a string, and it must match a device that is described in the \u201cconfigurations\u201d \u201cdevices\u201d section.   </p> <p>Libxfpga \u2013 Updating the Metrics API </p> <p>Edit libraries/plugins/xfpga/sysfs.c.  Find the definition of the opae_id_to_hw_type() function.  Update the function to add the new vendor/device ID to hw_type mapping. </p> <p>This mapping is used by the SDK\u2019s metrics API to determine the method of accessing the board sensor information and is very specific to the underlying BMC implementation.  It may be necessary to add a new hw_type value and to update the logic in libraries/plugins/xfpga/metrics. </p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#110-dfl-linux-kernel-drivers","title":"11.0 DFL Linux Kernel Drivers","text":"<p>OFS DFL driver software provides the bottom-most API to FPGA platforms. Libraries such as OPAE and frameworks such as DPDK are consumers of the APIs provided by OFS. Applications may be built on top of these frameworks and libraries. The OFS software does not cover any out-of-band management interfaces. OFS driver software is designed to be extendable, flexible, and provide for bare-metal and virtualized functionality.</p> <p>The OFS driver software can be found in theOFS repository - linux-dfl, under the linux-dfl specific category. This repository has an associated OFS repository - linux-dfl - wiki page that includes the following information: - An description of the three available branch archetypes - Configuration tweaks required while building the kernel - A functional description of the available DFL framework - Descriptions for all currently available driver modules that support FPGA DFL board solutions - Steps to create a new DFL driver - Steps to port a DFL driver patch</p> <p></p>"},{"location":"hw/common/reference_manual/ofs_sw/mnl_sw_ofs/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others.   </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/","title":"Accelerator Functional Unit Developer Guide: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae","text":""},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#1-introduction","title":"1. Introduction","text":"<p>This document is a design guide for creating an Accelerator Functional Unit (AFU) using Open FPGA Stack (OFS) for Intel\u00ae Stratix 10\u00ae FPGA. The AFU concept consists of separating the FPGA design development process into two parts, the FIM and AFU, as shown in the diagram below:</p> <p> </p> <p>This diagram shows the FPGA board interface development separation from the internal FPGA workload creation. This separation starts with the FPGA Interface Manager (FIM), which consists of the external interfaces and board management functions. The FIM is the base system layer typically provided by board vendors. The FIM interface is specific to a particular physical platform. The AFU uses the external interfaces with user-defined logic to perform a specific application. Separating the lengthy and complicated process of developing and integrating external interfaces for an FPGA into a board allows the AFU developer to focus on their workload needs.  Intel\u00ae OFS for Intel\u00ae Stratix 10\u00ae FPGA provides the following tools for rapid AFU development:</p> <ul> <li>Scripts for both compilation setup</li> <li>Integration with Open Programmable Acceleration Engine (OPAE) SDK for rapid software development for your AFU application</li> </ul> <p>Please notice that the AFU region consists of both static and PR logic in the above block diagram. Creating AFU logic for the static region is described in Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae . This guide covers logic in the AFU Main (PR) region.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#11-document-organization","title":"1.1 Document Organization","text":"<p> This document is organized as follows:</p> <ul> <li>Description of design flow</li> <li>Interfaces and functionality provided in the Intel\u00ae FPGA PAC D5005 FIM</li> <li>Downloading and installing Intel\u00ae OFSand OPAE SDK</li> <li>Hardware/Software co-simulation using ASE</li> <li>Testing the AFU example in Intel\u00ae FPGA PAC D5005</li> <li>Debugging an AFU with Remote Signal Tap</li> </ul> <p>This guide provides theory followed by tutorial steps to solidify your AFU development knowledge.</p> <p>This guide uses the Intel\u00ae FPGA PAC D5005 as the platform for all tutorial steps. Additionally, this guide and the tutorial steps can be used with other platforms; However, please consult the board and FIM supplier of other platforms for specific instructions on the use of custom FIM to develop  AFU design.</p> <p>If you have worked with previous Intel\u00ae Programmable Acceleration products, you will find OFS for Intel\u00ae Stratix 10\u00ae FPGA is similar; however, there are differences, and you are advised to carefully read and follow the tutorial steps to understand the design tools and flow fully.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#glossary","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#12-prerequisite","title":"1.2 Prerequisite","text":"<p> This guide assumes you understand the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows, including the  Intel\u00ae Quartus\u00ae Prime Pro Edition design flow.</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in  Intel\u00ae Quartus\u00ae Prime Pro Edition software, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on critical timing paths.</li> <li>RTL and coding practices to create synthesized logic.</li> <li>High-level synthesis (HLS) and Platform Designer design entry tools are supported.</li> <li>RTL simulation tools.</li> <li>Signal Tap Logic Analyzer tool in the  Intel\u00ae Quartus\u00ae Prime Pro Edition software.</li> </ul>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#121-development-environment","title":"1.2.1 Development Environment","text":"<p> To run the tutorial steps in this guide requires this development environment:</p> Item Version Operating System RHEL 8.2 Python 3.7.7 cmake 3.11.4 GCC 7.2.0 git 1.8.3.1 perl 5.8.8 <p>Verify your development has the above tools installed.</p> <p>The following server and Intel\u00ae PAC card are required to run the examples in this guide:</p> <ol> <li>Intel\u00ae FPGA PAC D5005 with root entry hash erased (Please contact Intel\u00ae for root entry hash erase instructions). The standard Intel\u00ae FPGA PAC D5005 card is programmed only to allow the FIM binary files signed by Intel\u00ae to be loaded. The root entry hash erases process will allow unsigned FIM binary files to be loaded.</li> <li>Qualified Server Models see Qualified Servers.</li> <li>Intel\u00ae FPGA PAC D5005 installed in the qualified server following instructions in OFS Getting Started User Guide</li> </ol>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#13-acceleration-functional-unit-afu-development-flow","title":"1.3 Acceleration Functional Unit (AFU) Development Flow","text":"<p>OFS Stack provides a rapid design methodology for creating complex FPGA applications. In addition, you are provided with the following:</p> <ul> <li>Hardware shell layer, known as FIM </li> <li>Software stack including tools for debug/diagnostics</li> <li>FPGA design flow  with full-stack simulation support</li> <li>AFU code samples demonstrating all interfaces</li> </ul> <p>For any non-Intel\u00ae platform, contact your board vendor for the above components specific to the platform. To start with AFU development, the first step should be to understand your platform capabilities. For example, what interface is the FPGA connected to the Host machine over PCI-E, if it is AXI like the Intel\u00ae Stratix 10\u00ae FPGA Platform, or CCIP or CXL. Does the platform provide an External Memory Interface or the HSSI interface? Once you know what the platform offers, you can develop your AFU requirements and architecture as the next step.  This document will cover example AFU architecture and things that will help build AFU for Intel\u00ae Stratix 10\u00ae FPGA reference platform and others coming in the future. In addition, this knowledge can be relatively applied for AFU development on other vendor-provided platforms.</p> <p>The figure below shows a typical AFU development process independent of the platform used. </p> <p></p> <pre><code>flowchart  TB;\n    A[Understand platform capabilities with OFS]--&gt;B[Review AFU requirements and code samples provided];\n    B[Review AFU requirements and code samples provided]--&gt;C[Define AFU architecture];\n    C[Define AFU architecture]--&gt;D[Design AFU hardware];\n    D[Design AFU hardware]--&gt;E[Develop AFU software to control hardware];\n    E[Develop AFU software to control hardware]--&gt;F{\"Simulate in AFU Simulation Enviroment (ASE)\"};\n    F:::if -- Pass --&gt; H[\"Compile AFU for synthesis, place &amp; route and timing (uses Quartus)\"];\n    H[\"Compile AFU for synthesis, place &amp; route and timing (uses Quartus)\"] --&gt; I[\"Analyze Quartus Compile reports\"];\n    I --&gt; J{\"Quartus reports clean? (e.g. timing closed)\"};\n    J:::if -- No --&gt; P2;\n    J -- Yes --&gt; K[\"Run/Validate design on OFS Platform\"];\n    K --&gt; L{\"Hardware validation pass?\"};\n    L == Yes ==&gt; M[\"AFU ready to deploy\"];\n    L -- No --&gt; N[\"Debug on hardware using traditional FPGA tools (e.g. SignalTab\"];\n    N --&gt; P2[\"Fix AFU design (e.g Design changes, timing closure constraints)\"];\n    P2 --&gt; O{\"Need functional validation?\"};\n    O:::if -- Yes --&gt;P[\"Fix AFU design (e.g Functional design changes, bug fixes)\"];\n    O -- No --&gt;H;    \n    F -- Fail --&gt; P;\n    P --&gt;D;      \n\n    classDef default color:#fff,fill:#0071c5,stroke:#71c5,stroke-width:1px\n    classDef if color:#0071c5,fill:#fff,stroke:#0071c5,stroke-width:2px</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#131-high-level-data-flow","title":"1.3.1. High Level Data Flow","text":"<p>The OFShigh-level data flow is shown below:  The control and data are composed of the following:</p> <ul> <li>Host Interface Adapter (PCIe)</li> <li>Low-Performance Peripherals</li> <li>Slow speed peripherals (I2C, Smbus, etc)</li> <li> <p>Management peripherals (FME)</p> </li> <li> <p>High-Performance Peripherals</p> </li> <li>Memory peripherals</li> <li>Acceleration Function peripherals</li> <li> <p>HPS Peripheral</p> </li> <li> <p>Fabrics</p> </li> <li>Peripheral Fabric (multi-drop)</li> <li>AFU Streaming fabric (point to point)</li> </ul> <p>Peripherals are connected using AXI or Avalon:</p> <ul> <li>Via the peripheral fabric (AXI4-Lite, multi-drop)</li> <li>Via the AFU streaming fabric (AXI-S, point to point)</li> </ul> <p>Peripherals are presented to software as:</p> <ul> <li>OFS managed peripherals that implement DFH CSR structure.  </li> <li>Native driver managed peripherals (i.e., Exposed via an independent PF, VF)</li> </ul> <p>The peripherals connected to the peripheral fabric are primarily OPAE managed resources, whereas the peripherals connected to the AFU are \"primarily\" driven by native OS drivers. The word \"primarily\" is used since the AFU is not mandated to expose all its peripherals to Intel\u00ae OPAE. Instead, it can be connected to the peripheral fabric but can choose to expose only a subset of its capability to OPAE.</p> <p>OFS uses a defined set of CSRs to expose the functionality of the FPGA to the host software. These registers are described in Open FPGA Stack Reference Manual - MMIO Regions section.</p> <p>If you make changes to the FIM that affect the software operation, Intel\u00ae OFS provides a mechanism to communicate that information to the proper software driver. The Device Feature Header (DFH) structure provides a mechanism to maintain compatibility with OPAE software. Please see FPGA Device Feature List (DFL) Framework Overview for an excellent description of DFL operation from the driver perspective.</p> <p>When planning your address space for your FIM updates, please be aware OFS FIM targeting Intel\u00ae FPGA PAC D5005, 256KB of MMIO region is allocated for external FME features, and 128kB of MMIO region is given for external port features. Each external feature must implement a feature DFH, and the DFH needs to be placed at the 4KB boundary. The last feature in the external feature list must have the EOL bit in its DFH set to 1 to mark the end of the external feature list. Since the FPGA address space is limited, consider using an indirect addressing scheme to conserve address space.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#132-considerations-for-pim-usage","title":"1.3.2. Considerations for PIM Usage","text":"<p>An early decision for your AFU development is determining if the PIM will be included in your design flow. The PIM is an abstraction layer, enabling partial AFU portability across hardware despite variations in hardware topology and native interfaces. Use of the PIM is optional for AFU development. The use of the PIM adds a level of logic between an accelerator (an AFU) and the platform (the FIM). It is a collection of System Verilog interfaces and shims. Please see Connecting an AFU to a Platform using PIM for details on using the PIM and its capabilities. Please see PIM Tutorial for a detailed tutorial on using PIM. The learning steps PIM Tutorial can be run with Intel\u00ae OFS for Intel\u00ae Stratix 10\u00ae FPGA FIM package after you have installed this package as described later in this guide.  </p> <p>If you choose not to use the PIM, please see Non-PIM AFU Development for instructions on using a traditional RTL design flow. Note, the example AFU provided in Intel\u00ae OFS does not include PIM.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#133-afu-interfaces-included-with-intel-fpga-pac-d5005","title":"1.3.3 AFU Interfaces Included with Intel\u00ae FPGA PAC D5005","text":"<p>The figure below shows the interfaces available to the AFU in this architecture. It also shows the design hierarchy with module names from the FIM (top.sv) to the PR  region AFU (afu_main.sv). One of the main differences from the previous Intel\u00ae Stratix 10\u00ae FPGA OFS architecture is a static port gasket region (port_gasket.sv) that has components to facilitate the AFU and also consists of the GBS region (afu_main.sv) via the PR  slot. The Port Gasket contains all the PR -specific modules and logic, e.g., PR  slot reset/freeze control, user clock, remote STP etc. Architecturally, a Port Gasket can have multiple PR  slots to which user workload can be programmed. However, only one PR  slot is supported for Intel\u00ae OFS Release for Intel\u00ae Stratix 10\u00ae FPGA. Therefore, everything in the Port Gasket until the PR  slot should be provided by the FIM developer. The task of the AFU developer is to add their desired application in the afu_main.sv module by stripping out unwanted logic and instantiating the target accelerator. As shown in the figure below, here are the interfaces connected to the AFU (highlighted in green) via Intel\u00ae FPGA PAC D5005 FIM:</p> <ul> <li>AXI Streaming (AXI-S) interface to the Host via PCIe Gen3x16</li> <li>Avalon Memory-Mapped Channels (4) to the DDR4 EMIF interface</li> <li>AXI Streaming (AXI-S) interface to the HSSI 10G Ethernet</li> </ul> <p></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#134-platform-capabilities","title":"1.3.4. Platform Capabilities","text":"<p> The FIM targets operation in the Intel\u00ae FPGA PAC D5005 card.  The block diagram of the Intel\u00ae FPGA PAC D5005 is shown below: </p> <p>The key Intel\u00ae FPGA PAC D5005 FPGA interfaces are:</p> <ul> <li>Host interface <ul> <li>PCIe Gen3 x 16</li> </ul> </li> <li>Network interface</li> <li>2 - QSFP28 cages</li> <li>Current FIM supports 1 x 10 GbE, other interfaces can be created  </li> <li>External Memory</li> <li>2 or 4 channels of DDR4-2400 to RDIMM modules</li> <li>RDIMM modules =  8GB organized as 1 Gb X 72</li> <li>Board Management</li> <li>SPI interface</li> <li>FPGA configuration</li> </ul>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#135-top-level-fpga","title":"1.3.5. Top Level FPGA","text":"<p> The internal FPGA architecture is shown below:</p> <p></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2-set-up-afu-development-environment","title":"2. Set Up AFU Development Environment","text":"<p> This section covers:</p> <ul> <li>Development environment set up</li> <li>Retrieving and installing OFS, OPAE SDK</li> <li>Building theIntel\u00ae FPGA PAC D5005 FIM</li> <li>Building a relocatable AFU tree</li> <li>Compiling the host_chan_mmio example AFU</li> </ul> <p>Additionally, this section includes steps to demonstrate loading and running the host_chan_mmio example AFU in an Intel\u00ae FPGA PAC D5005 equipped Linux server.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#21-prepare-afu-development-environment","title":"2.1. Prepare AFU development environment","text":"<p>Typical development and hardware test environments consist of a development server or workstation with installed FPGA development tools and a separate server installed with the target OFS-compatible FPGA PCIe card. The typical usage and flow of data between these two servers are shown below:</p> <p></p> <p>Please refer to Unit Level Simulation if you would like to make any simulation Unit Level Simulation.</p> <p>Note that both development and hardware testing can be performed on the same server if desired.</p> <p>This guide uses Intel\u00ae FPGA PAC D5005 as the target OFS-compatible FPGA PCIe card platform for demonstration steps. The Intel\u00ae FPGA PAC D5005 must be fully installed following OFS Getting Started User Guide If using a different OFS FPGA PCIe card, contact your supplier for instructions on how to install and operate a user-developed AFU.</p> <p>NOTE: </p> <p>The following chapters assume you use the same server for development and Deployment (Run the FIM/AFU/SW over the Intel\u00ae FPGA PAC D5005):</p> <p>Development: Modify the FIM/AFU/SW run simulation and compile the design (Generate the binaries).  Deployment: Program the binaries under the Intel\u00ae FPGA PAC D5005 and exercise the Hardware and Sw with real hardware</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#211-installation-of-quartus-and-ofs","title":"2.1.1. Installation of Quartus and OFS","text":"<p> Building AFU with OFS forIntel\u00ae Stratix 10\u00ae FPGA requires the build machine to have at least 64 GB of RAM.  </p> <p>The following is a summary of the steps to set up for AFU development:</p> <ol> <li>Install  Intel\u00ae Quartus\u00ae Prime Pro Edition  22.3 Linux with Intel\u00ae Stratix 10\u00ae FPGA device support.</li> <li>Make sure support tools are installed and meet version requirements.</li> <li>Clone the repository.</li> <li>Review the files provided in the repository.</li> <li>Build a relocatable PR  tree - this will be the base FIM for your AFU.</li> </ol> <p>Intel\u00ae Quartus\u00ae Prime Pro Edition version  22.3 is the currently verified version of  Intel\u00ae Quartus\u00ae Prime Pro Edition 22.3 used for building the AFU images. The recommended Best Known Configuration (BKC) OFS Version 2022.3:</p> Item Version Intel\u00ae Quartus\u00ae Prime Pro Edition 22.3 Operating System RHEL 8.2 OPAE SDK 2.3.0-1 OFS Release ofs-d5005-1.0.1 Python 3.7.7 cmake 3.11.4 GCC 7.2.0 git 1.8.3.1 perl 5.8.8"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2111-installation-of-quartus","title":"2.1.1.1 Installation of Quartus","text":"<ol> <li> <p>Download Intel\u00ae Quartus\u00ae Prime Pro Edition Linux.</p> </li> <li> <p>After running the  Intel\u00ae Quartus\u00ae Prime Pro Edition version  22.3 installer, set the PATH environment variable to make utility <code>quartus</code>, <code>jtagconfig</code>, and <code>quartus_pgm</code> discoverable. Edit your bashrc file <code>~/.bashrc</code> to add the following line:</p> </li> </ol> <pre><code>export QUARTUS_MAINPATH=&lt;Quartus install directory&gt;\nexport QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ipexport\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld\nexport QSYS_ROOTDIR=$QUARTUS_MAINPATH/qsys/bin\nexport PATH=$PATH:$QUARTUS_ROOTDIR/bin\n</code></pre> <p>For example:</p> <pre><code>export QUARTUS_MAINPATH=/home/&lt;mylocaluser&gt;/intelFPGA_pro/22.3\nexport QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ipexport\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld\nexport QSYS_ROOTDIR=$QUARTUS_MAINPATH/qsys/bin\nexport PATH=$PATH:/home/intelFPGA_pro/22.3/quartus/bin\n</code></pre> <ol> <li>Verify that  Intel\u00ae Quartus\u00ae Prime Pro Edition is discoverable by opening a new shell:</li> </ol> <pre><code>$ which quartus\n/home/&lt;mylocaluser&gt;/intelFPGA_pro/22.3/quartus/bin/quartus\n</code></pre> <p>NOTE: </p> <p>Ensure your proxy is set up if you use an intranet network.</p> <p><pre><code>export no_proxy=&lt;yourproxy&gt;\nexport http_proxy=&lt;yourproxy&gt;\nexport https_proxy=&lt;yourproxy&gt;\n</code></pre> </p> <p>Useful resources</p> <p>Intel\u00ae FPGA Software Licenses \\ Intel\u00ae FPGA Software Installation and Licensing manual </p> <p>Cloning the repo using the HTTPS method requires a personal access token. Please see this blog post for information about obtaining a personal access token, Github Creating a personal access token.</p> <p>Console Output: <pre><code>quartus_syn --version\nQuartus Prime Synthesis\nVersion 22.3.0 Build 104 09/14/2022 SC Pro Edition\nCopyright (C) 2022  Intel Corporation. All rights reserved.\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2112-install-ofs","title":"2.1.1.2. Install OFS","text":"<p> 1. Retrieve OFS repositories:</p> <pre><code>The Intel\u00ae OFS FIM source code is included in the OFS GitHub repository. First, create a new directory to store the retrieved files as a clean starting point. The following is a short description of each repository, followed by the git commands for cloning. The instructions section uses the HTTPS git method for cloning repositories.\n</code></pre> <ol> <li>Navigate to the location for storage of OFS source, create the top-level source directory, and clone OFS repositories.</li> </ol> <p><pre><code>mkdir ofs_fim_build_root\ncd ofs_fim_build_root\n</code></pre> <pre><code>export OFS_BUILD_ROOT=$PWD\n</code></pre> <pre><code>git clone --recurse-submodules  https://github.com/OFS/ofs-d5005.git\n</code></pre></p> <p>Console Output: <pre><code>Cloning into 'ofs-d5005' ...\nUsername for 'https://github.com': &lt;&lt;Enter your git hub username&gt;&gt;\nPassword for 'https://&lt;&lt;Your username&gt;&gt;': &lt;&lt;Enter your personal access token&gt;&gt;\nremote: Enumerating objects:  ....\n...\n...\nResolving deltas  ..., done.\n</code></pre> </p> <p>Edit your bashrc file ~/.bashrc to add the following lines: <pre><code>export OFS_ROOTDIR=$OFS_BUILD_ROOT/ofs-d5005\nexport WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification\n</code></pre> <pre><code>cd ofs-d5005\n</code></pre></p> <p>Select the latest OFS Release <pre><code>git checkout tags/ofs-d5005-1.0.1\n</code></pre></p> <p>Console Output: ```sh You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout.</p> <p>If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example:</p> <p>git checkout -b  HEAD is now at 7e4dc70 ofs-d5005-1.0.1"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2113-directory-structure-of-ofs","title":"2.1.1.3. Directory Structure of OFS","text":"<p> Verify the following directories in the $OFS_BUILD_ROOT directory with the following command.  </p> <pre><code>cd  $OFS_ROOTDIR\nls\n</code></pre> <p>Console Output: <pre><code> eval_scripts ipss ofs-common license  LICENSE.md  README.md  sim  src  syn  verification\n</code></pre> </p> <p>The directories are arranged as shown below:</p> <pre><code>\u251c\u2500\u2500 eval_scripts\n\u2502   \u251c\u2500\u2500 ofs_d5005_eval.sh\n\u2502   \u251c\u2500\u2500 README_ofs_d5005_eval.txt\n|\n\u251c\u2500\u2500 ofs-common\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 verification\n|   \u251c\u2500\u2500 LICENSE.txt   \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 ipss        **Directory ipss consists of Platform Designer subsystems used in FIM**\n\u2502   \u251c\u2500\u2500 hssi\n\u2502   \u251c\u2500\u2500 mem\n\u2502   \u251c\u2500\u2500 pcie\n|   \u251c\u2500\u2500 pmic |   \u251c\u2500\u2500 spi  \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 license\n\u2502   \u2514\u2500\u2500 quartus-0.0-0.01iofs-linux.run    ** Quartus Patch with IP licenses.  \u2502                                         ** Note, these licenses are not used for Intel\u00ae FPGA PAC D5005** \u251c\u2500\u2500 sim             **Unit level simulation files**\n\u2502   \u251c\u2500\u2500 unit_test\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 bfm\n\u2502   \u251c\u2500\u2500 rp_bfm   \u2502   \u2514\u2500\u2500 readme.txt     \u2502    \u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 README.md\n|\n\u251c\u2500\u2500 src             **Source RTL files**\n\u2502   \u251c\u2500\u2500 afu_top\n\u2502   \u251c\u2500\u2500 includes\n\u2502   \u251c\u2500\u2500 pd_qsys\n\u2502   \u251c\u2500\u2500 top\n|   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 external\n\u2502   \u2514\u2500\u2500 ofs-platform-afu-bbb\n|\n\u251c\u2500\u2500 syn              **Quartus compilation settings**\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 setup\n\u2502   \u251c\u2500\u2500 syn_top\n\u2502   \u251c\u2500\u2500 readme.txt\n\u2502   \u2514\u2500\u2500 README\n</code></pre> <pre><code>\u251c\u2500\u2500 eval_scripts\n\u2502   \u251c\u2500\u2500 ofs_d5005_eval.sh\n\u2502   \u251c\u2500\u2500 README_ofs_d5005_eval.txt\n|\n\u251c\u2500\u2500 ofs-common\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 verification\n|   \u251c\u2500\u2500 LICENSE.txt   \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 ipss        **Directory ipss consists of Platform Designer subsystems used in FIM**\n\u2502   \u251c\u2500\u2500 hssi\n\u2502   \u251c\u2500\u2500 mem\n\u2502   \u251c\u2500\u2500 pcie\n|   \u251c\u2500\u2500 pmic |   \u251c\u2500\u2500 spi  \u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 license\n\u2502   \u2514\u2500\u2500 quartus-0.0-0.01iofs-linux.run    ** Quartus Patch with IP licenses.  \u2502                                         ** Note, these licenses are not used for Intel\u00ae FPGA PAC D5005** \u251c\u2500\u2500 sim             **Unit level simulation files**\n\u2502   \u251c\u2500\u2500 unit_test\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 bfm\n\u2502   \u251c\u2500\u2500 rp_bfm   \u2502   \u2514\u2500\u2500 readme.txt     \u2502    \u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 README.md\n|\n\u251c\u2500\u2500 src             **Source RTL files**\n\u2502   \u251c\u2500\u2500 afu_top\n\u2502   \u251c\u2500\u2500 includes\n\u2502   \u251c\u2500\u2500 pd_qsys\n\u2502   \u251c\u2500\u2500 top\n|   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 external\n\u2502   \u2514\u2500\u2500 ofs-platform-afu-bbb\n|\n\u251c\u2500\u2500 verification     **Top level UVM simulation files**\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 README.d5005\n\u2502   \u2514\u2500\u2500 regress_d5005.pl\n\u251c\u2500\u2500 syn              **Quartus compilation settings**\n\u2502   \u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 setup\n\u2502   \u251c\u2500\u2500 syn_top\n\u2502   \u251c\u2500\u2500 readme.txt\n\u2502   \u2514\u2500\u2500 README\n--&gt;\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2114-license-installation-for-ofs","title":"2.1.1.4 License Installation for OFS","text":"<p> The required setup Intel\u00ae OFS License quartus-0.0-0.01iofs-linux.run, follow the following steps :</p> <pre><code>cd $OFS_ROOTDIR/license\nchmod +x quartus-0.0-0.01iofs-linux.run\nsudo ./quartus-0.0-0.01iofs-linux.run\n# Confirm the license instaltion using below command.\nquartus_syn --version\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2115-retrieve-pim-files","title":"2.1.1.5. Retrieve PIM Files","text":"<p> The ofs-platform-afu-bbb repository contains the PIM files and example AFU that can be used for testing and demonstration purposes. This guide will use the host_chan_mmio example in the remaining sections to demonstrate OFS capabilities.</p> <p><pre><code>cd $OFS_BUILD_ROOT\n</code></pre> <pre><code>git clone https://github.com/OFS/ofs-platform-afu-bbb.git\n</code></pre> Edit your bashrc file ~/.bashrc to add the following lines: <pre><code>export OFS_PLATFORM_AFU_BBB=$OFS_BUILD_ROOT/ofs-platform-afu-bbb\n</code></pre></p> <p>Verify the following directories are present in $OFS_BUILD_ROOT directory. <pre><code>cd $OFS_PLATFORM_AFU_BBB\n</code></pre> <pre><code>ls\n</code></pre></p> <p>Console Output: <pre><code> COPYING  plat_if_develop  plat_if_release  plat_if_tests  README.md\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#212-compiling-the-ofs-fim","title":"2.1.2. Compiling the OFS FIM","text":"<p>Intel\u00ae OFS provides a build script with the following FPGA image creation options:</p> <ul> <li>Flat compile, which combines the FIM and AFU into one FPGA image loaded into the entire FPGA device as a static image.</li> <li>A PR  compile that creates an FPGA image consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. Additional AFU may be loaded into the dynamic region using partial reconfiguration.  </li> </ul> <p>The build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested. Each build script step will take several hours to complete. Building in Quartus GUI is not supported - you must build with the provided scripts.</p> <p>The following sections describe how to set up the environment and build the provided FIM with a relocatable tree supporting PR . You will use this relocatable PR  tree for all example AFU simulation and compilation steps in this guide.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2121-setting-up-required-environment-variables","title":"2.1.2.1. Setting Up Required Environment Variables","text":"<p> Set required environment variables as shown below. These environment variables must be set before simulation or compilation tasks, so creating a simple script to set these variables saves time.</p> <p>Edit your bashrc file ~/.bashrc to add the following lines: <pre><code>export OPAE_SDK_REPO_BRANCH=release/2.3.0\n</code></pre></p> <p>Check point : Ensure you file ~/.bashrc have all the following lines:</p> <p><pre><code>export QUARTUS_MAINPATH=&lt;Quartus install directory&gt;\nexport QUARTUS_ROOTDIR=$QUARTUS_MAINPATH/quartus\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ipexport\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport INTELFPGAOCLSDKROOT=$QUARTUS_MAINPATH/hld\nexport QSYS_ROOTDIR=$QUARTUS_MAINPATH/qsys/bin\nexport PATH=$PATH:$QUARTUS_ROOTDIR/bin\nexport OFS_BUILD_ROOT=&lt;root location&gt; ** Here should be located your ofs-d5005 and ofs-platform-afu-bbb\nexport OFS_ROOTDIR=$OFS_BUILD_ROOT/ofs-d5005\nexport WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification\nexport OFS_PLATFORM_AFU_BBB=$OFS_BUILD_ROOT/ofs-platform-afu-bbb\nexport OPAE_SDK_REPO_BRANCH=release/2.3.0\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2122-compiling-your-base-fim","title":"2.1.2.2. Compiling Your Base FIM","text":"<p> The usage of the compile build script is shown below:</p> <p><pre><code>ofs-common/scripts/common/syn/build_top.sh [-p] target_configuration work_dir \n\n      * target_configuration - Specifies the project  \n         For example: d5005\n\n      * work_dir - Work Directory for this build in the form a directory name. It is created in the &lt;local repo directory&gt;/ofs-d5005/&lt;work_dir&gt; \n          - NOTE: The directory name must start with \"work\". If the working directory exists, the script stops and asks if you want to overwrite the directory.\n            - e.g.\n                - ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005\n\n                work directory as a name will be created in &lt;local repo directory&gt;/ofs-d5005/work_d5005\n\n                The obmission of &lt;work_dir&gt; results in a default work directory (&lt;local repo  directory&gt;/ofs-d5005/work)\n\n        - compile reports and artifacts (.rpt, .sof, etc) are stored in &lt;work_dir&gt;/syn/&lt;OFS_PROJECT&gt;/&lt;OFS_FIM&gt;/&lt;OFS_BOARD&gt;/syn_top/output_files\n\n        - There is a log file created in ofs-d5005 directory.  \n        - [-p]  Optional switch for creating a relocatable PR  build tree supporting the creation of a PR -able AFU workload.   \n        The \"-p\" switch invokes generate_pr_release.sh at the end of the FIM build and writes the PR  build tree to the top of the working directory. More information on this option is provided below. \n</code></pre> In the following example, you will build the provided example design using a flat, non-PR  build flow. If you use the -p, you could avoid the section.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#21221-relocatable-pr-directory-tree","title":"2.1.2.2.1. Relocatable PR Directory Tree.","text":"<p>Build the provided base example design:</p> <p><pre><code>cd $OFS_ROOTDIR\n</code></pre> <pre><code>ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005\n</code></pre></p> <p>Console Output: <pre><code>    ... build takes ~5 hours to complete\nCompile work directory:     &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top\nCompile artifact directory: &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top/output_files\n\n***********************************\n***\n***        OFS_PROJECT: d5005\n***        Q_PROJECT:  d5005\n***        Q_REVISION: d5005\n***        SEED: 03\n***        Build Complete\n***        Timing Passed!\n***\n</code></pre> </p> <p>Pro Tip: if the timing report fails, try to go into the iofs_pr_afu.qsf and modify the seed number from 3 to 4, it will create multiple seed/starting points of your design to find the best timing/fit. <code>/home/&lt;myuser&gt;/&lt;mainfolderforOFS&gt;/ofs-d5005/work_d5005/syn/syn_top/iofs_pr_afu.qsf</code> <pre><code>set_global_assignment -name SEED 0 #0-4\n</code></pre> </p> <p>The build script copies the ipss, sim, src, and syn directories to the specified work directory, and then these copied files are used in the Quartus compilation process. Therefore, do not edit the files in the work directory; these files are copies of source files.</p> <p>Some of the critical output files are described below:</p> <p>$OFS_ROOTDIR//syn/syn_top <pre><code>\u251c\u2500\u2500 syn_top                    //Intel\u00ae FPGA PAC D5005 Quartus build area with Quartus files used this build\n\u2502  \u251c\u2500\u2500 d5005.ipregen.rpt       // IP regeneration report states the output of IP upgrade\n\u2502  \u251c\u2500\u2500 d5005.qpf               // Quartus Project File (qpf) mentions about Quartus version and project revision\n\u2502  \u251c\u2500\u2500 d5005.qsf               // Quartus Settings File (qsf) lists current project settings and entity level assignments\n\u2502  \u251c\u2500\u2500 d5005.stp               // Signal Tap file included in the d5005.qsf. This file can be modified as required\n\u2502  \u251c\u2500\u2500 fme_id.mif              // the fme id hex value is stored in a mif file format\n\u2502  \u251c\u2500\u2500 iofs_pr_afu.json        // PR JSON file\n\u2502  \u251c\u2500\u2500 iofs_pr_afu.qsf                // PR AFU qsf file\n\u2502  \u251c\u2500\u2500 iofs_pr_afu_sources.tcl        // AFU source file list\n</code></pre> <p>$OFS_ROOTDIR//syn/syn_top/output_files == Directory with build reports and FPGA programming files. <p>The programming files consist of the Quartus generated d5005.sof and d5005.pof. The Intel\u00ae FPGA PAC D5005 board hardware provides a 2 Gb flash device to store the FPGA programming files and a BMC CARD that reads this flash and programs the Intel\u00ae FPGA PAC D5005 Intel\u00ae Stratix 10\u00ae FPGA. The ./ofs-common/scripts/common/syn/build_top.sh script runs script file ./ofs-common/scripts/common/syn/build_top.sh which takes the Quartus generated d5005.sof and creates binary files in the proper format to be loaded into the 2 Gb flash device.  You can also run build_flash.sh by itself if needed. </p> <p>The build script will run PACSign and create an unsigned FPGA programming file for both user1 and user2 locations of the Intel\u00ae FPGA PAC D5005 flash. Please note, if the Intel\u00ae FPGA PAC D5005 has the root entry hash key loaded, then PACsign must be run to add the proper key to the FPGA binary file. Please see Security User Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA for details on the security aspects of Intel\u00ae Open FPGA Stack and refer to BMC User Guide for Flash partition.</p> <p>The following table provides further detail on the generated bin files.</p> File Description d5005.sof This is the Quartus generated programming file created by Quartus synthesis and place and route. This file can be used to program the FPGA using a JTAG  programmer. This file is the source file for the binary files used to program the FPGA flash. d5005.bin This is an intermediate raw binary image of the FPGA d5005_page1.bin This is the binary file created from the input file, d5005.sof. This file is used as the input file to the PACSign utility to generate d5005_page1_unsigned.bin binary image file. d5005_page1_unsigned.bin This is the unsigned PACSign output which can be programmed into the FPGA flash of an unsigned Intel\u00ae FPGA PAC D5005 using the OPAE SDK utility fpgasupdate mfg_d5005_reversed.bin A particular programming file for a third-party device used in board manufacturing. This file is typically not used. <p>build/output_files/timing_report == Directory containing clocks report, failing paths and passing margin reports</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#213-relocatable-pr-directory-tree","title":"2.1.3. Relocatable PR Directory Tree","text":"<p> If you are developing FIM to be used by another team developing the AFU workload, scripts are provided that create a relocatable PR  directory tree. ODM and board developers will use this capability to enable a broad set of AFU to be loaded on a board using PR . The relocatable PR  directory contains the Quartus *.qdb file that goes the FIM.</p> <p>Creating the relocatable PR  directory tree requires a clone of the Intel\u00ae Basic Building Blocks (BBB) repository. The OFS_PLATFORM_AFU_BBB environment variable must point to the repository, for example.</p> <p><pre><code>cd $OFS_BUILD_ROOT\n</code></pre> <pre><code>git clone https://github.com/OFS/ofs-platform-afu-bbb.git\n</code></pre> <pre><code>cd $OFS_ROOTDIR\n</code></pre></p> <p>You can create this relocatable PR  directory tree by either:</p> <ul> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh followed by running /syn/common/scripts/generate_pr_release.sh (section 2.1.3. Relocatable PR Directory Tree)</li> <li>Build FIM and AFU using ofs-common/scripts/common/syn/build_top.sh with optional -p switch included</li> </ul> <p>The generate_pr_release.sh has the following command structure:</p> <p><pre><code>ofs-common/scripts/common/syn/generate_pr_release.sh -t &lt;path to generated release tree&gt; *Board Build Target* &lt;work dir from build_top.sh&gt;\nWhere:\n-t &lt;path to generated release tree&gt; = location for your relocatable PR  directory tree\n*Board Build Target* is the name of the board target/FIM e.g. d5005\n&lt;work dir from build_top.sh&gt; \n</code></pre> Here is an example of running the generate_pr_release.sh script in user mode:</p> <pre><code>ofs-common/scripts/common/syn/generate_pr_release.sh -t work_d5005/build_tree d5005  work_d5005\n</code></pre> <p>Console Output: <pre><code>**********************************\n********* ENV SETUP **************\nFIM Project:\n  OFS_PROJECT = d5005\n  OFS_FIM     = .\n  OFS_BOARD   = .\n  Q_PROJECT   = d5005\n  Q_REVISION  = d5005\n  Fitter SEED = 03\nFME id\n  BITSTREAM_ID = 040100022c164db1\n  BITSTREAM_MD = 0000000002212053\n...\n...\n</code></pre> </p> <p>The resulting relocatable build tree has the following structure:</p> <pre><code>.\n\u251c\u2500\u2500 bin\n\u2502   \u251c\u2500\u2500 afu_synth\n\u2502   \u251c\u2500\u2500 build_env_config\n\u2502   \u251c\u2500\u2500 run.sh -&gt; afu_synth\n\u2502   \u2514\u2500\u2500 update_pim\n\u251c\u2500\u2500 hw\n\u2502   \u251c\u2500\u2500 blue_bits\n\u2502   \u2502   \u251c\u2500\u2500 d5005_page1_unsigned.bin\n\u2502   \u2502   \u2514\u2500\u2500 d5005.sof -&gt; ../lib/build/syn/syn_top/   output_files/d5005.sof\n\u2502   \u2514\u2500\u2500 lib\n\u2502       \u251c\u2500\u2500 build\n\u2502       \u251c\u2500\u2500 fme-ifc-id.txt\n\u2502       \u251c\u2500\u2500 fme-platform-class.txt\n\u2502       \u2514\u2500\u2500 platform\n\u251c\u2500\u2500 README\n</code></pre> <p>Edit your bashrc file ~/.bashrc to add the following line: <pre><code>export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_d5005/build_tree\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#214-programing-the-fim","title":"2.1.4. Programing the FIM","text":"<p> 1.  Run the following command to find the PCIe address for your card.</p> <pre><code>sudo fpgainfo fme\n</code></pre> <p>Console Output: <pre><code>Board Management Controller, MAX10 NIOS FW version: 2.0.13\nBoard Management Controller, MAX10 Build version: 2.0.13\n//****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nDevice Id                        : 0xBCCE\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 288511861987640872\nBitstream Version                : 4.0.1\nPr Interface Id                  : d51533ad-aee6-5dab-80fb-a44bbf579b68\nBoot Page                        : user\n</code></pre> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#2141-load-fim-into-the-flash-of-the-intel-fpga-pac-d5005","title":"2.1.4.1. Load FIM into the Flash of the Intel\u00ae FPGA PAC D5005","text":"<p> The base FIM used in AFU compilation must be loaded on the board. In this step, you will load the generated FIM binary into the Intel\u00ae FPGA PAC D5005 FPGA flash. By performing this step, subsequent AFU developed in this guide will use this base FIM and allow your newly created AFU to match the base FIM loaded on the board.</p> <p>More information related to fpgaupdate is located OFS Getting Started User Guide.</p> <p>Run fpgasupdate to load the image into the user location of the Intel\u00ae FPGA PAC D5005 FPGA flash and the RSU  command to reboot the PCIE Card:</p> <p><pre><code>sudo fpgasupdate $OFS_ROOTDIR/work_d5005/syn/syn_top/output_files/d5005_page1_unsigned.bin 3b:00.0\n</code></pre> Run rsu command to re-configure FPGA on Intel\u00ae FPGA PAC D5005. <pre><code>sudo rsu bmcimg 3b:00.0\n</code></pre></p> <pre><code>sudo fpgainfo fme\n</code></pre> <p>Console Output: ```sh</p> <p>Board Management Controller, MAX10 NIOS FW version: 2.0.13 Board Management Controller, MAX10 Build version: 2.0.13 //** FME ****// Object Id                        : 0xF000000 PCIe s:b:d.f                     : 0000:3b:00.0 Device Id                        : 0xBCCE Socket Id                        : 0x00 Ports Num                        : 01 Bitstream Id                     : 288511861987640872 Bitstream Version                : 4.0.1 Pr Interface Id                  : d51533ad-aee6-5dab-80fb-a44bbf579b68 Boot Page                        : user </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#30-opae-software-development-kit","title":"3.0 OPAE Software Development Kit","text":"<p> The OPAE SDK software stack sits in user space on top of the Intel\u00ae OFS kernel drivers. It is a common software infrastructure layer that simplifies and streamlines the integration of programmable accelerators such as FPGAs into software applications and environments. OPAE consists of a set of drivers, user-space libraries, and tools to discover, enumerate, share, query, access, manipulate, and re-configure programmable accelerators. OPAE is designed to support a layered, common programming model across different platforms and devices. To learn more about OPAE, its documentation, code samples, an explanation of the available tools, and an overview of the software architecture, please visit the OPAE.io page.</p> <p>The OPAE SDK source code is contained within a single GitHub repository hosted at the OPAE GitHub. This repository is open source and should not require any permissions to access.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#31-opae-sdk-build-environment-setup","title":"3.1 OPAE SDK Build Environment Setup","text":"<p>This installation process assumes the user has access to an internet connection to pull specific GitHub repositories and satisfy package dependencies. If an offline install process is required, please reach out to your Intel\u00ae representative.</p> <p>1. Before OPAE SDK installation, the user must remove any prior OPAE frameworks. To remove these packages:</p> <pre><code>sudo dnf remove opae*\n</code></pre> <p>2. The user must enable the following repository changes in order to install all dependencies on CentOS 8.3:</p> <pre><code>sudo dnf config-manager --set-enabled powertools\nsudo dnf install epel-release\n</code></pre> <p>3. The following package dependencies must be satisfied by the user. Double check that all packages have been found and installed:</p> <pre><code>sudo dnf install autoconf automake bison boost boost-devel cmake doxygen dwarves elfutils-libelf-devel \\\nflex gcc gcc-c++ git hwloc-devel json-c-devel libarchive libedit libedit-devel libpcap libpng12 libuuid libuuid-devel libxml2 libxml2-devel make ncurses  \\\nncurses-devel ncurses-libs openssl-devel python2-pip python3-devel python3-jsonschema rsync tbb-devel libudev-devel\n</code></pre> <p>All steps in this installation will use a generic top-level directory at <code>$OFS_BUILD_ROOT</code>. If the user has created a different top-level directory, replace this path with the user's custom path.</p> <p>4. Initialize an empty git repository and clone the tagged OPAE SDK source code:</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#32-install-opae-sdk","title":"3.2 Install OPAE SDK","text":"<p> Perform the following steps to install OPAE SDK:</p> <p><pre><code>cd $OFS_BUILD_ROOT\ngit clone https://github.com/OPAE/opae-sdk.git\ncd opae-sdk\ngit checkout tags/2.3.0-1 -b release/2.3.0\n</code></pre> Verify proper branch is selected</p> <pre><code>git describe\n  2.3.0-1\n\ngit branch\n  master\n  * release/2.3.0\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#33-building-and-installing-the-opae-sdk","title":"3.3 Building and Installing the OPAE SDK","text":"<p> 1. Build the OPAE SDK source code, and pack it into several local RPM packages. Building the code into packages allows for easier installation and removal. This build script can use multiple processors to parallelize the build process. Display how many processors are available with the <code>nproc</code> command, and then specify how many make threads to utilize with the -j option. Note that the number of threads can exceed the number of processors. In this case, the number of threads is set to the number of processors in the system.</p> <pre><code>cd $OFS_BUILD_ROOT/opae-sdk\nmkdir install-opae-sdk\ncd install-opae-sdk\ncmake .. -DCPACK_GENERATOR=RPM -DOPAE_BUILD_FPGABIST=ON -DOPAE_BUILD_PYTHON_DIST=ON -DCMAKE_BUILD_PREFIX=/install-opae-sdk make -j `nproc`\nmake -j `nproc` package_rpm\n</code></pre> <p>The <code>install-opae-sdk</code> directory location was selected for ease of use. If the user wishes to build the OPAE SDK in a different location, they will need to replace the '..' in the above command with the direct or relative path to the opae-sdk repository.</p> <p>2. After a successful compile, there should be eight packages present:</p> <pre><code>cd $OFS_BUILD_ROOT/opae-sdk/install-opae-sdk\nls | grep rpm\nopae-2.3.0-1.x86_64.rpm                                                                                                    opae-PACSign-2.3.0-1.x86_64.rpm                                                                                            opae-devel-2.3.0-1.x86_64.rpm                                                                                              opae-libs-2.3.0-1.x86_64.rpm                                                                                               opae-opae.admin-2.3.0-1.x86_64.rpm                                                                                         opae-packager-2.3.0-1.x86_64.rpm                                                                                           opae-tests-2.3.0-1.x86_64.rpm                                                                                              opae-tools-2.3.0-1.x86_64.rpm                                                                                              opae-tools-extra-2.3.0-1.x86_64.rpm\n</code></pre> <p>3. Install the OPAE SDK packages:</p> <pre><code>cd $OFS_BUILD_ROOT/opae-sdk/install-opae-sdk\nsudo dnf localinstall -y opae*.rpm\n</code></pre> <p>4. check that all packages have been installed:</p> <pre><code>rpm -qa | grep opae\nopae-devel-2.3.0-1.x86_64                                                                                                  opae-packager-2.3.0-1.x86_64                                                                                               opae-2.3.0-1.x86_64                                                                                                        opae-tools-2.3.0-1.x86_64                                                                                                  opae-PACSign-2.3.0-1.x86_64                                                                                                opae-tools-extra-2.3.0-1.x86_64                                                                                            opae-opae.admin-2.3.0-1.x86_64                                                                                             opae-tests-2.3.0-1.x86_64                                                                                                  opae-libs-2.3.0-1.x86_64\n</code></pre> <p>5. Setup required environment variables</p> <p><pre><code>export PATH=$PATH:$OFS_BUILD_ROOT/opae-sdk/install-opae-sdk/bin\nexport LIBRARY_PATH=$OFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib\nexport LD_LIBRARY_PATH=$OFS_BUILD_ROOT/opae-sdk/install-opae-sdk/lib64\n</code></pre> <pre><code>cd ../lib/python*/site-packages\nexport PYTHONPATH=$PWD\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#4-compiling-an-afu","title":"4. Compiling An AFU","text":"<p>This section will use the FIM build tree created in the previous steps to compile an example AFU. This section will continue the work with the <code>host_chan_mmio</code> AFU.. You can perform the build steps listed below to demonstrate the ease in building and running a real example on the Intel\u00ae FPGA PAC D5005.</p> <p>To run the steps in this section, you must complete all steps in section 2. Set Up AFU Development Environment, and ensure the <code>OPAE_PLATFORM_ROOT</code> \"environment variable that points to the directory of the PR  build tree generated previously. </p> <p>Ensure your bashrc file ~/.bashrc have the following line: <pre><code>export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_d5005/build_tree\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#41-set-afu-synthesis-environment","title":"4.1. Set AFU Synthesis Environment","text":"<p>Here, you will create the synthesis environment to build the <code>host_chan_mmio</code> example. The PIM flow includes the synthesis environment creation script <code>afu_synth_setup</code> for this task. The usage of afu_synth_setup is shown below:</p> <pre><code>usage: afu_synth_setup [-h] -s SOURCES [-p PLATFORM] [-l LIB] [-f] dst\nGenerate a Quartus build environment for an AFU. A build environment is\ninstantiated from a release and configured for the specified AFU. AFU\nsource files are specified in a text file parsed by rtl_src_config,\nwhich is part of the OPAE base environment.\npositional arguments:\n  dst                   Target directory path (directory must not exist).\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA platform name.\n  -l LIB, --lib LIB     FPGA platform release hw/lib directory. If not\n                        specified, the environment variables OPAE_FPGA_HW_LIB\n                        and then BBS_LIB_PATH are checked.\n  -f, --force           Overwrite target directory if it exists.\n</code></pre> <p>Execute <code>afu_synth_setup</code> \"as follows to create the synthesis environment for a <code>host_chan_mmio</code> \"AFU that fits the Intel\u00ae FPGA PAC D5005 FIM previously constructed.</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/\nafu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_d5005_x16\n</code></pre> <p>Now, execute the <code>afu_synth</code> command that resides inside the <code>$OFS_ROOTDIR/work_d5005/build_tree/bin</code> directory, to actually build the <code>host_chan_mmio</code> AFU.</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/build_d5005_x16\n$OPAE_PLATFORM_ROOT/bin/afu_synth\n...\n...\nWrote host_chan_mmio.gbs\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\nDesign meets timing\n===========================================================================\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#411-loading-and-running-the-host_chan_mmio-example-afu","title":"4.1.1. Loading and Running the host_chan_mmio example AFU","text":"<p> Once the compilation completes successfully, load the new bitstream file, <code>host_chan_mmio.gbs</code>, into the partial reconfiguration region of the target Intel\u00ae FPGA PAC D5005. Keep in mind, that the loaded image is dynamic - this image is not stored in flash, and if the card is power cycled, then the PR  region is re-loaded with the default AFU.</p> <p>To load the image, perform the following steps:</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/build_d5005_x16\nsudo fpgasupdate host_chan_mmio.gbs 3b:00.0\n[sudo] password for &lt;&lt;Your username&gt;&gt;: [WARNING ] Update starting. Please do not interrupt.\n[INFO    ] Partial Reconfiguration OK\n[INFO    ] Total time: 0:00:01.88\n</code></pre> <p>Determine the BDF of the Intel\u00ae FPGA PAC D5005.</p> <p>The PCIe BDF address is initially determined when the server powers on. The user can determine the addresses of all Intel\u00ae FPGA PAC D5005 using lspci:</p> <pre><code>lspci -d :bcce\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <p>Set up your board to work with the newly loaded host_chan_mmio.gbs</p> <ol> <li> <p>Create the Virtual Functions (VFs): <pre><code>sudo pci_device 3b:00.0 vf 3\n</code></pre></p> </li> <li> <p>Verify that all three VFs have been created.</p> </li> </ol> <pre><code>$ lspci -s 3b:00\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.1 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.2 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.3 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <ol> <li>Bind the 3 VFs to the vfio-pci driver.</li> </ol> <p>sudo opae.io init -d  , e.g. <pre><code>$ sudo opae.io init -d 0000:3b:00.1 user:user\nBinding (0x8086,0xbccf) at 0000:3b:00.1 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.1 is 142\nAssigning /dev/vfio/142 to &lt;local user&gt;\nChanging permissions for /dev/vfio/142 to rw-rw----\n\n$ sudo opae.io init -d 0000:3b:00.2 user:user\nBinding (0x8086,0xbccf) at 0000:3b:00.2 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.2 is 143\nAssigning /dev/vfio/143 to &lt;local user&gt;\nChanging permissions for /dev/vfio/143 to rw-rw-----\n\n$ sudo opae.io init -d 0000:3b:00.3 user:user\nBinding (0x8086,0xbccf) at 0000:3b:00.3 to vfio-pci\niommu group for (0x8086,0xbccf) at 0000:3b:00.3 is 144\nAssigning /dev/vfio/144 to &lt;local user&gt;\nChanging permissions for /dev/vfio/144 to rw-rw----\n</code></pre> <ol> <li>Verify the new AFU is loaded.  The host_chan_mmio AFU GUID is 76d7ae9c-f66b-461f-816a-5428bcebdbc5.</li> </ol> <pre><code>$ fpgainfo port\n//****** PORT ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x603B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : d15ab1ed-0000-0000-0210-000000000000\n//****** PORT ******//\nObject Id                        : 0x403B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 76d7ae9c-f66b-461f-816a-5428bcebdbc5\n//****** PORT ******//\nObject Id                        : 0x203B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n</code></pre> <p>Run the host_chan_mmio software application to demonstrate the newly loaded AFU image. You navigate to $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw and compile the software application and then run.</p> <p>If OPAE SDK libraries were not installed in the default systems directory <code>/usr/lib64/</code> \", define the OPAE_LOC environment variable to point to the directory where the OPAE SDK libraries were installed.</p> <p><pre><code>$ export OPAE_LOC=/usr\n$ export LIBRARY_PATH=$OPAE_LOC/lib64:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n</code></pre> <pre><code>cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw\nmake ./host_chan_mmio\n</code></pre></p> <p>Console Output: <pre><code>AFU ID:  76d7ae9cf66b461f 816a5428bcebdbc5\nAFU MMIO interface: AXI Lite\nAFU MMIO read bus width: 64 bits\n512 bit MMIO write supported: yes\nAFU pClk frequency: 250 MHz\n\nTesting 32 bit MMIO reads:\n  PASS - 4 tests\n\nTesting 32 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 64 bit MMIO writes:\n  PASS - 5 tests\n\nTesting 512 bit MMIO writes:\n  PASS\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#412-loading-and-running-the-hello_world-example-afu","title":"4.1.2. Loading and running the hello_world example AFU","text":"<p>The platform-independent BBB repository, ofs-platform-afu-bbb, also provides some interesting [example AFUs]. In this section, you will compile and execute the PIM-based <code>hello_world</code> AFU. The RTL of the <code>hello_world</code> AFU receives from the host application an address via memory-mapped I/O (MMIO) write and generates a DMA write to the memory line at that address. The content written to memory is the string \"Hello world!\". The host application spins, waiting for the memory line to be updated. Once available, the software prints out the string.</p> <p>The <code>hello_world</code> example AFU consists of the following files. </p> <p><pre><code>hello_world\n\u251c\u2500\u2500 hw\n\u2502   \u2514\u2500\u2500 rtl\n\u2502       \u251c\u2500\u2500 avalon\n\u2502       \u2502   \u251c\u2500\u2500 hello_world_avalon.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502       \u2502   \u2514\u2500\u2500 sources.txt\n\u2502       \u251c\u2500\u2500 axi\n\u2502       \u2502   \u251c\u2500\u2500 hello_world_axi.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502       \u2502   \u2514\u2500\u2500 sources.txt\n\u2502       \u251c\u2500\u2500 ccip\n\u2502       \u2502   \u251c\u2500\u2500 hello_world_ccip.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu.sv\n\u2502       \u2502   \u2514\u2500\u2500 sources.txt\n\u2502       \u2514\u2500\u2500 hello_world.json\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 hello_world.c\n    \u2514\u2500\u2500  Makefile\n</code></pre> The hw directory contains the RTL to implement the hardware functionality using CCIP, Avalon, and AXI interfaces. However, this guide will use the AXI version of the AFU to go through the compilation steps. The sw directory of the AFU contains the source code of the host application that communicates with the AFU hardware.</p> <p>The following instructions can be used to compile other AFU samples accompanying this repository.</p> <ol> <li>If not done already, download and clone the below repository.</li> </ol> <pre><code>   cd $OFS_BUILD_ROOT git clone https://github.com/OPAE/intel-fpga-bbb.git\n   git clone https://github.com/OFS/examples-afu.git\n</code></pre> <ol> <li>Install the Basic Building Blocks include files and libraries. </li> </ol> <pre><code>   cd intel-fpga-bbb\n   mkdir build\n   cd build\n   cmake -DCMAKE_INSTALL_PREFIX=/usr ..\n   make\n   make install\n</code></pre> <p>By default, the Basic Building Blocks include and library files will be installed in <code>/usr/local</code>. You can change this installation prefix to another path by adding <code>-DCMAKE_INSTALL_PREFIX=&lt;&lt;custom_path&gt;&gt;</code> to the cmake command, as above. In most cases, you should choose the same prefix for both the OPAE SDK and the Basic Building Blocks.</p> <p>If OPAE and the Basic Building Blocks are installed to standard system directories, such as <code>/usr/</code> and <code>/usr/local</code>, they may already be found on C and C++ header and library search paths. Otherwise, their installation directories must be added explicitly.</p> <p>\u00a0\u00a0\u00a0\u00a0 * Header files from OPAE and BBB must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.</p> <p>\u00a0\u00a0\u00a0\u00a0 * OPAE and BBB libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.</p> <ol> <li>Make sure to set the next environment variables.</li> </ol> <pre><code>  # Set the FPGA_BBB_CCI_SRC variable to the full path of the intel-fpga-bbb directory created in the git clone step above.\n$ export FPGA_BBB_CCI_SRC=$OFS_BUILD_ROOT/examples-afu  # Header files from OPAE and MPF must either be on the default compiler search paths or on both C_INCLUDE_PATH and CPLUS_INCLUDE_PATH.\n$ export C_INCLUDE_PATH=/usr/src/debug/opae-2.3.0-1.el8.x86_64/tests/framework\n\n# OPAE and MPF libraries must either be on the default linker search paths or on both LIBRARY_PATH and LD_LIBRARY_PATH.  \n$ export OPAE_LOC=/usr\n  $ export LIBRARY_PATH=$OPAE_LOC/lib:$LIBRARY_PATH\n$ export LD_LIBRARY_PATH=$OPAE_LOC/lib64:$LD_LIBRARY_PATH\n# OPAE_PLATFORM_ROOT points to a release tree that has been configured with the Platform Interface Manager (PIM).  \n$ export OPAE_PLATFORM_ROOT=$OFS_ROOTDIR/work_d5005/build_tree\n</code></pre> <ol> <li> <p>Compile the <code>hello_word</code> sample AFU.  <pre><code>  $ cd $OFS_ROOTDIR/work_d5005\n  $ afu_synth_setup -s $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/hello_world/hw/rtl/axi/sources.txt hello_world_synth\n  $ cd hello_world_synth\n  $ ${OPAE_PLATFORM_ROOT}/bin/afu_synth\n\n.\n.\n.\nInfo (19538): Reading SDC files took 00:00:06 cumulatively in this process.\nWrote hello_world.gbs\n\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'hello_world.gbs'\nDesign meets timing\n===========================================================================\n</code></pre></p> </li> <li> <p>To test the AFU in actual hardware, load the <code>hello_world.gbs</code> to the Intel\u00ae FPGA PAC D5005 card. For this step to be successful, the Intel\u00ae FPGA PAC D5005 FIM must have already been loaded to the Intel\u00ae FPGA PAC D5005 card following the steps described in Section 2 of this document.</p> </li> </ol> <pre><code>  $ cd $OFS_ROOTDIR/work_d5005/hello_world_synth\n  $ sudo fpgasupdate hello_world.gbs 3b:00.0\n  [sudo] password for &lt;&lt;Your username&gt;&gt;: [2022-12-06 13:25:10.22] [WARNING ] Update starting. Please do not interrupt.\n[2022-12-06 13:25:12.06] [INFO    ] Partial Reconfiguration OK\n[2022-12-06 13:25:12.06] [INFO    ] Total time: 0:00:01.83\n</code></pre> <p>Set up your Intel\u00ae FPGA PAC D5005 board to work with the newly loaded <code>hello_world.gbs</code> file.</p> <pre><code>#  Create the Virtual Functions (VFs):\n$ sudo pci_device 3b:00.0 vf 3\n# Verify:\n$ lspci -s 3b:00\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.1 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.2 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.3 Processing accelerators: Intel Corporation Device bccf (rev 01)\n# Bond VFs to VFIO driver.  Enter &lt;&lt;Your username&gt;&gt;\nsudo opae.io init -d 0000:3b:00.1 &lt;Your username&gt;\n Unbinding (0x8086,0xbcce) at 0000:3b:00.1 from dfl-pci\n Binding (0x8086,0xbccf) at 0000:3b:00.1 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:3b:00.1 is 142\nAssigning /dev/vfio/142 to &lt;Your username&gt;\n Changing permissions for /dev/vfio/142 to rw-rw----\n\nsudo opae.io init -d 0000:3b:00.2 &lt;Your username&gt;\n Unbinding (0x8086,0xbccf) at 0000:3b:00.2 from dfl-pci\n Binding (0x8086,0xbccf) at 0000:3b:00.2 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:3b:00.2 is 143\nAssigning /dev/vfio/143 to &lt;Your username&gt;\n Changing permissions for /dev/vfio/143 to rw-rw----\n\nsudo opae.io init -d 0000:3b:00.3 &lt;Your username&gt;\n Unbinding (0x8086,0xbccf) at 0000:3b:00.3 from dfl-pci\n Binding (0x8086,0xbccf) at 0000:3b:00.3 to vfio-pci\n iommu group for (0x8086,0xbccf) at 0000:3b:00.3 is 144\nAssigning /dev/vfio/144 to &lt;Your username&gt;\n Changing permissions for /dev/vfio/144 to rw-rw----\n\n# &lt; Verify the new AFU is loaded.  The hello_world AFU GUID is \"c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\".\n$ fpgainfo port\n//****** PORT ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x603B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\n//****** PORT ******//\nObject Id                        : 0x403B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : c6aa954a-9b91-4a37-abc1-1d9f0709dcc3\n//****** PORT ******//\nObject Id                        : 0x203B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n</code></pre> <ol> <li>Compile and execute the host application of the <code>hello_world</code> AFU. You should see the application outputs the \"Hello world!\" message in the terminal.</li> </ol> <pre><code>  # Move to the sw directory of the hello_world AFU and run the following commands in user mode\ncd $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/hello_world/sw/\n\nmake\n\n# Launch the host application\n./hello_world\n   Hello world TLP!\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#413-modify-the-afu-user-clocks-frequency","title":"4.1.3. Modify the AFU user clocks frequency","text":"<p>An OPAE compliant AFU specifies the frequency of the <code>uclk_usr</code> and <code>uclk_usr_div2</code> clocks through the JSON file for AFU configuration located under the <code>&lt;afu_example&gt;/hw/rtl</code> directory of an AFU design. For instance, the AFU configuration file of the <code>host_chan_mmio</code> example is <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/host_chan_mmio.json</code>.</p> <p>The AFU specifies the frequency for uClk_usr in its platform configuration file using the following key:value pairs:</p> <pre><code>  \"clock-frequency-high\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n  \"clock-frequency-low\": [&lt;float-value&gt;|\u201dauto\u201d|\u201dauto-&lt;float-value&gt;\u201d]\n</code></pre> <p>These <code>key:value</code> tuples are used to configure the PLL of the target platform that provides the user clocks through the AFU clocks interface. In addition, the specified frequency affects the timing closure process on the user clocks during AFU compilation. </p> <p>Setting the value field to a float number (e.g., 315.0 to specify 315 MHz) drives the AFU generation process to close timing within the bounds set by the low and high values and sets the AFU's JSON metadata to specify the user clock PLL  frequency values.</p> <p>The following example shows the JSON file of the <code>host_chan_mmio</code> to set the AFU uClk to 300 MHz and uClk_div2 to 150 MHz.</p> <pre><code>{\n   \"version\": 1,\n   \"afu-image\": {\n      \"power\": 0,\n      \"clock-frequency-high\": 300,\n      \"clock-frequency-low\": 150,\n      \"afu-top-interface\":\n         {\n            \"class\": \"ofs_plat_afu\"\n         },\n      \"accelerator-clusters\":\n         [\n            {\n               \"name\": \"host_chan_mmio\",\n               \"total-contexts\": 1,\n               \"accelerator-type-uuid\": \"76d7ae9c-f66b-461f-816a-5428bcebdbc5\"\n            }\n         ]\n   }\n}\n</code></pre> <p>Save the changes to <code>host_chan_mmio.json</code> file, then execute the <code>afu_synth_setup</code> script to create a new copy of the AFU files with the modified user clock settigns.</p> <p><pre><code>  $ cd $OFS_ROOTDIR/work_d5005\n  $ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_d5005_afu_clks\n\nLoading platform database: /home/&lt;Your username&gt;/&lt;Your localpath&gt;/ofs-d5005/work_d5005/build_tree/hw/lib/platform/platform_db/ofs_d5005.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting platform/platform_afu_top_config.vh\nWriting platform/platform_if_addenda.qsf\nWriting ../hw/afu_json_info.vh\n</code></pre> Compile the <code>host_chan_mmio</code> AFU with the new frequency values.</p> <pre><code>   cd $OFS_ROOTDIR/work_d5005/build_d5005_afu_clks\n   $OFS_ROOTDIR/work_d5005/build_tree/bin/afu_synth\n</code></pre> <p>During the compilation phase, you will observe the Timing Analyzer uses the specified user clock frequency values as the target to close timing.</p> <p></p> <p>AFU developers must ensure the AFU hardware design meets timing. The compilation of an AFU that fails timing shows a message similar to the following.</p> <pre><code>.\n.\n.\n\nWrote host_chan_mmio.gbs\n\n===========================================================================\nPR AFU compilation complete\nAFU gbs file is 'host_chan_mmio.gbs'\n*** Design does not meet timing\n  *** See build/syn/syn_top/output_files/timing_report\n\n===========================================================================\n</code></pre> <p>The previous output indicates the location of the timing reports for the AFU designer to identify the failing paths and perform the necessary design changes. Next, is a listing of the timing report files from a <code>host_chan_mmio</code> AFU that fails to meet timing after modifying the user clock frequency values.</p> <pre><code>  $ cd $OFS_ROOTDIR/work_d5005/build_d5005_afu_clks\n  $ ls build/syn/syn_top/output_files/timing_report\n\nclocks.rpt  clocks.sta.fail.summary  clocks.sta.pass.summary iofs_pr_afu_2_slow_900mv_0c_recovery.rpt\niofs_pr_afu_2_slow_900mv_0c_setup.rpt\niofs_pr_afu_2_slow_900mv_100c_recovery.rpt\niofs_pr_afu_2_slow_900mv_100c_setup.rpt\niofs_pr_afu_2_slow_vid2_0c_recovery.rpt\niofs_pr_afu_2_slow_vid2_0c_setup.rpt\niofs_pr_afu_2_slow_vid2_100c_recovery.rpt\niofs_pr_afu_2_slow_vid2_100c_setup.rpt\niofs_pr_afu_MIN_fast_900mv_0c_recovery.rpt\niofs_pr_afu_MIN_fast_900mv_0c_setup.rpt\niofs_pr_afu_MIN_fast_900mv_100c_recovery.rpt\niofs_pr_afu_MIN_fast_900mv_100c_setup.rpt\n</code></pre> <p>Warning: AFU developers must inform software developers of the maximum operating frequency (Fmax) of the user clocks to avoid any unexpected behavior of the accelerator and potentially of the overall system.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#5-simulating-an-afu-using-ase","title":"5. Simulating an AFU using ASE","text":"<p>The AFU Simulation Environment (ASE) is a hardware/software co-simulation environment for your AFU. See diagram below illustrating ASE operation:</p> <p></p> <p>ASE uses the simulator Direct Programming Interface (DPI) to provide HW/SW connectivity.  The PCIe connection to the AFU under testing is emulated with a transactional model.</p> <p>The following list describes ASE operation:</p> <ul> <li>Attempts to replicate the transactions that will be seen in real system.</li> <li>Provides a memory model to AFU, so illegal memory accesses can be identified early.</li> <li>Not a cache simulator.</li> <li>Does not guarantee synthesizability or timing closure.</li> <li>Does not model system latency.</li> <li>No administrator privileges are needed to run ASE.  All code is user level.</li> </ul> <p>The remainder of this section is a tutorial providing the steps on how to run ASE with either VCS or QuestaSim using an example AFU and the AFU build tree previously created in this guide.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#51-set-up-steps-to-run-ase","title":"5.1. Set Up Steps to Run ASE","text":"<p>In this section you will set up your server to support ASE by independently downloading and installing OPAE SDK and ASE. Then, set up the required environment variables.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#511-install-opae-sdk","title":"5.1.1. Install OPAE SDK","text":"<p>Follow the instructions documented in the Getting Started Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae FPGA PAC D5005, section 5.0 OPAE Software Development Kit to build and install the required OPAE SDK for the Intel\u00ae FPGA PAC D5005 PAC card.</p> <p>The Intel\u00ae FPGA PAC D5005 PAC card requires opae-2.3.0-1. Follow the instructions provided in the Getting Started Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae FPGA PAC D5005 section 5.0 OPAE Software Development Kit. However, just make sure to check out the cloned repository to tag 2.3.0-1 and branch release/2.3.0.</p> <pre><code>git checkout tags/2.3.0-1 -b release/2.3.0\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#512-install-ase-tools","title":"5.1.2 Install ASE Tools","text":"<p>ASE is an RTL simulator for OPAE-based AFUs. The simulator emulates both the OPAE SDK software user space API and the AFU RTL interface. The majority of the FIM as well as devices such as PCIe and local memory are emulated with simple functional models.</p> <p>ASE must be installed separatedly from the OPAE-SDK. However, the recommendation is to install it in the same target directory as OPAE-SDK.</p> <ol> <li> <p>If not done already, set the environment variables as described in section, Set Up AFU Development Environment.</p> </li> <li> <p>Clone the <code>ase-sim</code> repository.</p> </li> </ol> <p><pre><code>  $ cd $OFS_BUILD_ROOT\n$ git clone ${{ env.D5005_url_opae-sim }\n$ cd opae-sim  </code></pre> 2. Building ASE requires the include file <code>mock/opae_std.h</code>. If the OPAE-SDK was installed under the default system directories, the C_INCLUDE_PATH variable must be set as follows. </p> <pre><code>export C_INCLUDE_PATH=\"/usr/src/debug/opae-${{ env.D5005_OPAE_VER }.el8.x86_64/tests/framework\"\n</code></pre> <ol> <li>Create a build directory and build ASE to be installed under the default system directories along with OPAE SDK.</li> </ol> <pre><code>   mkdir build\n   cd build\n   cmake  -DCMAKE_INSTALL_PREFIX=/usr ..\n   make\n</code></pre> <p>Optionally, if the desire is to install ASE binaries in a different location to the system's default, provide the path to CMAKE through the CMAKE_INSTALL_PREFIX switch, as follows.</p> <pre><code>   cmake -DCMAKE_INSTALL_PREFIX=&lt;&lt;/some/arbitrary/path&gt;&gt; ..  </code></pre> <ol> <li>Install ASE binaries and libraries under the system directory <code>/usr</code>.</li> </ol> <pre><code>   sudo make install  </code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#513-setup-required-ase-environment-variables","title":"5.1.3. Setup Required ASE Environment Variables","text":"<p>The values set to the following environment variables assume the OPAE SDK and ASE were installed in the default system directories below <code>/usr</code>. Setup these variables in the shell where ASE will be executed. You may wish to add these variables to the script you created to facilitate configuring your environment.</p> <pre><code>   cd /usr/bin\n   export PATH=$PWD:$PATH\ncd ../lib/python*/site-packages\n   export PYTHONPATH=$PWD\ncd /usr/lib\n   export LIBRARY_PATH=$PWD\ncd /usr/lib64\n   export LD_LIBRARY_PATH=$PWD\ncd $OFS_BUILD_ROOT/ofs-platform-afu-bbb\n   export OFS_PLATFORM_AFU_BBB=$PWD\ncd $OFS_ROOTDIR/work_d5005/build_tree\n   export OPAE_PLATFORM_ROOT=$PWD\n## For VCS, set the following:\nexport VCS_HOME=&lt;Set the path to VCS installation directory&gt;\n   export PATH=$VCS_HOME/bin:$PATH\n## For QuestaSIM, set the following:\nexport MTI_HOME=&lt;path to Modelsim installation directory&gt;\n   export PATH=$MTI_HOME/linux_x86_64/:$MTI_HOME/bin/:$PATH\n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#52-simulating-the-host_chan_mmio-afu","title":"5.2. Simulating the host_chan_mmio AFU","text":"<p>The <code>$OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio</code> is a simple example demonstrating both hardware and software access to an AFU. The <code>host_chan_mmio</code> example AFU consists of the following files:</p> <pre><code>host_chan_mmio\n\u251c\u2500\u2500 hw\n\u2502   \u2514\u2500\u2500 rtl\n\u2502       \u251c\u2500\u2500 avalon\n\u2502       \u2502   \u251c\u2500\u2500 afu_avalon512.sv\n\u2502       \u2502   \u251c\u2500\u2500 afu_avalon.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_avalon512.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_avalon_from_ccip.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_avalon_from_axi.sv\n\u2502       \u2502   \u2514\u2500\u2500 ofs_plat_afu_avalon.sv\n\u2502       \u251c\u2500\u2500 axi\n\u2502       \u2502   \u251c\u2500\u2500 afu_axi512.sv\n\u2502       \u2502   \u251c\u2500\u2500 afu_axi.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_axi512.sv\n\u2502       \u2502   \u251c\u2500\u2500 ofs_plat_afu_axi_from_ccip.sv\n\u2502       \u2502   \u2514\u2500\u2500 ofs_plat_afu_axi.sv\n\u2502       \u251c\u2500\u2500 host_chan_mmio.json\n\u2502       \u251c\u2500\u2500 test_mmio_avalon0_from_ccip.txt\n\u2502       \u251c\u2500\u2500 test_mmio_avalon1.txt\n\u2502       \u251c\u2500\u2500 test_mmio_avalon2_512rw.txt\n\u2502       \u251c\u2500\u2500 test_mmio_axi0_from_ccip.txt\n\u2502       \u251c\u2500\u2500 test_mmio_axi1.txt\n\u2502       \u2514\u2500\u2500 test_mmio_axi2_512rw.txt\n\u2514\u2500\u2500 sw\n    \u251c\u2500\u2500 main.c\n    \u251c\u2500\u2500 Makefile\n</code></pre> <p>This example AFU contains examples using both Avalon and AXI interface buses. This guide will use the AXI version of the <code>host_chan_mmio</code> AFU.</p> <p>ASE uses client-server application architecture to deliver hardware/software co-simulation.  You require one shell for the hardware based simulation and another shell where the software application is running. The hardware is started first with a simulation compilation and simulator startup script, once the simulator has loaded the design, it will wait until the software process starts. Once the software process starts, the simulator proceeds.  Transaction logging and waveform capture is performed.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#521-set-up-and-run-the-hw-simulation-process","title":"5.2.1 Set Up and Run the HW Simulation Process","text":"<p>You will run the <code>afu_sim_setup</code> script to create the scripts for running the ASE environment.  The <code>afu_sim_setup</code> script has the following usage:</p> <pre><code>usage: afu_sim_setup [-h] -s SOURCES [-p PLATFORM] [-t {VCS,QUESTA,MODELSIM}]\n                     [-f] [--ase-mode ASE_MODE] [--ase-verbose]\n                     dst\n\nGenerate an ASE simulation environment for an AFU. An ASE environment is\ninstantiated from the OPAE installation and then configured for the specified\nAFU. AFU source files are specified in a text file that is parsed by\nrtl_src_config, which is also part of the OPAE base environment.\n\npositional arguments:\n  dst                   Target directory path (directory must not exist).\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s SOURCES, --sources SOURCES\n                        AFU source specification file that will be passed to\n                        rtl_src_config. See \"rtl_src_config --help\" for the\n                        file's syntax. rtl_src_config translates the source\n                        list into either Quartus or RTL simulator syntax.\n  -p PLATFORM, --platform PLATFORM\n                        FPGA Platform to simulate.\n  -t {VCS,QUESTA,MODELSIM}, --tool {VCS,QUESTA,MODELSIM}\n                        Default simulator.\n  -f, --force           Overwrite target directory if it exists.\n  --ase-mode ASE_MODE   ASE execution mode (default, mode 3, exits on\n                        completion). See ase.cfg in the target directory.\n  --ase-verbose         When set, ASE prints each CCI-P transaction to the\n                        command line. Transactions are always logged to\n                        work/ccip_transactions.tsv, even when not set. This\n                        switch sets ENABLE_CL_VIEW in ase.cfg.\n</code></pre> <p>Run <code>afu_sim_setup</code> to create the ASE simulation environment for the <code>host_chan_mmio</code> example AFU. The <code>'-t VCS'</code> option indicates to prepare the ASE simulation environment for VCS.</p> <pre><code>cd $OFS_ROOTDIR/work_d5005/\n\nafu_sim_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt -t VCS host_chan_mmio_sim\n\nCopying ASE from /opae-sdk/install-opae-sdk/share/opae/ase...\nCopying ASE from /usr/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\n\nTool Brand: VCS\nLoading platform database: /home/&lt;Your username&gt;/&lt;Your localpath&gt;/ofs-d5005/work_d5005/build_tree/hw/lib/platform/platform_db/ofs_d5005.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> creates the ASE scripts in the directory <code>host_chan_mmio_sim</code> where the <code>afu_sim_setup</code> script was run.  Start the simulator as shown below in user mode:</p> <pre><code>   cd host_chan_mmio_sim\n   make\n   make sim\n</code></pre> <p>This process launches the AFU hardware simulator. Before moving to the next section, pay attention to the simulator output highlighted in the image below.</p> <p></p> <p>The simulation artifacts are stored in host_chan_mmio/work and consist of:</p> <pre><code>log_ase_events.tsv\nlog_ofs_plat_host_chan.tsv \nlog_ofs_plat_local_mem.tsv \nlog_pf_vf_mux_A.tsv \nlog_pf_vf_mux_B.tsv \n</code></pre>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#522-set-up-and-run-the-sw-process","title":"5.2.2 Set Up and Run the SW Process","text":"<p>Open an additional shell to build and run the host application that communicates with the actual AFU hardware. Set up the same environment variable you have set up in the shell you have been working on until this point. </p> <p>Additionally, as indicated by the hardware simulator output that is currently executing in the \"simulator shell\", copy and paste the line <code>\"export ASE_WORKDIR=...\"</code>, into the new \"software shell\". See the last image of the previous section.</p> <p><pre><code>   export ASE_WORKDIR= &lt;&lt;as directed in HW simulation shell&gt;&gt;\n</code></pre> Then, go to the sw directory of the <code>host_chan_mmio</code> AFU example to compile the host application.</p> <pre><code>cd $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/sw  make\n\nafu_json_mgr json-info --afu-json=../hw/rtl/host_chan_mmio.json --c-hdr=obj/afu_json_info.h\nWriting obj/afu_json_info.h\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c main.c -o obj/main.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c test_host_chan_mmio.c -o obj/test_host_chan_mmio.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/connect.c -o obj/connect.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/csr_mgr.c -o obj/csr_mgr.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/hash32.c -o obj/hash32.o\ncc -g -O2 -std=gnu99 -fstack-protector -fPIE -fPIC -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -I../../common/sw -I./obj -c ../../common/sw/test_data.c -o obj/test_data.o\ncc -o host_chan_mmio obj/main.o obj/test_host_chan_mmio.o obj/connect.o obj/csr_mgr.o obj/hash32.o obj/test_data.o  -z noexecstack -z relro -z now -pie -luuid -lopae-c\n</code></pre> <p>Now, launch the host application to exercise the AFU hardware running on the simulator shell. The next image shows the AFU hardware simulation process on the left side shell. The right hand shell shows the host application's output of a successful simulation.</p> <p></p> <p>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</p> <pre><code>   make wave\n</code></pre> <p>This brings up the VCS simulator GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the afu instance located under, <code>ase_top | ase_top_plat | ofs_plat_afu | afu</code> , as shown below.</p> <p></p> <p>Right click on the <code>afu (afu)</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#53-simulating-the-hello_world-afu","title":"5.3 Simulating the hello_world AFU","text":"<p>In this section, you will quickly simulate the PIM-based <code>hello_world</code> sample AFU accompanying the example_afu repository.</p> <ol> <li> <p>Set the environment variables as described in section 5.1. Set Up Steps to Run ASE.</p> </li> <li> <p>Prepare an RTL simulation environment for the AXI version of the <code>hello_world</code> AFU.</p> <p>Simulation with ASE requires two software processes, one to simulate the AFU RTL and the other to run the host software that exercises the AFU. To construct an RTL simulation environment under the directory <code>$OFS_ROOTDIR/work_d5005</code>, execute the following.</p> <pre><code>  $ cd $OFS_ROOTDIR/work_d5005\n  $ afu_sim_setup -s $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/hello_world/hw/rtl/axi/sources.txt -t VCS hello_world_sim\n\nCopying ASE from /usr/local/share/opae/ase...\n#################################################################\n#                                                               #\n#             OPAE Intel(R) Xeon(R) + FPGA Library              #\n#               AFU Simulation Environment (ASE)                #\n#                                                               #\n#################################################################\nTool Brand: VCS\nLoading platform database: /home/&lt;Your username&gt;/&lt;Your localpath&gt;/ofs-d5005/work_d5005/build_tree/hw/lib/platform/platform_db/ofs_d5005.json\nLoading platform-params database: /usr/share/opae/platform/platform_db/platform_defaults.json\nLoading AFU database: /usr/share/opae/platform/afu_top_ifc_db/ofs_plat_afu.json\nWriting rtl/platform_afu_top_config.vh\nWriting rtl/platform_if_addenda.txt\nWriting rtl/platform_if_includes.txt\nWriting rtl/ase_platform_name.txt\nWriting rtl/ase_platform_config.mk and rtl/ase_platform_config.cmake\nASE Platform: discrete (FPGA_PLATFORM_DISCRETE)\n</code></pre> <p>The <code>afu_sim_setup</code> script constructs an ASE environment in the <code>hello_world_sim</code> subdirectory. If the command fails, confirm that the path to the afu_sim_setup is on your PATH environment variable (in the OPAE SDK bin directory) and that your Python version is at least 3.7.</p> </li> <li> <p>Build and execute the AFU RTL simulator in user mode.</p> <pre><code>   cd $OFS_ROOTDIR/work_d5005/hello_world_sim\n   make\n   make sim  </code></pre> <p>The previous commands will build and run the VCS RTL simulator, which prints a message saying it is ready for simulation. The simulation process also prints a message instructing you to set the ASE_WORKDIR environment variable in a second shell.</p> </li> <li> <p>Open a second shell where you will build and execute the host software. In this new \"software shell\", set up the environment variables you have set up so far in the \"hardware simulation\" shell.</p> </li> <li> <p>Also, set the ASE_WORKDIR environment variable following the instructions given in the \"hardware simulation\" shell.</p> </li> </ol> <p><pre><code>export ASE_WORKDIR=$OFS_ROOTDIR/work_d5005/hello_world_sim/work\n</code></pre>   6. Then, move to the sw directory of the <code>hello_world</code> AFU sample to build the host software.</p> <pre><code>cd $FPGA_BBB_CCI_SRC/examples-afu/tutorial/afu_types/01_pim_ifc/hello_world/sw\n   make      </code></pre> <ol> <li>Run the <code>hello_world</code> host application to resume the work of the RTL simulation. The host software process and the RTL simulation execute in lockstep. If successful, you should see the Hello world! output.</li> </ol> <pre><code>  $ with_ase ./hello_world\n\n[APP]  Initializing simulation session ...\nHello world!\n  [APP]  Deinitializing simulation session\n  [APP]         Took 43,978,424 nsec\n  [APP]  Session ended\n</code></pre> <p>The image below shows the simulation of the AFU hardware and the execution of the host application side-by-side.</p> <p></p> <p></p> <p></p> <ol> <li>Finally, on the hardware simulation shell, you can view the wave forms by invoking the following command.</li> </ol> <pre><code>   make wave\n</code></pre> <p>This brings up the DVE GUI and loads the simulation waveform files. Use the Hierarchy window to navigate to the AFU instance located under, <code>ase_top | ase_top_plat | ofs_plat_afu</code>, as shown below.</p> <p></p> <p>Right click on the <code>ofs_plat_afu</code> entry to display the drop-down menu. Then, click on <code>Add to Waves | New Wave View</code> to display the following waveforms window.</p> <p> </p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#6-adding-remote-signal-tap-logic-analyzer-to-debug-the-afu","title":"6. Adding Remote Signal Tap Logic Analyzer to debug the AFU","text":"<p>The OPAE SDK provides a remote Signal Tap facility. It also supports the following in system debug tools included with the Intel\u00ae  Intel\u00ae Quartus\u00ae Prime Pro Edition:</p> <ul> <li>In-system Sources and Probes</li> <li>In-system Memory Content Editor</li> <li>Signal Probe</li> <li>System Console</li> </ul> <p>This section is a short guide on adding remote Signal Tap instances to an AFU for in-system debugging. In order of execution, you can follow the steps in the following sections to create an instrumented AFU. The host_chan_mmio AFU is used in this guide as the target AFU to be instrumented.</p> <p>You need a basic understanding of Signal Tap. Please see the Signal Tap Logic Analyzer: Introduction &amp; Getting Started Web-Based Training for more information.</p> <p>You will run with a Signal Tap GUI running locally on the server with the Intel\u00ae FPGA PAC D5005 as shown below:</p> <p></p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#61-adding-rstp-to-the-host_chan_mmio-afu","title":"6.1. Adding RSTP to the host_chan_mmio AFU","text":"<p> RSTP is added to an AFU by:</p> <ol> <li>Defining signals to be instrumented in Signal Tap. Create a new *.stp file.</li> <li>Modify ofs_top.qpf to include the new *.stp file</li> <li>Modify ofs_top.qsf</li> <li>Modify ofs_pr_afu.qsf </li> <li>Re-run afu_synth_setup to update project settings</li> <li>Re-run $OPAE_PLATFORM_ROOT/bin/afu_synth to build the PR -able image containing the RSTP instance</li> </ol> <p>The following steps use the previously built host_chan_mmio AFU example. You can use these detailed steps to instrument your AFU.</p> <ol> <li>Navigate to host_chan_mmio AFU Quartus project and open the project using Quartus GUI.</li> </ol> <pre><code> cd $OFS_ROOTDIR/work_d5005/build_d5005_x16/build/syn/syn_top\n $ quartus d5005.qpf &amp;\n</code></pre> <ol> <li>Once the project is loaded in Quartus, review the project hierarchy as shown in the Project Navigator. This example will add Signal Tap probe points to the AFU region. Reviewing the code will give insight into the function of this block. You can up the code in the Project Navigator by expanding afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu, right-click, select Locate Node - Locate in Design File as shown below.</li> </ol> <p></p> <ol> <li> <p>Bring up Signal Tap to create the *.stp file. In the Quartus GUI, go to Tools - Signal Tap Logic Analyzer. Click <code>Create</code> to accept the default template in the New File from Template pop-up. The Signal Tap Logic Analyzer window comes up.</p> </li> <li> <p>Set up the clock for the Signal Tap logic instance by clicking <code>...</code> button as shown below:</p> </li> </ol> <p> 5. The Node Finder comes up, and you will click <code>...</code> as shown below to bring up the hierarchy navigator or copy-paste the following location at <code>Look in</code>:</p> <pre><code>iofs_top|afu_top|port_gasket|pr_slot|afu_main|ofs_plat_afu|afu\n</code></pre> <p></p> <ol> <li> <p>In the Select Hierarchy Level, navigate to top - afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu and click <code>Ok</code>.</p> </li> <li> <p>Enter <code>*clk*</code> in the <code>Named:</code> box and click <code>Search</code>.  This brings up matching terms.  Click <code>mmio64_if.clk</code> and <code>&gt;</code>.  Verify your Node Finder is as shown below and then click <code>Ok</code>:    </p> </li> <li> <p>Double click the <code>Double-click to add nodes</code> and once again, click <code>...</code> and navigate to top - afu_top - port_gasket - pr_slot - afu_main - ofs_plat_afu, then select instance afu and click <code>Ok</code>.  Enter <code>mmio64</code> then click <code>&gt;&gt;</code> to add these signals to the STP instance as shown below:     </p> <p>Then click <code>Insert</code> and <code>Close</code>.</p> </li> <li> <p>Save the newly created STP by clicking <code>File - Save As</code> in the save as navigate to $OFS_ROOTDIR/work_d5005/build_d5005_x16/build/syn/syn_top and save the STP file as <code>host_chan_mmio.stp</code> as shown below:       </p> </li> <li>Edit <code>ofs_top.qsf</code> to add host_chan_mmio.stp file and enable STP.  Open $OFS_ROOTDIR/work_d5005/build_d5005_x16/build/syn/syn_top/d5005.qpf in an editor and modify lines as shown below:</li> </ol> <pre><code>set_global_assignment -name ENABLE_SIGNALTAP ON\nset_global_assignment -name USE_SIGNALTAP_FILE host_chan_mmio.stp\nset_global_assignment -name SIGNALTAP_FILE host_chan_mmio.stp\n</code></pre> <p>Save the d5005.qpf and close Quartus.</p> <ol> <li>Edit <code>iofs_pr_afu.qsf</code> to add host_chan_mmio.stp file and enable STP.  Open $OPAE_PLATFORM_ROOT/hw/lib/build/syn/syn_top/iofs_pr_afu.qsf in an editor and ensure the lines are included as  below (note: the verilog macro <code>INCLUDE_REMOTE_STP</code> will already be present), also copy and paste the file <code>host_chan_mmio.stp</code> in this location:</li> </ol> <p>The updated lines are: <pre><code>set_global_assignment -name VERILOG_MACRO \"INCLUDE_REMOTE_STP\"\nset_global_assignment -name ENABLE_SIGNALTAP ON\nset_global_assignment -name USE_SIGNALTAP_FILE host_chan_mmio.stp\nset_global_assignment -name SIGNALTAP_FILE host_chan_mmio.stp\n</code></pre> Save the iofs_pr_afu.qsf and ensure Quartus is closed.</p> <ol> <li>The afu_synth script is run to create a new copy of AFU files. In your original build shell, enter the following commands:</li> </ol> <pre><code>    $ cd $OFS_ROOTDIR/build_d5005_x16\n    $ afu_synth_setup -s $OFS_PLATFORM_AFU_BBB/plat_if_tests/host_chan_mmio/hw/rtl/test_mmio_axi1.txt build_d5005_x16_stp\n\n    Notice that your previous build_d5005_x16_stp directory is preserved, and a new build_d5005_x16_stp directory is created. You will use build_d5005_x16_stp to build the STP-enabled image.\n\n    $ cd build_d5005_x16_stp\n    $ $OPAE_PLATFORM_ROOT/bin/afu_synth\n\n...\n...\nWrote host_chan_mmio.gbs\n\n===========================================================================\n PR AFU compilation complete\n AFU gbs file is 'host_chan_mmio.gbs'\n  Design meets timing\n===========================================================================\n</code></pre> <ol> <li>Once compilation completes, the new host_chan_mmio.gbs file that contains the Signal Tap instance can be loaded.</li> </ol> <pre><code>$ sudo fpgasupdate host_chan_mmio.gbs 3b:00.0\n[sudo] password for &lt;myuser&gt;: \n[WARNING ] Update starting. Please do not interrupt.\n [INFO    ] \nPartial Reconfiguration OK\n[INFO    ] Total time: 0:00:01.87\n</code></pre> <ol> <li>Use the OPAE SDK mmlink tool to create a TCP/IP connection to your Intel\u00ae Stratix 10\u00ae FPGA card under test. The mmlink command has the following format:</li> </ol> <pre><code>Usage:\nmmlink\n&lt;Segment&gt;             --segment=&lt;SEGMENT NUMBER&gt;\n&lt;Bus&gt;                 --bus=&lt;BUS NUMBER&gt;           OR  -B &lt;BUS NUMBER&gt;\n&lt;Device&gt;              --device=&lt;DEVICE NUMBER&gt;     OR  -D &lt;DEVICE NUMBER&gt;\n&lt;Function&gt;            --function=&lt;FUNCTION NUMBER&gt; OR  -F &lt;FUNCTION NUMBER&gt;\n&lt;Socket-id&gt;           --socket-id=&lt;SOCKET NUMBER&gt;  OR  -S &lt;SOCKET NUMBER&gt;\n&lt;TCP PORT&gt;            --port=&lt;PORT&gt;                OR  -P &lt;PORT&gt;\n&lt;IP ADDRESS&gt;          --ip=&lt;IP ADDRESS&gt;            OR  -I &lt;IP ADDRESS&gt;\n&lt;Version&gt;             -v,--version Print version and exit\n</code></pre> <p>ProTip: </p> <p>Open a new shell session for mmlink; this console needs to remain open to allow mmlink connection.</p> <p>Enter the command below to create a connection using port 3333:</p> <pre><code>$ sudo mmlink -P 3333 -B 0x3b\n\n------- Command line Input START ----\n\nSocket-id             : -1\n Port                  : 3333\nIP address            : 0.0.0.0\n ------- Command line Input END   ----\n\nPORT Resource found.\nServer socket is listening on port: 3333\n</code></pre> <p>Leave this shell open with the mmlink connection.</p> <ol> <li>In this step, you will open a new shell and enable JTAG over protocol. You must have Quartus Prime Pro \u00ae  22.3 Programmer loaded on the Intel\u00ae FPGA PAC D5005 server for local debugging.</li> </ol> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/127.0.0.1:3333/0\n\nVerify connectivity with jtagconfig --debug\n\n$ jtagconfig --debug\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/127.0.0.1:3333/0]\n(JTAG Server Version 22.3.0 Build 104 09/14/2022 SC Pro Edition)\n020D10DD   VTAP10 (IR=10)\nDesign hash    D41D8CD98F00B204E980\n    + Node 00406E00  Virtual JTAG #0\nCaptured DR after reset = (020D10DD) [32]\nCaptured IR after reset = (155) [10]\nCaptured Bypass after reset = (0) [1]\nCaptured Bypass chain = (0) [1]\n</code></pre> <ol> <li>Start Quartus Signal Tap GUI, connect to target, load stp file by navigating to  $OPAE_PLATFORM_ROOT/hw/lib/build/syn/syn_top/ . The Quartus Signal Tap must be the same version of Quartus used to compile the host_chan_mmio.gbs. Quartus Prime Pro \u00ae  22.3 Pro is used in the steps below:</li> </ol> <pre><code>cd $OPAE_PLATFORM_ROOT/hw/lib/build/syn/syn_top/\nquartus_stpw host_chan_mmio.stp\n</code></pre> <p>This command brings up Signal Tap GUI. Connect to the Signal Tap over protocol by selecting the <code>Hardware</code> button on the right side of the GUI and clicking the \"Please Select\" pull-down as shown below:</p> <p></p> <p>JTAG  over protocol selected:</p> <p></p> <p>This connection process will take approximately 2-3 minutes for the Signal Tap instance to indicate \"Ready to acquire\".</p> <p>8) Set the trigger condition for a rising edge on signal <code>valid</code> signal. 9) In the Signal Tap window, enable acquisition by pressing key <code>F5</code>. The Signal Tap GUI will indicate \"Acquisition in progress\". Run the hello_world application and observe that the Signal Tap instance has triggered. You should see signals being captured in the Signaltap GUI.</p> <p>See captured image below:</p> <p></p> <p>To end your Signal Tap session, close the Signal Tap GUI, then in the mmlink shell, enter <code>ctrl c</code> to kill the mmlink process.</p>"},{"location":"hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others.   </p> <p>example AFUs</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/","title":"Intel\u00ae FPGA Interface Manager Developer Guide: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#1-introduction","title":"1. Introduction","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#11-about-this-document","title":"1.1. About This Document","text":"<p>This document serves as a design guide for FPGA developers, system architects and hardware developers using OFS as a starting point for the creating the FPGA Interface Manager (FIM) for a custom FPGA acceleration board or Platform with Intel FPGAs.</p> <p>This development guide is organized as follows: </p> <ul> <li>Introduction</li> <li>Top Level Block Diagram description</li> <li>Control and data flow</li> <li>Description of Subsystems</li> <li>Command/status registers (CSR) and software interface</li> <li>Clocking, resets and interfaces</li> <li>High speed interface (HSSI)</li> <li>External attached memory</li> <li>High Level development flow description</li> <li>Installation of OFS RTL and development packages</li> <li>Compiling FIM</li> <li>Simulation  </li> <li>Demonstration steps illustrating how to change areas of the design</li> <li>Debugging using JTAG</li> </ul> <p>This document uses the Intel\u00ae FPGA PAC D5005 as an example platform to illustrate key points and demonstrate how to extend the capabilities provided in OFS (Open FPGA Stack) to custom platforms. The demonstration steps serves as a tutorial for the development of your OFS knowledge.</p> <p>This document covers OFS architecture lightly.  For more details on the OFS architecture, please see Open FPGA Stack Technical Reference Manual.</p> <p>You are encouraged to read OFS AFU Development Guide to fully understand how AFU Developers will use your newly developed FIM.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#glossary","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#12-introduction","title":"1.2. Introduction","text":"<p>Open FPGA Stack (OFS) addresses the scalability for FPGA acceleration boards and workloads by providing a powerful and systematic methodology for the rapid development of FPGA-based Acceleration systems.  This methodology addresses the key challenges of hardware, software and workload developers by providing a complete FPGA project consisting of RTL and simulation code, build scripts and software. The FPGA project released in OFS can be rapidly customized to meet new market requirements by adding new features, custom IPs and Intel interface subsystems IPs. </p> <p>A high-level overview of the OFS Intel\u00ae Stratix 10\u00ae FPGA hardware architecture on the Intel\u00ae Stratix 10\u00ae FPGA reference platform, Intel\u00ae FPGA PAC D5005 is shown in the below figure. The provided FPGA architecture is divided into two main components     - The outer area in white, the FPGA Interface manager (or FIM)    - The inner area in green, the Acceleration Function Unit or AFU Region. </p> <p>The outer area, the FIM, provides the core infrastructure and interfaces within the FPGA. The AFU region is where a user\u2019s custom logic would reside for their specific workload.    * FPGA external interfaces and IP cores (e.g. Ethernet, DDR-4, PCIe, etc)   * PLLs/resets   * FPGA - Board management infrastructure   * Interface to Acceleration Function Unit (AFU)</p> <p>The AFU region has both static and dynamic partial reconfiguration regions enabling a lot of customization.    * Uses the FIM interfaces to perform useful work inside the FPGA   * Contains logic supporting partial reconfiguration   * Remote Signal Tap core for remote debugging of workload</p> <p>Outside of the FPGA is the Board Management Controller which provides board management, root of trust, board monitoring, and remote system updates. </p> <p>The overall architecture is built to be very composable and modular in blocks that can be modified while leaving the rest of the infrastructure intact so you may only need to modify a few of these blocks. </p> <p></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#12-release-capabilities","title":"1.2. Release Capabilities","text":"<p>This release of OFS FIM supports the following key features:</p> <ul> <li>1 - Host channel interface via PCIe Gen 3 x 16 SRIOV (1PF, 3 VF, AXI-S TLP packets)</li> <li>DDR4 SDRAM External memory interface (AXI-M)</li> <li>1 - 10G Ethernet interfaces (1x10G)</li> <li>MSI-X Interrupts (PF, VF)</li> <li>1 - AFU</li> <li>Exercisers demonstrating PCIe, external memory and Ethernet interfaces</li> <li>Port, FME CSR</li> <li>Remote Signal Tap</li> </ul> <p>OFS is extensible to meet the needs of a broad set of customer applications, however not all use cases are easily served.  The general uses cases listed below are examples where the OFS base design can be easily re-used to build a custom FIM: 1. Use OFS reference design as-is     - Porting the code to another platform that is identical to the OFS reference platform only changing target FPGA device and pinout     - Change I/O assignments without changing design 2. Update the configuration of peripheral IP in OFS reference design, not affecting FIM architecture     - External memory settings     - HSSI analog settings 3. Remove/update peripheral feature in OFS reference design, not affecting FIM architecture     - External memory speed/width change     - Change 10G Ethernet to 25 or 100G Ethernet IP     - Change number of VFs supported 4. Add new features as an extension to OFS reference design, not affecting FIM architecture     - Add/remove external memory interface to the design     - Add/remove user clocks for AFU     - Add/remove IP to the design with connection to AFU</p> <p>More advanced use cases requiring changes or additions to the host PCIe channel are not easily supported with this release of the OFS FIM.</p> <p>Reuse of the provided host management FPGA logic and software is the fastest and most simple approach to FIM customization.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#13-prerequisites","title":"1.3. Prerequisites","text":""},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#131-base-knowledge-and-skills-prerequisites","title":"1.3.1. Base Knowledge and Skills Prerequisites","text":"<p>OFS is an advanced application of FPGA technology. This guide assumes you have the following FPGA logic design-related knowledge and skills:</p> <ul> <li>FPGA compilation flows using Intel\u00ae Quartus\u00ae Prime Pro Edition design flow.</li> <li>Static Timing closure, including familiarity with the Timing Analyzer tool in Intel\u00ae Quartus\u00ae Prime Pro Edition, applying timing constraints, Synopsys* Design Constraints (.sdc) language and Tcl scripting, and design methods to close on timing critical paths.</li> <li>RTL and coding practices for FPGA implementation.</li> <li>RTL simulation tools.</li> <li>Intel\u00ae Quartus\u00ae Prime Pro Edition Signal Tap Logic Analyzer tool software.</li> </ul>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#132-development-environment","title":"1.3.2. Development Environment","text":"<p>To run the tutorial steps in this guide requires this development environment:</p> Item Version Intel Quartus Prime Pro Intel Quartus Prime Pro 22.3 (with license patch) Target D5005 Sever Operating System RHEL 8.2 OPAE SDK 2.3.0-1  Linux DFL ofs-2022.3-2 Python 3.7.7 cmake 3.11.4 GCC 7.2.0 perl 5.8.8 <p>The following server and Intel PAC card are required to run the examples in this guide:</p> <ol> <li>Qualified Intel Xeon \u00ae server see Qualified Servers.</li> <li>Intel\u00ae FPGA PAC D5005 with root entry hash erased (Please contact Intel for root entry hash erase instructions).  The standard Intel\u00ae FPGA PAC D5005 card is programmed to only allow the FIM binary files signed by Intel to be loaded.  The root entry hash erase process will allow newly created, unsigned FIM binary files to be loaded.</li> <li>Intel\u00ae FPGA PAC D5005 installed in the qualified server following instructions in OFS Getting Started User Guide.</li> </ol> <p>The steps included in this guide have been verified in the Dell R740 and HPE ProLiant DL380 Gen10 servers.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#2-high-level-description","title":"2. High Level Description","text":"<p>The FIM targets operation in the Intel\u00ae FPGA PAC D5005 card.  The block diagram of the D5005 is shown below:</p> <p></p> <p>The key D5005 FPGA interfaces are:</p> <ul> <li>Host interface <ul> <li>PCIe Gen3 x 16</li> </ul> </li> <li>Network interface</li> <li>2 - QSFP28 cages</li> <li>Current FIM supports 1 x 10 GbE, other interfaces can be created  </li> <li>External Memory</li> <li>2 or 4 channels of DDR4-2400 to RDIMM modules</li> <li>RDIMM modules =  8GB organized as 1 Gb X 72</li> <li>Board Management</li> <li>SPI interface</li> <li>FPGA configuration</li> </ul>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#21-fpga-interface-manager-overview","title":"2.1. FPGA Interface Manager Overview","text":"<p>The FPGA Interface Manager architecture is shown in the below diagram:</p> <p></p> <p>The FIM consists of the following components    - PCIe Subsystem    - Memory Subsystem    - HSSI Subsystem    - Platform Management Component Intercommunications (PMCI)     - Board Peripheral Fabric (BPF)     - AFU Peripheral Fabric (APF)    - Port Gasket    - AXI-S PF/VF Demux/Mux    - Host Exerciser Modules - HE-MEM, HE-LB, HE-HSSI    - FPGA Management Engine (FME)</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#22-fim-fpga-resource-usage","title":"2.2. FIM FPGA Resource Usage","text":"<p>The FIM uses a small portion of the available FPGA resources.  The table below shows resource usage for a base FIM built with 2 channels of external memory, a small AFU instantiated that has host CSR read/write, external memory test and Ethernet test functionality.</p> <p></p> Entity ALMs Used % ALMS Used M20Ks % M20Ks used DSP Blocks Pins IOPLLs OFS_top 125009.4 13.0% 661 5.4% 0 630 15 afu_top 70522.7 7.0% 228 2.4% 0 0 1 auto_fab_0 1305.7 0.0% 9 0.1% 0 0 0 bpf_rsv_5_slv 0.6 0.0% 0 0.0% 0 0 0 bpf_rsv_6_slv 0.6 0.0% 0 0.0% 0 0 0 bpf_rsv_7_slv 0.4 0.0% 0 0.0% 0 0 0 bpf 241.9 0.0% 0 0.0% 0 0 0 emif_top_inst 10508.6 1.0% 0 0.0% 0 0 12 eth_ac_wrapper 6024.8 0.5% 9 0.1% 0 0 0 fme_top 615.5 0.2% 7 0.1% 0 0 0 pcie_wrapper 35424.7 3.5% 348 2.9% 0 0 1 pmci_top 318.5 0.1% 0 0.0% 0 0 0 rst_ctrl 40.2 0.0% 0 0.0% 0 0 0 sys_pll 0.5 0.0% 0 0.0% 0 0 1 Total ALMS 933,120 Total M20Ks 11,721 Summary FPGA Resource Utilization Logic utilization (in ALMs) 124,092 / 933,120 ( 13 % ) Total dedicated logic registers 282822 Total pins 630 / 912 ( 69 % ) Total block memory bits 3,425,120 / 240,046,080 ( 1 % ) Total RAM Blocks 661 / 11,721 ( 6 % ) Total DSP Blocks 0 / 5,760 ( 0 % ) Total eSRAMs 0 / 75 ( 0 % ) Total HSSI P-Tiles 17 / 48 ( 35 % ) Total HSSI E-Tile Channels 17 / 48 ( 35 % ) Total HSSI HPS 0 / 1 ( 0 % ) Total HSSI EHIPs 0 / 2 ( 0 % ) Total PLLs 36 / 104 ( 35 % )"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#23-ofs-directory-structure","title":"2.3. OFS Directory Structure","text":"<p>The OFS Git OFS repository ofs-d5005 directory structure is shown below:</p> <p></p> <p>```bash session \u251c\u2500\u2500 eval_script |   \u251c\u2500\u2500 ofs_d5005_eval.sh |   \u2514\u2500\u2500 README_ofs_d5005_eval.txt \u251c\u2500\u2500 ipss \u2502   \u251c\u2500\u2500 hssi |   \u251c\u2500\u2500 mem |   \u251c\u2500\u2500 pcie |   \u251c\u2500\u2500 pmci |   \u251c\u2500\u2500 spi |   \u2514\u2500\u2500 README.md \u251c\u2500\u2500 license \u2502   \u2514\u2500\u2500 quartus-0.0-0.01Intel OFS-linux.run \u251c\u2500\u2500 ofs-common |   \u251c\u2500\u2500 scripts |   \u251c\u2500\u2500 src |   \u251c\u2500\u2500 verification |   \u251c\u2500\u2500 LICENSE.txt |   \u2514\u2500\u2500 README.md \u251c\u2500\u2500 sim |   \u251c\u2500\u2500 bfm |   \u251c\u2500\u2500 rp_bfm \u2502\u00a0\u00a0 \u251c\u2500\u2500 scripts |   \u251c\u2500\u2500 unit_test  \u2502\u00a0\u00a0 \u2514\u2500\u2500 readme.txt \u251c\u2500\u2500 src \u2502   \u251c\u2500\u2500 afu_top \u2502   \u251c\u2500\u2500 includes \u2502   \u251c\u2500\u2500 pd_qsys \u2502   \u251c\u2500\u2500 README.md \u2502   \u2514\u2500\u2500 top \u251c\u2500\u2500 syn \u2502   \u251c\u2500\u2500 scripts \u2502   \u251c\u2500\u2500 setup \u2502   \u251c\u2500\u2500 syn_top \u2502   \u251c\u2500\u2500 readme.txt \u2502   \u2514\u2500\u2500 README \u251c\u2500\u2500 LICENSE.txt \u2514\u2500\u2500 README.md <pre><code>The contents of each directory are described below:\n\n**Eval Script** - Contains scripts for evaluation of OFS for D5005 including compiling FIM/AFU from source, unit level test. Also includes resources to report and setup D5005 development environment\n\n**ipss** - Contains the code and supporting files that define or set up the IP subsystems (HSSI, PCIe, memory, PMCI, SPI, etc...) contained in the D5005 FPGA Interface Manager (FIM).   \n\n**license** - License file for the Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP core.\n\n**ofs-common** - This directory contains resources that may be used across the board-specific repositories. This directory is referenced via a link within each of the FPGA-specific repositories.\n\n**sim** - Contains the testbenches and supporting code for all the unit test simulations. \n   - Bus Functional Model code is contained here.\n   - Scripts are included for automating a myriad of tasks.\n   - All of the individual unit tests and their supporting code is also located here.\n\n**src** - SystemVerilog source and script files  \n   - Contains all of the structural and behavioral code for the FIM.\n   - Scripts for generating the AXI buses for module interconnect.\n   - Top-level RTL for synthesis is located in this directory.\n   - Accelerated Functional Unit (AFU) infrastructure code is contained in this directory.\n\n**syn** - This directory contains all of the scripts, settings, and setup files for running synthesis on the FIM.\n\n# 3. Description of Sub-Systems\n\n## 3.1. Host Control and Data Flow\nThe host control and data flow are shown in the diagram below:\n\n![OFS FIM Top Level Block Diagram](images/FIM_data_flow.png)\n\nThe control and data flow is composed of the following:\n\n* Host Interface Adapter (PCIe)\n* Low Performance Peripherals\n  * Slow speed peripherals (I2C, Smbus, etc)\n  * Management peripherals (FME)\n\n* High Performance Peripherals\n  * Memory peripherals\n  * Acceleration Function peripherals\n  * HPS Peripheral\n\n* Fabrics\n   * Peripheral Fabric (multi drop)\n   * AFU Streaming fabric (point to point)\n\nPeripherals are connected to one another using AXI:\n\n* Via the peripheral fabric (AXI4-Lite, multi drop)\n* Via the AFU streaming fabric (AXI-S, point to point)\n\nPeripherals are presented to software as:\n\n* OFS managed peripherals that implement DFH CSR structure.  \n* Native driver managed peripherals (i.e. Exposed via an independent PF, VF)\n\nThe peripherals connected to the peripheral fabric are primarily Intel OPAE managed resources, whereas the peripherals connected to the AFU are \u201cprimarily\u201d managed by native OS drivers. The word \u201cprimarily\u201d is used since the AFU is not mandated to expose all its peripherals to Intel OPAE. It can be connected to the peripheral fabric, but can choose to expose only a subset of its capability to Intel OPAE.\n\nOFS uses a defined set of CSRs to expose the functionality of the FPGA to the host software.  These registers are described in [Open FPGA Stack Reference Manual - MMIO Regions section].\n\nIf you make changes to the FIM that affect the software operation, then OFS provides a mechanism to communicate that information to the proper software driver.  The [Device Feature Header (DFH) structure] provides a mechanism to maintain compatibility with OPAE software.  Please see [FPGA Device Feature List (DFL) Framework Overview] for an excellent description of DFL operation from the driver perspective.\n\nWhen you are planning your address space for your FIM updates, please be aware that the OFS FIM targeting Intel\u00ae FPGA PAC D5005, 256KB of MMIO region is allocated for external FME features and 128kB of MMIO region is allocated for external port features. Each external feature must implement a feature DFH, and the DFH needs to be placed at 4KB boundary. The last feature in the external feature list must have the EOL bit in its DFH set to 1 to mark the end of external feature list.  Since the FPGA address space is limited, consider using an indirect addressing scheme to conserve address space.\n\n# 4. FIM Development Flow\n\nOFS provides a framework of FPGA synthesizable code, simulation environment, and synthesis/simulation scripts.  FIM designers can take the provided code and scripts and modify existing code or add new code to meet their specific product requirements.\n\nFIM development for a new acceleration card consists of the following steps:\n\n1. Installation of OFS and familiarization with scripts and source code\n1. Development of high-level block diagram with your specific functionality\n    1. Determination of requirements and key performance metrics\n    1. Selection of IP cores\n    1. Selection of FPGA device\n    2. Software memory map\n2. Selection and implementation of FIM Physical interfaces including:\n    1. External clock sources and creation of internal PLL clocks\n    2. General I/O\n    3. Transceivers\n    4. External memories\n    5. FPGA programming methodology\n3. Device physical implementation\n    1. FPGA device pin assignment\n    2. Inclusion of logic lock regions\n    3. Creation of timing constraints\n    4. Create Quartus FIM test project and validate:\n        1. Placement\n        2. Timing constraints\n        3. Build script process\n        4. Review test FIM FPGA resource usage\n4. Select FIM to AFU interfaces and development of PIM\n5. FIM design implementation\n    1. RTL coding\n    2. IP instantiation\n    3. Development of test AFU to validate FIM\n    4. Unit and device level simulation\n    5. Timing constraints and build scripts\n    6. Timing closure and build validation\n6. Creation of FIM documentation to support AFU development and synthesis\n7. Software Device Feature discovery\n8. Hardware/software integration, validation and debugging\n9.  High volume production preparation\n\nThe FIM developer works closely with the hardware design of the target board, software development and system validation.\n\nUnderstanding how the AFU developer utilizes the FIM is important for FIM development success.  Please read [OFS AFU Development Guide] for a detailed description of AFU development.\n\n## 4.1. Installation of OFS\n\nIn this section you set up a development machine for compiling the OFS FIM. These steps are separate from the setup for a deployment machine where the FPGA acceleration card is installed.  Typically, FPGA development and deployment work is performed on separate machines, however, both development and deployment can be performed on the same server if desired.  Please see [OFS Getting Started User Guide] for instructions on installing software for deployment of your FPGA FIM, AFU and software application on a server.  \n\nBuilding the OFS FIM requires the development machine to have at least 64 GB of RAM.\n\nThe following is a summary of the steps to set up for FIM development:\n\n1. Install Quartus Prime Pro 22.3 Linux and setup environment\n2. Clone the github `ofs-d5005` repository\n3. Test installation by building the provided FIM\n\nIntel Quartus Prime Pro version 22.3 is the currently verified version of Quartus used for building the FIM and AFU images for this release.  Porting to newer versions of Quartus may be performed by developers.  Download Quartus Prime Pro Linux version 22.3 from [Intel\u00ae Quartus\u00ae Prime Pro Edition Linux].\n\nAfter running the Quartus Prime Pro installer, set the PATH environment variable to make utilities `quartus`, `jtagconfig`, and `quartus_pgm` discoverable. Edit your bashrc file `~/.bashrc` to add the following line:\n\n```bash session\nexport PATH=$PATH:&lt;Quartus install directory&gt;/quartus/bin\n</code></pre></p> <p>For example, if the Quartus install directory is /home/intelFPGA_pro/22.3 then the new line is:</p> <p><code>bash session export PATH=$PATH:/home/intelFPGA_pro/22.3/quartus/bin <pre><code>Verify, Quartus is discoverable by opening a new shell:\n\n```bash session\nwhich quartus\n## Output\n/home/intelFPGA_pro/22.3/quartus/bin/quartus\n</code></pre> Note, for some Linux distributions such as RHEL 8.2, Quartus requires installation of the following libraries:</code>bash session sudo dnf install libnsl sudo dnf install ncurses-compat-libs sudo ln -s /usr/bin/python3 /usr/bin/python <pre><code>You will need to obtain a license for Intel Quartus Prime Pro version 22.3 to compile the design.  This license is obtained from Intel.  Additionally, OFS for Intel\u00ae Stratix 10\u00ae FPGA requires a license for the Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP core.  This license is required to generate a programming file using the provided OFS source code.  The Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP core license patch installer is provided in the ofs-d5005 git repository in the /license directory.  After cloning the OFS release in step 4 below, you can install this IP license.  \n\n3. Install git and install git lfs to extract large files within the repository that are compressed with git lfs.  Please note, for proper operation of files retrieved from OFS repository, you will require git lfs. \n\n```bash session\nsudo dnf install git\n</code></pre>    ## Install git lfs: ```bash session curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash sudo dnf install git-lfs git lfs install <pre><code>4. Retrieve OFS repositories:\n\nThe OFS FIM source code is included in the GitHub repository. Create a new directory to use as a clean starting point to store the retrieved files.  \n\n1. Navigate to location for storage of OFS source, create the top-level source directory and clone OFS repositories.\n\n```bash session\nmkdir OFS_fim_build_root\ncd OFS_fim_build_root\nexport OFS_BUILD_ROOT=$PWD\ngit clone --recurse-submodules  https://github.com/OFS/ofs-d5005.git\ncd ofs-d5005\ngit checkout tags/ofs-d5005-1.0.1\n</code></pre> Verify proper tag is selected:</p> <p>```bash session  git describe --tags ofs-d5005-1.0.1 <pre><code>2. Install the Low Latency 10Gbps Ethernet MAC (6AF7 0119) IP license by running provided license installer.\n\n```bash session\ncd license\nchmod +x quartus-0.0-0.01Intel OFS-linux.run\nsudo ./quartus-0.0-0.01Intel OFS-linux.run\n</code></pre></p> <ol> <li>Verify patch installed ```bash session quartus_sh --version</li> </ol>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#output","title":"Output","text":"<p>Quartus Prime Shell Version 22.3 Pro Edition <pre><code>## 4.2. Compiling OFS FIM\n\nOFS provides a build script with the following FPGA image creation options:\n\n* Flat compile which combines the FIM and AFU into one FPGA image that is loaded into the entire FPGA device\n\n* A PR compile which creates a FPGA image consisting of the FIM that is loaded into the static region of the FPGA and a default AFU that is loaded into dynamic region. Additional AFUs maybe loaded into the dynamic region using partial reconfiguration.\n\nThe build scripts included with OFS are verified to run in a bash shell. Other shells have not been tested. Each build script step will take several hours to completes, Please note, building directly in Quartus GUI is not supported - you must build with the provided scripts.\n\nThe following sections describe how to set up the environment and build the provided FIM and AFU. Follow these steps as a tutorial to learn the build flow. You will use this environment and build scripts for the creation of your specialized FIM.\n\n### 4.2.1. Setting Up Required Environment Variables\nSet required environment variables as shown below. These environment variables must be set prior to simulation or compilation tasks so creating a simple script to set these variables saves time.\n\n```bash session\ncd $OFS_BUILD_ROOT/ofs-d5005\nexport OFS_ROOTDIR=$PWD\n\n##   *Note, OFS_ROOTDIR is the directory where you cloned the repo, e.g. /home/MyProject/ofs-d5005 *\n\nexport WORKDIR=$OFS_ROOTDIR\nexport VERDIR=$OFS_ROOTDIR/verification\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\n\n##   *Note, QUARTUS_ROOTDIR is your Quartus installation directory, e.g. $QUARTUS_ROOTDIR/bin contains Quartus executuable*\n\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip\nexport OPAE_SDK_REPO_BRANCH=release/2.3.0\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#422-compiling","title":"4.2.2. Compiling","text":"<p>The usage of the compile build script is shown below: ```bash session ofs-common/scripts/common/syn/build_top.sh [-p] target_configuration work_dir  Usage: ofs-common/scripts/common/syn/build_top.sh [-k] [-p]  [] <p>Build a FIM instance specified by . The target names an FPGA architecture, board and configuration. <p>The FIM is built in . If not specified, the target is ${OFS_ROOTDIR}/work. <p>The -k option preserves and rebuilds within an existing work tree instead of overwriting it.</p> <p>When -p is set, if the FIM is able then a partial reconfiguration template tree is generated at the end of the FIM build. The PR template tree is located in the top of the work directory but is relocatable   and uses only relative paths. See syn/common/scripts/generate_pr_release.sh for details.</p> <p>The -e option runs only Quartus analysis and elaboration.</p> <pre><code>  * target_configuration - Specifies the project  \n     For example: d5005\n\n  * work_dir - Work Directory for this build in the form a directory name. It is created in the &lt;local repo directory&gt;/ofs-d5005/&lt;work_dir&gt; \n      - NOTE: The directory name must start with \"work\".  If the work directory exists, then the script stops and asks if you want to overwrite the directory.\n        - e.g.\n            - ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005\n\n            work directory as a name will be created in &lt;local repo directory&gt;/ofs-d5005/work_d5005\n\n\n            The obmission of &lt;work_dir&gt; results in a default work directory (&lt;local repo  directory&gt;/ofs-d5005/work)\n\n    - compile reports and artifacts (.rpt, .sof, etc) are stored in &lt;work_dir&gt;/syn/syn_top/output_files\n\n    - There is a log file created in ofs-d5005 directory.  \n    - [-p]  Optional switch for creation of a relocatable PR build tree supporting the creation of a PR-able AFU workload.   \n    The \"-p\" switch invokes generate_pr_release.sh at the end of the FIM build and writes the PR build tree to the top of the work directory.  More information on this option is provided below.\n</code></pre> <p><code>In the next example, you will build the provided example design using a flat, non-PR build flow.    Build the provided base example design:</code>bash session cd $OFS_BUILD_ROOT/ofs-d5005  ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005  <code></code>bash session     ... build takes ~5 hours to complete  Compile work directory:     &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top Compile artifact directory: &lt;$OFS_BUILD_ROOT&gt;/work_d5005/syn/syn_top/output_files</p> <p>        OFS_PROJECT: d5005         Q_PROJECT:  d5005         Q_REVISION: d5005         SEED: 03         Build Complete         Timing Passed!</p> <p>``` The build script copies the ipss, sim, src and syn directories to the specified work directory and then these copied files are used in the Quartus compilation process.  Do not edit the files in the work directory, these files are copies of source files.</p> <p>Some of the key files are described below:</p> <p>/syn/syn_top ==  ```bash session \u251c\u2500\u2500 syn_top                    // D5005 Quartus build area with Quartus files used this build \u2502\u00a0\u00a0\u251c\u2500\u2500 d5005.ipregen.rpt       // IP regeneration report states the output of IP upgrade \u2502\u00a0\u00a0\u251c\u2500\u2500 d5005.qpf               // Quartus Project File (qpf) mentions about Quartus version and project revision \u2502  \u251c\u2500\u2500 d5005.qsf               // Quartus Settings File (qsf) lists current project settings and entity level assignments \u2502\u00a0\u00a0\u251c\u2500\u2500 d5005.stp               // Signal Tap file included in the d5005.qsf. This file can be modified as required if you need to add an Signal Tap instance \u2502\u00a0\u00a0\u251c\u2500\u2500 fme_id.mif              // the fme id hex value is stored in a mif file format \u2502  \u251c\u2500\u2500 Intel OFS_pr_afu.json        // PR JSON file \u2502\u00a0\u00a0\u251c\u2500\u2500 Intel OFS_pr_afu.qsf                // PR AFU qsf file \u2502\u00a0\u00a0\u251c\u2500\u2500 Intel OFS_pr_afu_sources.tcl        // AFU source file list \u2502\u00a0\u00a0\u251c\u2500\u2500 ip_upgrade_port_diff_reports   // IP upgrade report files for reference <pre><code>&lt;work_dir&gt;/syn/syn_top/output_files == Directory with build reports and FPGA programming files. \n\nThe programming files consist of the Quartus generated d5005.sof and d5005.pof.  The D5005 board hardware provides a 2 Gb flash device to store the FPGA programming files and a MAX10 BMC that reads this flash and programs the D5005 Intel\u00ae Stratix 10\u00ae FPGA FPGA. The syn/build_top.sh script runs script file syn/syn_top/build_flash/build_flash.s which takes the Quartus generated d5005.sof and creates binary files in the proper format to be loaded into the 2 Gb flash device.  You can also run build_flash.sh by yourself if needed.  The build_flash  script runs PACSign (if installed) to create an unsigned FPGA programming file that can be stored in the D5005 FPGA flash. Please note, if the D5005 has the root entry hash key loaded, then PACsign must be run with d5005_page1.bin as the input with the proper key to create an authenticated FPGA binary file.  Please see [Security User Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA] for details on the security aspects of Intel\u00ae Open FPGA Stack.\n\nThe following table provides further detail on the generated bin files.\n\n| File            | Description                        |\n|-----------------|------------------------------------|\n| d5005.sof | This is the Quartus generated programming file created by Quartus synthesis and place and route.  This file can be used to programming the FPGA using a JTAG programmer.  This file is used as the source file for the binary files used to program the FPGA flash. |\n| d5005.bin |  This is an intermediate raw binary image of the FPGA  |\n| d5005_page1.bin | This is the binary file created from input file, d5005.sof.  This file is used as the input file to the PACSign utility to generate **d5005_page1_unsigned.bin** binary image file. |\n| d5005_page1_unsigned.bin | This is the unsigned PACSign output which can be programmed into the FPGA flash of an unsigned D5005 usign the OPAE SDK utility **fpgasupdate**  |\n| mfg_d5005_reversed.bin | A special programming file for a third party programming device used in board manufacturing.  This file is typically not used.|\n\nbuild/output_files/timing_report == Directory containing clocks report, failing paths and passing margin reports\n\n### 4.2.3. Relocatable PR Directory Tree\n\nIf you are developing a FIM to be used by another team developing the AFU workload, scripts are provided that create a relocatable PR directory tree. ODM and board developers will make use of this capability to enable a broad set of AFUs to be loaded on a board using PR.  The relocatable PR directory contains the Quartus *.qdb file that goes the FIM.\n\nThe creation of the relocatable PR directory tree requires a clone of the Intel Basic Building Blocks (BBB) repository. The OFS_PLATFORM_AFU_BBB environment variable must point to the repository, for example.\n\n```bash session\ncd $OFS_BUILD_ROOT\ngit clone https://github.com/OPAE/ofs-platform-afu-bbb\ncd ofs-platform-afu-bbb\nexport OFS_PLATFORM_AFU_BBB=$PWD\ncd $OFS_ROOTDIR\n</code></pre> <p>You can create this relocatable PR directory tree by either:</p> <ul> <li>Build FIM and AFU using /syn/build_top.sh followed by running /syn/common/scripts/generate_pr_release.sh</li> <li>Build FIM and AFU using /syn/build_top.sh with optional -p switch included</li> </ul> <p>The generate_pr_release.sh has the following command structure:</p> <p>```bash session ./syn/common/scripts/generate_pr_release.sh -t  Board Build Target <p>Where:</p> <p>-t  = location for your relocatable PR directory tree Board Build Target is the name of the board target/FIM e.g. d5005  <pre><code>Here is an example of running the generate_pr_release.sh script:\n\n```bash session\nsyn/common/scripts/generate_pr_release.sh -t work_d5005/build_tree d5005  work_d5005\n</code></pre> ```bash session <p>* ENV SETUP **</p> <p>FIM Project:   OFS_PROJECT = d5005   OFS_FIM     = .   OFS_BOARD   = .   Q_PROJECT   = d5005   Q_REVISION  = d5005   Fitter SEED = 03 FME id   BITSTREAM_ID = 04010002c7cab852   BITSTREAM_MD = 0000000002204283</p> <p>... ... <pre><code>The resulting relocatable build tree has the following structure:\n```bash session\n.\n\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 afu_synth\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 build_env_config\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 run.sh -&gt; afu_synth\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 update_pim\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 blue_bits\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 d5005_page1_unsigned.bin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 d5005.sof -&gt; ../lib/build/syn/syn_top/output_files/d5005.sof\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 lib\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 build\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 fme-ifc-id.txt\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 fme-platform-class.txt\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 platform\n</code></pre></p> <p>This build tree can be moved to a different location and used for AFU development of a PR capable AFU to be used with this board.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#424-unit-level-simulation","title":"4.2.4. Unit Level Simulation","text":"<p>Unit level simulation of key components is provided. These simulations provide verification of the following areas:</p> <ul> <li>HSSI</li> <li>PCIe</li> <li>External Memory</li> <li>FIM management</li> </ul> <p>These simulations use the Synopsys VCS simulator. Each simulation contains a readme file explaining how to run the simulation. Refer to Simulation User Guide: Open FPGA Stack for Intel Intel\u00ae Stratix 10\u00ae FPGA  for details of simulation examples. Your simulation shell requires Python, Quartus, and VCS to run.  To run a simulation of the dfh_walker that simulates host access to the internal DFH registers, perform the following steps:</p> <p>```bash session Before running unit simulation, you must set environment variables as described below: cd $OFS_BUILD_ROOT/ofs-d5005 export OFS_ROOTDIR=$PWD</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#note-ofs_rootdir-is-the-directory-where-you-cloned-the-repo-eg-homemyprojectofs-d5005","title":"*Note, OFS_ROOTDIR is the directory where you cloned the repo, e.g. /home/MyProject/ofs-d5005 *","text":"<p>export WORKDIR=$OFS_ROOTDIR export VERDIR=$OFS_ROOTDIR/verification export QUARTUS_HOME=$QUARTUS_ROOTDIR</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#note-quartus_rootdir-is-your-quartus-installation-directory-eg-quartus_rootdirbin-contains-quartus-executuable","title":"Note, QUARTUS_ROOTDIR is your Quartus installation directory, e.g. $QUARTUS_ROOTDIR/bin contains Quartus executuable","text":"<p>export QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR export IMPORT_IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip export IP_ROOTDIR=$QUARTUS_ROOTDIR/../ip export OPAE_SDK_REPO_BRANCH=release/2.3.0 <pre><code>To compile all IPs:\n\nTo Generate Simulation Files &amp; compile all IPs, run the following command:\n```bash session     \ncd $OFS_ROOTDIR/ofs-common/scripts/common/sim\nsh gen_sim_files.sh d5005\n</code></pre> The RTL file list for unit_test is located here: $OFS_ROOTDIR/sim/scripts/rtl_comb.f</p> <p>The IPs are generated here:  ```bash session $OFS_ROOTDIR/sim/scripts/qip_gen <pre><code>The IP simulation filelist is generated here: \n```bash session\n$OFS_ROOTDIR/sim/scripts/ip_flist.f\n</code></pre> Once the IPs are generated, they can be used for any unit test.</p> <p>To run the simulation, run the following command:</p> <p><code>bash session cd $OFS_ROOTDIR/sim/unit_test/&lt;Unit Test Name&gt;/scripts sh run_sim.sh VCS=1 <pre><code>Simulation files are located in the sim/unit_test/&lt;test_name&gt;/sim directory.\n</code></pre> To view simulation waveform:</code>bash session cd $OFS_ROOTDIR/sim/unit_test//script/sim/unit_test//scripts/sim_vcs dve -full64 -vpd vcdplus.vpd &amp; <pre><code>#### 4.2.4.1. DFH Walking Unit Simulation Output\n\n```bash session\n********************************************\n Running TEST(0) : test_fme_dfh_walking\n********************************************\nREAD64: address=0x00000000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x4000000010000000\n\nFME_DFH\n   Address   (0x0)\n   DFH value (0x4000000010000000)\nREAD64: address=0x00001000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000020000001\n\nTHERM_MNGM_DFH\n   Address   (0x1000)\n   DFH value (0x3000000020000001)\nREAD64: address=0x00003000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000010000007\n\nGLBL_PERF_DFH\n   Address   (0x3000)\n   DFH value (0x3000000010000007)\nREAD64: address=0x00004000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x30000000c0001004\n\nGLBL_ERROR_DFH\n   Address   (0x4000)\n   DFH value (0x30000000c0001004)\nREAD64: address=0x00010000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x300000010000000e\n\nSPI_DFH\n   Address   (0x10000)\n   DFH value (0x300000010000000e)\nREAD64: address=0x00020000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000100000020\n\nPCIE_DFH\n   Address   (0x20000)\n   DFH value (0x3000000100000020)\nREAD64: address=0x00030000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x300000010000100f\n\nHSSI_DFH\n   Address   (0x30000)\n   DFH value (0x300000010000100f)\nREAD64: address=0x00040000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000500000009\n\nEMIF_DFH\n   Address   (0x40000)\n   DFH value (0x3000000500000009)\nREAD64: address=0x00090000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000010001005\n\nFME_PR_DFH\n   Address   (0x90000)\n   DFH value (0x3000000010001005)\nREAD64: address=0x00091000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x4000000010001001\n\nPORT_DFH\n   Address   (0x91000)\n   DFH value (0x4000000010001001)\nREAD64: address=0x00092000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000010000014\n\nUSER_CLOCK_DFH\n   Address   (0x92000)\n   DFH value (0x3000000010000014)\nREAD64: address=0x00093000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x30000000d0002013\n\nPORT_STP_DFH\n   Address   (0x93000)\n   DFH value (0x30000000d0002013)\nREAD64: address=0x000a0000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000010000002010\n\nAFU_INTF_DFH\n   Address   (0xa0000)\n   DFH value (0x3000010000002010)\nMMIO error count matches: x\n\nTest status: OK\n\n********************\n  Test summary\n********************\n   test_fme_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n</code></pre> The simulation transcript is displayed while the simulation runs.  The transcript is saved to the file transcript.out for review after the simulation completes.  The simulation waveform database is saved as vcdplus.vpd for post simulation review. You are encouraged to run the additional simulation examples to learn about each key area of the OFS shell."},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#43-compiling-the-ofs-fim-using-eval-script","title":"4.3. Compiling the OFS FIM using Eval Script","text":"<p>The Evaluation Script provides resources to setup and report D5005 development environment. You can use the evaluation script to compile and simulate the FIM. Refer to README_ofs_d5005_eval.txt for details of using the evaluation script.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#44-debugging","title":"4.4. Debugging","text":"<p>For debugging issues within the FIM, Signal Tap can be used to gain internal visibility into your design.  This section describes the process of adding a Signal Tap instance to your FIM design</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#441-signal-tap-prerequisites","title":"4.4.1. Signal Tap Prerequisites","text":"<p>To use Signal Tap with OFS, you will need the following:</p> <ul> <li> <p>Understanding of Signal Tap fundamentals - please review Quartus Prime Pro Edition User Guide: Debug Tools. section 2. Design Debugging with the Signal Tap Logic Analyzer.</p> </li> <li> <p>The Intel\u00ae FPGA PAC D5005 has a built in Intel FPGA Download Cable II allowing JTAG access to the S10 FPGA. You can access the D5005 built in Intel FPGA Download Cable II by connecting your server to the Micro USB connector as shown below:</p> </li> </ul> <p></p> <ul> <li>If you are using a custom board without a built-in Intel FPGA Download Cable then an external Intel FPGA Download Cable II (see Download Cables for more information) can be used for Signal Tap access.  The custom board must have JTAG access to the target FPGA for the Intel FPGA Download Cable II.</li> </ul>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#442-adding-signal-tap","title":"4.4.2. Adding Signal Tap","text":"<p>The following steps guide you through the process of adding a Signal Tap instance to your design.  The added Signal Tap instance provides hardware to capture the desired internal signals and connect the stored trace information via JTAG.  Please be aware, the added Signal Tap hardware will consume FPGA resources and may require additional floorplanning steps to accommodate these resources.  Some areas of the FIM use logic lock regions and these regions may need to be re-sized. These steps assume the use of the Intel\u00ae FPGA PAC D5005.</p> <ol> <li>Perform a full compile using the script build_top.sh.</li> <li>Once the compile completes open the Quartus GUI using the FIM project.  The Quartus project is named d5005 and is located in the work directory syn/syn_top/d5005.qpf.  Once the project is loaded, go to Tools &gt; Signal Tap Logic Analyzer to bring up the Signal Tap GUI.</li> </ol> <p></p> <ol> <li>Accept the \"Default\" selection and click \"Create\".</li> </ol> <p></p> <ol> <li>This brings up Signal Tap Logic Analyzer window as shown below:</li> </ol> <p></p> <ol> <li>Set up clock for STP instance.  In this example, the EMIF CSR module is being instrumented.  If unfamiliar with code, it is helpful to use the Quartus Project Navigator to find the specific block of interest and open the design instance for review.  For example, see snip below using Project Navigator to open emif_csr block:</li> </ol> <p> </p> <ol> <li>After reviewing code, assign clock for sampling Signal Tap instrumented signals of interest.  Note, the clock selected and the signals you want to view should be the same for best trace fidelity.  Different clocks can be used however there maybe issues with trace inaccuracy due sampling time differences.  In the middle right of the Signal Tap window under Signal Configuration, Clock:  select \"\u2026\" as shown below: </li> </ol> <p></p> <ol> <li>After reviewing code, assign clock for sampling Signal Tap instrumented signals of interest.  In the middle right of the Signal Tap window under Signal Configuration, Clock:  select \"\u2026\" as shown below:   This brings up the Node Finder tool.  Input \"emif_csr\" into Named and select \"Search\".  This brings up all nodes from the pre-synthesis view.  Expand, \"mem\" and \"emif_csr\" and scroll through this list to become familiar with nodes, and then select csr_if.clk and click \"&gt;\"  to select this clock as shown below and click \"OK\": </li> </ol> <p></p> <ol> <li>Update the sample depth and other Signal Tap settings as needed for your debugging criteria.</li> </ol> <p></p> <ol> <li>In the Signal Tap GUI add nodes to be instrumented by double clicking on \"Double-click to add nodes\".</li> </ol> <p></p> <ol> <li>This brings up the Node Finder.  Add signals to be traced by the Signal Tap instance.  Click \"Insert\" to add the signals.</li> <li>To provide a unique name for your Signal Tap instance, select \"auto signaltap_0\", right click and select rename instance and provide a descriptive name for your instance.</li> <li>Save the newly created Signal Tap file and click \"Yes\" to add the new Signal Tap file to the project.</li> <li>Compile the project with the Signal Tap file added to the project.</li> <li>Once the compile successfully completes with proper timing, you can load the generated d5005.sof using the Intel FPGA Downloader cable.</li> </ol>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#443-signal-tap-trace-acquisition","title":"4.4.3. Signal Tap trace acquisition","text":"<p>To acquire signals using SignalTap, first load the Signal Tap instrumented SOF file into your target board, open the STP file in the Signal Tap GUI and start the signal acquisition. </p> <p>Avoid system hang during programming the sof file, mask AER regsiter using below steps </p> <p>Find Root complex - End Point mapping using the below command</p> <p>```bash session lspci -vt <pre><code>```bash session\n+-[0000:3a]-+-00.0-[3b-3c]----00.0  Intel Corporation Device bcce\n |           +-05.0  Intel Corporation Sky Lake-E VT-d\n |           +-05.2  Intel Corporation Sky Lake-E RAS Configuration Registers\n |           +-05.4  Intel Corporation Sky Lake-E IOxAPIC Configuration Registers\n |           +-08.0  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-09.0  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.0  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.1  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.2  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.3  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.4  Intel Corporation Sky Lake-E Integrated Memory Controller\n |           +-0a.5  Intel Corporation Sky Lake-E LM Channel 1\n</code></pre></p> <p>Use the bus information from the lspci logs to mask the AER (Advanced Error Reporting) register</p> <p>```bash session sudo su</p> <p>setpci -s 0000:3b:00.0 ECAP_AER+0x08.L=0xFFFFFFFF  setpci -s 0000:3b:00.0 ECAP_AER+0x14.L=0xFFFFFFFF setpci -s 0000:3a:00.0 ECAP_AER+0x08.L=0xFFFFFFFF setpci -s 0000:3a:00.0 ECAP_AER+0x14.L=0xFFFFFFFF echo \"1\" &gt; /sys/bus/pci/devices/0000:3b:00.0/remove</p> <p>exit <pre><code>1. The SOF file is located in the work directory work_d5005/syn/syn_top/output_files/d5005.sof.  If the target FPGA is on a different server, then transfer d5005.sof and STP files to the server with the target FPGA. Load the SOF using the Intel\u00ae FPGA PAC D5005 built-in Intel FPGA Download Cable II. \n\n```bash session\nsudo su\necho \"1\" &gt; /sys/bus/pci/rescan\n</code></pre></p> <ol> <li>Make sure D5005 is present by checking expected bitstream ID using command:</li> </ol> <p>```bash session sudo fpgainfo fme Intel FPGA Programmable Acceleration Card D5005 Board Management Controller, MAX10 NIOS FW version: 2.0.13  Board Management Controller, MAX10 Build version: 2.0.8  //** FME ****// Object Id                        : 0xF000000 PCIe s:b:d.f                     : 0000:3B:00.0 Vendor Id                        : 0x8086 Device Id                        : 0xBCCE SubVendor Id                     : 0x8086 SubDevice Id                     : 0x138D Socket Id                        : 0x00 Ports Num                        : 01 Bitstream Id                     : 0x40100022C164DB1 Bitstream Version                : 4.0.1 Pr Interface Id                  : 210a4631-18bb-57d1-879f-2c3d59b26e37 Boot Page                        : user <pre><code>3. Once the SOF file is loaded, start the Quartus Signal Tap GUI.\n\n```bash session\nquartus_stpw\n</code></pre> The Signal Tap GUI comes up.</p> <ol> <li>In the Signal Tap GUI, <code>Hardware:</code> selection box select the cable \"Stratix10 Darby Creek [ JTAG cable number ]\" as shown below:</li> </ol> <p></p> <ol> <li>In <code>File</code> open your STP file.  Your STP file settings will load.  If not already set, you can create the trigger conditions, then start analysis with <code>F5</code>.</li> </ol> <p></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#5-fim-modification-example","title":"5. FIM Modification Example","text":"<p>An example of FIM modification is provided in this section.  This example can be used in your specific application as a starting point.  This example shows the basic flow and listing of files that are to be changed.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#51-hello-fim-example","title":"5.1. Hello FIM example","text":"<p>If you intend to add a new module to the FIM area, then you will need to inform the host software of the new module.  The FIM exposes its functionalities to host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO).  This set of CSR registers and their operation is described in FIM MMIO Regions.</p> <p>See FPGA Device Feature List (DFL) Framework Overview for a description of the software process to read and process the linked list of Device Feature Header (DFH) CSRs within a FPGA.</p> <p>This example adds a simple DFH register set to the FIM. You can use this example as the basis for adding a new feature to your FIM.  </p> <p>The steps to add this simple DFH register are described below.</p> <ol> <li>Review current design documentation: OFS Tech Ref MMIO Regions</li> <li>Understand FME and Port regions, DFH walking, DFH register structure </li> <li>Run unit level simulations and review output:             i.  sim/unit_test/dfh_walker</li> <li>Note DFH link list order, see DFH Walker Unit Level Simulation Output</li> <li>Make code changes to top level FIM file to instantiate new DFH register</li> <li>The DFH registers follow a link list.  This example inserts the hello_fim DFH register after the EMIF DFH register, so the emif_csr.sv parameters are updated to insert the hello_fim DFH register as next register in the link list.</li> <li>Create the new hello_fim SystemVerilog files.</li> <li>Update and run the dfh_walker unit simulation files</li> <li>Update synthesis files to include the new hello_fim source files</li> <li>Build and test the new FIM</li> </ol> <p>The following sections describe changes to add the hello_fim DFH example to the Intel provided FPGA design.</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#511-srctopiofs_topsv","title":"5.1.1. src/top/iofs_top.sv","text":"<ol> <li>Edit top level design module: src/top/iofs_top.sv</li> <li>Instantiate new hello_fim module in OFS_top.sv at line 294</li> </ol> <pre><code>//*******************************\n// FME\n//*******************************\nfme_top fme_top(\n.clk               (clk_1x                    ),\n.rst_n             (rst_n_d_1x       ),\n.pwr_good_n        (ninit_done                ),\n.i_pcie_error      ('0                        ),\n.axi_lite_m_if     (bpf_fme_mst_if            ),\n.axi_lite_s_if     (bpf_fme_slv_if            )\n);\n`ifdef INCLUDE_HELLO_FIM\nhello_fim_top hello_fim_top (\n.clk   (clk_1x),\n.rst_n                      (rst_n_d_1x),\n.csr_lite_if             (bpf_rsv_5_slv_if)\n);\n`endif\n//*******************************\n// AFU\n//*******************************\n</code></pre> <p>You will connect the Hello_FIM DFH register to the existing BPF reserved link 5.  The provided OFS reference design includes 3 reserved BPF interfaces available for custom usage such as new OPAE controlled modules.  The address map of BPF is shown below:</p> Address Size (Byte) Feature Master 0x00000 \u2013 0x0FFFF 64K FME (FME, Error, etc) Yes 0x10000 \u2013 0x1FFFF 64K PMCI Proxy (SPI Controller) Yes 0x20000 \u2013 0x2FFFF 64K PCIe CSR 0x30000 \u2013 0x3FFFF 64K HSSI CSR 0x40000 \u2013 0x4FFFF 64K EMIF CSR 0x50000 \u2013 0x5FFFF 64K Reserved 0x60000 \u2013 0x6FFFF 64K Reserved 0x70000 \u2013 0x7FFFF 64K Reserved <p>The BPF reserved link 5 is connected to a dummy connection to prevent this link from being optimized out the design during synthesis.  You will add a compiler `define that will cause this dummy connection to be removed when the variable INCLUDE_HELLO_FIM is defined by editing line 575 if iofs_top.sv as shown below:</p> <pre><code>    // Reserved address response\n`ifndef INCLUDE_HELLO_FIM\nbpf_dummy_slv\nbpf_rsv_5_slv (\n.clk            (clk_1x),\n.dummy_slv_if   (bpf_rsv_5_slv_if)\n);\n`endif\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#512-ipssmememif_csrsv","title":"5.1.2. ipss/mem/emif_csr.sv","text":"<p>The Hello_FIM DFH is inserted in the DFH link list after the EMIF CSR DFH and before the FME_PR DFH.  The file ipss/d5005/emif/emif_csr.sv contains a parameter defining the next address for the next DFH in in the link list chain.  You will change the next address offset to be 0x10000 so the reveserved BPF AXI lite link connected to the Hello_FIM DFH register is next in the DFH link list.</p> <pre><code>module emif_csr #(\nparameter NUM_LOCAL_MEM_BANKS = 1,\nparameter END_OF_LIST         = 1'b0,\n`ifndef INCLUDE_HELLO_FIM\nparameter NEXT_DFH_OFFSET     = 24'h05_0000\n`else\nparameter NEXT_DFH_OFFSET     = 24'h01_0000//New for Hello_FIM, next offset now at 0x50000\n`endif\n)\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#513-srchello_fimhello_fim_topsv","title":"5.1.3. src/hello_fim/hello_fim_top.sv","text":"<p>Create hello_fim_top.sv, and store it in src/hello_fim directory. The main purpose of this RTL is to convert AXI4-Lite interface to a simple interface to interface with the registers in hello_fim_com.sv.  This register sets the DFH feature ID to 0xfff which is undefined.  Since this for test purposes, using an undefined feature ID will result in no driver being used.  Normally, a defined feature ID will be used to associate a specific driver with the FPGA module.</p> <pre><code>// ***************************************************************************\n//                               INTEL CONFIDENTIAL\n//\n//        Copyright (C) 2021 Intel Corporation All Rights Reserved.\n//\n// The source code contained or described herein and all  documents related to\n// the  source  code  (\"Material\")  are  owned  by  Intel  Corporation  or its\n// suppliers  or  licensors.    Title  to  the  Material  remains  with  Intel\n// Corporation or  its suppliers  and licensors.  The Material  contains trade\n// secrets  and  proprietary  and  confidential  information  of  Intel or its\n// suppliers and licensors.  The Material is protected  by worldwide copyright\n// and trade secret laws and treaty provisions. No part of the Material may be\n// used,   copied,   reproduced,   modified,   published,   uploaded,  posted,\n// transmitted,  distributed,  or  disclosed  in any way without Intel's prior\n// express written permission.\n//\n// No license under any patent,  copyright, trade secret or other intellectual\n// property  right  is  granted  to  or  conferred  upon  you by disclosure or\n// delivery  of  the  Materials, either expressly, by implication, inducement,\n// estoppel or otherwise.  Any license under such intellectual property rights\n// must be express and approved by Intel in writing.\n//\n// You will not, and will not allow any third party to modify, adapt, enhance, \n// disassemble, decompile, reverse engineer, change or create derivative works \n// from the Software except and only to the extent as specifically required by \n// mandatory applicable laws or any applicable third party license terms \n// accompanying the Software.\n//\n// -----------------------------------------------------------------------------\n// Engineer     : \n// Create Date  : Nov 2021\n// Module Name  : hello_fim_top.sv\n// Project      : OFS\n// -----------------------------------------------------------------------------\n//\n// Description: \n// This is a simple module that implements DFH registers and \n// AVMM address decoding logic.\nmodule hello_fim_top  #(\nparameter ADDR_WIDTH  = 12, parameter DATA_WIDTH = 64, parameter bit [11:0] FEAT_ID = 12'hfff,\nparameter bit [3:0]  FEAT_VER = 4'h0,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h04_0000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput  logic    clk,\ninput  logic    rst_n,\n// -----------------------------------------------------------\n//  AXI4LITE Interface\n// -----------------------------------------------------------\nofs_fim_axi_lite_if.slave   csr_lite_if\n);\nimport ofs_fim_cfg_pkg::*;\nimport ofs_csr_pkg::*;\n//-------------------------------------\n// Signals\n//-------------------------------------\nlogic [ADDR_WIDTH-1:0]              csr_waddr;\nlogic [DATA_WIDTH-1:0]              csr_wdata;\nlogic [DATA_WIDTH/8-1:0]            csr_wstrb;\nlogic                               csr_write;\nlogic                               csr_slv_wready;\ncsr_access_type_t                   csr_write_type;\nlogic [ADDR_WIDTH-1:0]              csr_raddr;\nlogic                               csr_read;\nlogic                               csr_read_32b;\nlogic [DATA_WIDTH-1:0]              csr_readdata;\nlogic                               csr_readdata_valid;\nlogic [ADDR_WIDTH-1:0]              csr_addr;\nlogic [63:0]                        com_csr_writedata;\nlogic                               com_csr_read;\nlogic                               com_csr_write;\nlogic [63:0]                        com_csr_readdata;\nlogic                               com_csr_readdatavalid;\nlogic [5:0]                         com_csr_address;\n// AXI-M CSR interfaces\nofs_fim_axi_mmio_if #(\n.AWID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.AWADDR_WIDTH (ADDR_WIDTH),\n.WDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH),\n.ARID_WIDTH   (ofs_fim_cfg_pkg::MMIO_TID_WIDTH),\n.ARADDR_WIDTH (ADDR_WIDTH),\n.RDATA_WIDTH  (ofs_fim_cfg_pkg::MMIO_DATA_WIDTH)\n) csr_if();\n// AXI4-lite to AXI-M adapter\naxi_lite2mmio axi_lite2mmio (\n.clk       (clk),\n.rst_n     (rst_n),\n.lite_if   (csr_lite_if),\n.mmio_if   (csr_if)\n);\n//---------------------------------\n// Map AXI write/read request to CSR write/read,\n// and send the write/read response back\n//---------------------------------\nofs_fim_axi_csr_slave #(\n.ADDR_WIDTH (ADDR_WIDTH),\n.USE_SLV_READY (1'b1)\n) csr_slave (\n.csr_if             (csr_if),\n.csr_write          (csr_write),\n.csr_waddr          (csr_waddr),\n.csr_write_type     (csr_write_type),\n.csr_wdata          (csr_wdata),\n.csr_wstrb          (csr_wstrb),\n.csr_slv_wready     (csr_slv_wready),\n.csr_read           (csr_read),\n.csr_raddr          (csr_raddr),\n.csr_read_32b       (csr_read_32b),\n.csr_readdata       (csr_readdata),\n.csr_readdata_valid (csr_readdata_valid)\n);\n// Address mapping\nassign csr_addr             = csr_write ? csr_waddr : csr_raddr;\nassign com_csr_address      = csr_addr[5:0];  // byte address\nassign csr_slv_wready       = 1'b1 ;\n// Write data mapping\nassign com_csr_writedata    = csr_wdata;\n// Read-Write mapping\nalways_comb\nbegin\ncom_csr_read             = 1'b0;\ncom_csr_write            = 1'b0;\ncasez (csr_addr[11:6])\n6'h00 : begin // Common CSR\ncom_csr_read       = csr_read;\ncom_csr_write      = csr_write;\nend   default: begin\ncom_csr_read       = 1'b0;\ncom_csr_write      = 1'b0;\nend\nendcase\nend\n// Read data mapping\nalways_comb begin\nif (com_csr_readdatavalid) begin\ncsr_readdata       = com_csr_readdata;\ncsr_readdata_valid = 1'b1;\nend\nelse begin\ncsr_readdata       = '0;\ncsr_readdata_valid = 1'b0;\nend\nend\nhello_fim_com  #(\n.FEAT_ID          (FEAT_ID),\n.FEAT_VER         (FEAT_VER),\n.NEXT_DFH_OFFSET  (NEXT_DFH_OFFSET),\n.END_OF_LIST      (END_OF_LIST)\n) hello_fim_com_inst (\n.clk                   (clk                     ),\n.rst_n                 (rst_n                  ),\n.writedata             (com_csr_writedata       ),\n.read                  (com_csr_read            ),\n.write                 (com_csr_write           ),\n.byteenable            (4'hF                    ),\n.readdata              (com_csr_readdata        ),\n.readdatavalid         (com_csr_readdatavalid   ),\n.address               (com_csr_address         )\n);\nendmodule\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#514-srchello_fimhello_fim_comsv","title":"5.1.4. src/hello_fim/hello_fim_com.sv","text":"<p>Create hello_fim_com.sv, and store it in src/hello_fim directory. This is the simple RTL to implement the Hello FIM registers. You may use this set of registers as the basis for your custom implementation.</p> <pre><code>// ***************************************************************************\n//                               INTEL CONFIDENTIAL\n//\n//        Copyright (C) 2021 Intel Corporation All Rights Reserved.\n//\n// The source code contained or described herein and all  documents related to\n// the  source  code  (\"Material\")  are  owned  by  Intel  Corporation  or its\n// suppliers  or  licensors.    Title  to  the  Material  remains  with  Intel\n// Corporation or  its suppliers  and licensors.  The Material  contains trade\n// secrets  and  proprietary  and  confidential  information  of  Intel or its\n// suppliers and licensors.  The Material is protected  by worldwide copyright\n// and trade secret laws and treaty provisions. No part of the Material may be\n// used,   copied,   reproduced,   modified,   published,   uploaded,  posted,\n// transmitted,  distributed,  or  disclosed  in any way without Intel's prior\n// express written permission.\n//\n// No license under any patent,  copyright, trade secret or other intellectual\n// property  right  is  granted  to  or  conferred  upon  you by disclosure or\n// delivery  of  the  Materials, either expressly, by implication, inducement,\n// estoppel or otherwise.  Any license under such intellectual property rights\n// must be express and approved by Intel in writing.\n//\n// You will not, and will not allow any third party to modify, adapt, enhance, \n// disassemble, decompile, reverse engineer, change or create derivative works \n// from the Software except and only to the extent as specifically required by \n// mandatory applicable laws or any applicable third party license terms \n// accompanying the Software.\n//\n// -----------------------------------------------------------------------------\n// Engineer     : \n// Create Date  : Nov 2021\n// Module Name  : hello_fim_com.sv\n// Project      : IOFS\n// -----------------------------------------------------------------------------\n//\n// Description: \n// This is a simple module that implements DFH registers and \n// AVMM address decoding logic.\nmodule hello_fim_com #(\nparameter bit [11:0] FEAT_ID = 12'h001,\nparameter bit [3:0]  FEAT_VER = 4'h1,\nparameter bit [23:0] NEXT_DFH_OFFSET = 24'h1000,\nparameter bit END_OF_LIST = 1'b0\n)(\ninput clk,\ninput rst_n,\ninput [63:0] writedata,\ninput read,\ninput write,\ninput [3:0] byteenable,\noutput reg [63:0] readdata,\noutput reg readdatavalid,\ninput [5:0] address\n);\nreg [63:0] rdata_comb;\nreg [63:0] scratch_reg;\nalways @(posedge clk)  if (!rst_n) readdata[63:0] &lt;= 64'h0; else readdata[63:0] &lt;= rdata_comb[63:0];\nalways @(posedge clk)\nif (!rst_n) readdatavalid &lt;= 1'b0; else readdatavalid &lt;= read;\nwire wr = write;\nwire re = read;\nwire [5:0] addr = address[5:0];\nwire [63:0] din  = writedata [63:0];\nwire wr_scratch_reg = wr &amp; (addr[5:0]  == 6'h30)? byteenable[0]:1'b0;\n// 64 bit scratch register\nalways @( posedge clk)\nif (!rst_n)  begin\nscratch_reg &lt;= 64'h0;\nend\nelse begin\nif (wr_scratch_reg) begin scratch_reg &lt;=  din;  end\nend\nalways @ (*)\nbegin\nrdata_comb = 64'h0000000000000000;\nif(re) begin\ncase (addr)  6'h00 : begin\nrdata_comb [11:0]   = FEAT_ID ;  // dfh_feature_id  is reserved or a constant value, a read access gives the reset value\nrdata_comb [15:12]  = FEAT_VER ;  // dfh_feature_rev    is reserved or a constant value, a read access gives the reset value\nrdata_comb [39:16]  = NEXT_DFH_OFFSET ;  // dfh_dfh_ofst is reserved or a constant value, a read access gives the reset value\nrdata_comb [40]     = END_OF_LIST ;        //dfh_end_of_list\nrdata_comb [59:40]  = 20'h00000 ;  // dfh_rsvd1     is reserved or a constant value, a read access gives the reset value\nrdata_comb [63:60]  = 4'h3 ;  // dfh_feat_type  is reserved or a constant value, a read access gives the reset value\nend\n6'h30 : begin\nrdata_comb [63:0]   = scratch_reg; end\n6'h38 : begin\nrdata_comb [63:0]       = 64'h6626_0701_5000_0034;\nend\ndefault : begin\nrdata_comb = 64'h0000000000000000;\nend\nendcase\nend\nend\nendmodule\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#515-unit-level-simulations","title":"5.1.5. Unit Level Simulations","text":"<p>To run a unit level simulation test for the updated RTL files, make modifications to your cloned /my_ofs_project/ofs-d5005/sim/d5005/unit_test/dfh_walker files.  The following simulation files are updated to test the new hello_fim.</p> <ol> <li> <p>Edit sim/unit_test/dfh_walker/testbench/test_csr_defs.sv</p> </li> <li> <p>Update enum line 38</p> </li> </ol> <pre><code>       typedef enum {\nFME_DFH_IDX,\nTHERM_MNGM_DFH_IDX,\nGLBL_PERF_DFH_IDX,\nGLBL_ERROR_DFH_IDX,\nSPI_DFH_IDX,\nPCIE_DFH_IDX,\nHSSI_DFH_IDX,\nEMIF_DFH_IDX,\nHELLO_FIM_DFH_IDX,//New for HELLO_FIM\nFME_PR_DFH_IDX,\nPORT_DFH_IDX,\nUSER_CLOCK_DFH_IDX,\nPORT_STP_DFH_IDX,\nAFU_INTF_DFH_IDX,\nMAX_FME_DFH_IDX\n} t_fme_dfh_idx;\n</code></pre> <ol> <li>Edit function dfh_name line 78</li> </ol> <pre><code>function automatic dfh_name[MAX_FME_DFH_IDX-1:0] get_fme_dfh_names();\ndfh_name[MAX_FME_DFH_IDX-1:0] fme_dfh_names;\nfme_dfh_names[FME_DFH_IDX]         = \"FME_DFH\";\nfme_dfh_names[THERM_MNGM_DFH_IDX]  = \"THERM_MNGM_DFH\";\nfme_dfh_names[GLBL_PERF_DFH_IDX]   = \"GLBL_PERF_DFH\";\nfme_dfh_names[GLBL_ERROR_DFH_IDX]  = \"GLBL_ERROR_DFH\";\nfme_dfh_names[SPI_DFH_IDX]         = \"SPI_DFH\";\nfme_dfh_names[PCIE_DFH_IDX]        = \"PCIE_DFH\";\nfme_dfh_names[HSSI_DFH_IDX]        = \"HSSI_DFH\";\nfme_dfh_names[EMIF_DFH_IDX]        = \"EMIF_DFH\";\nfme_dfh_names[HELLO_FIM_DFH_IDX]        = \"HELLO_FIM_DFH\";//New for HELLO_FIM\nfme_dfh_names[FME_PR_DFH_IDX]      = \"FME_PR_DFH\";\nfme_dfh_names[PORT_DFH_IDX]        = \"PORT_DFH\";\nfme_dfh_names[USER_CLOCK_DFH_IDX]  = \"USER_CLOCK_DFH\";\nfme_dfh_names[PORT_STP_DFH_IDX]    = \"PORT_STP_DFH\";\nfme_dfh_names[AFU_INTF_DFH_IDX]    = \"AFU_INTF_DFH\";\nreturn fme_dfh_names;\nendfunction\n</code></pre> <ol> <li>Update get_fme_dfh_values</li> </ol> <pre><code>  function automatic [MAX_FME_DFH_IDX-1:0][63:0] get_fme_dfh_values();\nlogic[MAX_FME_DFH_IDX-1:0][63:0] fme_dfh_values;\nfme_dfh_values[FME_DFH_IDX]        = 64'h4000_0000_1000_0000;\nfme_dfh_values[THERM_MNGM_DFH_IDX] = 64'h3_00000_002000_0001;\nfme_dfh_values[GLBL_PERF_DFH_IDX]  = 64'h3_00000_001000_0007;\nfme_dfh_values[GLBL_ERROR_DFH_IDX] = 64'h3_00000_00C000_1004;  fme_dfh_values[SPI_DFH_IDX]        = 64'h3_00000_010000_000e;  fme_dfh_values[PCIE_DFH_IDX]       = 64'h3_00000_010000_0020;  fme_dfh_values[HSSI_DFH_IDX]       = 64'h3_00000_010000_100f;  fme_dfh_values[EMIF_DFH_IDX]       = 64'h3_00000_010000_0009; //Update to link to Hello_FIM \nfme_dfh_values[HELLO_FIM_DFH_IDX]  = 64'h3_00000_040000_0FFF;  //New for Hello_FIM\nfme_dfh_values[FME_PR_DFH_IDX]     = 64'h3_00000_001000_1005;  fme_dfh_values[PORT_DFH_IDX]       = 64'h4000_0000_1000_1001;\nfme_dfh_values[USER_CLOCK_DFH_IDX] = 64'h3_00000_001000_0014;\nfme_dfh_values[PORT_STP_DFH_IDX]   = 64'h3_00000_00D000_2013;\nfme_dfh_values[AFU_INTF_DFH_IDX]   = 64'h3_00001_000000_2010; return fme_dfh_values;\nendfunction\n</code></pre> <ol> <li>Update verification/scripts/Makefile_VCS.mk to set macro for INCLUDE_HELLO_FIM starting at line 56 to add +define+INCLUDE_HELLO_FIM ```bash session VLOG_OPT += +define+SIM_MODE +define+VCS_S10 +define+RP_MAX_TAGS=64 +define+INCLUDE_DDR4 +define+INCLUDE_SPI_BRIDGE +define+INCLUDE_USER_CLOCK +define+INCLUDE_HSSI +define+SIM_USE_PCIE_DUMMY_CSR +define+INCLUDE_HELLO_FIM <pre><code>1. Update sim/scripts/rtl_comb.f to add the path to your new hello_fim_top and hello_top_com SystemVerilog files.  The update is shown below as the new line - 329 below:\n\n```bash session\n$WORKDIR/src/hello_fim/hello_fim_com.sv\n$WORKDIR/src/hello_fim/hello_fim_top.sv\n</code></pre></li> </ol> <p>After making these changes, run the unit level simulation using sim/unit_test/dfh_walker test.  Before running, ensure your shell has the environment variables set properly as defined in Setting Up Required Environment Variables.</p> <p>```bash session cd verification/scripts gmake -f Makefile_VCS.mk cmplib gmake -f Makefile_VCS.mk build run [DUMP=1] <pre><code>Expected output:\n```bash session\n ********************************************\n Running TEST(0) : test_fme_dfh_walking\n********************************************\nREAD64: address=0x00000000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x4000000010000000\n\nFME_DFH\n   Address   (0x0)\n   DFH value (0x4000000010000000)\nREAD64: address=0x00001000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000020000001\n\nTHERM_MNGM_DFH\n   Address   (0x1000)\n   DFH value (0x3000000020000001)\nREAD64: address=0x00003000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000010000007\n\nGLBL_PERF_DFH\n   Address   (0x3000)\n   DFH value (0x3000000010000007)\nREAD64: address=0x00004000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x30000000c0001004\n\nGLBL_ERROR_DFH\n   Address   (0x4000)\n   DFH value (0x30000000c0001004)\nREAD64: address=0x00010000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x300000010000000e\n\nSPI_DFH\n   Address   (0x10000)\n   DFH value (0x300000010000000e)\nREAD64: address=0x00020000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000100000020\n\nPCIE_DFH\n   Address   (0x20000)\n   DFH value (0x3000000100000020)\nREAD64: address=0x00030000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x300000010000100f\n\nHSSI_DFH\n   Address   (0x30000)\n   DFH value (0x300000010000100f)\nREAD64: address=0x00040000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000100000009\n\nEMIF_DFH\n   Address   (0x40000)\n   DFH value (0x3000000100000009)\nREAD64: address=0x00050000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000400000fff\n\nHELLO_FIM_DFH\n   Address   (0x50000)\n   DFH value (0x3000000400000fff)\nREAD64: address=0x00090000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000010001005\n\nFME_PR_DFH\n   Address   (0x90000)\n   DFH value (0x3000000010001005)\nREAD64: address=0x00091000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x4000000010001001\n\nPORT_DFH\n   Address   (0x91000)\n   DFH value (0x4000000010001001)\nREAD64: address=0x00092000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000000010000014\n\nUSER_CLOCK_DFH\n   Address   (0x92000)\n   DFH value (0x3000000010000014)\nREAD64: address=0x00093000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x30000000d0002013\n\nPORT_STP_DFH\n   Address   (0x93000)\n   DFH value (0x30000000d0002013)\nREAD64: address=0x000a0000 bar=0 vf_active=0 pfn=0 vfn=0\n\n   READDATA: 0x3000010000002010\n\nAFU_INTF_DFH\n   Address   (0xa0000)\n   DFH value (0x3000010000002010)\nMMIO error count matches: x\n\nTest status: OK\n\n********************\n  Test summary\n********************\n   test_fme_dfh_walking (id=0) - pass\nTest passed!\nAssertion count: 0\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#516-synsyn_topd5005qsf","title":"5.1.6. syn/syn_top/d5005.qsf","text":"<ol> <li>Edit syn/syn_top/d5005.qsf      </li> <li>Add new macro \"INCLUDE_HELLO_FIM\" line 107 ```bash session         set_global_assignment -name VERILOG_MACRO \"INCLUDE_HELLO_FIM\" <pre><code>  2. Add new line 211 to source TCL script with new hello_fim files\n```bash session\n        set_global_assignment -name SOURCE_TCL_SCRIPT_FILE ../../../syn/setup/hello_fim_design_files.tcl\n</code></pre></li> </ol>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#517-synsetuphello_fim_design_filestcl","title":"5.1.7. syn/setup/hello_fim_design_files.tcl","text":"<p>Create \"hello_fim_design_files.tcl\" file and store in the syn/setup directory. This tcl file is called from d5005.qsf.</p> <pre><code># Copyright 2021 Intel Corporation.\n#\n# THIS SOFTWARE MAY CONTAIN PREPRODUCTION CODE AND IS PROVIDED BY THE\n# COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# Hello FIM Files\n#--------------------\nset_global_assignment -name SYSTEMVERILOG_FILE src/hello_fim/hello_fim_com.sv\nset_global_assignment -name SYSTEMVERILOG_FILE src/hello_fim/hello_fim_top.sv\n</code></pre>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#518-build-hello_fim-example","title":"5.1.8. Build hello_fim example","text":"<p>With the preceding changes complete, build the new hello_fim example using the following steps:</p> <p>```bash session cd $OFS_ROOTDIR ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005_hello_fim</p> <p><pre><code>Verify the design successfully compiled and timing closure is achieved by checking work_d5005_hello_fim/syn/syn_top/output_files/timing_report/clocks.sta.fail.summary - this file should be empty.  If there are timing failures, then this file will list the failing clock domain(s).\n\n### 5.1.9. Test the hello_fim on a D5005\n\nLoad the built FPGA binary file using an unsigned image.  The FPGA image will be in work_d5005_hello_fim/syn/syn_top/output_files/d5005_page1_unsigned.bin\n\nProvide the file d5005_page1_unsigned.bin on the server with the Intel\u00ae FPGA PAC D5005.\n\n```bash session\nsudo fpgasupdate d5005_page1_unsigned.bin &lt;D5005 PCIe B:D.F&gt;\nsudo rsu bmcimg &lt;D5005 PCIe B:D.F&gt;\n</code></pre> Verify FPGA image is loaded. ```bash session sudo fpgainfo fme</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#output_1","title":"Output","text":"<p>Intel FPGA Programmable Acceleration Card D5005 Board Management Controller, MAX10 NIOS FW version: 2.0.13  Board Management Controller, MAX10 Build version: 2.0.8  //** FME ****// Object Id                        : 0xF000000 PCIe s:b:d.f                     : 0000:3B:00.0 Vendor Id                        : 0x8086 Device Id                        : 0xBCCE SubVendor Id                     : 0x8086 SubDevice Id                     : 0x138D Socket Id                        : 0x00 Ports Num                        : 01 Bitstream Id                     : 0x40100022C164DB1 Bitstream Version                : 4.0.1 Pr Interface Id                  : 7d91e0d0-4dcd-58c3-a93d-b9295e6e29b0 Boot Page                        : user</p> <p><pre><code>Use the OPAE SDK tool opae.io to check default driver binding using your card under test PCIe B:D.F.  The steps below will use 0000:12:00.0 as the card under test PCIe B:D.F.\n\n```bash session\n sudo opae.io init -d 0000:12:00.0 $USER\n ##Output\n [0000:12:00.0] (0x8086, 0xbcce) Intel D5005 ADP (Driver: dfl-pci)\n</code></pre> The dfl-pci driver is used by OPAE SDK fpgainfo commands.  The next steps will bind the card under test to the vfio driver to enable access to the registers.</p> <p>```bash session  sudo opae.io init -d 0000:12:00.0 $USER  ##Output  opae.io 0.2.3 Unbinding (0x8086,0xbcce) at 0000:12:00.0 from dfl-pci Binding (0x8086,0xbcce) at 0000:12:00.0 to vfio-pci iommu group for (0x8086,0xbcce) at 0000:12:00.0 is 35 Assigning /dev/vfio/35 to $USER <pre><code>Confirm the vfio driver is bound to the card under test.\n\n```bash session\nopae.io ls\n## Output\nopae.io 0.2.3\n[0000:12:00.0] (0x8086, 0xbcce) Intel D5005 ADP (Driver: vfio-pci)\n</code></pre> Run the following command to walk DFH link list.  The new hello_fim register is located at offset 0x50000.</p> <p>```bash session opae.io walk -d 0000:12:00.0</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#output_2","title":"Output","text":"<p>opae.io 0.2.3 offset: 0x0000, value: 0x4000000010000000     dfh: id = 0x0, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4 offset: 0x1000, value: 0x3000000020000001     dfh: id = 0x1, rev = 0x0, next = 0x2000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x3000, value: 0x3000000010000007     dfh: id = 0x7, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x4000, value: 0x30000000c0001004     dfh: id = 0x4, rev = 0x1, next = 0xc000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x10000, value: 0x300000010000000e     dfh: id = 0xe, rev = 0x0, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x20000, value: 0x3000000100000020     dfh: id = 0x20, rev = 0x0, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x30000, value: 0x300000010000100f     dfh: id = 0xf, rev = 0x1, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x40000, value: 0x3000000100000009     dfh: id = 0x9, rev = 0x0, next = 0x10000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x50000, value: 0x3000000400000fff     dfh: id = 0xfff, rev = 0x0, next = 0x40000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x90000, value: 0x3000000010001005     dfh: id = 0x5, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x91000, value: 0x4000000010001001     dfh: id = 0x1, rev = 0x1, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x4 offset: 0x92000, value: 0x3000000010000014     dfh: id = 0x14, rev = 0x0, next = 0x1000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0x93000, value: 0x30000000d0002013     dfh: id = 0x13, rev = 0x2, next = 0xd000, eol = 0x0, reserved = 0x0, feature_type = 0x3 offset: 0xa0000, value: 0x3000010000002010     dfh: id = 0x10, rev = 0x2, next = 0x0, eol = 0x1, reserved = 0x0, feature_type = 0x3</p> <p><pre><code>Read the default values from the hello_fim registers:\n\n```bash session\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50000\nopae.io 0.2.3\n0x3000000400000fff\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50030\nopae.io 0.2.3\n0x0\n$ opae.io -d 0000:12:00.0 -r 0 peek 0x50038\nopae.io 0.2.3\n0x6626070150000034\n</code></pre> Write the scratchpad register at 0x50030</p> <p>```bash session $ opae.io -d 0000:12:00.0 -r 0 poke 0x50038 0x123456789abcdef opae.io 0.2.3 $ opae.io -d 0000:12:00.0 -r 0 peek 0x50038 opae.io 0.2.3 0x6626070150000034 $ opae.io -d 0000:12:00.0 -r 0 poke 0x50030 0x123456789abcdef opae.io 0.2.3 $ opae.io -d 0000:12:00.0 -r 0 peek 0x50030 opae.io 0.2.3 0x123456789abcdef $ opae.io -d 0000:12:00.0 -r 0 poke 0x50030 0xfedcba9876543210 opae.io 0.2.3 $ opae.io -d 0000:12:00.0 -r 0 peek 0x50030 opae.io 0.2.3 0xfedcba9876543210 $ opae.io -d 0000:12:00.0 -r 0 poke 0x50030 0x55550000aaaaffff opae.io 0.2.3 $ opae.io -d 0000:12:00.0 -r 0 peek 0x50030 opae.io 0.2.3 0x55550000aaaaffff <pre><code>Release the card under test from the vfio driver to re-bind to the dfl-pci driver:\n\n```bash session\nsudo opae.io release -d 0000:12:00.0\n## Output\nopae.io 0.2.3\nReleasing (0x8086,0xbcce) at 0000:12:00.0 from vfio-pci\nRebinding (0x8086,0xbcce) at 0000:12:00.0 to dfl-pci\n$ sudo opae.io ls\nopae.io 0.2.3\n[0000:12:00.0] (0x8086, 0xbcce) Intel D5005 ADP (Driver: dfl-pci)\n</code></pre></p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#52-memory-subsystem-modification","title":"5.2. Memory Subsystem Modification","text":"<p>OFS enables modifications on the different subsystems that encompass the FIM. To customize the Memory Subsystem follow these instructions.</p> <ol> <li> <p>Set up the environment variables as described in section 4.2.1. Setting Up Required Environment Variables</p> </li> <li> <p>Modify the NUM_MEM_CH parameter in src/afu_top/mux/top_cfg_pkg.sv Change NUM_MEM_CH from 4 to 2 as shown in below code </p> </li> </ol> <pre><code>//=========================================================================================================================\n//                         OFS Configuration Parameters                                                                 \n//=========================================================================================================================\nparameter NUM_MEM_CH     = 2                                                 ,// Number of Memory/DDR Channel         \nNUM_HOST       = 1                                                 ,// Number of Host/Upstream Ports        \nNUM_PORT       = 4                                                 ,// Number of Functions/Downstream Ports \nDATA_WIDTH     = 512                                               ,// Data Width of Interface              \nTOTAL_BAR_SIZE = 20                                                ,// Total Space for APF/BPF BARs (2^N) \n//------------+-------------+-------------+-----------------+           //--------------------------------------\n// VF Active  |     PF #    |     VF #    |  Mux Port Map   |           //  PF/VF Mapping Parameters            \n//------------+-------------+-------------+-----------------+           //--------------------------------------\nCFG_VA = 0  , CFG_PF = 0  , CFG_VF =  0 ,  CFG_PID = 3    ,           //  Configuration Register Block        \nHLB_VA = 1  , HLB_PF = 0  , HLB_VF =  0 ,  HLB_PID = 0    ,           //  HE Loopback Engine                  \nPRG_VA = 1  , PRG_PF = 0  , PRG_VF =  1 ,  PRG_PID = 1    ,           //  Partial Reconfiguration Gasket      \nHSI_VA = 1  , HSI_PF = 0  , HSI_VF =  2 ,  HSI_PID = 2    ;           //  HSSI interface \n</code></pre> <p>Compile a new FIM that incorporates the newly configured Memory Subsystem. </p> <p>```bash session cd $OFS_BUILD_ROOT/ofs-d5005 ofs-common/scripts/common/syn/build_top.sh d5005 work_d5005_mem_2channel <pre><code>\n</code></pre></p> <p>        OFS_PROJECT: d5005         Q_PROJECT:  d5005         Q_REVISION: d5005         SEED: 03         Build Complete         Timing Passed!</p> <pre><code>Program d5005_page1_unsigned.bin file using below command\n\n```bash session\nsudo fpgasupdate d5005_page1_unsigned.bin 3b:00.0\n</code></pre> <p>Run rsu command ```bash session sudo rsu bmcimg 3b:00.0 <pre><code>Check if binary was loaded correctly\n```bash session\nfpgainfo fme\n## Output\nIntel FPGA Programmable Acceleration Card D5005\nBoard Management Controller, MAX10 NIOS FW version: 2.0.13\nBoard Management Controller, MAX10 Build version: 2.0.13\n//****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 288511861987640872\nBitstream Version                : 4.0.1\nPr Interface Id                  : d51533ad-aee6-5dab-80fb-a44bbf579b68\nBoot Page                        : user\n</code></pre></p> <p>Run Host Excersiser to check Memory Subsystem performance</p> <p>```bash session sudo host_exerciser mem</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#output_3","title":"Output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer     Host Exerciser Performance Counter:     Host Exerciser numReads: 1024     Host Exerciser numWrites: 1025     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 5365     Total number of Reads sent: 1024     Total number of Writes sent: 1024     Bandwidth: 3.054 GB/s     Test mem(1): PASS <code>Verify Memory controller placement in syn/syn_top/output_files/d5005.fit.place.rpt file. Open fitter place stage report in any text editor of your choice, find keyword *emif* in the file. You should see emif[0] &amp; emif[1] for Memory channel 0 &amp; 1 respectively.</code>verilog |emif[0].ddr4_pr_freeze_sync|                ; 0.4 (0.0)            ; 0.5 (0.0)                        ; 0.1 (0.0)                            ; |resync_chains[0].synchronizer_nocut|        ; 0.4 (0.4)            ; 0.5 (0.5)                        ; 0.1 (0.1)                            ; |emif[0].ddr4_softreset_sync|                ; 0.5 (0.0)            ; 0.7 (0.0)                        ; 0.2 (0.0)                            ; |resync_chains[0].synchronizer_nocut|        ; 0.5 (0.5)            ; 0.7 (0.7)                        ; 0.2 (0.2)                            ; |emif[0].pr_frz_afu_avmm_if|                 ; 647.5 (647.5)        ; 917.3 (917.3)                    ; 272.8 (272.8)                        ; |emif[1].ddr4_pr_freeze_sync|                ; 0.4 (0.0)            ; 0.8 (0.0)                        ; 0.4 (0.0)                            ; |resync_chains[0].synchronizer_nocut|        ; 0.4 (0.4)            ; 0.8 (0.8)                        ; 0.4 (0.4)                            ; |emif[1].ddr4_softreset_sync|                ; 0.4 (0.0)            ; 1.0 (0.0)                        ; 0.6 (0.0)                            ; |resync_chains[0].synchronizer_nocut|        ; 0.4 (0.4)            ; 1.0 (1.0)                        ; 0.6 (0.6)                            ; |emif[1].pr_frz_afu_avmm_if|                 ; 641.1 (641.1)        ; 914.0 (914.0)                    ; 272.9 (272.9)                        ; |p[0].pr_frz_fn2mx_a_port|                   ; 435.4 (0.0)          ; 476.2 (0.0)                      ; 40.8 (0.0)                           ; |r.axis_pl_stage[0].axis_reg_inst|           ; 435.4 (435.4)        ; 476.2 (476.2)                    ; 40.8 (40.8)                          ; |p[0].pr_frz_fn2mx_b_port|                   ; 434.6 (0.0)          ; 494.3 (0.0)                      ; 59.6 (0.0)                           ;  ```</p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#6-conclusion","title":"6. Conclusion","text":"<p>Using the OFS reference design and OPAE SDK enables the rapid creation of market leading FPGA based Acceleration systems. OFS facilitates customization of the FIM area for your custom board or platforms. </p>"},{"location":"hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others.   </p> <p>example AFUs</p>"},{"location":"hw/d5005/doc_modules/Glossary/","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/doc_modules/links/","title":"Links","text":"<p>example AFUs</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/","title":"FPGA Interface Manager Technical Reference Manual: Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1-overview","title":"1 Overview","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document describes the hardware architecture of the\u200b Open FPGA Stack (OFS) targeting the Intel\u00ae Stratix 10 FPGA.  After reviewing this document you should understand the features and functions of the components that comprise the FPGA Interface Manager (FIM), also known as the \"shell.\"</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#glossary","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12-introduction-to-the-open-fpga-stack","title":"1.2 Introduction to the Open FPGA Stack","text":"<p>The Open FPGA Stack (OFS) is a modular collection of hardware platform components, open source upstreamed software, and broad ecosystem support that enables an efficient path to develop a custom FPGA platform.  OFS Provides a framework of FPGA synthesizable code, simulation environment and synthesis/simulation scripts.  The key components of OFS include: -   Target development platforms such as Intel-branded Programmable Acceleration Cards (PACs), Acceleration Development Platforms (ADPs) and third-party platforms.</p> <ul> <li>Board Management Controller RTL and firmware that supports telemetry monitoring, remote configuration updates and most importantly a root of trust for the platform.</li> </ul> <ul> <li> <p>Source accessible, modular FPGA Interface  manager (FIM) RTL with unit tests that can be leveraged for your own custom FIM design</p> </li> <li> <p>Basic building blocks for interconnect and PF/VF translation and arbitration; Platform Interface Manager (PIM) which provides Avalon\u00ae bus compliant interfaces.</p> </li> <li> <p>AFU examples both in the git repository and workload examples provided by 3rd party vendors</p> </li> <li> <p>The OneAPI shim provides a layer that is used by the OneAPI runtime to communicate with the kernel.</p> </li> </ul> <ul> <li> <p>OPAE software development kit (APIs, upstreamed Linux drivers and software tools)</p> </li> <li> <p>Support for other frameworks to be built on top of the OPAE such as DPDK </p> </li> </ul> <p>The OFS hardware repository supports hardware development and simulation.  Repositories for OFS high level design support and board management controller RTL and firmware source code are also provided.  These repositories can be found in the Intel Opensource Technology GitHub location, which requires entitlement access.  To request access, please contact your local Intel sales representative.</p> <p>Table 1-2 OFS GitHub Repositories (https://github.com/OFS/)</p> Repository Contains ofs-fim-common Contains common modules shared by all OFS designs.  This repository is a submodule of each platform repository. ofs-d5005 Contains FIM or shell RTL design, automated compilation scripts, unit tests. <p> The OPAE software GitHub site is fully opensource and contains resources for both software and workload developers.</p> <p>Table 1-3 OPAE Public Git Repositories (https://github.com/OFS)</p> OPAE Git Repository Folder Contains linux-dfl Contains OFS Linux drivers that are being upstreamed to the Linux kernel. linux-dfl-backport Backport versions of the linux-dfl to older kernel versions. opae-sdk Contains the files for building and installing OPAE SDK from source. opae-sim Contains an AFU/Workload simulator for software/hardware co-simulation. examples-afu Contains simple AFU tutorials. <p>Providing the hardware and software source code and supporting test frameworks in a GitHub repository allows you to easily customize your own designs with the latest versions.</p> <p>Most hardware and software ingredients are available in our OFS GitHub location.  For access to the board management controller firmware and RTL or our security guide for OFS, please contact a local Intel sales representative. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#13-ofs-features","title":"1.3 OFS Features","text":"<p>The OFS architecture within the FPGA comprises two partitions:</p> <ul> <li> <p>FPGA Interface Manager (FIM)</p> </li> <li> <p>Accelerator Functional Unit (AFU)</p> </li> </ul> <p>The FIM or shell provides platform management functionality, clocks, resets and interface access to the host and peripheral features of the acceleration platform. The FIM architecture along with the supporting OPAE software supports features such as partial reconfiguration and virtualization. The FIM provides a standard Arm AMBA 4 AXI4 datapath interface. The FIM resides in the static region of the FPGA.</p> <p>The AFU partition is provided for custom acceleration workloads and may contain both static and partial reconfiguration regions.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#131-fpga-interface-manager-fim","title":"1.3.1 FPGA Interface Manager (FIM)","text":"<p> The updated OFS architecture for Intel\u00ae Stratix 10\u00ae FPGA devices improves upon the modularity, configurability and scalability of the first release of the OFS architecture while maintaining compatibility with the original design.  The primary components of the FPGA Interface Manager or shell of the reference design are: </p> <ul> <li>PCIe Subsystem</li> <li>HSSI Subsystem</li> <li>Memory Subsystem</li> <li>Reset Controller</li> <li>FPGA Management Engine</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from Host or AFU</li> <li>SPI Interface to BMC controller</li> </ul> <p>The AFU Region provides design space for custom workloads and contains both static and partial reconfiguration regions.  Partial reconfiguration allows you to update your specific logic blocks or entire workload while the rest of your static design is still in operation.</p> <p>Note that as discussed previously, the BMC RTL and firmware, the OFS OPAE software stack and support for building your own customer board support package are also provided in separate OFS repositories.</p> <p>Figure 1-2 OFS for Intel Stratix 10 Block Diagram</p> <p></p> <p>The table below details the features of the OFS release targeting the Intel\u00ae Stratix 10\u00ae FPGA .</p> <p>Table 1-4 Features</p> Key Feature OFS Update Comments PCIe H-tile PCIe Gen3x16 Interface Integrates PCIe TLP adapter for new data mover packet format. MSI-X vector and PBA tables are located in the PCIe subsystem. Interrupts from  FME as well as four user interrupts coming from PF0.VF1 are supported. Memory Two Avalon Memory Mapped channels provided as default with capability to compile design with four channels support. - HSSI 1 Arm* AMBA* 4 AXI4-Stream channel of 10G Ethernet, using the low latency Ethernet 10G MAC Intel FPGA IP interfacing to an E-tile PHY.  - Manageability SPI interface to Board Management Controller targeting Intel FPGA PAC D5005 - CoreFIM Flexible configuration support using Arm* AMBA* 4 AXI4-Stream Physical Function/Virtual Function (PF/VF) Demux/Mux and AFU Peripheral Fabric (APF) and Board Peripheral (BPF) Fabric Interconnects.   APF and BPF fabrics are Platform Designer generated IPs. The Arm* AMBA* 4 AXI4-Stream PF/VF Demux/Mux is a new component.  Physical Function/Virtual 1 PF/3VF configuration is provided as an example but the architecture now supports full virtualization with the ability to expand to whatever the PCIe tile supports. - Partial Reconfiguration 1 Partial Reconfiguration region supported in hardware and software - Sample test PR AFUs Host exerciser modules provided to exercise interfaces.  These modules are provided in both the flat and PR AFU examples. - OneAPI Yes Available Q1 2023 Software Support OFS software stack with support for full virtualization. -"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#fpga-management-engine-fme","title":"FPGA Management Engine (FME)","text":"<p>The FIM contains only one FME, regardless of the number of host interfaces to the FIM. The FME provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link.  For more information about DFHs, refer to the [Device Feature Header (DFH) structure].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#streaming-datapath","title":"Streaming Datapath","text":"<p>The FIM implements an AXI4-Stream bus protocol for data transfer in the FIM. AXI4-Stream channels send data packets to and from the host channel IP without data abstraction. Memory-mapped I/O (MMIO) CSR accesses are routed to the ST2MM module which converts the AXI4-Stream to an AXI4 memory mapped protocol.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#virtualization","title":"Virtualization","text":"<p>This design supports virtualization by making use of the virtualization functionality in the PCIe Hard IP and mapping packets to the appropriate physical or virtual function through a PF/VF multiplexer.  This reference FIM supports 1 PF and 3 VFs as an example; however, you may extend your configuration to whatever the PCIe Hard IP can support or what your application requires.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#132-afu","title":"1.3.2 AFU","text":"<p>An AFU is an acceleration workload that interfaces to the FIM. The AFU boundary in this design comprises both static and partial reconfiguration (PR) regions.  You can decide how you want to partition these two areas or if you want your AFU region to only be a partial reconfiguration region.  A port gasket within the design provides all the PR specific modules and logic required partial reconfiguration. Only one partial reconfiguration region is supported in this design.</p> <p>Similar to the FME, the port gasket exposes its capability to the host software driver through a DFH register placed at the beginning of the port gasket CSR space. In addition, only one PCIe link can access the port register space.  The port is part of the FPGA Interface Unit (FIU) that resides in the FIM.</p> <p>You can compile your design in one of the following ways: * Your entire AFU resides in a partial reconfiguration region of the FPGA  * The AFU is part of the static region and is compiled a flat design</p> <p>In this design, PF0.VF1 and PF0.VF2 map to host exerciser modules (HEM) that map to HE-LB and HE-HSSI respectively.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#133-platform-interface-manager","title":"1.3.3 Platform Interface Manager","text":"<p> The PIM provides a way to abstract the AXI4-Stream interface to the AFU by providing a library of shims that convert the host channel native packet into other protocols such as CCI-P, AXI4 memory-mapped, Avalon\u00ae streaming (Avalon-ST) or Avalon\u00ae memory-mapped (Avalon-MM). The FPGA or AFU developer implement these interface abstractions in the AFU region of the design.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#134-opae-sdk-fpga-platform-feature-discovery","title":"1.3.4 OPAE SDK FPGA Platform Feature Discovery","text":"<p> The OPAE C library in the OPAE software development kit is built on top of the OPAE Intel FPGA driver stack that abstracts the hardware and operating system specific details of the platform to the host. The FIM implements a DFH linked list to allow an FPGA platform driver running on the host to discover FME, port and AFU features. This model is similar to how PCIe enumeration occurs. You must implement a 64-bit DFH Device Feature Header register at the beginning (first 8B aligned address) of the feature CSR space for a new feature to be discovered or enumerated by a driver.</p> <p>A driver starts the traversing by reading the DFH of the first feature from the first address on PF0 BAR0. Based on the information in the DFH, a driver can determine the CSR address range of the feature and other associated details of the feature. The end of the DFH contains a \"next DFH offset\" field that points the driver to the DFH of the next feature. The software must continue traversing the linked list until it sees the EOL (End-Of-List) bit set to 1 in the \"next DFH offset\" field it is inspecting. A 1 indicates this is the last feature in the feature set. Figure below gives a simple illustration of the feature discovery by traversing the DFH registers.</p> <p>Figure 1-3 Device Feature Header Linked List Traversal </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#135-ofs-reference-design","title":"1.3.5 OFS Reference Design","text":"<p> OFS provides FIM designs you can use as a starting point for your own custom design. These designs target a specific programmable acceleration card or development kit and exercise key FPGA device interfaces. The Intel Stratix\u00ae 10 code line for OFS targets the Intel FPGA PAC D5005.  FIM designs are released to [OFS D5005 FIM Github Branch] for evaluation and use.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#136-fim-simulation","title":"1.3.6 FIM Simulation","text":"<p> OFS provides a UVM environment for the FIM and a framework for new feature verification. UVM provides a modular, reusable, and scalable testbench structure by providing an API framework that can be deployed across multiple projects. The FIM testbench is UVM compliant and integrates third-party verification IPs from Synopsys that require license to use. Verification components include:</p> <ul> <li> <p>FIM monitor to detect correct design behavior</p> </li> <li> <p>FIM assertions for signal level integrity testing</p> </li> <li> <p>Arm AMBA AXI4 scoreboards to check data integrity</p> </li> <li> <p>FIM coverage to collect functional data</p> </li> </ul> <p>The verification infrastructure can be in the verification folder here [OFS D5005 FIM Github Branch]  for evaluation and use. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#2-ofs-high-level-architecture","title":"2 OFS High Level Architecture","text":"<p>OFS provides distinct datapaths that simplifies the design and integration process for add or for removing interface modules:</p> <ul> <li>High Bandwidth datapath for AFU-attached high performance peripherals (HSSI, Memory, HPS, workload).</li> <li>Low Bandwidth datapath for OFS management and slow peripheral components (JTAG, I2C, SMBus).</li> <li>AFU Peripheral Fabric (APF) to Board Peripheral Fabric (BPF) path to communicate with interface control and status registers (CSRs) and board components.</li> <li>Peer-to-peer datapath between AFU components.</li> <li>Peer-to-peer datapath between BPF components.</li> </ul> <p>Depending on your design goals, you can present peripherals to software as:</p> <ul> <li>OFS managed peripherals with a device feature header that is part of a device feature list.</li> <li>Native driver managed peripherals that are exposed through an independent physical function or virtual function.</li> </ul> <p>Figure 2-1 OFS Datapath Structure</p> <p></p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#3-pcie-interface","title":"3 PCIe Interface","text":"<p> The FIM's H-tile PCIe* hard IP is a Gen3x16 design.  The IP supports SR-IOV and is configured to provide one PF and three VFs.  Native PCIe TLP packets are sent through the PCIe using Arm AMBA 4 AXI-4 Stream Protocol.  Before they reach the AFU, however, the packets go through an adapter that converts any headers to a data mover format that is forward compatible with Intel Agilex FPGA devices and beyond.   </p> <p>Figure 3-1 OFS FIM RX-TX Datapath</p> <p></p> <p>Some key features of the PCIe interface are:</p> Feature OFS for Intel Stratix 10 Configuration Mode PCIe Gen3x16 Port Mode Native Endpoint SR-IOV 1 PF, 3 VFs MSI-X Support Yes Functional Mode Data Mover Profile Virtual+ TLP Bypass No Header Packing Scheme Simple Data Width 512-bit (64-byte) PLD Clock Frequency 250 MHz Tags Supported 128 Reordering No reordering of requests, no completion reordering Maximum Payload Size 256 Bytes Memory Requests Supported 1CL, 2CL, 4CL MMIO transaction Size 4B, 8B"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#31-receiver-datapath","title":"3.1 Receiver Datapath","text":"<p> The path of data received by the FIM is as follows:</p> <ol> <li> <p>The PCIe Hard IP receives TLP packets from the host.  Host response types can be:</p> <ul> <li>MMIO read or response</li> <li>Memory write request</li> <li>Interrupt response</li> <li>Memory read request or response</li> </ul> </li> <li> <p>The PCIe IP routes the TLP packets to the PCIe bridge interface in     the FIM, where they get buffered into the RX FIFO.</p> </li> <li> <p>The TLP checker in the bridge examines the packets and filters     erroneous packets including packets with unsupported requests or fields.     Errors are sent to the error logger and are logged as advance error     reporting (AER). Error status is sent to the PCIe hard IP and to the     FIM error status registers. Appropriate action is taken for the     errors as described in the Reliability, Accessibility, Serviceability (RAS) and Error Handling section. The TLP checker also     maintains RX buffer credits for TLP completions with data (CplD)     that are received from the host in response to a memory read request     (MRd request sent by the AFU). The TLP checker notifies the PCIe TX bridge when there are not enough RX buffer credits available in the PCIe RX bridge. If there are not enough credits, the PCIe TX bridge pauses MRd requests from the AFU to Host until there     is availability.</p> </li> <li> <p>The TLP checker forwards packets that pass TLP checking to an AXI4     adapter which moves the packets into an Arm AMBA 4 AXI4-Stream bus.</p> </li> <li> <p>AXI4-Stream packets are sent downstream to datamover AXI4-Stream adapter to be modified into the new datamover packet format.</p> </li> <li> <p>Datamover packets are sent to the PF/VF Mux in the AFU.</p> </li> <li> <p>The AXI4-Stream to Memory Mapped (ST2MM) module in the AFU region routes MMIO requests targeting FIM CSRs (FME, peripherals and AFU).</p> </li> </ol>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#32-transmit-datapath","title":"3.2 Transmit Datapath","text":"<p> The Transmit (TX) datapath refers to all TLP packet types that originate in the FPGA.  A single Arm AMBA 4 AXI4-Stream channel at the port interface boundary of the FIM carries PCIe TLP packets and interrupt requests upstream from the AFU.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#33-data-handshaking","title":"3.3 Data Handshaking","text":"<p> The Arm AMBA 4 AXI4 interfaces to the AFU use the <code>VALID</code> and <code>READY</code> signal for handshaking and backpressure management.  The FIM holds the <code>DATA</code> and <code>VALID</code> asserted until the receiver asserts the <code>READY</code> signal.  The AFU accepts the data when both the <code>VALID</code> and <code>READY</code> signals are asserted. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#34-arm-amba-4-axi4-stream-interface","title":"3.4 Arm AMBA 4 AXI4-Stream Interface","text":"<p>The table below shows the high-level signal mapping of the channels for the OFS for Intel Stratix 10 FPGA.  If you have previously used the OFS EA architecture, that mapping is provided as a comparison as well in this table.  </p> <p>Table 3-1 AXI4-Stream RX Channel</p> AXI4-Stream Signal Source OFS Stratix 10 Mapping OFS Early Access Mapping ACLK Clock Source PCLK = 250 MHz PCLK = 250 MHz AResetn Reset Source System Reset System Reset TVALID Master Data Valid Data Valid TREADY Slave Ready Ready TDATA Master Width=512 bits When packet includes a header (32 bytes) and data the packing scheme is: 16B data mover header: 4B prefix PF NumberVM Number VF Active Slot Number Memory Mapped Number8B Address/Metadata Data: 32B If the packet is only data then all 64 bytes comprise data [TLP_CH] [8n]  n=49 (392 bits)TLP_CH=2 (2TLP data streams)Mapping of each TLP data stream [391:136] payload (32-byte data payload) [135:8]: hdr (16 byte header) [7:3]: rsvd0 (reserved bits)[2]: end of packet (eop)  [1]: start of packet (sop)  [0]: valid (TLP packet on data stream is valid) TLAST Master Set to 1'b1 when end of packet is sent; otherwise TLAST is 1'b0 Set to 1'b1 when end of packet is sent; otherwise TLAST is 1'b0 TKEEP Byte Qualifier Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. TUSER Master WIDTH = 10  Bit 0 is always equal to 1'b1 to indicate data mover header format [4:1] - Indicates header position on the TDATA bus and is always equal to 4'b0001 indicating that the header starts from Byte0.All other bits of TUSER are unused. [TLP_CH][u-1:0] u=21 Sideband of each TLP data stream[20]: ummio_rd (Unsupported MMIO request)[19:0]: destination routing ID, where:[19:17]= BAR offset[2:0][16:4]=VF number[12:0][3:1]=PF number[2:0][0]=vf_active, indicating if the virtual function feature is enabled <p>Figure 3-3 AXI4-Stream RX Request Cycle Header Format</p> <p></p> <p>All Host requests sent to the AFU are memory-mapped I/O requests.  Of the fields below, the following are not supported in the design: * Prefix * Slot number (set to 0) * Local Address</p> <p>Figure 3-4 AXI4-Stream RX Completion Header Format</p> <p></p> <p>All completions in the RX direction are data completions.  Of the fields below, the following are not supported in the design: * Prefix * MM mode * Slot number (set to 0) * Meta Data</p> <p>Note that: * VF Active, VF Num and PF Num are obtained from TUSER. * Data packet responses (for memory read requests from the AFU) from the PCIe may come out of order when the size is greater than 64 bytes.</p> <p>Table 3-2 AXI4-Stream TX Channel</p> AXI4-Stream Signal Source OFS Stratix 10 Mapping OFS Early Access Mapping ACLK Clock Source PCLK = 250 MHz PCLK = 250 MHz AResetn Reset Source System Reset System Reset TVALID Master Data Valid Data Valid TREADY Slave Ready ReadyOnly 1 ready signal for the two channels TDATA Master Width=512 bits When packet includes a header (32 bytes) and data the packing scheme is: 16B data mover header: 4B prefix PF NumberVM Number VF Active Slot Number Memory Mapped Number8B Address/Metadata Data: 32B If the packet is only data then all 64 bytes comprise data [TLP_CH] [8n]  n=49 (392 bits)TLP_CH=2 (2TLP data streams)Mapping of each TLP data stream [391:136] payload (32 byte data payload) [135:8]: hdr (16 byte header) [7:3]: rsvd0 (reserved bits)[2]: end of packet (eop)  [1]: start of packet (sop)  [0]: valid (TLP packet on data stream is valid) TLAST Master Per protocol Set to 1'b1 TKEEP Byte Qualifier Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. Signal indicates whether content of the associated byte is valid.  Invalid bytes are allowed only during TLAST cycle.  Valid bytes always start from Byte 0. TUSER Master WIDTH = 10  Bit 0 \u2013 Indicates Header Format: 0 \u2013 Power user mode header format 1 \u2013 Data mover header format Bit [4:1] - Indicates header position on the TDATA bus and is always equal to 4'b0001 indicating that the header starts from Byte0.All other bits of TUSER are unused. [TLP_CH][u-1:0] u=2Sideband of each TLP data stream[0]=vf_active, indicating if the virtual function feature is enabled[0]: afu_irq (AFU interrupt) <p>Table 3-3 Interrupt Response Channel</p> AXI4-Stream Signal Source Mapping ACLK Clock Source PCLK AResetn Reset Source System Reset TVALID Master Valid TREADY Slave Ready TDATA [8n-1:0]  n=3 (24 bits) Master [23:16]: 8-bit interrupt ID  [15:0]: Requester ID <p>Figure 3-5:  AXI4-Stream TX Request Cycle Header Format</p> <p></p> <p>All requests in the TX direction are Memory Read/Write. The requester ID does not come from the AFU; the AXI-Stream adapter supplies it.  The tag must come from the AFU.  Of the fields below, the following are not used in the H-Tile PCIe subsystem design: * Prefix * MM Mode * Slot number (set to 0) * Local Address</p> <p>Note that VF Active, VF Num and PF Num are obtained from the header packet.</p> <p>Figure 3-4 AXI4-Stream TX Completion Header Format</p> <p></p> <p>All completions in the TX direction are for MMIO.  Of the fields below, the following are not supported in the design: * Prefix * MM mode * Slot number (set to 0) * Meta Data</p> <p>Note that: * VF Active, VF Num and PF Num are obtained from TUSER.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#4-platform-interface-manager","title":"4 Platform Interface Manager","text":"<p> The FIM interfaces to an AFU through AXI4-Stream channels.  This format allows the AFU to access the host channel's raw interface without any translation. As a FIM developer, you have the option to provide the raw data format associated with the host interface channel to the workload or AFU developer or you can provide an intermediate protocol using Platform Interface Manager Components or your own custom interface. If you expose the raw AXI4-Stream interface of the FIM, workload developers also have the option to convert to a desired protocol using the PIM resources as well.  </p> <p>Refer to https://github.com/OPAE/ofs-platform-afu-bbb for more information on options for implementing the PIM.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#5-afu-interface-handler","title":"5 AFU Interface Handler","text":"<p>The AFU Interface Handler resides inline between the PCIe AXI4-Stream Adapter and the AXI4-Stream PF/VF Demux/Mux logic. Its main function is to provide:  * Unique PCIe tags \u2013 Each PCIe transaction shares the 128 tags across all VFs in the AFU region * AFU error logging for all VFs in the AFU region</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#51-afu-error-handling","title":"5.1 AFU Error Handling","text":"<p>In this OFS design, the AFU Interface Handler handles error logging for all VFs in the AFU. Errors handled are as follows</p> Checker Field Description AFU protocol checker (PCIe TLP) TxReqCounterOverflow Pending memory write or memory read requests exceed the predefined limit TxFifoOverflow Tx FIFO in the port that buffers TLP packets from AFU is overflow Malformed TLP AFU PCIe TLP contains unsupported format type MaxPayloadError AFU memory write payload size exceeds max_payload_length limit MaxReadReqSizeError AFU memory read payload size exceeds max_read_request_size limit MaxTagError AFU memory read request tag value exceeds the maximum supported tag count TagOccupiedErr AFU sends out memory read request using a tag that is already used for a pending memory read request UnalignedAddrErr The address field in AFU memory write/read request TLP is not DW-aligned. UnexpMMIOResp AFU is sending a MMIO read response with no matching MMIO read request. MMIOTimedOutAFU is not responding to a MMIO read request within the pre-defined response timeout period.  MMIODataPayloadOverrunThe number of data payload sent by AFU for a MMIO response (cplD) is more than the data length specified in the response. MMIOInsufficientDataThe number of data payload sent by AFU for a MMIO response (cplD) is less than the data length specified in the response. TxMWrDataPayloadOverrun    The number of data payload sent by AFU for a memory write request is more than the data length specified in the request. TxMWrInsufficientData  The number of data payload sent by AFU for a memory write request is less than the data length specified in the request. AFU Protocol Checker (AXI4-Stream)TxValidViolationThree checkers are implemented in the FIM to catch errors and protocol violations. <p>To view the CSR space for the AFU interface handle, go to the src/afu_top/AFU_INTF_CSR.xls file [OFS D5005 FIM Github Branch].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#6-interconnect-fabric","title":"6 Interconnect Fabric","text":"<p>There are three types of interconnect fabric in the OFS FIM design:  * AXI4-Stream mux/demux fabric  * AFU Periheral Fabric (APF)  * Board Peripheral Fabric (BPF)</p> <p>Figure 6-1 Interonnect Fabric Diagram</p> <p></p> <p>TLP packets sent from upstream PCIe Subsystem on AXI4-Stream channel are demultiplexed in the AXI4-Stream PF/VF mux/demux fabric and routed to the respective PF/VF function based on the PF/VF information in the TLP header, such as vf_active or the PF/VF number. On the opposite direction, TLP packets from downstream PF/VF function are muxed in the fabric and sent to PCIe subsystem over AXI4-Stream channel.</p> <p>All host MMIO requests targeting PF0 BAR0 are routed to the ST2MM module. The ST2MM converts MMIO TLP packets into AXI-Lite memory requests and places the requests onto AFU Peripheral Fabric (APF). AFU peripherals, such as OFS managed AFU features and ST2MM) and Board Peripheral Fabric (BPF) are interconnected by APF. The BPF is the interconnect fabric one hiearchy below APF which connects all the board peripherals. Both APF and BPF allow multiple AXI4-Lite master and slave interconnect topology.</p> <p>The following table summarizes the mechanism for configuring PF/VF functions:</p> <p>Table 6-1 Interconnect Configuration Methods </p> InterconnectConfiguration Mechanism APF or BPFEither:Use Platform Designer (PD) to generate the fabrics directly, or  Specify desired cfg in iofs_dfl.txt and run dfh2tcl.pl script to generate the necessary HW TCL scripts as needed by PD. This PERL script also takes care of invoking PD in script mode to generate the end result of RTL design Verilog files. This is the preferred method for generation. AXI-S PF/VF Demux/MuxUpdate parameters in these RTL files: * src/includes/top_cfg_pkg.sv * src/common/pf_vf_mux.sv Then make the corresponding update to AFU top level instantiation and connections: * src/FIMs/.../afu_top.sv <p>Note:</p> <p>In all cases, you must configure and regenerate the PCIe IP to match the new PF/VF configuration if it deviates from the reference FIM provided.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#61-fabric-generation-flow","title":"6.1 Fabric Generation Flow","text":"<p>You have two options to generate APF/BPF IPs.</p> <ul> <li> <p>Use Quartus Platform Designer.  This method requires familiarity with Quartus Platform Designer.  With this option, you manually enter each address space and define the associated master and slave interface in a table provided by the Platform Designer.  The parameters and attributes such as data width, address width, number of outstanding cycles, \u2026 etc. are also set to the desired values.  After this is completed, you then connect each master and slave interface in the table.  Platform Designer then generates the RTL files according to the table.  For more details, please refer to the Intel Quartus Prime Pro Edition User Guide.</p> </li> <li> <p>Use the APF/BPF script that reads in <code>iofs_dfl.txt</code> and automatically generates APF/BPF IPs.  Both APF and BPF are generated from Platform Designer using hardware TCL scripts. To provide a more user friendly experience to OFS Rel 1 and AC ADP customers, a perl script <code>dfh2tcl.pl</code> has been developed to provide a higher level of abstraction. The below figure illustrates the high level flow:</p> </li> </ul> <p>Figure 6-2 APF/BPF Generation</p> <p></p> <p>Note that the only input required is the <code>iofs_dfl.txt</code> text file which allows you to specify how many ports, which fabric, type of AXI4-Lite port (master, slave, or both), port addresses and sizes.  Using <code>iofs_dfl.txt</code> and <code>dfh2tcl.pl</code> to generate the APF and BPF is the preferred method.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#62-iofs_dfltxt-format","title":"6.2   iofs_dfl.txt Format","text":"<p>The following table describes the format of the <code>iofs_dfl.txt</code> input file:</p> <p>Table 6-2 iofs_dfl.txt Format Types</p> ColumnDescription REGISTERName of the port on the APF/BPF fabrics. Note that each entry must be unique. FABRICAllows the user to specify which fabric this port is connected to, and also the type of AXI4-Lite port (master, slave, or both). The format is FABRIC-PORT_TYPE, where: * FABRIC = APF or PBF * PORT_TYPE = MST, SLV, or BID (Master, Slave, or Bi-Directional) BASE_ADDRSpecifies the address offset of the AXI4-Lite port. BAR_SIZE=2^N   Specifies the size of the port. For simplicity reasons, all AXI4-Lite ports are configured as 64KB. i.e. 2^16 <p>Additional AXI4-Lite ports can be easily created by adding more rows in the <code>iofs_dfl.txt file</code>. </p> <p>Note that there are several reserved ports in both APF and BPF so it might not be necessary for you to regenerate the fabrics if the design does not exceed the number of ports as implemented in the APF/BPF in the reference FIMs.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#63-afu-peripheral-fabric-apf","title":"6.3   AFU Peripheral Fabric (APF)","text":"<p>The AFU Peripheral Fabric (APF) is a 64-bit AXI4-lite compliant interconnect fabric that connects AFU peripheral modules to board peripheral modules through the Board Peripheral Fabric (BPF).  The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time. </p> <p>The address mapping for components interconnected by the APF is listed below. All components are mapped to PF0 BAR0 and implement AXI-lite slave interface. The Master column indicates if a component also implements AXI4-lite master interface which can send request to APF.</p> <p>Table 6-3 APF Address Mapping</p> AddressSize (Byte)FeatureMaster 0x00000 \u2013 0x7FFFF512KBoard Peripherals (See BPF address mapping)   No AFU Peripherals 0x80000 \u2013 0x8FFFF64KST2MMYes (Send MMIO request to all the peripherals) 0x90000 \u2013 0x9FFFF64KPort GasketYes 4KPR Control &amp; Status 4KUser clock 16KRemote STP 0xA0000 \u2013 0xAFFFF64KAFU Interface HandlerNo 0xB0000 \u2013 0xBFFFF64KRSV_b_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xC0000 \u2013 0xCFFFF64KRSV_c_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xD0000 \u2013 0xDFFFF64KRSV_d_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xE0000 \u2013 0xEFFFF64KRSV_e_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. 0xF0000 \u2013 0xFFFFF64KRSV_f_DFHAvailable for customer useMay be programmed as master if used.  By default this is a reserved base address. <p>The five reserved regions have associated ports available in the APF for customer use.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#64-board-peripheral-fabric-bpf","title":"6.4   Board Peripheral Fabric (BPF)","text":"<p>The Board Peripheral Fabric is the 64-bit AXI4-Lite compliant interconnect fabric that connects board peripheral modules to APF. The fabric is clocked by <code>clk_csr</code> and has a read allowance and write allowance of 1, i.e. only 1 active write/read is allowed in the fabric at any single time.</p> <p>The address mapping for components interconnected by BPF is listed below. All components are mapped to PF0 BAR0 and implement AXI4-lite slave interface. The Master column indicates if a component also implements AXI4-lite master interface which can send request to BPF.</p> <p>Table 6-4 BPF Address Mapping</p> AddressSize (Byte)FeatureMaster 0x00000 \u2013 0x0FFFF64KFME (FME, Error, etc)Yes 0x10000 \u2013 0x1FFFF64KSPI ControllerYes 0x20000 \u2013 0x2FFFF64KPCIe CSR- 0x30000 \u2013 0x3FFFF64KHSSI CSR- 0x40000 \u2013 0x4FFFF64KEMIF CSR- 0x50000 \u2013 0x5FFFF64KReservedAvailable for customer use.Dependent on user programming 0x60000 \u2013 0x6FFFF64KReservedAvailable for customer use.Dependent on user programming 0x70000 \u2013 0x7FFFF64KReservedAvailable for customer use.Dependent on user programming <p>The three reserved regions have associated ports available in the BPF for customer use.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#65-axi4-stream-pfvf-muxdemux","title":"6.5   AXI4-Stream PF/VF Mux/Demux","text":"<p>The AXI4-Stream PF/VF Mux/Demux routes the PCIe TLP packets from the PCIe subsytem AXI4-Stream RX channel to downstream PF/VF based on the pf_num and vf_num information in the PCIe TLP header.</p> <p>The AXI4-Stream PF/VF mux arbitrates PCIe TLP packets from downstream PF/VF to the PCIe SS AXI-S TX channel. The PF/VF Mux/Demux is an M x N switch that allows any M port to target any N port, and any N port to target any M port, where M is the number of host/upstream ports, and N is the numbers functions/downstream ports.  M and N values are parameterized in the RTL for adding, removing, or remapping of FPGA functional units/modules to PF/VF.  </p> <p>The fpga top package file, found in the src/includes/ofs_fim_cfg_pkg.sv file [OFS D5005 FIM Github Branch]  contains these parameters as well as the mapping of N port\u2019s PF/VF.</p> <p>Structurally, M x N switch is composed of M number of N:1 mux, and N number of M:1 mux.  Each mux output has an arbiter that perform round robin priority arbitration of its inputs.  At the mux output is a FIFO with depth greater than the handshake round trip delay.  The FIFO allows the switch to arbitrarily insert pipeline/register stages for timing.</p> <p>Note that M x N switch is design for AXI streaming, but it can be easily converted to AVST.  The protocol signals pass through switch intact \u2013 only ready, valid, and last (common between AVST and AXI) effect switch operation.  The data width of the switch is also parameterized in the src/includes/ofs_fim_cfg_pkg.sv file [OFS D5005 FIM Github Branch].  </p> <p>The default mapping is shown below:</p> <p>Table 6-5 PF/VF Mapping</p> DevicePhysical Function #Virtual Function #Switch Port ID APF/BPF0x3 HE Loopback000 Port Gasket011 HSSI022 <p>For information on how to modify the PF/VF mapping for your own design, refer to the [Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#66-unified-tag-remapping","title":"6.6 Unified Tag Remapping","text":"<p>When a FPGA function sends out a read cycle, it allocates a unique tag which is subsequently used to identify the read completion.  The tag is considered busy; it cannot be assigned to another read cycle until read completion.  While a tag may be unique within a unit, two different units could unknowingly send out two read cycles of the same tag.  The PCIe subsystem requires unique tags for all read cycles irrespective of their origins.  Therefore, a mechanism is needed to uniquify tag globally across different units.</p> <p>OFS contains a tag remapper (tag_remap) that intercepts the read cycle, finds a globally unique tag, and replaces the original tag value.  It also restores the original tag value when returning completion to the read requester.  tag_remap is placed between the AXI4-Stream interface of the PCIE subsystem and the PF/VF Mux/Demux.</p> <p>The logic is described as follows:</p> <ol> <li>A sub-module (ofs_fim_tag_pool) maintains a pool of available tags.</li> <li>TX read requests are held until a tag is available from the pool by setting tvalid=0 to the host, and tready=0 to the PF/VF Mux/Demux.</li> <li>When a TX read is dispatched, the tag is marked busy in the pool.</li> <li>The original tag is stored in tag_reg, so it can be recovered when returning a completion to the unit/function.</li> <li>Since completion to a read request can split into multiple smaller transfer sizes, responses are monitored and the final completion is detected using PCIe TLP rules.</li> <li>Tags are released in the pool only when all requested data are transferred.</li> <li>When the completion returns, the original tag is restored from tag_reg.</li> </ol>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#67-tlp-to-axi4-lite-memory-mapped-bridge-st2mm","title":"6.7 TLP to AXI4-Lite Memory Mapped Bridge (ST2MM)","text":"<p>ST2MM implements the following key features: * Host MMIO bridge     * Maps MMIO TLP packets received from the PCIe Subsystem over streaming interface to AXI4-Lite memory-mapped request. The memory-mapped request is sent to AFU or Board peripherals over APF and BPF.     * Maps AXI4-lite MM response received from AFU or Board peripherals to TLP packets and send the packets over ST streaming channel to host HIA subsystem. * Sends MMIO response of all 0\u2019s for MMIO read to unused BAR region. * Interrupt     * Sends interrupt packets to the PCIe subsystem when interrupt requests are received from the peripherals. Interrupts can be requested by a peripheral through a memory write to interrupt CSR registers in the ST2MM.</p> <p>Figure 6-2 APF/BPF Generation</p> <p></p> <p>ST2MM implements both AXI4-lite master and slave interfaces that are connected to the designated slave and master port on APF. Host memory requests are sent on the ST2MM master interface to AFP where the requests are routed to the targeted peripherals. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#7-mmio-regions","title":"7 MMIO Regions","text":"<p> The FIM and AFU expose their functionalities to the host software through a set of CSR registers that are mapped to an MMIO region (Memory Mapped IO). An MMIO region is an address space within a base address register (BAR) region to which features are memory mapped.  For example, when a feature is mapped to an MMIO region, the CSR registers of that feature are located within the address range of that region. There can be multiple MMIO regions within a BAR region. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#71-base-address-register-bar-layout","title":"7.1 Base Address Register (BAR) Layout","text":"<p>The function, BAR and external feature region starting address are put into a platform specific parameter SystemVerilog package file src/includes/ofs_fim_cfg_pkg.sv file [OFS D5005 FIM Github Branch].  </p> <p>You can modify the parameterization according to your platform requirements, however you must ensure the corresponding software driver is also updated to align with the new assignment. </p> <p>Table 7-1 BAR Layouts</p> PF VF Feature BAR BAR Size PF0 - OFS Managed Peripherals BAR 0 512K AFU PeripheralsBoard Peripherals 256K256K VF0 HE-LB BAR0 4K VF1 HE-MEM in PR slot BAR0 4K VF2 HE-HSSI BAR0 4K"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#72-feature-region","title":"7.2 Feature Region","text":"<p> A group of related CSRs can be categorized as a feature region. For example, a DMA engine has queue management function and quality of service (QoS) function; these are two different features of the DMA engine. A feature region is contained within a single PCIe BAR and cannot span across two BAR region boundaries.   You can view the PF0 BAR0 MMIO mapping by referencing thesrc/common/fme/fme_csr_pkg.sv file [OFS D5005 FIM Github Branch] file.</p> <p>A Device Feature Header (DFH) register marks the start of the feature region and sub-feature region, and you must place it at the first address of the region. Each DFH starts at 4KB boundary. A DFH register contains information that OPAE software requires to enumerate the feature. It also has an offset field that points to the next DFH in a feature list. OPAE software traverses the linked list of DFHs in each BAR region to discover all the features implemented on the platform. The <code>EOL</code> field in a DFH marks the end of a DFH list and is only set in the DFH of the last feature in the feature list. The feature type field in the DFH is used to differentiate between the different types of feature region. Basic building blocks (BBB) and private features are always a child of an AFU or FPGA Interface Unit (FIU) and must be contained within an AFU or FIU, respectively.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#721-device-feature-header-dfh-structure","title":"7.2.1 Device Feature Header (DFH) Structure","text":"<p> All DFHs must follow the following structure to be compatible with OPAE software.</p> <p>Table 7-2: DFH Structure</p> Bitfield Name Range Access Description FeatureType 63:60 RO 4\u2019b0000 \u2013 Reserved 4\u2019b0001 \u2013 AFU4\u2019b0010 \u2013 BBB4\u2019b0011 \u2013 Private Feature4'b0100 \u2013 FIU/FIM Reserved 59:41 Rsvd Reserved EOL 40 RO End of DFH List1'b0=No other feature header beyond this one1'b1=This is the last feature header NextDFHByteOffset 39:16 RO Next DFH byte offsetNext DFH Address= Current DFH address + Next DFH byte offset.  You can also use this value as an indication of the maximum size of the MMIO region occupied by this feature. FeatureRev 15:12 RO For AFU Feature type= AFU major version number that is user defined.All other feature types= Feature revision number FeatureID 11:0 RO For AFU feature type= CoreFIM version numberFor BBB feature type= Intel defined ID for BBBFor private feature type= User-defined ID to identify within an AFU For FIU type=ID for FIU unit (ex. 0 for FME, 1 for Port) <p>You must increment a feature revision number if a feature changes.  This change requires a corresponding change in the software to detect the new version and report mismatches between the hardware and software revision number. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#73-control-and-status-registers","title":"7.3 Control and Status Registers","text":"<p>All the Control and Status Registers (CSRs) in the FIM are 64-bit registers with the following MMIO write and MMIO read support.</p> <p>Table 7-3: CSR MMIO Read and Write Support</p> Request Memory Attribute Payload size Memory Ordering MMIO Write UC 4B or 8B Strongly ordered MMIO Read UC 4B or 8B Strongly ordered <p>The FIM does not reorder the MMIO requests or responses. For MMIO writes, there is no reordering of requests in FIM, and UC ordering rules are followed. Similarly, for MMIO reads, there is no re-ordering of requests or responses in the FIM. An AFU may opt to re-order the MMIO read responses but the FIM does not enforce read response ordering. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#731-software-access-to-registers","title":"7.3.1    Software Access to Registers","text":"<ul> <li>Software accesses 64-bit registers as aligned quadwords. For example, to modify a field (bit or byte) in a 64-bit register, the entire quadword is read, the appropriate field(s) are modified, and the entire quadword is written back.</li> <li>When updating registers through multiple accesses (whether in software or due to hardware disassembly), certain registers may have specific requirements on how the accesses must be ordered for proper behavior. These are documented as part of the respective register descriptions.</li> <li>For compatibility with future extensions or enhancements, software must assign the last read value to all \u201cReserved and Preserved\u201d (RsvdP) fields when written. In other words, any updates to a register must be read so that the appropriate merge between the RsvdP and updated fields occurs. Also, software must assign a value of zero for \u201cReserved and Zero\u201d (RsvdZ) fields when written.</li> <li>PCIe locked operations to FPGA hardware registers are not supported. Software must not issue locked operations to access FPGA hardware registers.</li> </ul> <p>In the following two cases, the FIM terminates MMIO Read requests by sending a completion with the data (CplD) specified below: * MMIO Timeout:  This occurs when the AFU does not respond within a set timeout. The timeout value is currently configured to 512 pclks (clk_2x). In this case, the FIM returns all 1s.</p> <ul> <li>Illegal MMIO Accesses: This occurs when the read is accessing undefined registers in the FIM or if an AFU access violation.  An example of an access violation is when a PF attempts to access the AFU when it is set to VF mode, or when a VF attempts to access the AFU when it is set to PF mode. In this case, the FME will return all 0s.</li> </ul>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#732-register-attribute-definition","title":"7.3.2    Register Attribute Definition","text":"<p>Table 7-4: OFS Register Attribute Definitions</p> Attribute Expansion Description RW Read/Write This bit can be read or written by software. RO Read Only The bit is set by hardware only. Software can only read this bit. Writes do not have any effect. RW1C Read/ Write 1 to Clear Software can read or clear this bit. The software must write 1 to clear this bit. Writing zero to RW1C bit has no effect. Note that a multi-bit RW1C field may exist. In this case, all bits in the field are cleared if a 1 is written to any of the bits. RW1S Read/ Write 1 to Set Software can read this bit. Writing a 1 to the bit sets it to 1. Writing a 0 has no effect. It is not possible for software to set this bit to 0. The 1 to 0 transition can only be performed by HW. RW1CS Read/Write 1 to Clear Sticky Software can read and clear this bit. Writing a 1 to a bit clears it, while writing a 0 to a bit has no effect. This bit is only reinitialized to its default value by a power-on reset. RWD Read/Write Sticky across Hard Reset The bit can be read or written by SW. This bit is sticky or unchanged by any reset type, including Hard Reset. The bit gets cleared only with power on. *S Sticky across Soft Reset The bit will be sticky or unchanged by soft reset. These bits are only re-initialized to their default value by a power-on reset. *D Sticky across Hard Reset The bit is sticky or unchanged by or unchanged by any reset type, including hard reset. The bit gets cleared only with power on. Rsvd Reserved Reserved for future definitions. Currently don\u2019t care bits. RsvdP Reserved and Protected Reserved for future RW implementations. The software must preserve the value of this bit by read modify write. RsvdZ Reserved and Zero Reserved for future RW1C implementations. The software must write zero to this bit."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#733-csr-offset-in-bars","title":"7.3.3 CSR Offset in BARs","text":"<p>The table below captures the FIM and AFU features in the supported BAR regions. The offset highlighted in red indicates the first DFH in the DFH list of a BAR region where device driver starts the DFH traversal.</p> <p>Table 3-6: PF0 BAR0 Features</p> Offset Feature CSR set <code>0x00000</code> <code>FME</code> 0x03000 Global Performance 0x04000 Global Error 0x10000 SPI Controller 0x20000 PCIe CSR Interface 0x30000 HSSI CSR Interface 0x40000 EMIF CSR Interface 0x80000 Reserved for ST2MM Bridge 0x90000 PR Control &amp; Status (Port Gasket) 0x91000 Port CSRs (Port Gasket) 0x92000 User Clock (Port Gasket) 0x93000 Remote SignalTap (Port Gasket) 0xA000 AFU Errors (AFU Interface Handler) <p>Table 3-7: PF0 BAR4 Features</p> Offset Feature CSR set 0x02000 MSI-X 0x03000 MSI-X PBA Tables <p>Table 3-8: PF0-VF0 BAR0 Features</p> Offset Feature CSR set 0x00000 HE-LBK <p>Table 3-9: PF0-VF1 BAR0 Features</p> Offset Feature CSR set 0x00000 HE-MEM <p>Table 3-10: PF0-VF2 BAR0 Features</p> Offset Feature CSR set 0x00000 HE-HSSI"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#8-fim-clocks","title":"8 FIM Clocks","text":"<p> The following table provides the clocks available in the OFS reference design that targets the Intel FPGA PAC D5005.  Clocks that the high speed serial interface (HSSI) or external memory interface provide to the FIM may be different depending on if you modify your external features with different components.</p> <p>Table 8-1: External Clock Source</p> Clock Frequency Description SYS_RefClk 100 MHz Reference clock to system IOPLL (sys_pll) which provides FIM system clocks. qsfp*_644_53125_clk 644.5312 5MHz HSSI reference clocks ddr4_mem*.ref_clk 150 MHz Reference clocks to DDR4 interfaces PCIE_REFCLK 100MHz PCIe reference clock <p>Table 8-2: Internal Clocks</p> Clock Frequency Description clk_1x 250 MHz Generated by the system IOPLL (sys_pll). This clock drives CoreFIM datapath and the AFU interface. clk_div2 125 MHz Generated by the system IOPLL, synchronous to clk_1x. This clock drives IM datapath and AFU interface. clk_100 100 MHz Generated by the system IOPLL, synchronous to clk_1x.  This clock also supplies the HSSI reconfiguration clock. avl_clk 250 MHz PCIe H-tile Hard IP clock output. This clock is not synchronous to Clk_* DDR4x_USERCLK 299.76 MHz Each of the four DDR interfaces generates one of these clocks, which provides the the clock to the  DDR4* Avalon Memory Mapped interfaces.  Your memory clock output may be different depending on the memory interface you are implementing in your design. uclk_usr User defined Provides an AFU user clock running at a user specified frequency. Generated by user IOPLL. Not synchronous to clk_*. uclk_usr_div2 uclk_usr/2 Second user clock to AFU running at half the frequency of uclk_usr. Synchronous to uclk_usr. Generated by user IOPLL. hssi[*].f2a_tx_parallel_clk_x1 156.2 MHz 1x TX clock generated from fPLL in the HSSI module in FIM, used to clock the HSSI TX datapath in AFU. hssi[*].f2a_tx_parallel_clk_x2 312.5 MHz 2x TX clock generated from fPLL in the HSSI module in FIM, used to clock the HSSI TX datapath in AFU. hssi[*].f2a_rx_clkout 322.265625MHz RX parallel clock from the HSSI PHY channels, used to clock the HSSI RX data datapath in AFU."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#9-reset","title":"9 Reset","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#91-reset-signals","title":"9.1   Reset Signals","text":"<p>The system reset of OFS reference platform is driven by <code>nPERST</code> pin, <code>pcie_reset_status</code> signal from the PCIe hard IP, the <code>INIT_DONE</code> and <code>nCONFIG</code> pins of the FPGA, and the locked signal of the SYS IOPLL that provides system clocks to FIM.  </p> <p>Upon power-on, the reset module in the FIM holds the FIM in reset until all the reset conditions are de-activated:</p> <ul> <li><code>nPERST</code> signal is asserted.</li> <li>The <code>INIT_DONE</code> pin is driven high to indicate core configuration is complete.</li> <li>The SYS IOPLL is locked.</li> <li>The reset status from PCIe hard IP is de-asserted indicating the IP is ready for transfer. </li> </ul> <p>The reset module places the FIM back into reset if any of these conditions becomes active again. The only way to invoke a system reset to the FIM after power-up is to deassert the <code>nPERST</code> pin either by performing a warm reboot or through PCIe driver intervention. There are soft reset signals set aside to allow software to reset the Port, AFU and partial reconfiguration IP. </p> <p>Table 9-1: FIM System Resets</p> Reset Description <code>nPERST</code> pin Active low PCIe reset pin that serves as the system reset pin on the platform. <code>nCONFIG</code> pin Active low input to the FPGA that causes the FPGA to lose its configuration data, enter a reset state, and tri-state all I/O pins. Host software must reload the FPGA FIM after nCONFIG is activated. <code>ninit_done</code> Active low signal derived from the INIT_DONE pin which indicates the FPGA core configuration is complete and has entered usermode. <code>pcie_reset_status</code> Active high reset status from PCIe hard IP. When driven high, this signal indicates that the PCIe IP core is not ready for usermode. <code>pll_locked</code> Active high SYS IOPLL locked signal <p>Table 9-2: Soft Resets</p> Soft Reset Bitfield Register Description <code>PortSoftReset</code> PORT_CONTROL[0] Resets Port and AFU. <code>FlrPortReset</code> PORT_CONTROL[3] PCIe function level reset that resets Port and AFU when SR-IOV is enabled. <code>PRReset</code> FME_PR_CTRL[0] Resets the partial reconfiguration (PR) controller."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#92-platform-power-up-sequence","title":"9.2   Platform Power up Sequence","text":"<p>Upon power up, the HSSI interfaces of the FIM go through an internal reset and calibration sequence. After the <code>nPERST</code> is de-activated, the PCIe interface and EMIF interfaces are first released from reset, followed by SYS IOPLL when the <code>ninit_done</code> is de-asserted. The rest of the FIM logic is still being hold in reset. The <code>nPOR</code> signal to the PCIe hard IP de-activates following <code>nPERST</code> assertion, which releases PCIe hard IP from reset. The PCIe hard IP asserts <code>pld_clk_inuse</code> to indicate to the application layer that the HIP transaction layer is using the <code>pld_clk</code> as its clock and is ready for operation with the Application layer (<code>pld_clk</code> is stable). Finally, <code>reset_status</code> from PCIe IP is de-asserted. When SYS IOPLL is locked and the <code>reset_status</code> from the PCIe interface is de-asserted, the FIM is released from reset while the Port and AFU is still held in reset by the <code>PortSoftReset</code> register bit (PORT_CONTROL[0]) that is held high until software writes a 0 to this bit to de-activate port reset. At this point, the platform is fully released from reset and PCIe link is going through link training and PCIe enumeration. Once the platform is successfully enumerated, driver can then be loaded to start the device feature discovery process and provision the platform for AFU application usage.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#10-interrupts","title":"10 Interrupts","text":"<p>The OFS platform supports interrupt through MSI-X feature. The OFS reference platform supports at least 4 FME interrupts (PF only) and 4 AFU interrupts (PF and VF). </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#101-msi-x","title":"10.1 MSI-X","text":"<p>In the default implementation the MSI-X feature that handles FME and AFU interrupts is inside the PCIe Subsystem.  The MSI-X vector table and Pending Bit Array (PBA) table for PF0 and PF0/VF1 are provided as an example.  FME interrupts are primarily used to notify the host of error events occurring in the FIM. </p> <p>All interrupt requests arrive inband through the AXI4-Stream interface to the TX AXI4-stream adapter inside the PCIe Subsystem.  </p> <p>An AFU sends an interrupt to the MSI-X module on the AXI interrupt request channel. After the interrupt request is serviced, the MSI-X module sends an interrupt response back to the AFU on the AXI interrupt response channel. The AFU has the flexibility to define the use of each AFU interrupt.</p> <p>The following interrupts are supported: PF supports 7 interrupt vectors: - 0-3:  User AFU triggered  - 4:    Port error triggered - 6:    FME error triggered</p> <p>VF supports 5 interrupt vectors: - 0-3:  User AFU triggered  - 4:    Port error triggered</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#11-external-memory-interface-emif","title":"11 External Memory Interface (EMIF)","text":"<p>There are four DDR4 external memory interfaces on the OFS EA FIM that targets the Intel FPGA PAC D5005 FIM for each of the four DDR4 banks (DDR4a, DDR4b, DDR4c, and DDR4d). Two of the DDR4 external memory interfaces and the associated clocks are directly exposed to AFU except for two Avalon Memory Mapped pipeline bridges to facilitate timing closure across PR boundary. The Avalon Memory Mapped interfaces of each external memory interface are connected to an Avalon-MM pipeline bridge (avmm_bridge) in the FIM, which is then connected to another Avalon-MM pipeline bridge in the PR or AFU region.  An AFU should use the USER_CLK associated with a memory interface when interfacing with the memory interface for better timing performance.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#111-emif-csr","title":"11.1 EMIF CSR","text":"<p>The CSR for the EMIF feature is memory mapped to the FME BAR region. Following table captures the EMIF CSR registers.</p> <p>Table 9-1: EMIF CSR Registers</p> EMIF_DFH 0x40000 0x3000000050000009 EMIF Management DFH FIELD NAMERANGEACCESSDEFAULT DESCRIPTION FeatureType [63:60] RO 0x3 Feature Type = Private Feature Reserved40 [59:40] RsvdZ 0x0 Reserved NextDfhByteOffset [39:16] RO 0x050000 Next DFH Byte offset FeatureRev [15:12] RO 0x0 Feature Revision FeatureID [11:0] RO 0x9 Feature Id EMIF_STAT 0x40008 0x0000000000000000 EMIF Status FIELD NAMERANGEACCESSDEFAULT DESCRIPTION Reserved [63:16] RsvdZ 0x0 Reserved Reserved [15:12] RsvdZ 0x0 Reserved EmifCalFail [11:8] RO 0x0 EMIF PHY Calibration Failure (1 bit per interface) Reserved [7:4] RsvdZ 0x0 Reserved EmifCalSuccess [3:0] RO 0x0 EMIF PHY Calibration Successful (1 bit per interface) <p>\u200b          \u200b               </p> EMIF_CTRL 0x40010 0x0000000000000000 EMIF Control FIELD NAMERANGEACCESSDEFAULT DESCRIPTION Reserved [63:0] RsvdZ 0x0 Reserved"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#92-afu-emif-interface","title":"9.2 AFU EMIF Interface","text":"<p>The FIM exposes 576-bits of Avalon Memory-Mapped data to the AFU, with 512-bit data and additional 64 bits that can either be used for additional metadata, parity or ECC. The AFU has the flexibility to decide the use of the extra 64 bits of data.  The ECC soft IP is not enabled in the EMIF IP to allow for the afore-mentioned flexibility. AFU developers can implement the ECC logic in the AFU by making use of the extra 64-bit of data.  Avalon Memory-Mapped is the native interface protocol used by Intel EMIF IP. AFU developers who desire other interface protocol in their designs over Avalon Memory-Mapped, such as AXI4 Memory-Mapped, can leverage the bridge in the PIM library. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12-hssi-subsystem","title":"12 HSSI Subsystem","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#121-hssi-subsystem-overview","title":"12.1 HSSI Subsystem Overview","text":"<p>The high speed serial interface (HSSI) subsystem architecture provides portability to different Ethernet configurations across platforms and generations and reusability of the hardware framework and software stack. This reference FIM contains the Low Latency Ethernet 10G MAC IP and provides a Linux driver that can be leveraged for customization. </p> <p>The HSSI design is leveraged from our OFS EA release so prior customers can easily maintain compatibility with past designs.</p> <p>A host exerciser, named he-hssi, is provided in the pr_slot of the AFU partition. The Ethernet interface to the AFU has an AXI4-Stream data and sideband interface. The HSSI control and status registers in the FIM are accessible by the AXI4-Stream memory mapped interface. </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#122-ofs-hssi-subsystem-interfaces","title":"12.2 OFS HSSI Subsystem Interfaces","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1221-hssi-subsystem-fim-interfaces","title":"12.2.1 HSSI Subsystem FIM Interfaces","text":"<p>There are three interfaces to the HSSI Subsystem that is part of the FIM:</p> <ol> <li>AXI4 Memory Mapped to access HSSI-CSR (to FIM)</li> <li>AXI4-Stream Ethernet Data Interface (from FIM)</li> <li>AXI4-Stream Ethernet Sideband Interface (from FIM)</li> </ol> <p>The PCIe subystem uses AXI Memory Mapped accesses to read and write HSSI Control and Status Registers in the FIM. The Ethernet MAC interface typically has a data streaming interface which is mapped to standard AXI4-Stream.</p> <p>Figure 12-1: HSSI Subsystem</p> <p></p> <p>Additionally, the Ethernet MAC interface has an interface for status and flow control. Status and flow control signals vary across IPs and operating modes so for this design we group the signals into a AXI4-Stream sideband interface which provides a standard interface to the AFU along with platform customizations if needed. The Avalon to Arm AMBA 4 AXI4 bridge (av_axi_st_bridge) converts native Avalon interfaces to an AXI4 Stream interface.</p> <p>The following flow control are implemented in the Ethernet MAC: * IEEE 802.3 flow control: this flow control implements the IEEE 802.3 Annex 31B standard to manage congestion. When the Low Latency Ethernet 10G MAC IP experiences congestion, the core sends a pause frame to request its link partner to suspend transmission for a given period of time. This flow control is a mechanism to manage congestion at the local or remote partner. When the receiving device experiences congestion, it sends an XOFF pause frame to the emitting device to instruct the emitting device to stop sending data for a duration specified by the congested receiver. Data transmission resumes when the emitting device receives an XON pause frame (pause quanta = zero) or when the timer expires. </p> <p>\u2022 Priority-based flow control (PFC): this flow control implements the IEEE 802.1Qbb standard. PFC manages congestion based on priority levels. It supports up to 8 priority queues. When the receiving device experiences congestion on a priority queue, it sends a PFC frame requesting the emitting device to stop transmission on the priority queue for a duration specified by the congested receiver. When the receiving device is ready to receive transmission on the priority queue again, it sends a PFC frame instructing the emitting device to resume transmission on the priority queue</p> <p>To use flow control, set the following registers:</p> <p>On the TX datapath:  1. Set tx_pfc_priority_enable[7:0] (Address :0x0046 -&gt; 11A0) to 0 to disable the PFC. The rest of the bits are unused. 2. Set tx_pauseframe_enable[0] (Address :0x0044 -&gt; 1142) to 1 to enable the flow control. </p> <p>On the RX datapath:</p> <p>\u2022   Set rx_pfc_control[7:0] (Address :0x00C0 -&gt; 818) to 1 to disable the PFC. The rest of the bits are mostly unused. \u2022   Set the IGNORE_PAUSE (Address :0x00AC -&gt; 800) bit in the rx_frame_control register to 0 to enable the flow control.</p> <p>To use Priority-Based Flow Control Follow these steps to use the priority-based flow control (PFC):  1. Enable the Priority-based flow control (PFC) parameter and specify the number of priority levels using the Number of PFC priorities parameter. You can specify between 2 to 8 PFC priority levels.  2. Set the following registers. </p> <p>On the TX datapath: * Set tx_pauseframe_enable (Address :0x0044 -&gt; 1142) to 0 to disable the flow control. * Set tx_pfc_priority_enable[n] (Address :0x0046 -&gt; 11A0) to 1 to enable the PFC for priority queue n. </p> <p>On the RX datapath:  * Set the IGNORE_PAUSE bit in the rx_frame_control (Address :0x00AC -&gt; 800) register to 1 to disable the flow control. * Set the rx_pfc_control[7:0] (Address :0x00C0 -&gt; 818) register bits to 0 to enable the PFC. Most of the rest of the bits are unused.  * Set PFC Quanta bit for the appropriate queue. Eg: pfc_pause_quanta_0 (0x048 -&gt; 1180) for queue0 and so on. *  Connect the avalon_st_tx_pfc_gen_data signal to the corresponding RX client logic and the avalon_st_rx_pfc_pause_data signal to the corresponding TX client logic.  * You have the option to configure the MAC RX to forward the PFC frame to the client by setting the rx_pfc_control[16] register to 1. By default, the MAC RX drops the PFC frame after processing it</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1222-hssi-subsystem-afu-interfaces","title":"12.2.2 HSSI Subsystem AFU Interfaces","text":"<p>The HSSI subsystem provides the following interfaces to the AFU region:</p> <ol> <li>AXI4-Memory Mapped access to the HSSI CSR (to FIM)</li> <li>AXI4-Stream Ethernet Data Interface (from FIM)</li> <li>AXI4-Stream Ethernet Sideband Interface (from FIM)</li> <li>Ethernet Clock Interface (eth_clock) (from FIM)</li> </ol> <p>The he-hssi uses the APF interface for HSSI CSR (MMIO) accesses. The AXI4-Stream Ethernet data and side band interface along with Ethernet clocks communicate directly to the he-hssi module in the AFU region through platform independent data structures provided by the PIM.  Even if you implement a different MAC you typically can leverage these data structures defined in the hssi/inc/ofs_fim_eth_avst_if.sv file here without modification.</p> <p>While the platform-independent interfaces in ofs_fim_eth_if.sv are convenient containers for passing data streams through the design hierarchy, both the MAC and AFU traffic generator require platform-specific data types. The payloads of the streams in ofs_fim_eth_if.sv are defined in platform-specific structures, with fields that are MAC-specific. In this 10GbE reference design, the payload datatypes are defined in the ipss/hssi/s10/includes/ofs_fim_eth_plat_if_pkg.sv file hhere. Implementers connecting a new MAC should generally edit only ofs_fim_eth_plat_if_pkg.sv when defining payloads.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1223-hssi-sideband-interface","title":"12.2.3 HSSI Sideband Interface","text":"<p>The AXI4-Stream sideband interface has been been defined to allow for time sensitive status and flow control information. It does not have the optional <code>tready</code> signal and assumes the slave always accepts  information.  The Ethernet sideband interface varies widely across IPs and operating modes and device generations. In OFS Stratix 10 FIM, the Ethernet sideband signals are mapped to the AXI4-Stream interface and interface variations can be accommodated by customizing the <code>tdata</code> signals of the sideband interface in platform specific interface packages using the PIM. </p> <p>As an example, please refer to ofs_fim_eth_sideband_tx_axis_if interface in the ipss/hssi/inc/ofs_fim_eth_if.sv found [OFS D5005 FIM Github Branch].</p> <p>The t_axis_eth_sideband_tx and t_axis_eth_sideband_rx structures are found in the ipss/hssi/s10/includes/ofs_fim_eth_plat_if_pkg.sv file [OFS D5005 FIM Github Branch].</p> <p>Platform specific details for the 10GbE example are from the ipss/hssi/s10/includes/ofs_fim_eth_plat_if_pkg.sv file [OFS D5005 FIM Github Branch].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1224-reconfiguration-interfaces","title":"12.2.4 Reconfiguration Interfaces","text":"<p>The reconfiguration interface in the OFS EA design consists of abstracted and consolidated memory-mapped transceiver reconfiguration interfaces that are exposed to the HSSI CSRs. The reconfiguration interface directly exposes the address space of the MAC and PHY IPs in order to allow a software driver to perform dynamic reconfiguration of those IPs (i.e. read/write access to the Native PHY CSRs). Therefore, to use this interface you must be familiar with the CSR memory maps of the corresponding Intel IP cores. </p> <p>The table below summarizes all the ports associated with Reconfiguration Interfaces. </p> Name Width Domain Description i_xcvr_reconfig_cmd 2 i_reconfig_clk Command port used to specify a read or write access operation to a MAC/PHY CSRs on a selected CSR_interface i_xcvr_reconfig_addr 20 i_reconfig_clkCSR access address of  MAC/PHY IP. Note that only the lower 16 bits are used, i_xcvr_reconfig_addr[15:0]. The remaining upper bits, i_xcvr_reconfig_addr[20:16], should be set to zero.  i_xcvr_reconfig_writedata  32 i_reconfig_clk CSR data to be written on a write command.  o_xcvr_reconfig_readdata 32 i_reconfig_clk CSR data that was read on a read command. o_xcvr_reconfig_ack 1 i_reconfig_clk Reconfiguration acknowledgement bit. Asserted when Reconfiguration Controller is finished performing an Avalon-MM read or write request (i.e. waitrequest is low). Deasserted when i_xcvr_reconfig_cmd is all-zero (i.e. command is invalidated). Note that the controller assumes a valid command when i_xcvr_reconfig_cmd is non-zero."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12241-reconfiguration-sequence","title":"12.2.4.1 Reconfiguration Sequence","text":"<p>The diagram below explains the sequence of operation and handshaking between software and a memory-mapped dynamic reconfiguration interface.</p> <p>Figure 12-2: Sequence of Operation and Handshaking between Software and a Memory-Mapped Dynamic Reconfiguration Interface.</p> <p></p> <p>(0)  Idle state \u2013 command and address buses are cleared (all-zero). 1.  Software sets a desired non-zero command and address to initiate reconfiguration.</p> <pre><code>a.  Memory-Mapped Reconfiguration Controller (MM CTRL) converts the command and address to a single Avalon Memory Mapped read or write request and handles Avalon Memory Mapped protocol details.\n\nb. MM CTRL completes the Avalon Memory Mapped transaction when the `waitrequest` signal of a given Avalon Memory Mapped interface is deasserted.\n\nc. MM CTRL sets the reconfiguration acknowledgment bit and `readdata` (in case of a read command) back to the FME and waits for command and address ports to be cleared by software. \n1.\n</code></pre> <ol> <li> <p>Meanwhile, software continuously polls the reconfiguration acknowledgment bit and waits for it to get asserted. Assertion of the acknowledgment bit confirms that the MM CTRL has completed the current Avalon Memory Mapped read/write request. </p> </li> <li> <p>Software reads <code>readdata</code> from the  HSSI_RCFG_DATA CSR that was returned by the MM CTRL (in case of a read command). </p> </li> <li> <p>Software clears the command and address buses to communicate back to the MM CTRL that the operation is finished from the CPU\u2019s perspective. </p> <p>a.  MM CTRL gets cleared (all-zero) command and address signals from the HSSI_CSR.  b.  MM CTRL clears (deasserts) the reconfiguration acknowledgment bit back to the HSSI_CSR and is finished / back to idle state.  5.  Meanwhile, software continuously polls the reconfiguration acknowledgment bit and waits for it to get deasserted. Deassertion of the acknowledgment bit confirms that the MM CTRL has completed its handshake and is now back to idle state. </p> </li> </ol> <p>NOTE</p> <p>Reads and writes cannot be performed at the same time. Remember that when multiple CSRs are at the same address, a Read-Modify-Write operation may be required to change the desired CSR without changing the CSRs in the same address.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1225-hssi-control-and-status-register-csr-map","title":"12.2.5   HSSI Control and Status Register (CSR) Map","text":"<p>The HSSI CSR Map structure is designed to scale according to IP capabilities.</p> <ul> <li>HSSI_DFH allows for identifying HSSI as an external FME feature.</li> <li>HSSI_CAPABILITY register exposes design capabilities and provides direction to SW/Driver. The fields num_channels, Num_channels_CSR interface, Num_CSR_interface indicate to the software how many CSR interfaces are exposed by the design and how to use mailbox registers (HSSI_RCFG_CMD and HSSI_RCFG_DATA). The number of mailbox registers(HSSI_RCFG_CMD and HSSI_RCFG_DATA) must scale to the number of CSR interfaces exposed by the design. This implementation facilitates flexibility in the design and reuse of the software stack. If you are modifying the HSSI interface, you must update these CSR fields according to HW configuration .  </li> </ul> <p>Example: If Num_CSR_interface=2 &amp; Num_channels_CSR_interface=2 then channel(0,1) are behind CSR interface 0 handled by HSSI_RCFG_CMD0/DATA0 , channel (2,3) are behind CSR interface 1 handled by HSSI_RCFG_CMD1/DATA1 HSSI_CTRL, HSSI_STATUS0, HSSI_STATUS1 provide control and status information and can scale upto 8 channels.  HSSI_RCFG_CMD0, HSSI_RCFG_DATA0 registers are for the reconfiguration interface,  and additional mailbox registers could be added depending on the number of CSR interfaces the design exposes. </p> <p>The HSSI CSR Map can be found in the ipss/hssi/s10/hssi_ss_csr.xls file [OFS D5005 FIM Github Branch].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1226-hssi-host-exercisier-he-hssi","title":"12.2.6 HSSI Host Exercisier (HE-HSSI)","text":"<p>HE-HSSI is an Ethernet AFU that handles client side ethernet traffic. The reference HE-HSSI has following features:</p> <ul> <li>HE-HSSI wraps the 10G Ethernet AFU that was provided in the OFS EA FIM with a wrapper that provides an E-tile compatible interface with OFS for Intel Stratix 10 and Intel Agilex FPGAs.</li> <li>Includes 10GbE traffic generator and checker (monitor)</li> <li>Provides pause signals to the HSSI subsystem for XON and XOFF generation</li> <li>It can generate traffic or incoming traffic that can be looped back into transmit path by enabling loopback mode, which will bypass traffic generator</li> <li>At the HE-HSSI interface boundary the Ethernet data interface is AXI4-Stream with 64-bit data at eth_clk clock</li> <li>An AXI4-Stream to Avalon-ST bridge converts Avalon-ST Ethernet traffic from the HE-HSSI traffic generator to AXI4-Stream traffic and AXI4-Stream RX data from the FIM to Avalon-ST for the HE-HSSI traffic checker. The data width for all the interfaces in this bridge is 64 bits at eth_clk clock.</li> <li>The Traffic generator and checker modules have a 64-bit data interface at eth_clk clock.</li> <li>The traffic generator supports the following modes:<ul> <li>Fixed length or Random Length</li> <li>Incremental pattern or Random pattern</li> </ul> </li> <li>The traffic checker does a 32-bit CRC check</li> <li>The CSR of this AFU is accessible through AXI4-Stream PCIe TLP interfac</li> <li>The PCIe TLP to CSR Interface Conversion module converts PCIe TLPs into simple CSR interface</li> <li>The CSR space of the traffic generator and checker modules are accessed in an indirect way using mailbox registers</li> <li>Though the default configuration for this reference HE-HSSI is 1x10GbE, it can be scaled up to eight 10G ethernet traffic generators and checkers in one HE-HSSI</li> <li>If used for more than one channel, each channel has a separate traffic generator and traffic checker with separate CSR space.</li> <li>Reads and Writes to individual traffic controller CSR spaces can be done by selecting that particular channel using channel select register.</li> </ul> <p>The HE-HSSI Ethernet block diagram is below. </p> <p>Figure 12-6: HE-HSSI Block Diagram Block Diagram</p> <p></p> <p>Figure 12-7: 10G Ethernet AFU Clock Domains</p> <p></p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#12261-he-hssi-csr-map","title":"12.2.6.1 HE-HSSI CSR Map","text":"<p>The reference HSSI AFU contains the following registers and a similar arrangement of register space can be implemented for other usecase specific HSSI AFUs. * AFU DFH Register: Device feature header for the AFU (AFU_DFH) * AFU ID Registers: 128-bit UUID for the AFU which occupies two 64-bit registers (AFU_ID_L, AFU_ID_H) * Mailbox Registers: Command and Data register for traffic controller register access. It follows the standard access method defined for OFS. Access method and implementation is same as Reconfiguration Interface defined for the HSSI FIM. (TRAFFIC_CTRL_CMD, TRAFFIC_CTRL_DATA) * Channel Select Register: Channel select register for traffic controller mailbox access. It is used in cases where more than one channel is in the AFU, else it defaults to zero, meaning channel-0 is selected. (TRAFFIC_CTRL_PORT_SEL) * Scratchpad Register: Scratchpad register for CSR access checking. (AFU_SCRATCHPAD) </p> <p>The CSR excel for the 10G HSSI reference AFU can be found ipss/hssi/s10/hssi_ss_csr.xls [OFS D5005 FIM Github Branch].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#123-hssi-software","title":"12.3 HSSI Software","text":"<p>There are two pieces of software related to running the HSSI Subsystem and the HE-HSSI host exerciser: The Linux* dfl network driver and a user space application.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1231-hssi-linux-driver","title":"12.3.1 HSSI Linux Driver","text":"<p>The HSSI subystem is exposed as a feature in the PCIe PF BAR0 region.  It has a Device Feature Header (DFH) indicating the HSSI interface. The feature ID in the DFH causes the following driver to be instantiated for the HSSI interface: drivers/net/ethernet/intel/s10hssi.c [Kernel Driver Branch]</p> <p>The primary functionality of the driver is to interact with the ethernet MAC and PHY through an indirect register access mailbox implemented by the HSSI_RCFG_CMD0, HSSI_RCFG_DATA0 registers described above. To aid in RTL bringup, the driver provides a debugfs interface directly to the indirect register access mailbox. For each HSSI interface in the system there would be a directory with the following form containing two files, regaddr and regval: /sys/kernel/debug/dfl-fme.X.Y</p> <p>To read a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then read the value as string out of regval file. To write a register offset in the MAC/PHY write the offset to the regaddr file as a C hex string (e.g. 0x04) and then write the value as a C hex string to regval file.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1232-hssi-user-space-tool","title":"12.3.2   HSSI User Space Tool","text":"<p>The HSSI user space application exports a control interface to the HSSI AFU's packet generator logic. Context-sensitive help is given by the --help option, doc/src/fpga_tools/hssi/hssi.md,  [OPAE SDK Branch].</p> <pre><code>$ hssi --help\n\n<p></p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#124-user-guidelines","title":"12.4 User Guidelines","text":"<p>You can either leverage Ethernet example designs from platform designer or use your own custom IP\u2019s. However below recommendations would help leverage the infrastructure of the OFS stack:\n* Follow the Ethernet-GBS interface standard, customize platform specific sideband and clock intefaces.\n* Follow the reconfiguration interface example and reuse the hssi_csr block by modifying the memory map (change address decoder map accordingly as well.)</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#13-partial-reconfiguration","title":"13 Partial Reconfiguration","text":"<p>Partial Reconfiguration (PR) is an Intel FPGA technology that allows user to reconfigure parts of the FPGA device dynamically, while the remainder of the device continues to operate. In a non-partial reconfiguration flow, any change to the design requires full reprogramming of the entire configuration RAM (CRAM) arrays in the device. With partial reconfiguration, you can dynamically reprogram one or more CRAM frames. A partial reconfiguration design has a static region, and one or more PR regions, which can be modified to implement new logic. The portion of the CRAM on the chip to be reconfigured is contained within a PR region.\nFor the PR flow, the design should be partitioned into static region and reconfigurable region. The static region is the area of your FPGA that is not reconfigured without reprogramming the entire FPGA. An area of the chip that you plan to partially reconfigure is a PR region. </p>\n<p>The Port Gasket contains all the PR specific modules and logic, such as PR slot reset/freeze control, user clock, remote STP etc. For this reference example only one PR slot is supported.\nThe following figure depicts the high level view of the Port Gasket:</p>\n<p>Figure 13-1 Partial Reconfiguration Gasket\n</p>\n<p></p>\n<p>The isolation logic is provided on the output signals of the PR region to ensure they don\u2019t glitch and affect the interfacing logic in the Static Region (SR). The isolation logic is controlled by the PR Freeze logic during PR operation.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14-reliability-accessibility-serviceability-ras-and-error-handling","title":"14 Reliability, Accessibility, Serviceability (RAS) and Error Handling","text":"<ol>\n<li>Downstream AFU checker: Identifies AFU violations.  For example, this checker flags violations of the interface specification. </li>\n<li>Upstream software or PCIe link checker: Identifies invalid traffic from PCIe that violates either FIM specifications or PCIe specifications. For example, this checker flags an application sending traffic if it violates the FIM specification or creates a PCIe link issue by causing completion timeout or malformed TLP. </li>\n<li>FIM - Checks for bugs in the FIM fabric.</li>\n</ol>\n<p>Errors reported by the checker are logged in either the FME error registers or Port error registers, or both, as shown in the table below.  For more details on each of the registers, please refer to src/common/protocol_checker/protocol_checker_csr.xml file [OFS FIM_COMMON Github Branch] or the SystemVerilog file src/common/fme/xls/d5005/FME_CSR.xls found [OFS FIM_COMMON Github Branch] .</p>\n<p>Table 14-1: Error Registers</p>\nMMIO Region\nArea\nRegister\nDescription\nFME\nCoreFIM\nFME_ERROR\nFME Error Status Register 0.  Registers parity errors, underflow or overflow errors and access mismatches.\nFME\nCoreFIM\nFME_ERROR0_MASK\nFME Error Mask Register 0.  Write a 0 to mask errors in the FME Error Status Register 0.\nFME\nExternal\nPCIE0_ERROR\nPCIe0 Error Status Register.\nFME\nExternal\nPCIE0_ERROR_MASK\nPCIe0 Error Mask Register 0.  Write a 0 to mask errors in the PCIe0 Error Status Register 0.\nFME\nCoreFIM\nFME_FIRST_ERROR\nFirst FME Error Register.\nFME\nCoreFIM\nFME_NEXT_ERROR\nFME Next Error Register.\nFME\nCoreFIM\nRAS_NOFAT_ERR_STAT\nReliability/Accessibility/Serviceability (RAS) Non-Fatal Error Status Register.\nFME\nCoreFIM\nRAS_NOFAT_ERR_MASK\nRAS Non-Fatal Error Mask Register. Write 0 to mask error fields in RAS_NOFAT_ERR_STAT Register.\nFME\nCoreFIM\nRAS_CATFAT_ERR_STAT\nRAS Catastrophic and Fatal Errors Status Register.\nFME\nCoreFIM\nRAS_CATFAT_ERR_MASK\nRAS Catastrophic and Fatal Errors Mask Register. Write 0 to mask error fields in the RAS_CATFAT_ERR_STAT Register.\nFME\nCoreFIM\nRAS_ERROR_INJ\nRAS error Injection Register.\nPORT\nCoreFIM\nPORT_ERROR\nPort Error Status Register.\nPORT\nCoreFIM\nPORT_FIRST_ERROR\nPort First Error Register .\nPORT\nCoreFIM\nPORT_MALFORMED_REQ0\nPort Malformed Request Register 0.  Provides malformed request header LSBs.\nPORT\nCoreFIM\nPORT_MALFORMED_REQ1\nPort Malformed Request Register 1.  Provides malformed request header MSBs."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#141-fme-errors","title":"14.1 FME Errors","text":""},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1411-fme_error0","title":"14.1.1   FME_ERROR0","text":"<p>\nThe FME_ERROR0 register flags CoreFIM FME errors in the Global Error (GLBL_ERROR) private feature. The error bits in this register are sticky bits. You can only clear these bits through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in FME_ERROR0_MASK register masks the error.</p>\n<p>Table 14-2: FME Error Types</p>\nError Type\nDescription\nFabric errors\nFIFO underflow/overflow condition in CoreFIM. These errors only occur if you have introduced bugs into the FIM or during very rare single event upset (SEU) or SEU-like events.\nInvalid port access\nA port can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the Port. If it finds a PF is trying to access a port that is mapped to a VF or vice-versa, an error will be reported.\nInvalid AFU access\nAn AFU can either be mapped to a PF or a VF, and not both. The checker reads the <code>AfuAccessCtrl</code> field in the FME CSR PORT0_OFFSET register to determine the access type of the AFU associated with the Port. If it finds a PF is trying to access an AFU that is mapped to a VF or vice-versa, an error is reported and a fake response is sent back to the requester to avoid a completion timeout on the host."},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1412-pcie0_error","title":"14.1.2 PCIE0_ERROR","text":"<p>\nThe PCIe Avalon-ST to AXI4-Stream bridge monitors the PCIe link for errors and logs any such errors in the PCIE0_ERROR register (in PCIE0 feature region) and PCIE0_ERROR register in the GLBL_ERR private feature.    The error bits in the PCIE0_ERROR register are sticky bits that you can only clear through software or through a system reset. Writing a 1 to the error field in the register clears the corresponding error bit. Writing a 1 to the corresponding bit in PCIE0_ERROR0_MASK masks the error.  </p>\n<p>If you have other external FME features, you can add similar _ERROR registers to this space. Please refer to the following spreadsheet, bbs/csr/stratix10/pac_d5005/fme_csr_pcie.xls,  [OFS D5005 FIM Github Branch] or the SystemVerilog file the SystemVerilog file src/common/fme/xls/d5005/FME_CSR.xls found [OFS FIM_COMMON Github Branch] for more details on this register. \n<p>NOTE</p>\n<p>The PCIE0_ERROR register is located in both the Global Error external feature memory space and a separate PCIe external feature memory space.  OPAE software supports the PCIe external feature memory space beginning at offset 0x40000 for OFS EA and going forward.  PCIe registers beginning at 0x4000 in the Global Error external feature memory space is there for backward compatibility to the Intel FPGA PAC D5005 v2.0.1 Acceleration Stack.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1413-fme_first_error-fme_next_error","title":"14.1.3   FME_FIRST_ERROR, FME_NEXT_ERROR","text":"<p>\nThe FME_FIRST_ERROR register flags which of the FME error reporting registers, such as FME_ERROR0, PCIE0_ERROR0, has reported the first error occurrence. The error fields of the first error register are then continuously logged into the FME_FIRST_ERROR register until a system reset or software clears all the errors in that first error register.\nLikewise, the FME_NEXT_ERROR indicates which of the FME error reporting registers (except the first error register) has reported the next occurrence of error after the first error register. The error fields of the next error register are continuously logged into the FME_NEXT_ERROR register until a system reset or software clears all the errors in the second error register.</p>\n<p>Please refer tobbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls, [OFS D5005 FIM Github Branch] for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv, [OFS D5005 FIM Github Branch]</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1414-reliability-accessibility-serviceability-ras-error-status","title":"14.1.4   Reliability, Accessibility, Serviceability (RAS) Error Status","text":"<p>\nThe RAS feature in CoreFIM labels errors as non-fatal, fatal or catastrophic based on their impact to the system. \n* A non-fatal error usually originates from software or an AFU.  With a non-fatal error, the user application may still be able to recover from the error by performing a soft reset on the AFU, fixing the user application software if necessary, and clearing the error. On the other hand, a fatal or catastrophic error is non-recoverable and requires the platform to be reset.\n* Non-fatal errors are logged in the RAS_NOFAT_ERR_STAT register and fatal or catastrophic errors are logged in the RAS_CATFAT_ERR_STAT register.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14141-non-fatal-errors","title":"14.1.4.1    Non-Fatal Errors","text":"<p>\nThe RAS_NOFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It logs the high-level status of non-fatal errors in the hardware.  Unlike the error bits in the PCIE0_ERROR and FME_ERROR0 registers which are RW1C (software can write a 1 to clear the error), the error bits in this register are read-only and can only be cleared by system reset. Software has an option to mask the error using RAS_NOFAT_ERR_MASK.\nPlease refer to bbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls, [OFS D5005 FIM Github Branch] for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv, [OFS D5005 FIM Github Branch].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14142-catastrophic-fatal-errors","title":"14.1.4.2    Catastrophic &amp; Fatal Errors","text":"<p>\nThe RAS_CATFAT_ERR_STAT is a read-only status register that is specifically added for the RAS feature. It captures the high-level status of errors that can only be recovered with a system reset. Therefore, the error bits in the RAS_CATFAT_ERR_STAT register are read-only and can only be cleared by system reset or masked through RAS_CATFAT_ERR_MASK.\nPlease refer to bbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls, [OFS D5005 FIM Github Branch] for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv [OFS D5005 FIM Github Branch].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1415-ras-error-injection","title":"14.1.5   RAS Error Injection","text":"<p>\nFor software testing purposes, you can inject non-fatal, fatal and catastrophic errors into the platform through the RAS_ERROR_INJ register.  These errors are reported in the RAS_CATFAT_ERR_STAT and RAS_NOFAT_ERR_STAT registers.\nPlease refer to bbs/csr/stratix10/pac_d5005/s10_iofs_csr_map_update_fme_ral_.xls [OFS D5005 FIM Github Branch] for individual register field descriptions or the SystemVerilog file: src/fme/fme_csr.sv [OFS D5005 FIM Github Branch].</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1416-fme-error-interrupts","title":"14.1.6   FME Error Interrupts","text":"<p>\nIn an event of an FME error, the MSI-X module in the FIM generates an interrupt so the host can decide on the next course of action. The FIM does not stall upstream and downstream traffic after the FME error. However, a port error triggered by invalid request from a user AFU stalls all the traffic going from AFU to PCIe.\nThe interrupt capability is discoverable by querying the <code>NumbSuppInterrupt</code> field of the PORT_CAPABILITY register in the Port private feature.  The MSI-X vector number is recorded in the <code>InterruptVectorNumber</code> field of the GLBL_ERROR_CAPABILITY register of the Global Error external feature.</p>\n<p>An FME error interrupt is generated in response to the FME_ERROR0, PCIE0_ERROR0, RAS_NOFAT_ERR_STAT or RAS_CATFAT_ERR_STAT registers recording a new, unmasked, error per the rules defined by CoreFIM interrupt feature.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14161-msi-x-masking-pending-bit-array-pba-clearing","title":"14.1.6.1    MSI-X Masking &amp; Pending Bit Array (PBA) Clearing","text":"<p>\nIf the MSI-X vector corresponding to the FME error interrupt is masked, events are recorded in the PBA array.  Clearing the FME error status registers clears the corresponding MSI-X PBA entries.  If only some events are cleared, the normal interrupt triggering rules apply and a new pending interrupt is registered.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1417-fme-error-handling","title":"14.1.7   FME Error Handling","text":"<p>\nWhen the host receives an FME error interrupt, it must take the recommended actions described below to bring the system back to its normal operation.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14171-catastrophicfatal-error","title":"14.1.7.1    Catastrophic/Fatal Error","text":"<p>\nA system reset is mandatory for any catastrophic or fatal error.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#14172-non-fatal-error","title":"14.1.7.2    Non-Fatal Error","text":"<p>\nWhen software receives a non-fatal error interrupt which does not require a system reset, it can take the following steps to clear the error after software handles the error:\n1.  Set the _ERROR_MASK register to all 1\u2019s to mask all errors\n2. Clear the _FIRST_ERROR register\n3. Clear the _ERROR register\n4. Set _ERROR_MASK register to all 0\u2019s to enable all errors</p>\n<ul>\n<li>Result: The _ERROR &amp; _FIRST_ERROR registers begin capturing new errors.</li>\n</ul>\n<p>NOTE</p>\n<p>A system reset can only clear RAS Error status registers.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#142-mmio-requests","title":"14.2   MMIO Requests","text":"<p>\nThe FIM is designed to gracefully handle MMIO request scenarios.  </p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1421-unsupported-functions-and-bars","title":"14.2.1 Unsupported Functions and BARs","text":"<p>\nThe OFS FIM EA has only one PCIe link and all MMIO requests from the host are sent through this link. The PCIe hard IP in the FIM guarantees that only TLP packets for the functions and BARs supported by the FIM (as configured in PCIe HIP IP instantiation) are sent to the FIM on the PCIe Avalon Streaming interface.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1422-mmio-request-decoding","title":"14.2.2   MMIO Request Decoding","text":"<p>\nThe packet router and memory decoder in the FIM ensure that only legal MMIO requests are forwarded to the targeted MMIO region. Full address and BAR decoding is done both in the packet router and the memory decoder to ensure the requests are forwarded to the designated CSR region as defined in the MMIO Regions chapter.  Any unsolicited/illegal MMIO request is dropped, and an error is reported back to host through the FME error register.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1423-unused-fmeport-csr-regions","title":"14.2.3   Unused FME/Port CSR Regions","text":"<p>\nAll the CSR slaves in FIM which are mapped to the FME or Port CSR regions must always respond to MMIO read requests targeting its associated CSR region. A CSR slave must return all 0s for MMIO reads to its unused CSR region such as a reserved space or a region where no CSR register is implemented for the address.\nThe FIM ensures MMIO reads to FME or Port CSR regions that are not mapped to any CSR slave always gets a response of all 0s. The memory decoder module and fake responder module in the FIM provide this guaranteed response.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1424-unsupported-mmio-request","title":"14.2.4   Unsupported MMIO Request","text":"<p>\nAny MMIO request targeting FME or Port CSR regions with a length or address alignment that are not  supported by the FIM is dropped, and an error is logged in PCIE0_ERROR register. The MMIO checker module in the FIM guarantees this response. When an unsupported MMIO read request to the FIM CSR region is detected, the FIM sends back a CPL (completion without data) with error status (UR) back to host.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1425-afu-access-violation","title":"14.2.5   AFU Access Violation","text":"<p>\nAFU access violations refer to the scenarios where a PF is attempting to access the MMIO region of an AFU bound to a VF (virtualization enabled), or when a VF is trying to access the MMIO region of an AFU bound to a PF (virtualization disabled). When such a violation is detected, the FIM drops the request and logs the error in the FME_ERROR0 register. If the request is an MMIO read request, the FIM returns a fake response to the host.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#1426-afu-mmio-response-timeout","title":"14.2.6   AFU MMIO Response Timeout","text":"<p>\nAn AFU MMIO Response timeout functions in the same manner described in the MMIO Response Timeout section.</p>"},{"location":"hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#15-design-guidance","title":"15 Design Guidance","text":"<p>The OFS FIM is designed with configurability and scalability in mind.  At a high level, these are the necessary steps for a user to customize the design.  Please refer to the FPGA Interface Manager Developer Guide: Open FPGA Stack for Intel Stratix 10</p>\n<p>Table 15-1 Features</p>\nStep\n            Description\n            Comments  \n        1\n            Re-configure PCIe HIP for additional VFs (if necessary)\n            * PF0 is mandatory for running OPAE software* Only modification of the VFs (added or subtracted) by the user is recommended.\n\u2022   Default configuration supports 1 PF and 3 VFs.\n        \n        2\n            Update AXI4-Stram PF/VF MUX-DEMUX configuration (if necessary)\n\n            * The PF/VF MUX-DEMUX is parameterized for flexibility.  You can change, add or delete PF or VF functions by updating the top_cfg_pkg.sv file.\n* You also have the option of keeping the default configuration and tying off the unused VFs if needed.\n\n        3\n            Update top level and AFU level as necessary\n\n     * If you integrating additional external interfaces, make the edits at the top level (iofs_top.sv) and propagate the interface down to the AFU level (afu_top.sv)\n 4\n            Add user implemented function(s) in AFU\n            * All of your implemented functions must have the required AXI4-Stream interface for both the data path and the MMIO control path to CSRs. * All CSRs in the user implemented function must have the required DFH layout. * See host exerciser CSRs for reference.\n   \n        \n\n\nFor more information on modifying the FIM, refer to the [Open FPGA Stack Technical Reference Manual].\n\n\n\n## Notices &amp; Disclaimers\n\nIntel\u00ae technologies may require enabled hardware, software or service activation.\nNo product or component can be absolutely secure. \nPerformance varies by use, configuration and other factors.\nYour costs and results may vary. \nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein.\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document.\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request.\nIntel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade.\nYou are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \n\u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others.   \n[License quartus-0.0-0.01iofs-linux.run]: https://github.com/OFS/ofs-d5005/blob/release/1.0.x/license/quartus-0.0-0.01iofs-linux.run\n[OFS D5005 FIM Github Branch]: https://github.com/OFS/ofs-d5005\n[OFS FIM_COMMON Github Branch]: https://github.com/OFS/ofs-fim-common\n[OPAE SDK Branch]: https://github.com/OFS/opae-sdk/tree/2.3.0-1\n[OPAE SDK Tag]: https://github.com/OFS/opae-sdk/releases/tag/2.3.0-1\n[OPAE SDK SIM Branch]: https://github.com/OFS/opae-sim/tree/2.3.0-1\n[OPAE SDK SIM Tag]: https://github.com/OFS/opae-sim/releases/tag/2.3.0-1\n[Linux DFL]: https://github.com/OFS/linux-dfl\n[Kernel Driver Branch]: https://github.com/OFS/linux-dfl/tree/ofs-2022.3-2\n[Kernel Driver Tag]: https://github.com/OFS/linux-dfl/releases/tag/ofs-2022.3-2\n[OFS Release]: https://github.com/OFS/ofs-d5005/releases/\n[Intel\u00ae Quartus\u00ae Prime Pro Edition Linux]: https://www.intel.com/content/www/us/en/software-kit/746666/intel-quartus-prime-pro-edition-design-software-version-22-3-for-linux.html\n\n[Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae]: https://ofs.github.io/hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/\n[Qualified Servers]: https://www.intel.com/content/www/us/en/products/details/fpga/platforms/pac/d5005/view.html\n[OFS Getting Started User Guide]: https://ofs.github.io/hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/\n[Open FPGA Stack Reference Manual - MMIO Regions section]: https://ofs.github.io/hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#7-mmio-regions\n[Device Feature Header (DFH) structure]: https://ofs.github.io/hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#721-device-feature-header-dfh-structure\n[FPGA Device Feature List (DFL) Framework Overview]: https://github.com/ofs/linux-dfl/blob/fpga-ofs-dev/Documentation/fpga/dfl.rst#fpga-device-feature-list-dfl-framework-overview\n[ofs-platform-afu-bbb]: https://github.com/OPAE/ofs-platform-afu-bbb\n[Connecting an AFU to a Platform using PIM]: https://github.com/OFS/ofs-platform-afu-bbb/blob/master/plat_if_develop/ofs_plat_if/docs/PIM_AFU_interface.md\n[OFS AFU Development Guide]: https://ofs.github.io/hw/d5005/dev_guides/afu_dev/ug_dev_afu_d5005/\n[example AFUs](https://github.com/OFS/examples-afu.git)\n[PIM Tutorial]: https://github.com/OFS/examples-afu/tree/main/tutorial\n[Non-PIM AFU Development]: https://github.com/OFS/examples-afu/tree/main/tutorial\n[Unit Level Simulation]: https://ofs.github.io/hw/d5005/dev_guides/fim_dev/ug_dev_fim_ofs_d5005/#412-unit-level-simulation\n[Security User Guide: Intel\u00ae Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA]: https://github.com/otcshare/intel-ofs-docs/blob/main/d5005/user_guides/%20ug_security_ofs_d5005/ug-pac-security-d5005.md\n[BMC User Guide]: https://github.com/otcshare/intel-ofs-docs/blob/main/d5005/user_guides/%20ug_security_ofs_d5005/ug-pac-security-d5005.md\n[OPAE.io]: https://opae.github.io/latest/docs/fpga_tools/opae.io/opae.io.html\n[OPAE GitHub]: https://github.com/OFS/opae-sdk\n[5.0 OPAE Software Development Kit]: https://ofs.github.io/hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#50-opae-software-development-kit\n[Simulation User Guide: Open FPGA Stack for Intel Intel\u00ae Stratix 10\u00ae FPGA]: https://github.com/OFS/otcshare/blob/main/hw/docs/d5005/user_guides/ug_sim_ofs_d5005/ug_sim_ofs_d5005.md\n[README_ofs_d5005_eval.txt]: https://github.com/OFS/ofs-d5005/blob/release/1.0.x/eval_scripts/README_ofs_d5005_eval.txt)\n[FIM MMIO Regions]: https://ofs.github.io/hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/#mmio_regions\n\n[Open FPGA Stack Technical Reference Manual]: https://ofs.github.io/hw/d5005/reference_manuals/ofs_fim/mnl_fim_ofs_d5005/\n\n[evaluation script]: https://github.com/OFS/ofs-d5005/tree/release/1.0.x/eval_scripts\n[OFS]: https://github.com/OFS\n[OFS GitHub page]: https://ofs.github.io\n[DFL Wiki]: https://github.com/OPAE/linux-dfl/wiki \n\n\n\n\n\n\n*[AFU]: Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region\n*[BBB]: Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID.\n*[BKC]: Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against.\n*[BMC]: Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors.\n*[DFL]: Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration.\n*[FIM]: FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring.\n*[FME]: FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform.\n*[HEM]:  Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc.\n*[JTAG]:  Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology.\n*[OFS]: Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs.\n*[OPAE SDK]: Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE.\n*[PIM]: Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols.\n*[PR]: Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page.\n*[RSU]: Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration.\n*[UVM]: Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework.\n*[TB]: Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output.\n*[Intel VT-d]: Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization.\n*[SR-IOV]: Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance.\n*[MMIO]: Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators.\n*[VFIO]: Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace.\n*[IOCTL]: Input/Output Control, System calls used to manipulate underlying device parameters of special files.\n*[AER]: Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting.\n*[PAC]: Programmable Acceleration Card: FPGA based Accelerator card"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/","title":"Quick Start Evaluation Guide","text":"OFS Evaluation Quick Start Guide: Open FPGA Stack for Intel Stratix 10 FPGA"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#glossary","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#1-overview","title":"1 Overview","text":""},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#11-about-this-document","title":"1.1 About this Document","text":"<p>This document serves as a set-up and user guide for the checkout and evaluation of an Intel\u00ae FPGA PAC D5005 development at form using Open FPGA Stack (OFS). After reviewing the document, you will be able to:</p> <ul> <li> <p>Set-up and modify the script to the your environment</p> </li> <li> <p>Compile and simulate an OFS reference design</p> </li> <li> <p>Run hardware and software tests to evaluate the complete OFS flow</p> </li> </ul>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#12-table-software-version-summary","title":"1.2 Table : Software Version Summary","text":"Component Version Description FPGA Platform Intel\u00ae FPGA PAC D5005 Intel platform you can use for your custom board development OFS FIM Source Code Branch: ofs-d5005, Tag: release/1.0.x OFS Shell RTL for Intel Stratix 10 FPGA (targeting Intel\u00ae FPGA PAC D5005) OFS FIM Common Branch: ofs-fim-common-1.1.0-rc2, Tag: ofs-fim-common-1.1.0-rc2 Common RTL across all OFS-based platforms AFU Examples Branch: examples-afu , Tag:ofs-examples-ofs-examples-afu-1.0.0-rc3 Tutorials and simple examples for the Accelerator Functional Unit region (workload region) OFS Platform Building Blocks Branch: ofs-platform-bbb,Tag: 1.0.0-rc3 Provides bridge interfaces for protocol translation OPAE SDK Branch: 2.3.0-1, Tag: 2.3.0-1 Open Programmable Acceleration Engine Software Development Kit Kernel Drivers Branch: ofs-2022.3-2, Tag: ofs-2022.3-2 OFS specific kernel drivers OPAE Simulation Branch: opae-sim, Tag: 2.3.0-1 Accelerator Simulation Environment for hardware/software co-simulation of your AFU (workload) Intel Quartus Prime Pro Edition Design Software 22.3 Intel\u00ae Quartus\u00ae Prime Pro Edition Linux Software tool for Intel FPGA Development Operating System RHEL 8.2 Operating system on which this script has been tested. <p>A download page containing the release and already-compiled FIM binary artifacts that you can use for immediate evaluation on the Intel\u00ae FPGA PAC D5005 can be found on the OFS 2022.3 official release drop on GitHub.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#2-introduction-to-ofs-evaluation-script","title":"2 Introduction to OFS Evaluation Script","text":"<p>By following the setup steps and using the OFS evaluation script you can quickly evaluate many features that the OFS framework provides and also leverage this script for your own development.  </p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#21-pre-requisites","title":"2.1 Pre-Requisites","text":"<p>This script uses on the following set of software tools which should be installed using the directory structure below. Tool versions can vary.</p> <ul> <li>Intel Quartus\u00ae Prime Pro Software</li> <li>Synopsys\u00ae VCS Simulator</li> <li>Siemens\u00ae Questa\u00ae Simulator</li> </ul> <p>Figure 2-1 Folder Hierarchy for Software Tools</p> <p></p> <ol> <li> <p>You must create a directory named \"ofs-X.X.X\" where the X represents the current release number, for example ofs-d5005-1.0.1. </p> </li> <li> <p>You must clone the required OFS repositories as per Figure 2-2 . Please refer to the BKC table for locations., Please go OFS Getting Started User Guide for the instructions for the BKC installation.</p> </li> <li> <p>Assign the ofs-X.X.X folder to the $OFS_BUILD_ROOT environment variable. </p> </li> <li> <p>Once the repositories are cloned, copy the evaluation script (ofs_d5005_eval.sh) which is located at evaluation script beneath the $OFS_BUILD_ROOT directory location as shown in the example below:</p> </li> </ol> <p>Figure 2-2 Directory Structure for OFS Project</p> <pre><code>## ofs-ofs-d5005-1.0.1\n##  -&gt; examples-afu\n##  -&gt; linux-dfl\n##  -&gt; fim-d5005\n##  -&gt; opae-sdk\n##  -&gt; opae-sim\n##  -&gt; ofs_d5005_eval.sh\n</code></pre> <ol> <li>Open the README file named (README_ofs_d5005_eval.txt) which is located at evaluation script which informs the user which sections to modify in the script prior to building the FIM and running hardware, software and simulation tests. </li> </ol>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#22-d5005-evaluation-script-modification","title":"2.2 d5005 Evaluation Script modification","text":"<p>To adapt this script to the user environment please follow the instructions below which explains which line numbers to change in the ofs_d5005_eval.sh script.</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#user-directory-creation","title":"User Directory Creation","text":"<p>The user must create the top-level source directory and then clone the OFS repositories</p> <pre><code>mkdir ofs\n</code></pre> <p>In the example above we have used ofs as the directory name</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#set-up-proxy-server-lines-61-63","title":"Set-Up Proxy Server (lines 61-63)","text":"<p>Please enter the location of your proxy server to allow access to external internet to build software packages.</p> <p>Note: Failing to add proxy server will prevent cloning of repositories and the user will be unable to build the OFS framework.</p> <pre><code>export http_proxy=&lt;user_proxy&gt;\nexport https_proxy=&lt;user_proxy&gt;\nexport no_proxy=&lt;user_proxy&gt;\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#license-files-lines-66-68","title":"License Files (lines 66-68)","text":"<p>Please enter the the license file locations for the following tool variables</p> <pre><code>export LM_LICENSE_FILE=&lt;user_license&gt;\nexport DW_LICENSE_FILE=&lt;user_license&gt;\nexport SNPSLMD_LICENSE_FILE=&lt;user_license&gt;\n</code></pre>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#tools-location-line-82","title":"Tools Location (line 82)","text":"<p>Set Location of Quartus, Synopsys and Questasim Tools</p> <pre><code>export TOOLS_LOCATION=/home\n</code></pre> <p>In the example above /home is used as the base location of Quartus, Synopsys and Questasim tools</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#quartus-tools-version-line-87","title":"Quartus Tools Version (line 87)","text":"<p>Set version of Quartus</p> <pre><code>export QUARTUS_VERSION=${{ env.5005_QUARTUS_PRIME_PRO_VER }}\n</code></pre> <p>In the example above \"${{ env.5005_QUARTUS_PRIME_PRO_VER }}\" is used as the Quartus tools version</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#opae-tools-line-100","title":"OPAE Tools (line 100)","text":"<p>change OPAE SDK VERSION</p> <pre><code>export OPAE_SDK_VERSION=${{ env.5005_D5005_OPAE_VER }}\n</code></pre> <p>In the example above \"${{ env.5005_D5005_OPAE_VER }}\" is used as the OPAE SDK tools version</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#pcie-bus-number-lines-223-and-230","title":"PCIe (Bus Number) (lines 223 and 230)","text":"<p>The Bus number must be entered by the user after installing the hardware in the chosen server, in the example below \"b1\" is the Bus Number for a single card as defined in the evaluation script.</p> <pre><code>export ADP_CARD0_BUS_NUMBER=b1\n</code></pre> <p>The evaluation script uses the bus number as an identifier to interrogate the card. The command below will identify the accelerator card plugged into a server. </p> <pre><code>lspci | grep acc\n\n86:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre> <p>The result identifies the card as being assigned \"86\" as the bus number so the entry in the script changes to</p> <pre><code>export ADP_CARD0_BUS_NUMBER=86\n</code></pre> <p>The user can also run the following command on the ofs_d5005_eval.sh script to automatically change the bus number to 86 in the ofs_d5005_eval.sh script.</p> <p>grep -rli '86' * | xargs -i@ sed -i '86' @</p> <p>if the bus number is 85 for example </p> <p>85:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)</p> <p>the command to change to 85 in the evaluation script would be</p> <p>grep -rli '86' * | xargs -i@ sed -i '85' @</p> <p>The ofs_d5005_eval.sh script has now been modified to the server set-up and the user can proceed to build, compile and simulate the OFS stack</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#3-using-the-evaluation-script","title":"3 Using the Evaluation Script","text":""},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#31-overview","title":"3.1 Overview","text":"<p>The evaluation script focuses on different evaluation areas.  Each of these menu options are described in the next section.  Note that some option selection numbers are not available currently.  As new features are added additional selections will be added.</p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#311-tools-menu","title":"3.1.1 TOOLS MENU","text":"<p>By selecting \"List of Documentation for ADP d5005 Project,\" a list of links to the latest OFS documentation appears. Note that these links will take you to documentation for the most recent release which may not correspond to the release version you are evaluating. To find the documentation specific to your release, ensure you clone the intel-ofs-docs tag that corresponds to your OFS version.</p> <p>By selecting \"Check Versions of Operating System and Quartus Premier Design Suite\", the tool verifies correct Operating System, Quartus version, kernel parameters, license files and paths to installed software tools.</p> <p></p> Menu Option Example Output 1 - List of Documentation for ADP d5005 Project Getting Started Guide: Intel Open FPGA Stack for Intel Stratix 10 FPGA                 Guides you through the setup and build steps to evaluate the OFS solution targeting an Intel\u00ae FPGA PAC D5005                  FPGA Interface Manager Technical Reference Manual: Intel Open FPGA Stack for Intel Stratix 10 FPGA                 Describes the OFS FIM architecture and features                  Software Reference Manual: Intel\u00ae Open FPGA Stack                 Describes the Open Programmable Acceleration Engine (OPAE) Software Development Kit, the OPAE C++ and Python API and management interfaces. This document also covers building the OPAE SDK, how to add a new PCIe device, and debugging the software stack                  FPGA Interface Manager Developer Guide: Intel Open Stack for Intel Stratix 10 FPGA                 Provides guidance on developing an FPGA Interface Manager (FIM) for a custom FPGA acceleration board                  Accelerator Functional Unit Developer Guide: Intel Open FPGA Stack                 Provides guidance on how to build and test an AFU when designing to an OFS-based FPGA Interface Manager                  Security User Guide: Intel Open FPGA Stack for Intel Stratix 10 FPGA                 Describes how to create keys and sign bitstreams for your custom design 2 - Check versions of Operating System and Quartus Premier Design Suite (QPDS) Checking Linux release                 Linux version 5.15.77-dfl-20${{ env.5005_QUARTUS_PRIME_PRO_VER }}-1 (DCPsupport@sj-2308-a405.sj.intel.com) (gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-15), GNU ld version 2.30-73.el8) #1 SMP Thu Dec 8 10:21:38 PST 2022                  Checking RedHat release                 Red Hat Enterprise Linux release 8.2                  Checking Ubuntu release                 cat: /etc/lsb-release: No such file or directory                  Checking Kernel parameters                 BOOT_IMAGE=(hd0,msdos1)/vmlinuz-5.15.77-dfl-20${{ env.5005_QUARTUS_PRIME_PRO_VER }}-1 root=/dev/mapper/rhel-root ro crashkernel=auto resume=/dev/mapper/rhel-swap rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200                  Checking Licenses                 LM_LICENSE_FILE is set to port@socket number:port@socket number                 DW_LICENSE_FILE is set to port@socket number:port@socket number                 SNPSLMD_LICENSE_FILE is set to port@socket number:port@socket number                  Checking Tool versions                 QUARTUS_HOME is set to /home/intelFPGA_pro/${{ env.5005_QUARTUS_PRIME_PRO_VER }}/quartus                 QUARTUS_ROOTDIR is set to /home/intelFPGA_pro/${{ env.5005_QUARTUS_PRIME_PRO_VER }}/quartus                 IMPORT_IP_ROOTDIR is set to /home/intelFPGA_pro/${{ env.5005_QUARTUS_PRIME_PRO_VER }}/quartus/../ip                 QSYS_ROOTDIR is set to /home/intelFPGA_pro/${{ env.5005_QUARTUS_PRIME_PRO_VER }}/quartus/../qsys/bin                  Checking QPDS Patches                 Quartus Prime Shell                 Version ${{ env.5005_QUARTUS_PRIME_PRO_VER }}.0 Build 104 09/14/2022 SC Pro Edition                 Copyright (C) 2022  Intel Corporation. All rights reserved."},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#312-hardware-menu","title":"3.1.2 HARDWARE MENU","text":"<p>Identifies card by PCIe number, checks power, temperature and current firmware configuration. </p> <p></p> Menu Option Example Output 3 - Identify Acceleration Development Platform (ADP) d5005 Hardware via PCIe PCIe card detected as                 86:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)                 Host Server is connected to SINGLE card configuration 4 - Identify the Board Management Controller (BMC) Version and check BMC sensors Intel FPGA Programmable Acceleration Card D5005                 Board Management Controller, MAX10 NIOS FW version: 2.0.13                 Board Management Controller, MAX10 Build version: 2.0.8                 //****** BMC SENSORS ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:86:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x138D                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x4010002278FD3AA                 Bitstream Version                : 4.0.1                 Pr Interface Id                  : 64c39726-fe2d-52ab-981f-ff49395db6e7 5 - Identify the FPGA Management Engine (FME) Version Intel FPGA Programmable Acceleration Card D5005                 Board Management Controller, MAX10 NIOS FW version: 2.0.13                 Board Management Controller, MAX10 Build version: 2.0.8                 //****** FME ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:86:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x138D                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x4010002278FD3AA                 Bitstream Version                : 4.0.1                 Pr Interface Id                  : 64c39726-fe2d-52ab-981f-ff49395db6e7                 Boot Page                        : user 6 - Check Board Power and Temperature Intel FPGA Programmable Acceleration Card D5005                 Board Management Controller, MAX10 NIOS FW version: 2.0.13                 Board Management Controller, MAX10 Build version: 2.0.8                 //****** POWER ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:86:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x138D                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x4010002278FD3AA                 Bitstream Version                : 4.0.1                 Pr Interface Id                  : 64c39726-fe2d-52ab-981f-ff49395db6e7                 ( 1) VCCERAM Voltage             : 0.90 Volts                 etc ......................                  Intel FPGA Programmable Acceleration Card D5005                 Board Management Controller, MAX10 NIOS FW version: 2.0.13                 Board Management Controller, MAX10 Build version: 2.0.8                 //****** TEMP ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:86:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x138D                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x4010002278FD3AA                 Bitstream Version                : 4.0.1                 Pr Interface Id                  : 64c39726-fe2d-52ab-981f-ff49395db6e7                 ( 1) VCCT Temperature            : 57.00 Celsius                 etc ...................... 7 - Check Accelerator Port status //****** PORT ******//                 Object Id                        : 0xEF00000                 PCIe s:b:d.f                     : 0000:86:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x138D                 Socket Id                        : 0x00 8 - Check MAC and PHY status Intel FPGA Programmable Acceleration Card D5005                 Board Management Controller, MAX10 NIOS FW version: 2.0.13                 Board Management Controller, MAX10 Build version: 2.0.8                 //****** MAC ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:86:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x138D                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x4010002278FD3AA                 Bitstream Version                : 4.0.1                 Pr Interface Id                  : 64c39726-fe2d-52ab-981f-ff49395db6e7                 MAC address                      : 64:4c:36:f:44:1f                  Intel FPGA Programmable Acceleration Card D5005                 Board Management Controller, MAX10 NIOS FW version: 2.0.13                 Board Management Controller, MAX10 Build version: 2.0.8                 //****** PHY ******//                 Object Id                        : 0xF000000                 PCIe s:b:d.f                     : 0000:86:00.0                 Vendor Id                        : 0x8086                 Device Id                        : 0xBCCE                 SubVendor Id                     : 0x8086                 SubDevice Id                     : 0x138D                 Socket Id                        : 0x00                 Ports Num                        : 01                 Bitstream Id                     : 0x4010002278FD3AA                 Bitstream Version                : 4.0.1                 Pr Interface Id                  : 64c39726-fe2d-52ab-981f-ff49395db6e7"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#313-fimpr-build-menu","title":"3.1.3 FIM/PR BUILD MENU","text":"<p>Builds FIM, Partial Reconfiguration Region and Remote Signal Tap</p> <p></p> Menu Option Description 9 - Check ADP software versions for ADP d5005 Project OFS_ROOTDIR is set to /home/DCPsupport/ofs-d5005-1.0.1/ofs-d5005                 OPAE_SDK_REPO_BRANCH is set to release/${{ env.5005_D5005_OPAE_VER }}                 OPAE_SDK_ROOT is set to /home/DCPsupport/ofs-d5005-1.0.1/ofs-d5005/../opae-sdk                 LD_LIBRARY_PATH is set to /home/DCPsupport/ofs-d5005-1.0.1/ofs-d5005/../opae-sdk/lib64: 10 - Build FIM for d5005 Hardware This option builds the FIM based on the setting for the $ADP_PLATFORM, $FIM_SKU1 or $FIM_SKU2 environment variable. Check these variables in the following file ofs_d5005_eval.sh 11 - Check FIM Identification of FIM for d5005 Hardware The FIM is identified by the following file fme-ifc-id.txt located at $OFS_ROOTDIR/$FIM_WORKDIR/syn/syn_top/ 12 - Build Partial Reconfiguration Tree for d5005 Hardware This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development and also for the OneAPI build flow  13 - Build Base FIM Identification(ID) into PR Build Tree template This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU and OneAPI workloads 14 - Build Partial Reconfiguration Tree for d5005 Hardware with Remote Signal Tap This option builds the Partial Reconfiguration Tree which is needed for AFU testing/development and also for the OneAPI build flow and for the Remote Signal Tap flow 15 - Build Base FIM Identification(ID) into PR Build Tree template with Remote Signal Tap This option copies the contents of the fme-ifc-id.txt into the Partial Reconfiguration Tree for Remote Signal Tap to allow the FIM amd Partial Reconfiguration Tree to match and hence allow subsequent insertion of AFU and OneAPI workloads"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#314-hardware-programmingdiagnostic-menu","title":"3.1.4 HARDWARE PROGRAMMING/DIAGNOSTIC MENU","text":"<p>The following submenu allows you to: * Program and check flash  * Perform a remote system update (RSU) of the FPGA image into the FPGA * Bind virtual functions to VFIO PCIe driver  * Run host exerciser (HE) commands such as loopback to test interfaces VFIO PCI driver binding * Read the control and status registers (CSRs) for bound modules that are part of the OFS reference design.</p> <p></p> Menu Option Description 16 - Program BMC Image into d5005 Hardware The user must place a new BMC flash file in the following directory $OFS_ROOTDIR/bmc_flash_files. Once the user executes this option a new BMC image will be programmed. A remote system upgrade command is initiated to store the new BMC image 17 - Check Boot Area Flash Image from d5005 Hardware This option checks which location area in FLASH the image will boot from, the default is user1              Boot Page : user1 18 - Program FIM Image into user1 area for d5005 Hardware This option programs the FIM image \"d5005_page1.bin\" into user1 area in flash 19 - Initiate Remote System Upgrade (RSU) from user1 Flash Image into d5005 Hardware This option initiates a Remote System Upgrade and soft reboots the server and re-scans the PCIe bus for the new image to be loaded              2022-12-13 07:31:33,244 - [[pci_address(0000:86:00.0), pci_id(0x8086, 0xbcce, 0x8086, 0x138d)]] performing RSU operation             2022-12-13 07:31:33,249 - [[pci_address(0000:85:00.0), pci_id(0x8086, 0x2030, 0x1590, 0x00ea)]] removing device from PCIe bus             2022-12-13 07:31:34,333 - waiting 10.0 seconds for boot             2022-12-13 07:31:44,344 - rescanning PCIe bus: /sys/devices/pci0000:85/pci_bus/0000:85             2022-12-13 07:31:44,377 - RSU operation complete 20 - Check PF/VF Mapping Table, vfio-pci driver binding and accelerator port status This option checks the current vfio-pci driver binding for the PF's and VF's 21 - Unbind vfio-pci driver This option unbinds the vfio-pci driver for the PF's and VF's 22 - Create Virtual Functions (VF) and bind driver to vfio-pci d5005 Hardware This option creates vfio-pci driver binding for the PF's and VF's             Once the VF's have been bound to the driver the user can select menu option 20 to check that the new drivers are bound 23 - Run HE-LB Test This option runs 5 tests              1) checks and generates traffic with the intention of exercising the path from the AFU to the Host at full bandwidth             2) run a loopback throughput test using one cacheline per request             3) run a loopback read test using four cachelines per request             4) run a loopback write test using four cachelines per request             5) run a loopback throughput test using four cachelines per request 24 - Run HE-MEM Test This option runs 2 tests              1) Checking and generating traffic with the intention of exercising the path from FPGA connected DDR; data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host             2) run a loopback throughput test using one cacheline per request 25 - Run HE-HSSI Test This option runs 1 test              HE-HSSI is responsible for handling client-side ethernet traffic. It wraps the 10G and 100G HSSI AFUs, and includes a traffic generator and checker. The user-space tool hssi exports a control interface to the HE-HSSI's AFU's packet generator logic              1) Send traffic through the 10G AFU              26 - Read from CSR (Command and Status Registers) for d5005 Hardware This option reads from the following CSR's             HE-LB Command and Status Register Default Definitions             HE-MEM Command and Status Register Default Definitions             HE-HSSI Command and Status Register Default Definitions"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#315-hardware-afu-testing-menu","title":"3.1.5  HARDWARE AFU TESTING MENU","text":"<p>This submenu tests partial reconfiguration by building and loading an memory-mapped I/O example AFU/workload, executes software from host, and tests remote signal tap.</p> <p></p> Menu Option Description 27 - Build and Compile host_chan_mmio example This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB_EXTERNAL/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS(Green Bit Stream) ready for hardware programming 28 - Execute host_chan_mmio example This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test 29 - Modify host_chan_mmio example to insert Remote Signal Tap This option inserts a pre-defined host_chan_mmio.stp Signal Tap file into the OFS code to allow a user to debug the host_chan_mmio AFU example 30 - Build and Compile host_chan_mmio example with Remote Signal Tap This option builds the host_chan_mmio example from the following repo $OFS_PLATFORM_AFU_BBB_EXTERNAL/plat_if_tests/$AFU_TEST_NAME, where AFU_TEST_NAME=host_chan_mmio. This produces a GBS(Green Bit Stream) ready for hardware programming with Remote Signal tap enabled 31 - Execute host_chan_mmio example with Remote Signal Tap This option builds the host code for host_chan_mmio example and programs the GBS file and then executes the test. The user must open the Signal Tap window when running the host code to see the transactions in the Signal tap window"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#316-hardware-afu-bbb-testing-menu","title":"3.1.6 HARDWARE AFU BBB TESTING MENU","text":"<p>This submenu tests partial reconfiguration using a hello_world example AFU/workload, executes sw from the host</p> <p></p> Menu Option Description 32 - Build and Compile hello_world example This option builds the hello_ world example from the following repo $FPGA_BBB_CCI_SRC/tutorial/afu_types/01_pim_ifc/$AFU_BBB_TEST_NAME, where AFU_BBB_NAME=hello_world. This produces a GBS (Green Bit Stream) file ready for hardware programming 33 - Execute hello_world example This option builds the host code for hello_world example and programs the GBS file and then executes the test"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#317-unit-test-project-menu","title":"3.1.7 UNIT TEST PROJECT MENU","text":"<p>Builds, compiles and runs standalone simulation block tests. More unit test examples are found at teh follwimng location ofs-d5005/sim/unit_test </p> <p></p> Menu Option Result 34 - Generate Simulation files for Unit Test This option builds the simulation file set for running a unit test simulation 35 - Simulate Unit Test dfh_walker and log waveform entry"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#318-adp-build-all-project-menu","title":"3.1.8 ADP BUILD ALL PROJECT MENU","text":"<p>Builds the complete OFS flow, good for regression testing and overnight builds</p> <p>For this menu a user can run a sequence of tests (compilation, build and simulation) and executes them sequentially. After the script is successfully executed, a set of binary files is produced which a you can use to evaluate your hardware. Log files are also produced which checks whether the tests passed.</p> <p>You can run a sequence of tests and execute them sequentially.  In the example below when the user selects option 36 from the main menu script, the complete OFS flow covering build, compile and simulation will execute.</p> <p></p> <p></p> Menu Option Result 36 - Build and Simulate Complete d5005 Project Generating Log File with date and timestamp                 Log file written to /home/DCPsupport/ofs-d5005-1.0.1/log_files/d5005_log_2022_11_10-093649/ofs_d5005_eval.log <p>Definition of Multi-Test Set-up</p> <p>Menu Option 36 above in the evaluation script can be refined to tailor it to the users need and is principally defined by the variable below</p> <p>MULTI_TEST[A,B]=C</p> <p>where</p> <p>A= Total Number of menu options in script B= Can be changed to a number to select the test order C= Menu Option in Script</p> <p>Example 1 MULTI_TEST[36,0]=2</p> <p>A= 36 is the total number of options in the script B= 0 indicates that this is the first test to be run in the script C= Menu option in Script ie 2- List of Documentation for ADP d5005 Project</p> <p>Example 2 MULTI_TEST[36,0]=2 MULTI_TEST[36,1]=9</p> <p>In the example above two tests are run in order ie 0, and 1 and the following menu options are executed ie 2- List of Documentation for ADP d5005 Project and 9 - Check ADP software versions for ADP d5005 Project</p> <p>The user can also modify the build time by de-selecting options they do not wish to use, see below for a couple of use-case scenarios.</p> <p>User Case for ADP FIM/PR BUILD MENU</p> <p>In the example below when the user selects option 36 from the main menu the script will only run options from the ADP FIM/PR BUILD MENU (7 options, main menu options 9, 10, 11, 12, 13, 14 and 15). All other tests with an \"X\" indicates do not run that test.</p> <p></p> <p></p>"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#4-common-test-scenarios","title":"4 Common Test Scenarios","text":"<p>This section will describe the most common compile build scenarios if a user wanted to evaluate an acceleration card on their server. The Pre-requisite column indicates the menu commands that must be run befere executing the test eg To run Test 5 then a user needs to have run option 10, 12 and 14 before running options 27, 28, 29, 30 and 31.</p> Test Test Scenario Pre-Requisite Menu Option Menu Option Test 1 FIM Build - 10 Test 2 Partial Reconfiguration Build 10 12 Test 3 Program FIM and perform Remote System Upgrade 10 18, 19 Test 4 Bind PF and VF to vfio-pci drivers - 20, 21, 22 Test 5 Build, compile and test AFU on hardware 10, 12, 13 27, 28 Test 6 Build, compile and test AFU Basic Building Blocks on hardware 10, 12, 13 32, 33 Test 8 Build and Simulate Unit Tests - 34, 35"},{"location":"hw/d5005/user_guides/ug_eval_ofs_d5005/ug_eval_script_ofs_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others.   </p> <p>example AFUs</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/","title":"Getting Started Guide: Open FPGA Stack for Intel Stratix 10","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#10-introduction","title":"1.0 Introduction","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#11-about-this-document","title":"1.1 About This Document","text":"<p>This document helps users get started in evaluating Open FPGA Stack (OFS) for Intel\u00ae Stratix 10\u00ae FPGA targeting the Intel\u00ae FPGA PAC D5005. After reviewing the document a user shall be able to:</p> <ul> <li>Set up a development environment with all OFS ingredients</li> <li>Build and install the OFS Linux Kernel drivers</li> <li>Build and install the Open Programmable Acceleration Engine Software Development Kit (OPAE SDK) software on top of the OFS Linux kernel drivers</li> <li>Flash an OFS FIM binary onto the Intel\u00ae FPGA PAC D5005</li> <li>Verify the functionality of OFS on an Intel\u00ae FPGA PAC D5005 board</li> <li>Know where to find additional information on all OFS ingredients</li> </ul> <p>The following flow charts show a high level overview of the initial bringup process, split into three sequential diagrams.</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#diagram-1-installing-the-opae-sdk","title":"Diagram 1: Installing the OPAE SDK","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#diagram-2-installing-the-linux-dfl-drivers","title":"Diagram 2: Installing the Linux DFL Drivers","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#diagram-3-bringing-up-the-intel-d5005","title":"Diagram 3: Bringing up the Intel D5005","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#12-terminology","title":"1.2 Terminology","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#glossary","title":"Glossary","text":"Term Description AER Advanced Error Reporting, The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. AFU Accelerator Functional Unit, Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance. Note: An AFU region is the part of the design where an AFU may reside. This AFU may or may not be a partial reconfiguration region BBB Basic Building Block, Features within an AFU or part of an FPGA interface that can be reused across designs. These building blocks do not have stringent interface requirements like the FIM's AFU and host interface requires. All BBBs must have a (globally unique identifier) GUID. BKC Best Known Configuration, The exact hardware configuration Intel has optimized and validated the solution against. BMC Board Management Controller, Acts as the Root of Trust (RoT) on the Intel FPGA PAC platform. Supports features such as power sequence management and board monitoring through on-board sensors. CSR Command/status registers (CSR) and software interface, OFS uses a defined set of CSR's to expose the functionality of the FPGA to the host software. DFL Device Feature List, A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. FIM FPGA Interface Manager, Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs. The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. FME FPGA Management Engine, Provides a way to manage the platform and enable acceleration functions on the platform. HEM Host Exerciser Module, Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Intel FPGA PAC D5005 Intel FPGA Programmable Acceleration Card D5005, A high performance PCI Express (PCIe)-based FPGA acceleration card for data centers. This card is the target platform for the initial OFS release. Intel VT-d Intel Virtualization Technology for Directed I/O, Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. IOCTL Input/Output Control, System calls used to manipulate underlying device parameters of special files. JTAG Joint Test Action Group, Refers to the IEEE 1149.1 JTAG standard; Another FPGA configuration methodology. MMIO Memory Mapped Input/Output, Users may map and access both control registers and system memory buffers with accelerators. OFS Open FPGA Stack, A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. OPAE SDK Open Programmable Acceleration Engine Software Development Kit, A collection of libraries and tools to facilitate the development of software applications and accelerators using OPAE. PAC Programmable Acceleration Card: FPGA based Accelerator card PIM Platform Interface Manager, An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. PR Partial Reconfiguration, The ability to dynamically reconfigure a portion of an FPGA while the remaining FPGA design continues to function. In the context of Intel FPGA PAC, a PR bitstream refers to an Intel FPGA PAC AFU. Refer to Partial Reconfiguration support page. RSU Remote System Update, A Remote System Update operation sends an instruction to the Intel FPGA PAC D5005 device that triggers a power cycle of the card only, forcing reconfiguration. SR-IOV Single-Root Input-Output Virtualization, Allows the isolation of PCI Express resources for manageability and performance. TB Testbench, Testbench or Verification Environment is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output. UVM Universal Verification Methodology, A modular, reusable, and scalable testbench structure via an API framework. VFIO Virtual Function Input/Output, An IOMMU/device agnostic framework for exposing direct device access to userspace."},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#13-introduction-to-ofs","title":"1.3 Introduction to OFS","text":"<p>Each OFS reference FIM targets a specific platform, but the modular hardware, software, simulation and test infrastructure allows you to modify each part of the design and test environment for your own custom acceleration platform card. The current OFS reference FIM for Stratix 10 FPGA targets the Intel\u00ae FPGA PAC D5005 board. This document focuses exclusively on the OFS release targeting the Intel\u00ae FPGA PAC D5005 board.</p> <p>The OFS repositories (in OFS ) on GitHub provide the following components targeting an Intel\u00ae FPGA PAC D5005:</p> <ul> <li>opae-sdk: Contains the Open Programmable Acceleration Software Development Kit source code and build scripts. The following submodule repositories are contained within <code>opae-sdk</code></li> <li>linux-dfl: Contains Linux kernel-level driver source code and build scripts.</li> <li>intel-ofs-fim: Contains the source code, build scripts and verification suite for FPGA RTL source code</li> <li>ofs-hld-shim: Contains the necessary files to generate Shim/BSP for OFS Cards, using OPAE SDK Interfaces.</li> </ul> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#14-intended-audience","title":"1.4 Intended Audience","text":"<p>The information in this document is intended for customers evaluating the Open FPGA Stack for Intel\u00ae Stratix 10\u00ae FPGA on the Intel PAC D5005. This document will cover key topics related to initial setup and development, with links for deeper dives on the topics discussed therein.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#15-reference-documents","title":"1.5 Reference Documents","text":"<p>Please refer to the README on the OFS GitHub for an updated list of collateral on the OFS GitHub page.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#16-component-version-summary","title":"1.6 Component Version Summary","text":"<p>The OFS 2022.3 Release targeting the Intel\u00ae Stratix 10\u00ae FPGA is built upon tightly coupled software and firmware versions. Use this section as a general reference for the versions which comprise this release.</p> <p>The following table highlights the hardware which makes up the Best Known Configuration (BKC) for the OFS 2022.3 release.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-1-2-hardware-bkc","title":"Table 1-2: Hardware BKC","text":"Component 1 x Intel\u00ae FPGA PAC D5005 1 x Supported Server Model 1 x Intel FPGA Download Cable II   *(Optional, only required if loading images via JTAG) <p>The following table highlights the versions of the software which comprise the OFS stack. The installation of the user-space OPAE SDK on top of the kernel-space linux-dfl drivers is discussed in subsequent sections of this document.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-1-3-software-version-summary","title":"Table 1-3: Software Version Summary","text":"Component Version FPGA Platform Intel\u00ae FPGA PAC D5005 OPAE SDK Tag: 2.3.0-1 Kernel Drivers Tag: ofs-2022.3-2 OFS FIM Source Code Branch: release/1.0.x Intel Quartus Prime Pro Edition Design Software 22.3 Intel\u00ae Quartus\u00ae Prime Pro Edition Linux Operating System RHEL 8.2 <p>A download page containing the release and already-compiled FIM binary artifacts that you can use for immediate evaluation on the Intel\u00ae FPGA PAC D5005 can be found on the OFS 2022.3 official release drop on GitHub.</p> <p>Note: If you wish to freeze your Red Hat operating system version on the RHEL 8.2, refer to the following solution provided in the Red Hat customer portal.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#20-ofs-stack-architecture-overview-for-reference-platform","title":"2.0 OFS Stack Architecture Overview for Reference Platform","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#21-hardware-components","title":"2.1 Hardware Components","text":"<p>The OFS hardware architecture decomposes all designs into a standard set of modules, interfaces, and capabilities. Although the OFS infrastructure provides a standard set of functionality and capability, the user is responsible for making the customizations to their specific design in compliance with the specifications outlined in the Open FPGA Stack Technical Reference Manual.</p> <p>OFS is a blanket term which can be used to collectively refer to all ingredients of the OFS reference design, which includes the core hardware components discussed below and software.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#211-fpga-interface-manager","title":"2.1.1 FPGA Interface Manager","text":"<p>The FPGA Interface Manager (FIM) or 'shell' provides platform management functionality, clocks, resets, and interface access to the host and peripheral features on the acceleration platform. The FIM is implemented in a static region of the FPGA device.</p> <p>The primary components of the FIM reference design are:</p> <ul> <li>PCIe Subsystem</li> <li>Transceiver Subsystem</li> <li>Memory Subsystem</li> <li>FPGA Management Engine</li> <li>AFU Peripheral Fabric for AFU accesses to other interface peripherals</li> <li>Board Peripheral Fabric for master to slave CSR accesses from host or AFU</li> <li>Interface to Board Management Controller (BMC)</li> </ul> <p>The FPGA Management Engine (FME) provides management features for the platform and the loading/unloading of accelerators through partial reconfiguration.</p> <p>For more information on the FIM and its external connections, please refer to the Open FPGA Stack Technical Reference Manual, and the Intel FPGA Programmable Acceleration Card D5005 Data Sheet. Below is a high-level block diagram of the FIM.</p> <p></p> <p>Figure 2-1 FIM Overview</p> <p></p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#212-afu","title":"2.1.2 AFU","text":"<p>An AFU is an acceleration workload that interfaces to the FIM. The AFU boundary in this reference design comprises both static and partial reconfiguration (PR) regions. You can decide how you want to partition these two areas or if you want your AFU region to only be a partial reconfiguration region. A port gasket within the design provides all the PR specific modules and logic required for partial reconfiguration. Only one partial reconfiguration region is supported in this design.</p> <p>Similar to the FME, the port gasket exposes its capabilities to the host software driver through a DFH register placed at the beginning of the port gasket CSR space. In addition, only one PCIe link can access the port register space.</p> <p>You can compile your design in one of the following ways:</p> <ul> <li>Your AFU resides in a partial reconfiguration (PR) region of the FPGA.</li> <li>Your AFU is a part of the static region (SR) and is a compiled flat design.</li> <li>Your AFU contains both static and PR regions.</li> </ul> <p>The AFU provided in this release is comprised of the following functions:</p> <ul> <li>AFU interface handler to verify transactions coming from the AFU region.</li> <li>PV/VF Mux to route transactions to and from corresponding AFU components, including the ST2MM module, PCIe loopback host exerciser (HE-LB), HSSI host exerciser (HE-HSSI), and Memory Host Exerciser (HE-MEM).</li> <li>AXI4 Streaming to Memory Map (ST2MM) Module that routes MMIO CSR accesses to FME and board peripherals.</li> <li>Host exercisers to test PCIe, memory and HSSI interfaces (these can be removed from the AFU region after your FIM design is complete to provide more resource area for workloads).</li> <li>Port gasket and partial reconfiguration support.</li> </ul> <p>For more information on the Platform Interface Manager (PIM) and AFU development and testing, please refer to the OFS AFU Development Guide.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#22-ofs-software-overview","title":"2.2 OFS Software Overview","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#221-kernel-drivers-for-ofs","title":"2.2.1 Kernel Drivers for OFS","text":"<p>OFS DFL driver software provides the bottom-most API to FPGA platforms. Libraries such as OPAE and frameworks like DPDK are consumers of the APIs provided by OFS. Applications may be built on top of these frameworks and libraries. The OFS software does not cover any out-of-band management interfaces. OFS driver software is designed to be extendable, flexible, and provide for bare-metal and virtualized functionality. An in depth look at the various aspects of the driver architecture such as the API, an explanation of the DFL framework, and instructions on how to port DFL driver patches to other kernel distributions can be found on the DFL Wiki page.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#30-intel-fpga-pac-d5005-card-and-server-requirements","title":"3.0 Intel FPGA PAC D5005 Card and Server Requirements","text":"<p>Currently OFS for Intel\u00ae Stratix 10\u00ae FPGA targets the Intel\u00ae FPGA PAC D5005. Because the Intel\u00ae FPGA PAC D5005 is a production card, you must prepare the card in order to receive a new non-production bitstream. For these instructions, please contact an Intel representative.</p> <p>In addition, refer to sections 2.1-2.3 of the Intel Acceleration Stack Quick Start Guide: Intel FPGA Programmable Acceleration Card D5005 for a complete overview of the physical installation process and ESD precautions for the D5005 platform.</p> <p>Note: Ensure that the system meets all the following requirements   before proceeding to install the Intel\u00ae FPGA PAC D5005 into a server.</p> <p></p> <p>Table 3-1 Server Requirements for Intel D5005</p> Component Description Server Qualified Servers Main Board PCI Express 3.0 compliant motherboard with at least one dual-width x16 PCIe slot available for card installation Board Power Supply* Auxiliary Power (12V) <p>* For more information on the required auxiliary power supply, refer to section 2.2.2 of the Intel FPGA Programmable Acceleration Card D5005 Data Sheet.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#31-supported-processors-for-intel-d5005","title":"3.1 Supported Processors for Intel D5005","text":"<p>OFS requires that the deployment machine's Xeon processor must support the following technologies. These options must also be enabled in the BIOS and as kernel parameters. The process to enable these parameters will be discussed in the section on driver installation:</p> <ul> <li>Intel VT-d (Intel Virtualization Technology for IA-32 and Intel 64 Processors)</li> <li>Intel VT-x (Intel Virtualization Technology for Directed I/O)</li> <li>Intel IOMMU</li> </ul> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#32-cooling-requirements-for-the-intel-fpga-pac-d5005","title":"3.2 Cooling Requirements for the Intel FPGA PAC D5005","text":"<p>Please refer to sections 8.1 and 8.2 of the Intel FPGA Programmable Acceleration Card D5005 Data Sheet for guidance on cooling specifications that must be met when using the D5005 card. Failure to adhere to these guidelines may result in thermal runaway and/or performance degradation.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#40-ofs-dfl-kernel-drivers","title":"4.0 OFS DFL Kernel Drivers","text":""},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#41-ofs-dfl-kernel-driver-environment-setup","title":"4.1 OFS DFL Kernel Driver Environment Setup","text":"<p>All OFS DFL kernel driver code resides in the Linux DFL GitHub repository. This repository is open source and does not require any permissions to access. It includes a snapshot of the latest best-known configuration (BKC) Linux kernel with the OFS driver included in the drivers/fpga/* directory. Downloading, configuration, and compilation will be discussed in this section. Please refer to Table 1-3 for the latest supported OS.</p> <p>It is recommended you boot into your operating system's native 4.18.x kernel  before attempting to upgrade to the dfl enabled 5.15-lts You may experience issues when moving between two dfl enabled 5.15-lts  kernels.</p> <p>This installation process assumes the user has access to an internet connection in order to pull specific GitHub repositories, and to satisfy package dependencies.</p> <p>1. You must make the following changes in order to install all dependencies on the latest BKC Operating System. These are required to both build and install the drivers from source, and to install them from pre-built packages:</p> <p></p> <pre><code>subscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\nsudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n</code></pre> <p>2. You must satisfy the following package dependencies if building and installing the drivers from source. Double check that all packages have been found and installed:</p> <p></p> <pre><code>sudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libuuid-devel rpm-build systemd-devel sudo nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\nspdlog-devel cli11-devel python3-pyyaml hwloc-devel libedit-devel openssl-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install --upgrade setuptools --prefix=/usr\n\n# To Install pybind11 following are the steps\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm' --output ./python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm' --output ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n</code></pre> <p>It is recommended you create an empty top-level directory for their OFS related repositories to keep the working environment clean. All steps in this installation will use a generic top-level directory at <code>/home/user/OFS/</code>. If you have created a different top-level directory, replace this path with your custom path.</p> <p>3. Initialize an empty git repository and clone the LTS tagged DFL driver source code: </p> <p>```bash session cd /home/user/OFS/ git init git clone https://github.com/OPAE/linux-dfl cd /home/user/OFS/linux-dfl git checkout tags/ofs-2022.3-2 -b fpga-ofs-dev-5.15-lts</p> <pre><code>**4.** Verify that the correct tag has been checkout out.\n\n```bash session\ngit describe \nofs-2022.3-2\n</code></pre> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#42-building-and-installing-the-ofs-dfl-kernel-drivers-from-source","title":"4.2 Building and Installing the OFS DFL Kernel Drivers from Source","text":"<p>1. The following set of instructions walk you through copying an existing kernel configuration file on your machine and changing the minimal required configuration settings:</p> <p><code>``bash session cd /home/user/OFS/linux-dfl cp /boot/config-</code>uname -r` .config cat configs/dfl-config &gt;&gt; .config echo 'CONFIG_LOCALVERSION=\"-dfl\"' &gt;&gt; .config echo 'CONFIG_LOCALVERSION_AUTO=y' &gt;&gt; .config sed -i -r 's/CONFIG_SYSTEM_TRUSTED_KEYS=.*/CONFIG_SYSTEM_TRUSTED_KEYS=\"\"/' .config sed -i '/^CONFIG_DEBUG_INFO_BTF/ s/./#&amp;/' .config echo 'CONFIG_DEBUG_ATOMIC_SLEEP=y' &gt;&gt; .config export LOCALVERSION= make olddefconfig <pre><code>(Optional) To use the built-in GUI menu for editing kernel configuration parameters, you can opt to run `make menuconfig`.\n\n**2.** Linux kernel builds take advantage of multiple processors to parallelize the build process. Display how many processors are available with the `nproc` command, and then specify how many make threads to utilize with the -j option. Note that number of threads can exceed the number of processors. In this case, the number of threads are set to the number of processors in the system.\n\n&lt;br&gt;\n\n```bash session\ncd /home/user/OFS/linux-dfl\nmake -j `nproc`\nmake -j `nproc` modules\n</code></pre></p> <p>3. The user has two options for installation from source:</p> <ul> <li>Using the built-in install option from the kernel Makefile.</li> <li>Locally building a set of RPM/DEB packages.</li> </ul> <p>3.a This first flow will directly install the kernel and kernel module files without the need to create a package first:</p> <p><code>``bash session cd /home/user/OFS/linux-dfl sudo make -j</code>nproc<code>modules_install sudo make -j</code>nproc` install <pre><code>**3.b** This second flow will locally build a set of packages. The package options for this flow as as follows:\n\n- rpm-pkg: Build both source and binary RPM kernel packages\n- binrpm-pkg: Build only the binary kernel RPM package\n- deb-pkg: Build both source and binary deb kernel packages\n- bindeb-pkg: Build only the binary kernel deb package\n\nIf you are concerned about the size of the resulting package and binaries, you can significantly reduce the size of the package and object files by using the make variable INSTALL_MOD_STRIP. If this is not a concern, feel free to skip this step. The below instructions will build a set of binary RPM packages:\n\n```bash session\ncd /home/user/OFS/linux-dfl\nmake INSTALL_MOD_STRIP=1 binrpm-pkg\n</code></pre></p> <p>3.b.1 By default a directory is created in your <code>home</code> directory called <code>rpmbuild</code>. This directory will house all of the kernel packages which have been built. You need to navigate to the newly built kernel packages and install them. The following files were generated using the build command executed in the previous step:</p> <p>```bash session cd ~/rpmbuild/RPMS/x86_64 ls kernel-5.15.77_dfl-1.x86_64.rpm  kernel-headers-5.15.77_dfl-1.x86_64.rpm sudo dnf localinstall kernel*.rpm <pre><code>**4.** The system will need to be rebooted for changes to take effect. After a reboot, select the newly built kernel as the boot target. This can be done pre-boot using the command `grub2-reboot`, which removes the requirement for user intervention. After boot, verify that the currently running kernel matches expectation.\n\n```bash session\nuname -r\n5.15.77-dfl\n</code></pre></p> <p>5. Verify the DFL drivers have been successfully installed. If an Intel\u00ae FPGA PAC D5005 card with the appropriate FIM is on the local system, the kernel driver modules will have been loaded. In the <code>lsmod</code> output the second column corresponds to the size of the kernel module in bytes, the third column displays the number of devices registered to that driver, and the fourth column displays the names of the devices using it. Verify their versions against the below.</p> <p>```bash session lsmod | grep -e fpga -e dfl</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output","title":"output","text":"<p>uio_dfl                20480  0 spi_altera_dfl         20480  0 uio                    20480  1 uio_dfl dfl_emif               16384  0 spi_altera_core        16384  1 spi_altera_dfl dfl_fme_region         20480  0 dfl_fme_br             16384  0 dfl_fme_mgr            20480  0 dfl_afu                36864  0 dfl_fme                49152  0 dfl_pci                20480  0 dfl                    40960  8 dfl_pci,s10hssi,uio_dfl,dfl_fme,dfl_fme_br,dfl_afu,spi_altera_dfl,dfl_emif fpga_region            20480  3 dfl_fme_region,dfl_fme,dfl fpga_bridge            20480  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br fpga_mgr               24576  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme</p> <pre><code>If an Intel\u00ae FPGA PAC D5005 card is not installed in the system and/or does not have the appropriate FIM configured, the user may read version information of the DFL drivers directly from `/lib/modules`:\n\n```bash session\ncd /usr/lib/modules/`uname -r`/kernel/drivers/fpga\nmodinfo dfl* fpga* | grep ^name\n#output\nname:           dfl_afu\nname:           dfl_fme_br\nname:           dfl_fme\nname:           dfl_fme_mgr\nname:           dfl_fme_region\nname:           dfl_hssi\nname:           dfl\nname:           dfl_n3000_nios\nname:           dfl_pci\nname:           fpga_bridge\nname:           fpga_mgr\nname:           fpga_regions\n</code></pre> <p>6. Four kernel parameters must be added to the boot command-line for the newly installed kernel. First, open the file <code>grub</code>:</p> <p>```bash session sudo vim /etc/default/grub <pre><code>&lt;a name=\"redirect-step12\"&gt;&lt;/a&gt;\n&lt;a name=\"step-7\"&gt;&lt;/a&gt;\n\n**7.** In the variable GRUB_CMDLINE_LINUX add the parameters shown after `quiet`:\n\n```bash\nGRUB_CMDLINE_LINUX=\"crashkernel=auto resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200\"\n</code></pre></p> <p>Note: If you wish to instead set hugepages on a per session basis, you can perform the following step. These settings will be lost on reboot.</p> <p>```bash session mkdir -p /mnt/huge  mount -t hugetlbfs nodev /mnt/huge  echo 2048 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages  echo 2048 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages  <pre><code>**8.** Save your edits, then apply them to the GRUB2 configuration file.\n\n```bash session\nsudo grub2-mkconfig  -o /boot/efi/EFI/redhat/grub.cfg\n</code></pre></p> <p>9. Warm reboot. Your kernel parameter changes should have taken affect.</p> <p>```bash session cat /proc/cmdline BOOT_IMAGE=(hd0,gpt2)/vmlinuz-5.15.77-dfl root=/dev/mapper/rhel_bapvedell028-root ro crashkernel=auto resume=/dev/mapper/rhel_bapvedell028-swap rd.lvm.lv=rhel_bapvedell028/root rd.lvm.lv=rhel_bapvedell028/swap rhgb quiet intel_iommu=on pcie=realloc hugepagesz=2M hugepages=200 <pre><code>&lt;a name=\"heading-5.0\"&gt;&lt;/a&gt;\n\n## **5.0 OPAE Software Development Kit**\n\nThe OPAE SDK software stack sits in user space on top of the OFS kernel drivers. It is a common software infrastructure layer that simplifies and streamlines integration of programmable accelerators such as FPGAs into software applications and environments. OPAE consists of a set of drivers, user-space libraries, and tools to discover, enumerate, share, query, access, manipulate, and reconfigure programmable accelerators. OPAE is designed to support a layered, common programming model across different platforms and devices. To learn more about OPAE, its documentation, code samples, an explanation of the available tools, and an overview of the software architecture, please visit the [OPAE GitHub] page.\n\nThe OPAE SDK source code is contained within a single GitHub repository hosted at the [OPAE GitHub]. This repository is open source.\n\n&lt;a name=\"heading-5.1\"&gt;&lt;/a&gt;\n\n### **5.1 OPAE SDK Build Environment Setup**\n\nEnsure the local environment matches the supported Operating System discussed in section [Table 1-3: Software Version Summary](#table-1-3). This installation process assumes you have access to an internet connection in order to pull specific GitHub repositories, and to satisfy package dependencies.\n\n&lt;a name=\"heading-5-1-1\"&gt;&lt;/a&gt;\n\n#### **5.1.1 Building and Installing the OPAE SDK from Source**\n\n**1.** Before OPAE SDK installation the user must remove any prior OPAE frameworks.  To remove these packages:\n&lt;br&gt;\n```bash session\nsudo dnf remove opae*\n</code></pre></p> <p>2. You must make the following changes to install all dependencies on RHEL 8.2:  ```bash session subscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms sudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm <pre><code>**3.** You must satisfy the following package dependencies. Double check that all packages have been found and installed:\n\n&lt;br&gt;\n\n```bash session\nsudo dnf install -y python3 python3-pip python3-devel \\\ngdb vim git gcc gcc-c++ make cmake libarchive libuuid-devel rpm-build systemd-devel sudo nmap \\\npython3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel \\\nspdlog-devel cli11-devel python3-pyyaml hwloc-devel libedit-devel openssl-devel\n\npython3 -m pip install --user jsonschema virtualenv pudb pyyaml\n\nsudo pip3 uninstall setuptools\n\nsudo pip3 install --upgrade setuptools --prefix=/usr\n\n# To Install pybind11 following are the steps\n\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/python3-pybind11-2.4.3-2.el8.x86_64.rpm' --output ./python3-pybind11-2.4.3-2.el8.x86_64.rpm\n\ncurl 'ftp://ftp.pbone.net/mirror/archive.fedoraproject.org/epel/8.2.2020-11-04/Everything/x86_64/Packages/p/pybind11-devel-2.4.3-2.el8.x86_64.rpm' --output ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n\nsudo dnf localinstall ./python3-pybind11-2.4.3-2.el8.x86_64.rpm ./pybind11-devel-2.4.3-2.el8.x86_64.rpm\n</code></pre></p> <p>It is recommended you create an empty top-level directory for their OFS related repositories to keep the working environment clean. All steps in this installation will use a generic top-level directory at <code>/home/user/OFS/</code>. If you have created a different top-level directory, replace this path with your custom path.</p> <p>4. Initialize an empty git repository and clone the tagged OPAE SDK source code:  ```bash session cd /home/user/OFS/ git init git clone https://github.com/OPAE/opae-sdk.git cd opae-sdk git checkout tags/2.3.0-1 -b release/2.3.0 <pre><code>**5.** Verify that the correct tag has been checkout out:\n&lt;br&gt;\n```bash session\ngit describe --tags\n2.3.0-1\n</code></pre></p> <p>6. Build the OPAE SDK source code, and pack it into several local RPM packages. Building the code into packages allows for easier installation and removal.  <code>bash session cd packaging/opae/rpm ./create fedora <pre><code>**7.** After a successful compile there should be 8 packages present:\n&lt;br&gt;\n```bash session\n\nls | grep rpm\n#output\nopae-2.3.0-1.el8.src.rpm\nopae-2.3.0-1.el8.x86_64.rpm\nopae-debuginfo-2.3.0-1.el8.x86_64.rpm\nopae-debugsource-2.3.0-1.el8.x86_64.rpm\nopae-devel-2.3.0-1.el8.x86_64.rpm\nopae-devel-debuginfo-2.3.0-1.el8.x86_64.rpm\nopae-extra-tools-2.3.0-1.el8.x86_64.rpm\nopae-extra-tools-debuginfo-2.3.0-1.el8.x86_64.rpm\n</code></pre> Remove the opae-2.3.0-1.el8.src.rpm file as it is not used.</code>bash session rm opae-2.3.0-1.el8.src.rpm <pre><code>&lt;a name=\"#prebuilt-skip-step3-opae\"&gt;&lt;/a&gt;\n\n**7.a** Install the user-built OPAE SDK packages:\n\n```bash session\nsudo dnf clean all\n\nsudo dnf localinstall -y opae*.rpm\n</code></pre></p> <p>8. Check that all packages have been installed:</p> <p>```bash session rpm -qa | grep opae</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_1","title":"output","text":"<p>opae-extra-tools-2.3.0-1.el8.x86_64 opae-debugsource-2.3.0-1.el8.x86_64 opae-2.3.0-1.el8.x86_64 opae-extra-tools-debuginfo-2.3.0-1.el8.x86_64 opae-debuginfo-2.3.0-1.el8.x86_64 opae-devel-2.3.0-1.el8.x86_64 opae-devel-debuginfo-2.3.0-1.el8.x86_64 <pre><code>You can query information about each installed package using `rpm -qi &lt;package__name&gt;`.\n\n&lt;a name=\"heading-5.2\"&gt;&lt;/a&gt;\n\n### **5.2 OPAE Tools Overview**\n\nThe OPAE SDK user-space tools sit upon the kernel-space DFL drivers. In order to use OPAE SDK functionality the user needs to complete the steps outlined in the previous section [4.1 OFS DFL Kernel Driver Environment Setup](#heading-4.1) before attempting to run any OPAE commands or flows. You must have at least one D5005 card with the appropriate FIM present in your system. The steps to read and load a new FIM version are discussed in section [6.1 Programming the OFS FIM](#heading-6.1). After both the DFL kernel-space drivers have been installed and the FIM has been upgraded, you may proceed to test the OPAE commands discussed below.\n\nThis section covers basic functionality of the commonly used OPAE tools and their expected results. These steps may also be used to verify that all OFS software installation has been completed successfully. A complete overview of the OPAE tools can be found on the [OPAE GitHub] and in your cloned GitHub repo at `&lt;your path&gt;/opae-sdk/doc/src/fpga_tools`. More commands are listed than are defined in the list below - most of these are called by other tools and do not need to be called directly themselves.\n\n&lt;a name=\"heading-5.2.1\"&gt;&lt;/a&gt;\n\n#### **5.2.1 `fpgasupdate`**\n\nThe fpgasupdate tool updates the Intel Max10 BMC image and firmware, root entry hash, and FPGA Static Region (SR) and user image (PR). The fpgasupdate will only accept images that have been formatted using PACsign. If a root entry hash has been programmed onto the board, then the image will also need to be signed using the correct keys. Please refer to the OFS Security User Guide for information on created signed images and on programming and managing the root entry hash.\n\nThe Intel FPGA PAC ships with a factory and user programmed image for both the FIM and BMC FW and RTL on all cards.\n\n&lt;a name=\"table-5-1\"&gt;&lt;/a&gt;\n\n#### Table 5-1: `fpgasupdate` Overview\n\n**Synopsis:**\n\n```bash session\nfpgasupdate [--log-level=&lt;level&gt;] file [bdf]\n</code></pre></p> <p>Description: The fpgasupdate command implements a secure firmware update.</p> Command args (optional) Description --log-level  Specifies the <code>log-level</code> which is the level of information output to your command tool. The following seven levels  are available: <code>state</code>, <code>ioctl</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, <code>critical</code>. Setting <code>--log-level=state</code> provides the most verbose output. Setting <code>--log-level=ioctl</code> provides the second most information, and so on. The default level is <code>info</code>. file Specifies the secure update firmware file to be programmed. This file may be to program a static region (SR), programmable region (PR), root entry hash, key cancellation, or other device-specific firmware. bdf The PCIe address of the PAC to program. <code>bdf</code> is of the form <code>[ssss:]bb:dd:f</code>, corresponding to PCIe segment, bus, device, function. The segment is optional. If you do not specify a segment, the segment defaults to <code>0000</code>. If the system has only one PAC you can omit the <code>bdf</code> and let <code>fpgasupdate</code>  determine the address automatically. <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-5-2-fim-version-summary-for-ofs-20223-release","title":"Table 5-2: FIM Version Summary for OFS 2022.3 Release","text":"FIM Version Bitstream ID Pr Interface ID File Name Download Location 1 288511861987640872 d51533ad-aee6-5dab-80fb-a44bbf579b68 d5005_page1_unsigned.bin OFS 2022.3 Release Page"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-5-3-bmc-version-summary-for-ofs-20223-release","title":"Table 5-3: BMC Version Summary for OFS 2022.3 Release","text":"BMC FW and RTL Version File Name Download Location 2.0.13 unsigned_bmc_fw.bin Contact your field representative for access"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#522-fpgainfo","title":"5.2.2 <code>fpgainfo</code>","text":"<p>Synopsis:</p> <p>```bash session    fpgainfo [-h] [-S ] [-B ] [-D ] [-F ] [PCI_ADDR]             {errors,power,temp,fme,port,bmc,mac,phy,security} <pre><code>**Description:**\n Displays FPGA information derived from sysfs files. The command argument is one of the following: errors, power, temp, port, fme, bmc, phy or mac, security. Some commands may also have other arguments or options that control their behavior.\n\nFor systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.\n\n|Command|args (optional)|Description|\n|-------|----------------|-------------|\n| | --help, -h | Prints help information and exits. |\n| | --version, -v | Prints version information and exits. |\n| | -S, --segment | PCIe segment number of resource. |\n| | -B, --bus | PCIe bus number of resource. |\n| | -D, --device | PCIe device number of resource. |\n| | -F, --function | PCIe function number of resource. |\n| errors | {fme, port, all} --clear, -c | First agument to the errors command specifies the resource type to display in human readable format. The second optional argument clears errors for the given FPGA resource. |\n|power|   |Provides total power in watts that the FPGA hardware consumes|\n|temp|   |Provides FPGA temperature values in degrees Celsius|\n|port|   |Provides information about the port|\n|fme|   |Provides information about the FME|\n|bmc|   |Provides BMC sensors information|\n|mac|   |Provides information about MAC ROM connected to FPGA|\n|security|  |Provides information about the security keys, hashes, and flash count, if available.|\n\n*Note: Your Bitstream ID and PR Interface Id may not match the below examples.*\n\nThe following examples walk through sample outputs generated by `fpgainfo`.\n\n```bash session\nsudo fpgainfo fme\n#output\nOpen FPGA Stack Platform\nBoard Management Controller, MAX10 NIOS FW version: 2.0.13\nBoard Management Controller, MAX10 Build version: 2.0.13\n//****** FME ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 288511861987640872\nBitstream Version                : 4.0.1\nPr Interface Id                  : d51533ad-aee6-5dab-80fb-a44bbf579b68\nBoot Page                        : user\n</code></pre> <p>```bash session sudo fpgainfo bmc</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_2","title":"output","text":"<p>Open FPGA Stack Platform Board Management Controller, MAX10 NIOS FW version: 2.0.13 Board Management Controller, MAX10 Build version: 2.0.13 //** BMC SENSORS ****// Object Id                        : 0xF000000 PCIe s:b:d.f                     : 0000:3B:00.0 Vendor Id                        : 0x8086 Device Id                        : 0xBCCE SubVendor Id                     : 0x8086 SubDevice Id                     : 0x138D Socket Id                        : 0x00 Ports Num                        : 01 Bitstream Id                     : 288511861987640872 Bitstream Version                : 4.0.1 Pr Interface Id                  : d51533ad-aee6-5dab-80fb-a44bbf579b68 ( 1) VCCERAM Voltage                                    : 0.90 Volts ( 2) VCCT Temperature                                   : 29.00 Celsius ( 3) 12v Backplane Voltage                              : 12.17 Volts ( 4) VCCERAM Current                                    : 0.18 Amps ( 5) FPGA Transceiver Temperature                       : 36.50 Celsius ( 6) QSFP1 Supply Voltage                               : 0.00 Volts ( 7) 3.3v Temperature                                   : 29.00 Celsius ( 8) 12v Backplane Current                              : 2.28 Amps ( 9) RDIMM3 Temperature                                 : 25.50 Celsius (10) VCCR Voltage                                       : 1.12 Volts (11) Board Inlet Air Temperature                        : 24.50 Celsius (12) 1.8v Temperature                                   : 27.50 Celsius (13) 12v AUX Voltage                                    : 12.14 Volts (14) VCCR Current                                       : 0.55 Amps (15) RDIMM0 Temperature                                 : 24.50 Celsius (16) FPGA Core Voltage                                  : 0.88 Volts (17) VCCERAM Temperature                                : 27.50 Celsius (18) 12v AUX Current                                    : 1.19 Amps (19) QSFP0 Temperature                                  : N/A (20) VCCT Voltage                                       : 1.12 Volts (21) FPGA Core Current                                  : 11.60 Amps (22) FPGA Core Temperature                              : 42.50 Celsius (23) 12v Backplane Temperature                          : 24.00 Celsius (24) VCCT Current                                       : 0.14 Amps (25) RDIMM1 Temperature                                 : 24.00 Celsius (26) 3.3v Voltage                                       : 3.30 Volts (27) VCCR Temperature                                   : 33.50 Celsius (28) 1.8v Voltage                                       : 1.80 Volts (29) 3.3v Current                                       : 0.32 Amps (30) Board Exhaust Air Temperature                      : 26.00 Celsius (31) 12v AUX Temperature                                : 25.00 Celsius (32) QSFP0 Supply Voltage                               : 0.00 Volts (33) QSFP1 Temperature                                  : N/A (34) 1.8v Current                                       : 0.54 Amps (35) RDIMM2 Temperature                                 : 26.00 Celsius <pre><code>&lt;a name=\"heading-5.2.3\"&gt;&lt;/a&gt;\n\n#### **5.2.3 `rsu`**\n\nThe **rsu** performs a **R**emote **S**ystem **U**pdate operation on a device, given its PCIe address. A **rsu** operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either the BMC or FPGA.\n\nThe Intel FPGA PAC contains a region of flash the user may store their FIM image. After an image has been programmed with fpgasupdate the user may choose to perform rsu to update the image on the device.\n\n**Note:** The D5005 platform only supports storing and configuring a single user image from flash for the FPGA. It does not include support for the user1/user2 partitions as shown in other OFS related acceleration boards.\n\n**`rsu` Overview**\n\n**Synopsis**\n\n```bash session\nrsu [-h] [-d] {bmc,bmcimg,retimer,sdm,fpgadefault} [PCIE_ADDR]\n</code></pre></p> <p>```bash session rsu bmc --page=(user) [PCIE_ADDR] rsu retimer [PCIE_ADDR] rsu sdm [PCIE_ADDR] <pre><code>Perform RSU (remote system update) operation on PAC device given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.\n\n*Note: As a result of using the **rsu** command, the host rescans the PCI bus and may assign a different Bus/Device/Function (B/D/F) value than the originally assigned value.*\n\n&lt;a name=\"heading-5.2.4\"&gt;&lt;/a&gt;\n\n#### **5.2.4 `PACsign`**\n\nPACSign is an OPAE utility which allows users to insert authentication markers into bitstreams targeted for the platform. All binary images must be signed using PACSign before fpgasupdate can use them for an update. Assuming no Root Entry Hash (REH) has been programmed on the device, the following examples demonstrate how to prepend the required secure authentication data, and specify which region of flash to update.\nMore information, including charts detailing the different certification types and their required options, are fully described in the PACsign python/pacsign/PACSign.md [OPAE GitHub] on GitHub.\n\n&lt;a name=\"table-5-4\"&gt;&lt;/a&gt;\n\n#### Table 5-4: `PACSign` Overview\n\n**Synopsis:**\n\n```bash session\nPACSign [-h] {FIM,SR,SR_TEST,BBS,BMC,BMC_FW,BMC_FACTORY,AFU,PR,PR_TEST,GBS,FACTORY,PXE,THERM_SR,THERM_PR} ...\n\nPACSign &lt;CMD&gt; [-h] -t {UPDATE,CANCEL,RK_256,RK_384} -H HSM_MANAGER [-C HSM_CONFIG] [-s SLOT_NUM] [-r ROOT_KEY] [-k CODE_SIGNING_KEY] [-d CSK_ID] [-R ROOT_BITSTREAM] [-S] [-i INPUT_FILE] [-o OUTPUT_FILE] [-b BITSTREAM_VERSION] [-y] [-v]\n</code></pre></p> <p>Description: The PACSign utility inserts authentication markers into bitstreams.</p> Command args (optional) Description (required) -t, --cert_type TYPE The following operations are supported: UPDATE, CANCEL, RK_256, RK_348 (required) -H, --HSM_manager MODULE The module name for a module that interfaces to a HSM. PACSign includes both the openssl_manager and pkcs11_manager to handle keys and signing operations. -C, --HSM_config CONFIG The argument to this operation is passed verbatim to the specified HSM. For pkcs11_manager, this option specifies a JSON file describing the PKCS #11 capable HSM\u2019s parameters. -r, --root_key KEY_ID The key identifier that the HSM uses to identify the root key to be used for the selected operation. -k, --code_signing_key KEY_ID The key indentifier that the HSM uses to identify the code signing key to be used for the selected operation -d, --csk_id CSK_NUM Only used for type CANCEL. Specifies the key number of the code signing key to cancel. -s, --slot_num For bitstream types with multiple slots (i.e. multiple ST regions), this option specifies which of the slots to which this bitstream is to be acted upon -b, --bitstream_version VERSION User-formatted version information. This can be any string up to 32 bytes in length. -S, --SHA384 Used to specify that PACSign is to use 384-bit crypto. Default is 256-bit -R, --ROOT_BITSTREAM ROOT_BITSTREAM Valid when verifying bitstreams. The verification step will ensure the generated bitstream is able to be loaded on a board with the specified root entry hash programmed. -i, --input_file FILE Only to be used for UPDATE operations. Specifies the file name containing data to be signed -o, --output_file FILE Specifies the file name for the signed output bitstream. -y, --yes Silently answer all queries from PACSign in the affirmative. -v, --verbose Can be specified multiple times. Increases the verbosity of PACSign. Once enables non-fatal warnings to be displayed. Twice enables progress information. Three or more occurrences enables very verbose debugging information. -h Prints help information and exits {FIM, SR, SR_TEST, BBS, BMC, BMC_FW, BMC_FACTORY, AFU, PR, PR_TEST, GBS, FACTORY, PXE, THERM_SR, THERM_PR} Bitstream type identifier. <p>PACSign can be run on images that have previously been signed. It will overwrite any existing authentication data.</p> <p>Note: For more information on PACSign and on general security practices, please contact your field representative to get access to the OFS Security User Guide.</p> <p>The following example will create an unsigned SR image from an existing signed SR binary update image.</p> <p>```bash session PACSign SR -t UPDATE -s 0 -H openssl_manager -i d5005_page1_unsigned.bin -o new_image.bin</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_3","title":"output","text":"<p>No root key specified.  Generate unsigned bitstream? Y = yes, N = no: y No CSK specified.  Generate unsigned bitstream? Y = yes, N = no: y No root entry hash bitstream specified.  Verification will not be done.  Continue? Y = yes, N = no: y 2022-07-20 10:13:54,954 - PACSign.log - WARNING - Bitstream is already signed - removing signature blocks <pre><code>&lt;a name=\"heading-5.2.5\"&gt;&lt;/a&gt;\n\n#### **5.2.5 `bitstreaminfo`**\n\nDisplays authentication information contained with each provided `file` on the command line. This includes any JSON header strings, authentication header block information, and a small portion  of the payload. The binary is installed by default at `/usr/bin/bitstreaminfo`.&lt;br&gt;\n\n&lt;a name=\"heading-5.2.6\"&gt;&lt;/a&gt;\n\n#### **5.2.6 `hssi`**\n\nThe hssi application provides a means of interacting with the 10G and with the 100G HSSI AFUs. In both 10G and 100G operating modes, the application initializes the AFU, completes the desired transfer as described by the mode-specific options. Only the `hssi_10g` MODE is currently supported. An example of this command's output can be found in section [5.2.9 Running the Host Exerciser Modules](#heading-5.2.9). The binary is installed by default at `/usr/bin/hssi`.&lt;br&gt;\n\n&lt;a name=\"heading-5.2.7\"&gt;&lt;/a&gt;\n\n#### **5.2.7 `opae.io`**\n\nOpae.io is a interactive Python environment packaged on top of libopaevfio.so, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device. opae.io has two operating modes: command line mode and interactive mode. An example of this command's output can be found in section [5.2.9 Running the Host Exerciser Modules](#heading-5.2.9). The binary is installed by default at `/usr/bin/opae.io`.&lt;br&gt;\n\n&lt;a name=\"heading-5.2.8\"&gt;&lt;/a&gt;\n\n#### **5.2.8 `host_exerciser`**\n\nThe host exerciser is used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc. An example of this command's output can be found in section [5.2.9 Running the Host Exerciser Modules](#heading-5.2.9). The binary is installed by default at `/usr/bin/host_exerciser`. For more information refer to - [Host Exerciser](https://opae.github.io/latest/docs/fpga_tools/host_exerciser/host_exerciser.html)&lt;br&gt;\n\n&lt;a name=\"heading-5.2.9\"&gt;&lt;/a&gt;\n\n#### **5.2.9 Running the Host Exerciser Modules**\n\nThe reference FIM and unchanged compilations contain Host Exerciser Modules (HEMs). These are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. \n\n---\n\n**Note:** Before continuing, if huge pages are not set refer to [section 4.2](#step-7)\n\n---\n\nThere are three HEMs present in the OFS FIM - HE-LPBK, HE-HSSI, and HE-MEM. These exercisers are tied to three different VFs that must be enabled before they can be used. The user should enable the VF for each HEM using the below steps:\n\n**1.** Determine the BDF of the Intel\u00ae FPGA PAC D5005 card.\n\nThe PCIe BDF address is initially determined when the server powers on. The user can determine the addresses of all Intel\u00ae FPGA PAC D5005 boards using `lspci`:\n\n```bash session\nlspci -d :bcce\n#output\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n</code></pre></p> <p>Note: Before continuing, if you updated your OFS installation, please also update your PAC FIM to run HEM</p> <p>2. Enable three VFs.</p> <p>In this example, the BDF address is 0000:3b:00.0. With this information the user can now enable three VFs with the following:</p> <p>```bash session sudo pci_device 0000:3b:00.0 vf 3 <pre><code>**3.** Verify that all three VFs have been created.\n\n```bash session\nlspci -s 3b:00\n#output\n3b:00.0 Processing accelerators: Intel Corporation Device bcce (rev 01)\n3b:00.1 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.2 Processing accelerators: Intel Corporation Device bccf (rev 01)\n3b:00.3 Processing accelerators: Intel Corporation Device bccf (rev 01)\n</code></pre></p> <p>4. Bind the 3 VFs to the vfio-pci driver.</p> <p>sudo opae.io init -d PCI_ADDR USER[:GROUP]]</p> <p>```bash session sudo opae.io init -d 0000:3b:00.1 $USER</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_4","title":"output","text":"<p>opae.io 0.2.5 Unbinding (0x8086,0xbccf) at 0000:3b:00.1 from dfl-pci Binding (0x8086,0xbccf) at 0000:3b:00.1 to vfio-pci iommu group for (0x8086,0xbccf) at 0000:3b:00.1 is 142 Assigning /dev/vfio/142 to $USER:$USER Changing permissions for /dev/vfio/142 to rw-rw----</p> <p>sudo opae.io init -d 0000:3b:00.2 $USER</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_5","title":"output","text":"<p>opae.io 0.2.5 Unbinding (0x8086,0xbccf) at 0000:3b:00.2 from dfl-pci Binding (0x8086,0xbccf) at 0000:3b:00.2 to vfio-pci iommu group for (0x8086,0xbccf) at 0000:3b:00.2 is 143 Assigning /dev/vfio/143 to $USER:$USER Changing permissions for /dev/vfio/143 to rw-rw----</p> <p>sudo opae.io init -d 0000:3b:00.3 $USER</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_6","title":"output","text":"<p>opae.io 0.2.5 Unbinding (0x8086,0xbccf) at 0000:3b:00.3 from dfl-pci Binding (0x8086,0xbccf) at 0000:3b:00.3 to vfio-pci iommu group for (0x8086,0xbccf) at 0000:3b:00.3 is 144 Assigning /dev/vfio/144 to $USER:$USER Changing permissions for /dev/vfio/144 to rw-rw---- <pre><code>**5.** Check that the accelerators are present using fpgainfo. *Note your port configuration may differ from the below.*\n\n```bash session\nsudo fpgainfo port\n#output\n//****** PORT ******//\nObject Id                        : 0xF000000\nPCIe s:b:d.f                     : 0000:3B:00.0\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCE\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\n//****** PORT ******//\nObject Id                        : 0x603B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.3\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 823c334c-98bf-11ea-bb37-0242ac130002\n//****** PORT ******//\nObject Id                        : 0x403B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.2\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 8568ab4e-6ba5-4616-bb65-2a578330a8eb\n//****** PORT ******//\nObject Id                        : 0x203B000000000000\nPCIe s:b:d.f                     : 0000:3B:00.1\nVendor Id                        : 0x8086\nDevice Id                        : 0xBCCF\nSubVendor Id                     : 0x8086\nSubDevice Id                     : 0x138D\nSocket Id                        : 0x00\nAccelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n</code></pre></p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#table-5-5-vf-to-hem-mappings","title":"Table 5-5 VF to HEM Mappings","text":"VF BDF HEM BBBB:DD.1 HE-LB BBBB:DD.2 HE-MEM BBBB:DD.3 He-HSSI <p>HE-MEM / HE-LB</p> <p>HE-LB is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth. HE-MEM is used to exercise the DDR interface; data read from the host is written to DDR, and the same data is read from DDR before sending it back to the host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller. Both exercisers rely on the user-space tool <code>host_exerciser</code>. The following commands are supported by the HE-LB/HE-MEM OPAE driver program. They may need to be run using <code>sudo</code> privileges, depending on your server configuration.</p> <p>Basic operations:</p> <p>```bash session sudo host_exerciser lpbk</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_7","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer     Host Exerciser Performance Counter:     Host Exerciser numReads: 1024     Host Exerciser numWrites: 1025     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 5342     Total number of Reads sent: 1024     Total number of Writes sent: 1024     Bandwidth: 3.067 GB/s     Test lpbk(1): PASS</p> <p>sudo host_exerciser --mode lpbk lpbk</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_8","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer     Host Exerciser Performance Counter:     Host Exerciser numReads: 1024     Host Exerciser numWrites: 1025     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 5358     Total number of Reads sent: 1024     Total number of Writes sent: 1024     Bandwidth: 3.058 GB/s     Test lpbk(1): PASS</p> <p>sudo host_exerciser --mode write lpbk</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_9","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer     Host Exerciser Performance Counter:     Host Exerciser numReads: 0     Host Exerciser numWrites: 1025     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 2592     Total number of Reads sent: 0     Total number of Writes sent: 1024     Bandwidth: 6.321 GB/s     Test lpbk(1): PASS</p> <p>sudo host_exerciser --mode trput lpbk</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_10","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer     Host Exerciser Performance Counter:     Host Exerciser numReads: 512     Host Exerciser numWrites: 513     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 3384     Total number of Reads sent: 512     Total number of Writes sent: 512     Bandwidth: 4.842 GB/s     Test lpbk(1): PASS</p> <pre><code>Number of cachelines per request 1, 2, and 4. The user may replace `--mode lpbk` with `read, write, trput`. The target `lpbk` can be replaced with `mem`:\n\n```bash session\nsudo host_exerciser --mode lpbk --cls cl_1 lpbk\n#output\n    starting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\n    Host Exerciser numWrites: 1025\n    Host Exerciser numPendReads: 0\n    Host Exerciser numPendWrites: 0\n    Host Exerciser numPendEmifReads: 0\n    Host Exerciser numPendEmifWrites: 0\n    Number of clocks: 5475\n    Total number of Reads sent: 1024\n    Total number of Writes sent: 1024\n    Bandwidth: 2.993 GB/s\n    Test lpbk(1): PASS\n\nsudo host_exerciser --mode lpbk --cls cl_2 lpbk\n#output\n    starting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\n    Host Exerciser numWrites: 1025\n    Host Exerciser numPendReads: 0\n    Host Exerciser numPendWrites: 0\n    Host Exerciser numPendEmifReads: 0\n    Host Exerciser numPendEmifWrites: 0\n    Number of clocks: 5356\n    Total number of Reads sent: 1024\n    Total number of Writes sent: 1024\n    Bandwidth: 3.059 GB/s\n    Test lpbk(1): PASS\n\nsudo host_exerciser --mode lpbk --cls cl_4 lpbk\n#output\n    starting test run, count of 1\nAPI version: 1\nAFU clock: 250 MHz\nAllocate SRC Buffer\nAllocate DST Buffer\nAllocate DSM Buffer\n    Host Exerciser Performance Counter:\n    Host Exerciser numReads: 1024\n    Host Exerciser numWrites: 1025\n    Host Exerciser numPendReads: 0\n    Host Exerciser numPendWrites: 0\n    Host Exerciser numPendEmifReads: 0\n    Host Exerciser numPendEmifWrites: 0\n    Number of clocks: 4481\n    Total number of Reads sent: 1024\n    Total number of Writes sent: 1024\n    Bandwidth: 3.656 GB/s\n    Test lpbk(1): PASS\n</code></pre> <p>Interrupt tests (only valid for mode <code>mem</code>):</p> <p>```bash session sudo host_exerciser --interrupt 0 mem</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_11","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer Using Interrupts     Host Exerciser Performance Counter:     Host Exerciser numReads: 1024     Host Exerciser numWrites: 1026     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 5140     Total number of Reads sent: 1024     Total number of Writes sent: 1024     Bandwidth: 3.188 GB/s     Test mem(1): PASS</p> <p>sudo host_exerciser --interrupt 1 mem</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_12","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer Using Interrupts     Host Exerciser Performance Counter:     Host Exerciser numReads: 1024     Host Exerciser numWrites: 1026     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 5079     Total number of Reads sent: 1024     Total number of Writes sent: 1024     Bandwidth: 3.226 GB/s     Test mem(1): PASS</p> <p>sudo host_exerciser --interrupt 2 mem</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_13","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer Using Interrupts     Host Exerciser Performance Counter:     Host Exerciser numReads: 1024     Host Exerciser numWrites: 1026     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 5525     Total number of Reads sent: 1024     Total number of Writes sent: 1024     Bandwidth: 3.439 GB/s     Test mem(1): PASS</p> <p>sudo host_exerciser --interrupt 3 mem</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_14","title":"output","text":"<pre><code>starting test run, count of 1\n</code></pre> <p>API version: 1 AFU clock: 250 MHz Allocate SRC Buffer Allocate DST Buffer Allocate DSM Buffer Using Interrupts     Host Exerciser Performance Counter:     Host Exerciser numReads: 1024     Host Exerciser numWrites: 1026     Host Exerciser numPendReads: 0     Host Exerciser numPendWrites: 0     Host Exerciser numPendEmifReads: 0     Host Exerciser numPendEmifWrites: 0     Number of clocks: 4735     Total number of Reads sent: 1024     Total number of Writes sent: 1024     Bandwidth: 3.460 GB/s     Test mem(1): PASS</p> <pre><code>**HE-HSSI**\n\nHE-HSSI is responsible for handling client-side ethernet traffic. It wraps the 10G ethernet AFU and includes a 10G traffic generator and checker. The user-space tool `hssi` exports a control interface to the HE-HSSI's AFU's packet generator logic. Context sensitive information is given by the `hssi --help` command. Help for the 10G specific test is given by `hssi hssi_10g --help` Example useage:\n\n```bash session\nsudo hssi --pci-address 3b:00.3 hssi_10g --eth-ifc s10hssi0 --eth-loopback on --he-loopback=off  --num-packets 100\n#output\n10G loopback test\n  port: 0\n  eth_loopback: on\n  he_loopback: off\n  num_packets: 100\n  packet_length: 64\n  src_address: 11:22:33:44:55:66\n    (bits):  0x665544332211\n  dest_address: 77:88:99:aa:bb:cc\n    (bits): 0xccbbaa998877\n  random_length: fixed\n  random_payload: incremental\n  rnd_seed0: 5eed0000\n  rnd_seed1: 5eed0001\n  rnd_seed2: 25eed\n  eth: s10hssi0\n</code></pre> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#60-compiling-ofs-fim","title":"6.0 Compiling OFS FIM","text":"<p>Pre-Compiled FIM binaries are at OFS 2022.3 release page and to compile the OFS FIM for Intel\u00ae FPGA PAC D5005 follow the below steps :</p> <p>1) Compile OFS FIM manually - Steps are provided in the developer guide to compile FIM and generate binaries. Refer to Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae.</p> <p>2) Compile OFS FIM using evaluation script - The script guides you to the steps required for compilation via selecting options from the menu. Refer to evaluation script</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#70-programming-the-ofs-fim-and-bmc","title":"7.0 Programming the OFS FIM and BMC","text":"<p>Instructions surrounding the compilation and simulation of the OFS FIM have fully moved into the Intel\u00ae FPGA Interface Manager Developer Guide: Open Stack for Intel\u00ae Stratix 10\u00ae.</p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#71-programming-the-ofs-fim","title":"7.1 Programming the OFS FIM","text":"<p>In order to program the OFS FIM, both the OPAE SDK and DFL drivers need to be installed on the host system. Please complete the steps in sections 4.0 OFS DFL Kernel Drivers and 5.0 OPAE Software Development Kit. The OFS FIM version can be identified using the OPAE tool <code>fpgainfo</code>. A sample output of this command is included below.</p> <p>```bash session sudo fpgainfo fme</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_15","title":"output","text":"<p>Intel FPGA Programmable Acceleration Card D5005 Board Management Controller, MAX10 NIOS FW version: 2.0.13 Board Management Controller, MAX10 Build version: 2.0.13 //** FME ****// Object Id                        : 0xF000000 PCIe s:b:d.f                     : 0000:3B:00.0 Vendor Id                        : 0x8086 Device Id                        : 0xBCCE SubVendor Id                     : 0x8086 SubDevice Id                     : 0x138D Socket Id                        : 0x00 Ports Num                        : 01 Bitstream Id                     : 288511861987640872 Bitstream Version                : 4.0.1 Pr Interface Id                  : d51533ad-aee6-5dab-80fb-a44bbf579b68 Boot Page                        : user <pre><code>Use the value under `PR Interface ID` to identify that FIM that has been loaded. Refer to the table below for a list of previous FIM releases.\n Please \n&lt;a name=\"table-7-1\"&gt;&lt;/a&gt;\n\n#### Table 7-1 Previous FIM Releases\n\n| PR Release | PR Interface ID |\n|---------|---------|\n| 2022.2 (tag 1.3.0)                         | bf531bcf-a896-5171-ab31-601a4ab754b6                    |\n| 2022.1 Beta (tag: 1.2.0-beta)              | 2fae83fc-8568-53aa-9157-8f75e9c0ba92                   |\n| OFS 2.1 Beta (tag: 1.1.0-beta)             | 99160d37e42a 3f8b586f-c275-594c-92e2-d9f2c23e94d1                    |\n| OFS 1.0 (tag: ofs-1.0.0)                   | b5f6a71e-daec-59c3-a43a-85567b51fd3f |\n| Intel Acceleration Stack for Intel\u00ae FPGA PAC D5005 2.0.1 | 9346116d-a52d-5ca8-b06a-a9a389ef7c8d |\n\nThe Beta release of the OFS software depends on the corresponding Beta release of the FIM. If the user's card does not report a PR Interface ID which matches the above table, then a new FIM will need to be programmed.\n\n&lt;a name=\"heading-7.1.1\"&gt;&lt;/a&gt;\n\n#### **7.1.1 Programming the FIM**\n\n**1.** Download the file **d5005_page1_unsigned.bin** from [OFS 2022.3 release page](https://github.com/OFS/ofs-d5005/releases/tag/ofs-d5005-1.0.1).\n\n**2.** Run `PACSign` to create an unsigned image with added header for use by fpgasupdate\n\n```bash session\nPACSign SR -y -v -t UPDATE -s 0 -H openssl_manager -i d5005_page1_unsigned.bin -o d5005_PACsigned_unsigned.bin\n</code></pre></p> <p>3. Run <code>fpgasupdate</code> to load the image into the user location of the Intel\u00ae FPGA PAC D5005 FPGA flash, NOTE: use \"sudo fpgainfo fme\" command to find the PCIe address for your card.</p> <p>```bash session sudo fpgasupdate d5005_PACsigned_unsigned.bin 3B:00.0 <pre><code>**4.** Run `RSU` command, and after powercycle your host.\n\n```bash session\nsudo rsu bmcimg 0000:3B:00.0\n</code></pre></p> <p></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#72-programming-the-bmc","title":"7.2 Programming the BMC","text":"<p>1. Download intel-fpga-bmc images(To download OFS Stratix 10 BMC binaries contact Intel Technical Sales Representative)</p> <p>2. The file <code>unsigned_bmc_fw.bin</code> has the newly binary format. This bitstream is programmed with remote system update (RSU) and the bitstream must be signed with PACSign tool to generate.</p> <p>3. Run <code>PACSign</code> to create an unsigned image with added header for use by fpgasupdate</p> <p>```bash session PACSign BMC -y -v -t UPDATE -s 0 -H openssl_manager -i unsigned_bmc_fw.bin -o PACsigned_unsigned_bmc_fw.bin</p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#output_16","title":"output","text":"<p>2022-04-22 03:07:05,626 - PACSign.log - INFO - OpenSSL version \"OpenSSL 1.1.1k  FIPS 25 Mar 2021\" matches \"1.1.1\" 2022-04-22 03:07:05,648 - PACSign.log - INFO - Bitstream not previously signed 2022-04-22 03:07:05,648 - PACSign.log - INFO - platform value is '688128' 2022-04-22 03:07:05,745 - PACSign.log - INFO - Starting Block 0 creation 2022-04-22 03:07:05,745 - PACSign.log - INFO - Calculating SHA256 2022-04-22 03:07:05,747 - PACSign.log - INFO - Calculating SHA384 2022-04-22 03:07:05,749 - PACSign.log - INFO - Done with Block 0 2022-04-22 03:07:05,749 - PACSign.log - INFO - Starting Root Entry creation 2022-04-22 03:07:05,749 - PACSign.log - INFO - Calculating Root Entry SHA 2022-04-22 03:07:05,749 - PACSign.log - INFO - Starting Code Signing Key Entry creation 2022-04-22 03:07:05,749 - PACSign.log - INFO - Calculating Code Signing Key Entry SHA 2022-04-22 03:07:05,749 - PACSign.log - INFO - Code Signing Key Entry done 2022-04-22 03:07:05,749 - PACSign.log - INFO - Starting Block 0 Entry creation 2022-04-22 03:07:05,749 - PACSign.log - INFO - Calculating Block 0 Entry SHA 2022-04-22 03:07:05,749 - PACSign.log - INFO - Block 0 Entry done 2022-04-22 03:07:05,749 - PACSign.log - INFO - Starting Block 1 creation 2022-04-22 03:07:05,750 - PACSign.log - INFO - Block 1 done 2022-04-22 03:07:05,757 - PACSign.log - INFO - Writing blocks to file 2022-04-22 03:07:05,758 - PACSign.log - INFO - Processing of file 'PACsigned_unsigned_bmc_fw.bin' complete <pre><code>**4.** Run `fpgasupdate` to perform an upgrade of the BMC.\n\n```bash session\nsudo fpgasupdate PACsigned_unsigned_bmc_fw.bin 3B:00.0\n#output\n[2022-04-22 03:08:34.15] [WARNING ] Update starting. Please do not interrupt.\n[2022-04-22 03:08:34.15] [INFO    ] updating from file pacsign_unsigned_bmc_fw.bin with size 819968\n[2022-04-22 03:08:34.15] [INFO    ] waiting for idle\n[2022-04-22 03:08:34.15] [INFO    ] preparing image file\n[2022-04-22 03:09:02.18] [INFO    ] writing image file\n(100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] [819968/819968 bytes][Elapsed Time: 0:00:13.01]\n[2022-04-22 03:09:15.20] [INFO    ] programming image file\n(100%) [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588][Elapsed Time: 0:00:29.03]\n[2022-04-22 03:09:44.24] [INFO    ] update of 0000:3B:00.0 complete\n[2022-04-22 03:09:44.24] [INFO    ] Secure update OK\n[2022-04-22 03:09:44.24] [INFO    ] Total time: 0:01:10.08\n</code></pre></p>"},{"location":"hw/d5005/user_guides/ug_qs_ofs_d5005/ug_qs_ofs_d5005/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others.   </p> <p>example AFUs</p>"},{"location":"hw/doc_modules/Glossary/","title":"Glossary","text":"Term Abbreviation Description Open FPGA Stack OFS A modular collection of hardware platform components, open source software, and broad ecosystem support that provides a standard and scalable model for AFU and software developers to optimize and reuse their designs. Accelerator Functional Unit AFU Hardware Accelerator implemented in FPGA logic which offloads a computational operation for an application from the CPU to improve performance.  Note: An AFU region is the part of the design where an AFU may reside.  This AFU may or may not be a partial reconfiguration region. Board Management Controller BMC Supports features such as power sequence management and board monitoring through on-board sensors. FPGA Interface Manager FIM Provides platform management, functionality, clocks, resets and standard interfaces to host and AFUs.  The FIM resides in the static region of the FPGA and contains the FPGA Management Engine (FME) and I/O ring. Platform Interface Manager PIM An interface manager that comprises two components: a configurable platform specific interface for board developers and a collection of shims that AFU developers can use to handle clock crossing, response sorting, buffering and different protocols. Intel Virtualization Technology for Directed I/O Intel VT-d Extension of the VT-x and VT-I processor virtualization technologies which adds new support for I/O device virtualization. Single-Root Input-Output Virtualization SR-IOV Allows the isolation of PCI Express resources for manageability and performance. Host Exerciser Module HEM Host exercisers are used to exercise and characterize the various host-FPGA interactions, including Memory Mapped Input/Output (MMIO), data transfer from host to FPGA, PR, host to FPGA memory, etc. Device Feature List DFL A concept inherited from OFS. The DFL drivers provide support for FPGA devices that are designed to support the Device Feature List. The DFL, which is implemented in RTL, consists of a self-describing data structure in PCI BAR space that allows the DFL driver to automatically load the drivers required for a given FPGA configuration. (link) Best Known Configuration BKC The exact hardware configuration Intel has optimized and validated the solution against. Open Programmable Acceleration Engine OPAE The OPAE SDK is a software framework for managing and accessing programmable accelerators (FPGAs). It consists of a collection of libraries and tools to facilitate the development of software applications and accelerators. The OPAE SDK resides exclusively in user-space. Memory Mapped Input/Output MMIO Users may map and access both control registers and system memory buffers with accelerators. FPGA Management Engine FME Performs reconfiguration and other infrastructure functions. Each FPGA device only has one FME. Input/Output Control IOCTL System calls used to manipulate underlying device parameters of special files. Virtual Function Input/Output VFIO An IOMMU/device agnostic framework for exposing direct device access to userspace. (link) Configuration and Status Register CSR Communication with the AFU is achieved by reading/writing CSRs and reading/writing shared memory buffers. Port N/A Represents the interface between the static FPGA fabric and a PR region containing an AFU. Advanced Error Reporting AER The PCIe AER driver is the extended PCI Express error reporting capability providing more robust error reporting. (link)"},{"location":"hw/doc_modules/Notices_%26_Disclaimers/","title":"Notices & Disclaimers","text":""},{"location":"hw/doc_modules/Notices_%26_Disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Intel\u00ae technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Intel Corporation.  Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.  Other names and brands may be claimed as the property of others. </p>"},{"location":"sw/build_chain/fpga_api/api_build/","title":"Building OPAE SDK Artifacts","text":""},{"location":"sw/build_chain/fpga_api/api_build/#steps","title":"Steps","text":"<ol> <li>Fetch the OPAE SDK source tree</li> <li>Configure the OPAE SDK CMake project</li> <li>Build OPAE SDK targets</li> </ol> <p>The example below lists commands that can be used to fetch and build OPAE SDK.</p> <pre><code># fetch the source\ngit clone https://github.com/OPAE/opae-sdk.git\ncd opae-sdk\n# configure CMake\ncmake ..\n# build\nmake\n</code></pre> <p>For a list of targets that can be built, type <code>make help</code> from the build directory.</p> <p>CMake options that may be set during the configuration include the following:</p> <pre><code>|----------------------------|-----------------------|-------------------------------------|---------------------------------------|----------------|\n| cmake flag                 | Optional or Mandatory | Purpose                             | Valid values                          | Default value  |\n|----------------------------|-----------------------|-------------------------------------|---------------------------------------|----------------|\n| -DCMAKE_BUILD_TYPE         | Optional              | Set compiler flags                  | Debug/Release/Coverage/RelWithDebInfo | RelWithDebInfo |\n| -DOPAE_BUILD_LEGACY        | Optional              | Enable/disable opae-legacy.git      | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_SPHINX_DOC    | Optional              | Enable/disable documentation build  | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_TESTS         | Optional              | Enable/disable building unit tests  | ON/OFF                                | OFF            |\n| -DOPAE_INSTALL_RPATH       | Optional              | Enable/disable rpath for install    | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_LIBOPAE_CXX   | Optional              | Enable/disable OPAE C++ bindings    | ON/OFF                                | ON             | \n| -DOPAE_WITH_PYBIND11       | Optional              | Enable/disable pybind11 binaries    | ON/OFF                                | ON             |\n| -DOPAE_BUILD_PYTHON_DIST   | Optional              | Enable/disable Python Distribution  | ON/OFF                                | OFF            |\n| -DOPAE_ENABLE_MOCK         | Optional              | Enable/disable mocks for unit tests | ON/OFF                                | OFF            |\n| -DOPAE_BUILD_SIM           | Optional              | Enable/disable opae-sim.git         | ON/OFF                                | OFF            |\n</code></pre>"},{"location":"sw/build_chain/fpga_driver/driver_build/","title":"Building the OPAE Intel FPGA driver (out-of-tree)","text":"<p>The Intel FPGA driver included with OPAE SDK releases is packaged as an RPM or DEB package as well as a source tarball. Starting with OPAE SDK release of 1.4, the driver can be built from source out-of-tree but requires the following packages:</p> <p>For RPM package managers (Red Hat, CentOS, Fedora, etc.) * kernel-headers * kernel-devel * gcc * make</p> <p>For DEB package managers (Debian, Ubuntu, etc.) * kernel-headers-generic * gcc * make</p> <p>After installation of necessary distribution packages, follow the steps in the example below to build the Intel Kernel driver. NOTE The example below references Intel FPGA Kernel driver version 2.0.2. but can be applied to later versions.</p> <pre><code>tar zxf opae-intel-fpga-driver-2.0.2-1.tar.gz\ncd opae-intel-fpga-driver-2.0.2\nmake\n</code></pre>"},{"location":"sw/drv_arch/drv_arch/","title":"Open Programmable Accelerator Engine (OPAE) Linux Device Driver Architecture","text":"<pre><code>.. toctree::\n.. highlight:: c\n.. highlight:: sh\n.. highlight:: console\n</code></pre> <p>The OPAE FPGA Linux Device Driver provides interfaces for user-space applications to configure, enumerate, open, and access FPGA accelerators on platforms equipped with Intel FPGA solutions. The OPAE FPGA driver also enables system-level management functions such as FPGA reconfiguration and virtualization.</p>"},{"location":"sw/drv_arch/drv_arch/#hardware-architecture","title":"Hardware Architecture","text":"<p>The Linux Operating System treats the FPGA hardware as a PCIe* device. A predefined data structure, Device Feature List (DFL), allows for dynamic feature discovery in an Intel FPGA solution.</p> <p></p> <p>The Linux Device Driver implements PCIe Single Root I/O Virtualization (SR-IOV) for the creation of Virtual Functions (VFs). The device driver can release individual accelerators for assignment to virtual machines (VMs).</p> <p></p>"},{"location":"sw/drv_arch/drv_arch/#fpga-management-engine-fme","title":"FPGA Management Engine (FME)","text":"<p>The FPGA Management Engine provides error reporting, reconfiguration, performance reporting, and other infrastructure functions. Each FPGA has one FME which is always accessed through the Physical Function (PF). The Intel Xeon\u00ae Processor with Integrated FPGA also performs power and thermal management. These functions are not available on the Intel Programmable Acceleration Card (PAC).</p> <p>User-space applications can acquire exclusive access to the FME using <code>open()</code>, and release it using <code>close()</code>. Device access may be managed by standard Linux interfaces and tools.</p> <p>.. Note::</p> <pre><code>    If an application terminates without freeing the FME or Port resources, Linux closes all\n    file descriptors owned by the terminating process, freeing those resources.\n</code></pre>"},{"location":"sw/drv_arch/drv_arch/#port","title":"Port","text":"<p>A Port represents the interface between two components: * The FPGA Interface Manager (FIM) which is part of the static FPGA fabric * The Accelerator Function Unit (AFU) which is the partially reconfigurable region</p> <p>The Port controls the communication from software to the AFU and makes features such as reset and debug available.</p>"},{"location":"sw/drv_arch/drv_arch/#accelerator-function-unit-afu","title":"Accelerator Function Unit (AFU)","text":"<p>An AFU attaches to a Port. The AFU provides a 256 KB memory mapped I/O (MMIO) region for accelerator-specific control registers.</p> <ul> <li>Use <code>open()</code> on the Port device to acquire access to an AFU associated with the Port device.</li> <li>Use <code>close()</code>on the Port device to release the AFU associated with the Port device.</li> <li>Use <code>mmap()</code> on the Port device to map accelerator MMIO regions.</li> </ul>"},{"location":"sw/drv_arch/drv_arch/#partial-reconfiguration-pr","title":"Partial Reconfiguration (PR)","text":"<p>Use PR to reconfigure an AFU from a bitstream file. Successful reconfiguration has the following requirement:</p> <ul> <li>You must generate the reconfiguration AFU for the exact FIM. The AFU and FIM are compatible if their interface IDs match. You can verify this match by comparing the interface ID in the bitstream header against the interface ID that is exported by the driver in sysfs.</li> </ul> <p>In all other cases PR fails and may cause system instability.</p> <p>.. note::</p> <pre><code>    Platforms that support 512-bit Partial Reconfiguration require\n    binutils &gt;= version 2.25.\n</code></pre> <p>Close any software programs accessing the FPGA, including those running in a virtualized host before initiating PR. For virtualized environments, the recommended sequence is as follows:</p> <ol> <li>Unload the driver from the guest</li> <li>Release the VF from the guest</li> </ol> <p>.. note::</p> <p><pre><code>    NOTE: Releasing the VF from the guest while an application on the guest is\n    still accessing its resources may lead to VM instabilities. We recommend\n    closing all applications accessing the VF in the guest before releasing the\n    VF.\n</code></pre> 3. Disable SR-IOV 4. Perform PR 5. Enable SR-IOV 6. Assign the VF to the guest 7. Load the driver in the guest</p>"},{"location":"sw/drv_arch/drv_arch/#fpga-virtualization","title":"FPGA Virtualization","text":"<p>To enable accelerator access from applications running on a VM, create a VF for the port using the following process:</p> <ol> <li> <p>Release the Port from the PF using the associated ioctl on the FME device.</p> </li> <li> <p>Use the following command to enable SR-IOV and VFs. Each VF can own a single Port with an AFU. In the following command, N is the number of Port released from the PF.</p> </li> </ol> <p><pre><code>    echo N &gt; $PCI_DEVICE_PATH/sriov_numvfs\n</code></pre> .. note::</p> <pre><code>    NOTE: The number, 'N', cannot be greater than the number of supported VFs.\n    This can be read from $PCI_DEVICE_PATH/sriov_totalvfs.\n</code></pre> <ol> <li> <p>Pass the VFs through to VMs using hypervisor interfaces.</p> </li> <li> <p>Access the AFU on a VF from applications running on the VM using the same driver inside the VM.</p> </li> </ol> <p>.. Note::</p> <p>`` Creating VFs is only supported for port devices. Consequently, PR and other management functions are only available through the PF. ```</p>"},{"location":"sw/drv_arch/drv_arch/#driver-organization","title":"Driver Organization","text":""},{"location":"sw/drv_arch/drv_arch/#pcie-module-device-driver","title":"PCIe Module Device Driver","text":"<p>!## Driver Organization ##</p>"},{"location":"sw/drv_arch/drv_arch/#pcie-module-device-driver_1","title":"PCIe Module Device Driver","text":"<p>FPGA devices appear as a PCIe devices. Once enumeration detects a PCIe PF or VF, the Linux OS loads the FPGA PCIe device driver. The device driver performs the following functions:</p> <ol> <li>Walks through the Device Feature List in PCIe device base address register (BAR) memory to discover features and their sub-features and creates necessary platform devices.</li> <li>Enables SR-IOV.</li> <li>Introduces the feature device infrastructure, which abstracts operations for sub-features and provides common functions to feature device drivers.</li> </ol>"},{"location":"sw/drv_arch/drv_arch/#pcie-module-device-driver-functions","title":"PCIe Module Device Driver Functions","text":"<p>The PCIe Module Device Driver performs the following functions:</p> <ol> <li>PCIe discovery, device enumeration, and feature discovery.</li> <li>Creates sysfs directories for the device, FME, and Port.</li> <li>Creates the platform driver instances, causing the Linux kernel to load their respective drivers.</li> </ol>"},{"location":"sw/drv_arch/drv_arch/#fme-platform-module-device-driver","title":"FME Platform Module Device Driver","text":"<p>The FME Platform Module Device Driver loads automatically after the PCIe driver creates the FME Platform Module. It provides the following features for FPGA management:</p> <ol> <li> <p>Power and thermal management, error reporting, performance reporting, and other infrastructure functions. You can access these functions via sysfs interfaces the FME driver provides.</p> </li> <li> <p>Partial Reconfiguration. During PR sub-feature initialization, the FME driver registers the FPGA Manager framework to support PR. When the FME receives the relevant ioctl request from user-space, it invokes the common interface function from the FPGA Manager to reconfigure the AFU using PR.</p> </li> <li> <p>Port management for virtualization (releasing/assigning port device).</p> </li> </ol> <p>After a port device is released, you can use the PCIe driver SR-IOV interfaces to create/destroy VFs.</p> <p>For more information, refer to \"FPGA Virtualization\".</p>"},{"location":"sw/drv_arch/drv_arch/#fme-platform-module-device-driver-functions","title":"FME Platform Module Device Driver Functions","text":"<p>The FME Platform Module Device Driver performs the the following functions:</p> <ul> <li>Creates the FME character device node.</li> <li>Creates the FME sysfs files and implements the FME sysfs file accessors.</li> <li>Implements the FME private feature sub-drivers.</li> <li>FME private feature sub-drivers:<ul> <li>FME Header</li> <li>Partial Reconfiguration</li> <li>Global Error</li> <li>Global Performance</li> </ul> </li> </ul>"},{"location":"sw/drv_arch/drv_arch/#port-platform-module-device-driver","title":"Port Platform Module Device Driver","text":"<p>After the PCIe Module Device Driver creates the Port Platform Module device, the FPGA Port and AFU driver are loaded.  This module provides an interface for user-space applications to access the individual accelerators, including basic reset control on the Port, AFU MMIO region export, DMA buffer mapping service, and remote debug functions.</p>"},{"location":"sw/drv_arch/drv_arch/#port-platform-module-device-driver-functions","title":"Port Platform Module Device Driver Functions","text":"<p>The Port Platform Module Device Driver performs the the following functions:</p> <ul> <li>Creates the Port character device node.</li> <li>Creates the Port sysfs files and implements the Port sysfs file accessors.</li> <li>Implements the following Port private feature sub-drivers.<ul> <li>Port Header</li> <li>AFU</li> <li>Port Error</li> <li>Signal Tap</li> </ul> </li> </ul>"},{"location":"sw/drv_arch/drv_arch/#opae-fpga-driver-interface","title":"OPAE FPGA Driver Interface","text":"<p>The user-space interface consists of a sysfs hierarchy and ioctl requests. Most kernel attributes can be accessed/modified via sysfs nodes in this hierarchy. More complex I/O operations are controlled via ioctl requests. The OPAE API implementation, libopae-c, has been designed to use this interface to interact with the OPAE FPGA kernel drivers.</p>"},{"location":"sw/fpga_api/plug_guide/readme/","title":"Plugin Developer's Guide","text":"<pre><code>.. toctree::\n</code></pre>"},{"location":"sw/fpga_api/plug_guide/readme/#overview","title":"Overview","text":"<p>Beginning with OPAE C library version 1.2.0, OPAE implements a plugin-centric model. This guide serves as a reference to define the makeup of an OPAE C API plugin and to describe a sequence of steps that one may follow when constructing an OPAE C API plugin.</p>"},{"location":"sw/fpga_api/plug_guide/readme/#plugin-required-functions","title":"Plugin Required Functions","text":"<p>An OPAE C API plugin is a runtime-loadable shared object library, also known as a module. On Linux systems, the dl family of APIs from libdl are used to interact with shared objects. Refer to \"man dlopen\" and \"man dlsym\" for examples of using the libdl API.</p> <p>An OPAE C API plugin implements one required function. This function is required to have C linkage, so that its name is not mangled.</p> <pre><code>    int opae_plugin_configure(opae_api_adapter_table *table, const char *config);\n</code></pre> <p>During initialization, the OPAE plugin manager component loads each plugin, searching for its <code>opae_plugin_configure</code> function. If none is found, then the plugin manager rejects that plugin. When it is found, <code>opae_plugin_configure</code> is called passing a pointer to a freshly-created <code>opae_api_adapter_table</code> and a buffer consisting of configuration data for the plugin.</p> <p>The job of the <code>opae_plugin_configure</code> function is to populate the given adapter table with each of the plugin's API entry points and to consume and comprehend the given configuration data in preparation for initialization.</p>"},{"location":"sw/fpga_api/plug_guide/readme/#opae-api-adapter-table","title":"OPAE API Adapter Table","text":"<p>The adapter table is a data structure that contains function pointer entry points for each of the OPAE APIs implemented by a plugin. In this way, it adapts the plugin-specific behavior to the more general case of a flat C API. Note that OPAE applications are only required to link with opae-c. In other words, the name of the plugin library should not appear on the linker command line. In this way, plugins are truly decoupled from the OPAE C API, and they are required to adapt to the strict API specification by populating the adapter table only. No other linkage is required nor recommended.</p> <p><code>adapter.h</code> contains the definition of the <code>opae_api_adapter_table</code>. An abbreviated version is depicted below, along with supporting type <code>opae_plugin</code>:</p> <pre><code>    typedef struct _opae_plugin {\nchar *path;\nvoid *dl_handle;\n} opae_plugin;\ntypedef struct _opae_api_adapter_table {\nstruct _opae_api_adapater_table *next;\nopae_plugin plugin;\nfpga_result (*fpgaOpen)(fpga_token token, fpga_handle *handle,\nint flags);\nfpga_result (*fpgaClose)(fpga_handle handle);\n...\nfpga_result (*fpgaEnumerate)(const fpga_properties *filters,\nuint32_t num_filters, fpga_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n...\n// configuration functions\nint (*initialize)(void);\nint (*finalize)(void);\n// first-level query\nbool (*supports_device)(const char *device_type);\nbool (*supports_host)(const char *hostname);\n} opae_api_adapter_table;\n</code></pre> <p>Some points worth noting are that the adapter tables are organized in memory by adding them to a linked list data structure. This is the use of the <code>next</code> structure member. (The list management is handled by the plugin manager.) The <code>plugin</code> structure member contains the handle to the shared object instance, as created by <code>dlopen</code>. This handle is used in the plugin's <code>opae_plugin_configure</code> to load plugin entry points. A plugin need only implement the portion of the OPAE C API that a target application needs. Any API entry points that are not supported should be left as NULL pointers (the default) in the adapter table. When an OPAE API that has no associated entry point in the adapter table is called, the result for objects associated with that plugin will be <code>FPGA_NOT_SUPPORTED</code>.</p> <p>The following code illustrates a portion of the <code>opae_plugin_configure</code> for a theoretical OPAE C API plugin libfoo.so:</p> <pre><code>    /* foo_plugin.c */\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\nadapter-&gt;fpgaOpen = dlsym(adapter-&gt;plugin.dl_handle, \"foo_fpgaOpen\");\nadapter-&gt;fpgaClose =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_fpgaClose\");\n...\nadapter-&gt;fpgaEnumerate =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_fpgaEnumerate\");\n...\nreturn 0;\n}\n</code></pre> <p>Notice that the implementations of the API entry points for plugin libfoo.so are prefixed with <code>foo_</code>. This is the recommended practice to avoid name collisions and to enhance the debugability of the application. Upon successful configuration, <code>opae_plugin_configure</code> returns 0 to indicate success. A non-zero return value indicates failure and causes the plugin manager to reject the plugin from futher consideration.</p>"},{"location":"sw/fpga_api/plug_guide/readme/#plugin-optional-functions","title":"Plugin Optional Functions","text":"<p>Once the plugin manager loads and configures each plugin, it uses the adapter table to call back into the plugin so that it can be made ready for runtime. This is the job of the <code>opae_plugin_initialize</code> entry point, whose signature is defined as:</p> <pre><code>    int opae_plugin_initialize(void);\n</code></pre> <p>The function takes no parameters, as the configuration data was already given to the plugin by <code>opae_plugin_configure</code>. <code>opae_plugin_initialize</code> returns 0 if no errors were encountered during initialization. A non-zero return code indicates that plugin initialization failed. A plugin makes its <code>opae_plugin_initialize</code> available to the plugin manager by populating the adapter table's <code>initialize</code> entry point as shown:</p> <pre><code>    /* foo_plugin.c */\nint foo_plugin_initialize(void)\n{\n...\nreturn 0; /* success */\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;initialize =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_initialize\");\n...\nreturn 0;\n}\n</code></pre> <p>If a plugin does not implement an <code>opae_plugin_initialize</code> entry point, then the <code>initialize</code> member of the adapter table should be left uninitialized. During plugin initialization, if a plugin has no <code>opae_plugin_initialize</code> entry in its adapter table, the plugin initialization step will be skipped, and the plugin will be considered to have initialized successfully.</p> <p>Once plugin initialization is complete for all loaded plugins, the system is considered to be running and fully functional.</p> <p>During teardown, the plugin manager uses the adapter table to call into each plugin's <code>opae_plugin_finalize</code> entry point, whose signature is defined as:</p> <pre><code>    int opae_plugin_finalize(void);\n</code></pre> <p><code>opae_plugin_finalize</code> returns 0 if no errors were encountered during teardown. A non-zero return code indicates that plugin teardown failed. A plugin makes its <code>opae_plugin_finalize</code> available to the plugin manager by populating the adapter table's <code>finalize</code> entry point as shown:</p> <pre><code>    /* foo_plugin.c */\nint foo_plugin_finalize(void)\n{\n...\nreturn 0; /* success */\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;finalize =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_finalize\");\n...\nreturn 0;\n}\n</code></pre> <p>If a plugin does not implement an <code>opae_plugin_finalize</code> entry point, then the <code>finalize</code> member of the adapter table should be left uninitialized. During plugin cleanup, if a plugin has no <code>opae_plugin_finalize</code> entry point in its adapter table, the plugin finalize step will be skipped, and the plugin will be considered to have finalized successfully.</p> <p>In addition to <code>initialize</code> and <code>finalize</code>, an OPAE C API plugin has two further optional entry points that relate to device enumeration. During enumeration, when a plugin is being considered for a type of device, the plugin may provide input on that decision by exporting an <code>opae_plugin_supports_device</code> entry point in the adapter table:</p> <pre><code>    bool opae_plugin_supports_device(const char *device_type);\n</code></pre> <p><code>opae_plugin_supports_device</code> returns true if the given device type is supported and false if it is not. A false return value from <code>opae_plugin_supports_device</code> causes device enumeration to skip the plugin.</p> <p>Populating the <code>opae_plugin_supports_device</code> is done as:</p> <pre><code>    /* foo_plugin.c */\nbool foo_plugin_supports_device(const char *device_type)\n{\nif (/* device_type is supported */)\nreturn true;\n...\nreturn false;\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;supports_device =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_supports_device\");\n...\nreturn 0;\n}\n</code></pre> <pre><code>.. note::\n    The `opae_plugin_supports_device` mechanism serves as a placeholder only.\n    It is not implemented in the current version of the OPAE C API.\n</code></pre> <p>Similarly to determining whether a plugin supports a type of device, a plugin may also answer questions about network host support by populating an <code>opae_plugin_supports_host</code> entry point in the adapter table:</p> <pre><code>    bool opae_plugin_supports_host(const char *hostname);\n</code></pre> <p><code>opae_plugin_supports_host</code> returns true if the given hostname is supported and false if it is not. A false return value from <code>opae_plugin_supports_host</code> causes device enumeration to skip the plugin.</p> <p>Populating the <code>opae_plugin_supports_host</code> is done as:</p> <pre><code>    /* foo_plugin.c */\nbool foo_plugin_supports_host(const char *hostname)\n{\nif (/* hostname is supported */)\nreturn true;\n...\nreturn false;\n}\nint opae_plugin_configure(opae_api_adapter_table *table, const char *config)\n{\n... adapter-&gt;supports_host =\ndlsym(adapter-&gt;plugin.dl_handle, \"foo_plugin_supports_host\");\n...\nreturn 0;\n}\n</code></pre> <pre><code>.. note::\n    The `opae_plugin_supports_host` mechanism serves as a placeholder only.\n    It is not implemented in the current version of the OPAE C API.\n</code></pre>"},{"location":"sw/fpga_api/plug_guide/readme/#plugin-construction","title":"Plugin Construction","text":"<p>The steps required to implement an OPAE C API plugin, libfoo.so, are:</p> <ul> <li>Create foo_plugin.c: implements <code>opae_plugin_configure</code>, <code>opae_plugin_initialize</code>, <code>opae_plugin_finalize</code>, <code>opae_plugin_supports_device</code>, and <code>opae_plugin_supports_host</code> as described in the previous sections.</li> <li>Create foo_plugin.h: implements function prototypes for each of the plugin-specific OPAE C APIs.</li> </ul> <pre><code>    /* foo_plugin.h */\nfpga_result foo_fpgaOpen(fpga_token token, fpga_handle *handle,\nint flags);\nfpga_result foo_fpgaClose(fpga_handle handle);\n...\nfpga_result foo_fpgaEnumerate(const fpga_properties *filters,\nuint32_t num_filters, fpga_token *tokens,\nuint32_t max_tokens,\nuint32_t *num_matches);\n...\n</code></pre> <ul> <li>Create foo_types.h: implements plugin-specific types for opaque data structures.</li> </ul> <pre><code>    /* foo_types.h */\nstruct _foo_token {\n...\n};\nstruct _foo_handle {\n...\n};\nstruct _foo_event_handle {\n...\n};\nstruct _foo_object {\n...\n};\n</code></pre> <ul> <li>Create foo_enum.c: implements <code>foo_fpgaEnumerate</code>, <code>foo_fpgaCloneToken</code>, and <code>foo_fpgaDestroyToken</code>.</li> <li>Create foo_open.c: implements <code>foo_fpgaOpen</code>.</li> <li>Create foo_close.c: implements <code>foo_fpgaClose</code>.</li> <li>Create foo_props.c: implements <code>foo_fpgaGetProperties</code>, <code>foo_fpgaGetPropertiesFromHandle</code>, <code>foo_fpgaUpdateProperties</code></li> <li>Create foo_mmio.c: implements <code>foo_fpgaMapMMIO</code>, <code>foo_fpgaUnmapMMIO</code> <code>foo_fpgaWriteMMIO64</code>, <code>foo_fpgaReadMMIO64</code>, <code>foo_fpgaWriteMMIO32</code>, <code>foo_fpgaReadMMIO32</code>.</li> <li>Create foo_buff.c: implements <code>foo_fpgaPrepareBuffer</code>, <code>foo_fpgaReleaseBuffer</code>, <code>foo_fpgaGetIOAddress</code>.</li> <li>Create foo_error.c: implements <code>foo_fpgaReadError</code>, <code>foo_fpgaClearError</code>, <code>foo_fpgaClearAllErrors</code>, <code>foo_fpgaGetErrorInfo</code>.</li> <li>Create foo_event.c: implements <code>foo_fpgaCreateEventHandle</code>, <code>foo_fpgaDestroyEventHandle</code>, <code>foo_fpgaGetOSObjectFromEventHandle</code>, <code>foo_fpgaRegisterEvent</code>, <code>foo_fpgaUnregisterEvent</code>.</li> <li>Create foo_reconf.c: implements <code>foo_fpgaReconfigureSlot</code>.</li> <li>Create foo_obj.c: implements <code>foo_fpgaTokenGetObject</code>, <code>foo_fpgaHandleGetObject</code>, <code>foo_fpgaObjectGetObject</code>, <code>foo_fpgaDestroyObject</code>, <code>foo_fpgaObjectGetSize</code>, <code>foo_fpgaObjectRead</code>, <code>foo_fpgaObjectRead64</code>, <code>foo_fpgaObjectWrite64</code>.</li> <li>Create foo_clk.c: implements <code>foo_fpgaSetUserClock</code>, <code>foo_fpgaGetUserClock</code>.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/","title":"OPAE C API Programming Guide","text":"<pre><code>.. toctree::\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#overview","title":"Overview","text":"<p>The OPAE C library (libopae-c) is a lightweight user-space library that provides abstractions for FPGA resources in a compute environment. The OPAE C library  builds on the driver stack that supports the FPGA device, abstracting  hardware- and OS-specific details. It provides access to the underlying FPGA resources as a set of features available to software programs running on the host. These features include the acceleration logic preconfigured on the FPGA and functions to manage and reconfigure the FPGA. The library enables your applications to transparently and seamlessly benefit from FPGA-based acceleration.</p> <p></p> <p>By providing a unified C API, the library supports different FPGA integration and deployment models, ranging from single-node systems with one or a few FPGA devices to large-scale FPGA deployments in a data center. At one end of the spectrum, the API supports a simple application using a PCIe link to reconfigure  the FPGA with different accelerator functions. At the other end of the spectrum, resource management and orchestration services in a data center can use this API to discover and select FPGA resources and then allocate them for use by acceleration workloads.</p>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-role","title":"OPAE Role","text":"<p>The OPAE provides a common base layer for a wide range of applications without sacrificing performance or efficiency. The abstraction layer limits  the details of the FPGA hardware that software applications must handle. </p> <p>The OPAE provides consistent interfaces to crucial components of the platform. The  OPAE does not constrain frameworks and applications by making optimizations with limited applicability. When the OPAE does provide convenience functions or optimizations, they are optional.</p> <p>For example, the OPAE provides an interface to allocate physically contiguous buffers in system memory that user-space software and an accelerator can share.  This interface enables the most basic feature set of allocating and sharing a large page of memory in one API call. However, it  does not provide a malloc()-like interface backed by a memory pool or slab allocator. Higher layers of the software stack can make such domain-specific optimizations.</p>"},{"location":"sw/fpga_api/prog_guide/readme/#intel-accelerator-stack-hardware-terminology","title":"Intel Accelerator Stack Hardware Terminology","text":"<p>The following terms define the hardware and hardware processes involved in creating an accelerator function. </p> <ul> <li>FPGA: Field Programmable Gate Array  is a discrete or integrated device connecting to a host CPU via PCIe or other type of interconnects.</li> <li>Accelerator Function Unit (AFU): The AFU is the supplied implementation of an accelerator, typically in HDL. AFUs implement a function such as compression, encryption, or mathematical operations. The Quartus Prime Pro software synthesizes the RTL logic into a bitstream. </li> <li>Accelerator Function (AF): The AF is the compiled binary for an AFU. An AF is a raw binary file (.rbf) bitstream. A tool (fpgaconf) reconfigures the FPGA using an AF bitstream.</li> <li>Reconfiguration: The process of reprogramming the FPGA with a different AF.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-software-concepts-reflected-in-the-c-api","title":"OPAE Software Concepts Reflected in the C API","text":"<p>The following OPAE data structures and functions integrate AFUs into the OPAE environment.  The OPAE C API models these data structures and functions. For more information on the object  models refer to the Object model section.</p> <ul> <li>Accelerator: An accelerator is an allocable accelerator function implemented in an FPGA.  An accelerator tracks the  ownership of an AFU (or part of it) for a process that uses it. Multiple processes can share an accelerator.</li> <li>Device: The OPAE enumerates and models two device types: the FPGA and the AFU.</li> <li>Events: Events are asynchronous notifications. The FPGA driver triggers particular events to indicate error conditions. Accelerator logic can also define its own events. User applications can choose to be notified when particular events occur and respond appropriately.</li> <li>Shared memory buffers: Software allocates shared memory buffers in user process memory on the host. Shared memory buffers facilitate data transfers between the user process and the  accelerator that it owns.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-library","title":"OPAE Library","text":"<p>Linking with this library is straightforward. Code using the  OPAE library should include the header file <code>fpga.h</code>. Taking the GCC compiler on Linux as an example, here is the simplest compile and link command:</p> <p><code>gcc myprog.c -I&lt;/path/to/fpga.h&gt; -L&lt;/path/to/libopae-c.so&gt; -lopae-c -luuid -ljson-c -lpthread</code></p> <p>.. note::</p> <pre><code>The OPAE library uses the third-party `libuuid` and `libjson-c` libraries that are not distributed with \nthe OPAE library. Make sure to install these libraries.\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#sample-code","title":"Sample Code","text":"<p>The library source includes two code samples. Use these samples to learn how to call functions in the library. Build and run these samples to determine if your installation and environment are set up properly. </p> <p>Refer to the Running the Hello FPGA Example chapter in the Intel\u00ae Acceleration Stack Quick Start Guide for for Intel Programmable Acceleration Card with Intel Arria\u00ae 10 GX FPGA for more information about using the sample code.  </p>"},{"location":"sw/fpga_api/prog_guide/readme/#high-level-directory-structure","title":"High-Level Directory Structure","text":"<p>Building and installing the OPAE library results in the following directory structure on the Linux OS. Windows and MacOS have similar directories and files.</p> Directory &amp; Files Contents include/opae Directory containing all header files include/opae/fpga.h Top-level header for user code to include include/opae/access.h Header file for accelerator acquire/release, MMIO, memory management, event handling, and so on include/opae/bitstream.h Header file for bitstream manipulation functions include/opae/common.h Header file for error reporting functions include/opae/enum.h Header file for AFU enumeration functions include/opae/manage.h Header file for FPGA management functions include/opae/types.h Various type definitions lib Directory containing shared library files lib/libopae-c.so The shared dynamic library for linking with the user application doc Directory containing API documentation doc/html Directory for documentation of HTML format doc/latex Directory for documentation of LaTex format doc/man Directory for documentation of Unix man page format"},{"location":"sw/fpga_api/prog_guide/readme/#basic-application-flow","title":"Basic Application Flow","text":"<p>The figure below shows the basic application flow from the viewpoint of a user-process. </p> <p></p>"},{"location":"sw/fpga_api/prog_guide/readme/#api-components","title":"API Components","text":"<p>The API object model abstracts the physical FPGA device and available functions. It is a generalized model and extends to  describe any FPGA type. </p>"},{"location":"sw/fpga_api/prog_guide/readme/#object-models","title":"Object Models","text":"<ul> <li><code>fpga_objtype</code>: An enum type that represents the type of an FPGA resource, either <code>FPGA_DEVICE</code> or <code>FPGA_ACCELERATOR</code>.  An <code>FPGA_DEVICE</code> object corresponds to a physical FPGA device. Only <code>FPGA_DEVICE</code> objects can invoke management functions. The <code>FPGA_ACCELERATOR</code> represents an instance of an AFU. </li> <li><code>fpga_token</code>: An opaque type that represents a resource known to, but not necessarily owned by, the calling process. The calling process must own a resource before it can invoke functions of the resource.</li> <li><code>fpga_handle</code>: An opaque type that represents a resource owned by the calling process. The API functions <code>fpgaOpen()</code> and <code>fpgaClose()</code> acquire and release ownership of a resource that an <code>fpga_handle</code> represents. (Refer to the Functions section for more information.)</li> <li><code>fpga_properties</code>: An opaque type for a properties object. Your applications use these properties to query and search for appropriate resources. The  FPGA Resource Properties section documents properties visible to your applications.</li> <li><code>fpga_event_handle</code>: An opaque handle the FPGA driver uses to notify your application about an event. </li> <li><code>fpga_event_type</code>: An enum type that represents the types of events. The following are valid values:  <code>FPGA_EVENT_INTERRUPT</code>, <code>FPGA_EVENT_ERROR</code>, and <code>FPGA_EVENT_POWER_THERMAL</code>. (The Intel Programmable Acceleration Card (PAC) with Intel Arria 10 GX FPGA does not handle thermal and power events.)</li> <li><code>fpga_result</code>: An enum type to represent the result of an API function. If the function returns successfully the result is <code>FPGA_OK</code>. Otherwise, the result is the appropriate error codes. Function <code>fpgaErrStr()</code> translates an error code into human-readable strings.</li> </ul>"},{"location":"sw/fpga_api/prog_guide/readme/#functions","title":"Functions","text":"<p>The table below groups important API calls by their functionality. For more information about each of the functions, refer to the  OPAE C API reference manual.</p> Functionality API Call FPGA Accelerator Description Enumeration <code>fpgaEnumerate()</code> Yes Yes Query FPGA resources that match certain properties Enumeration: Properties <code>fpga[Get, Update, Clear, Clone, Destroy Properties]()</code> Yes Yes Manage <code>fpga_properties</code> life cycle <code>fpgaPropertiesGet[Prop]()</code> Yes Yes Get the specified property Prop, from the FPGA Resource Properties table <code>fpgaPropertiesSet[Prop]()</code> Yes Yes Set the specified property Prop, from the FPGA Resource Properties table Access: Ownership <code>fpga[Open, Close]()</code> Yes Yes Acquire/release ownership Access: Reset <code>fpgaReset()</code> Yes Yes Reset an accelerator Access: Event handling <code>fpga[Register, Unregister]Event()</code> Yes Yes Register/unregister an event to be notified about <code>fpga[Create, Destroy]EventHandle()</code> Yes Yes Manage <code>fpga_event_handle</code> life cycle Access: MMIO <code>fpgaMapMMIO()</code>, <code>fpgaUnMapMMIO()</code> Yes Yes Map/unmap MMIO space <code>fpgaGetMMIOInfo()</code> Yes Yes Get information about the specified MMIO space <code>fpgaReadMMIO[32, 64]()</code> Yes Yes Read a 32-bit or 64-bit value from MMIO space <code>fpgaWriteMMIO[32, 64]()</code> Yes Yes Write a 32-bit or 64-bit value to MMIO space Memory management: Shared memory <code>fpga[Prepare, Release]Buffer()</code> Yes Yes Manage memory buffer shared between the calling process and an accelerator <code>fpgaGetIOAddress()</code> Yes Yes Return the device I/O address of a shared memory buffer Management: Reconfiguration <code>fpgaReconfigureSlot()</code> Yes No Replace an existing AFU with a new one Error report <code>fpgaErrStr()</code> Yes Yes Map an error code to a human readable string <p>.. note::</p> <pre><code>The UMsg APIs are not supported for the Intel(R) PAC cards. They will be deprecated in a future release.\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#fpga-resource-properties","title":"FPGA Resource Properties","text":"<p>Applications query resource properties by specifying the property name for <code>Prop</code> in the  <code>fpgaPropertiesGet[Prop]()</code> and <code>fpgaPropertiesSet[Prop]()</code> functions. The FPGA and Accelerator columns state whether or not the Property is available for the FPGA or Accelerator objects.</p> Property FPGA Accelerator Description Parent No Yes <code>fpga_token</code> of the parent object ObjectType Yes Yes The type of the resource: either <code>FPGA_DEVICE</code> or <code>FPGA_ACCELERATOR</code> Bus Yes Yes The bus number Device Yes Yes The PCI device number Function Yes Yes The PCI function number SocketId Yes Yes The socket ID DeviceId Yes Yes The device ID NumSlots Yes No Number of AFU slots available on an <code>FPGA_DEVICE</code> resource BBSID Yes No The FPGA Interface Manager (FIM) ID of an <code>FPGA_DEVICE</code> resource BBSVersion Yes No The FIM version of an <code>FPGA_DEVICE</code> resource VendorId Yes No The vendor ID of an <code>FPGA_DEVICE</code> resource GUID Yes Yes The GUID of an <code>FPGA_DEVICE</code> or <code>FPGA_ACCELERATOR</code> resource NumMMIO No Yes The number of MMIO space of an <code>FPGA_ACCELERATOR</code> resource NumInterrupts No Yes The number of interrupts of an <code>FPGA_ACCELERATOR</code> resource AcceleratorState No Yes The state of an <code>FPGA_ACCELERATOR</code> resource: either <code>FPGA_ACCELERATOR_ASSIGNED</code> or <code>FPGA_ACCELERATOR_UNASSIGNED</code>"},{"location":"sw/fpga_api/prog_guide/readme/#opae-c-api-return-codes","title":"OPAE C API Return Codes","text":"<p>The OPAE C library returns a code for every exported public API function.  <code>FPGA_OK</code> indicates successful completion of the requested operation. Any return code other than <code>FPGA_OK</code> indicates an error or unexpected behavior. When using the OPAE C API, always check the API return codes. </p> Error Code Description <code>FPGA_OK</code> Operation completed successfully <code>FPGA_INVALID_PARAM</code> Invalid parameter supplied <code>FPGA_BUSY</code> Resource is busy <code>FPGA_EXCEPTION</code> An exception occurred <code>FPGA_NOT_FOUND</code> A required resource was not found <code>FPGA_NO_MEMORY</code> Not enough memory to complete operation <code>FPGA_NOT_SUPPORTED</code> Requested operation is not supported <code>FPGA_NO_DRIVER</code> Driver is not loaded <code>FPGA_NO_DAEMON</code> FPGA Daemon (<code>fpgad</code>) is not running <code>FPGA_NO_ACCESS</code> Insufficient privileges or permissions <code>FPGA_RECONF_ERROR</code> Error while reconfiguring FPGA"},{"location":"sw/fpga_api/prog_guide/readme/#usage-models","title":"Usage Models","text":""},{"location":"sw/fpga_api/prog_guide/readme/#query-and-search-for-a-resource","title":"Query and Search for a Resource","text":"<p>The user-code first populates an <code>fpga_properties</code> object with the required properties. Then, <code>fpgaEnumerate()</code> searches for matching resources. <code>fpgaEnumerate()</code> may return more than one matching resource.</p> <pre><code>#include \"fpga/fpga.h\"\n\nfpga_guid               guid;\nfpga_properties         filter = NULL;\nfpga_result             res;\nfpga_token              tokens[MAX_NUM_TOKENS];\nuint32_t                num_matches = 0;\n\n/* Start with an empty properties object */\nres = fpgaGetProperties(NULL, &amp;filter);\n\n/* Populate the properties object with required values.\n   In this case, search for accelerators that matches \n   the specified GUID.\n*/\nuuid_parse(GUID, guid);\nres = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\nres = fpgaPropertiesSetGuid(filter, guid);\n\n/* Query the number of matching resources */\nres = fpgaEnumerate(&amp;filter, 1, NULL, 1, &amp;num_matches);\n\n/* Return tokens for all matching resources */\nres = fpgaEnumerate(&amp;filter, 1, tokens, num_matches, &amp;num_matches);\n\n/* Destroy the properties object */\nres = fpgaDestroyProperties(&amp;filter);\n\n/* More code */\n......\n\n/* Destroy tokens */\nfor (uint32_t i = 0; i &lt; num_matches; ++i) {\n    res = fpgaDestroyToken(tokens[i]);\n}\n</code></pre> <p>The <code>fpgaEnumerate()</code> function can take multiple <code>fpga_properties</code>objects in an array. In such cases, the function performs a logical OR of  the properties object and returns resources that match any of  the multiple properties. The  <code>fpga_token</code> objects that <code>fpgaEnumerate()</code> returns, do not signify ownership. To acquire ownership of a resource represented by a token, pass the token to <code>fpgaOpen()</code>.</p>"},{"location":"sw/fpga_api/prog_guide/readme/#acquire-and-release-a-resource","title":"Acquire and Release a Resource","text":"<p>Use <code>fpgaOpen()</code> and <code>fpgaClose()</code> to acquire and release ownership of a resource.  The calling process must own the resource before it can initiate MMIO, access share memory buffers,  and use functions offered by the resource.</p> <pre><code>    #include \"fpga/fpga.h\"\nfpga_handle             handle;\nfpga_result             res;\n/* Acquire ownership of a resource that \n    `fpgaEnumerate()` previously returned as a token */\nres = fpgaOpen(token, &amp;handle);\n/* More code */\n......\n/* Release the ownership */\nres = fpgaClose(handle);\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#shared-memory-buffer","title":"Shared Memory Buffer","text":"<p>This code snippet shows how to prepare a memory buffer to be shared between the calling process and an accelerator.</p> <pre><code>    #include \"fpga/fpga.h\"\nfpga_handle             handle;\nfpga_result             res;\n/* Hint for the virtual address of the buffer */\nvolatile uint64_t       *addr_hint;\n/* An ID we can use to reference the buffer later */\nuint32_t                bufid;\n/* Flag to indicate whether or not the buffer is preallocated */\nint                     flag = 0;\n/* Allocate (if necessary), pin, and map a buffer to be accessible\n       by an accelerator\n    */\nres = fpgaPrepareBuffer(handle, BUF_SIZE, (void **) &amp;addr_hint,\n&amp;bufid, flag);\n/* The actual address mapped to the buffer */\nuint64_t                iova;\n/* Get the IO virtual address for the buffer */\nres = fpgaGetIOAddress(handle, bufid, &amp;iova);\n/* Inform the accelerator about the virtual address by writing to its mapped\n       register file\n    */\n......\n/* More code */\n......\n/* Release the shared buffer */\nres = fpgaReleaseBuffer(handle, bufid);\n</code></pre> <p>.. note::</p> <pre><code>The `flag` variable can take a constant `FPGA_BUF_PREALLOCATED` to\nindicate that the calling process has already allocated the address space\nthat `addr_hint` points to.\n</code></pre>"},{"location":"sw/fpga_api/prog_guide/readme/#mmio","title":"MMIO","text":"<p>This code snippet shows how to map and unmap the register file of an accelerator into the calling process's virtual memory space.</p> <pre><code>    #include \"fpga/fpga.h\"\nfpga_handle             handle;\nfpga_result             res;\n/* Index of the MMIO space. There might be multiple spaces on an accelerator */\nuint32_t                mmio_num = 0;\n/* Mapped address */\nuint64_t                mmio_addr;\n/* Map MMIO */\nres = fpgaMapMMIO(handle, mmio_num, &amp;mmio_addr);\n/* Write to a 32-bit value to the mapped register file at a certain byte\n       offset.\n       CSR_CTL is the offset in the mapped space to where the value will be\n       written. It's defined elsewhere.\n    */\nres = fpgaWriteMMIO32(handle, mmio_num, CSR_CTL, value);\n/* More code */\n......\n/* Unmap MMIO */\nres = fpgaUnmapMMIO(handle, mmio_num);\n</code></pre> <p>.. Note::</p> <pre><code>Every AFU has its own register adress space and its own protocol to control operation through \nthe registers. \n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/","title":"Quick Start Guide","text":""},{"location":"sw/fpga_api/quick_start/readme/#overview","title":"Overview","text":"<p>The OPAE C library is a lightweight user-space library that provides an abstraction for FPGA resources in a compute environment. Built on top of the OPAE Intel\u00ae FPGA driver stack that supports Intel\u00ae FPGA platforms, the library abstracts away hardware-specific and OS-specific details and exposes the underlying FPGA resources as a set of features accessible from within software programs running on the host.</p> <p>These features include the acceleration logic preconfigured on the device, as well as functions to manage and reconfigure the device. Hence, the library can enable user applications to transparently and seamlessly leverage FPGA-based acceleration.</p> <p>In this document, we will explore the initial steps on how to set up the required libraries and utilities to use the FPGA devices.</p> <p>If you do not have access to an Intel\u00ae Xeon\u00ae processor with integrated FPGA, or a programmable FPGA acceleration card for Intel\u00ae Xeon\u00ae processors, you will not be able to run the examples below. However, you can still make use of the AFU simulation environment (ASE) to develop and test accelerator RTL with OPAE applications.</p> <p>The source for the OPAE SDK Linux device drivers is available at the OPAE Linux DFL drivers repository.</p>"},{"location":"sw/fpga_api/quick_start/readme/#build-the-opae-linux-device-drivers-from-the-source","title":"Build the OPAE Linux device drivers from the source","text":"<p>For building the OPAE kernel and kernel driver, the kernel development environment is required. So before you build the kernel, you must install the required packages. Run the following commands (we are using Fedora 32 as an example):</p> <pre><code>sudo yum install gcc gcc-c++ make kernel-headers kernel-devel elfutils-libelf-devel ncurses-devel openssl-devel bison flex\n</code></pre> <p>Download the OPAE upstream kernel tree from GitHub:</p> <pre><code>git clone https://github.com/OPAE/linux-dfl.git -b fpga-upstream-dev-5.8.0\n</code></pre> <p>Configure the kernel:</p> <pre><code>cd linux-dfl\ncp /boot/config-`uname -r` .config\ncat configs/n3000_d5005_defconfig &gt;&gt; .config echo 'CONFIG_LOCALVERSION=\"-dfl\"' &gt;&gt; .config\necho 'CONFIG_LOCALVERSION_AUTO=y' &gt;&gt; .config\nmake olddefconfig\n</code></pre> <p>Compile and install the new kernel:</p> <pre><code>make -j\nsudo make modules_install\nsudo make install\n</code></pre> <p>After the installation finishes, reboot your system. Log back into the system, and confirm the correct version for the kernel:</p> <pre><code>$ uname -a\nLinux localhost.localdomain 5.8.0-rc1-dfl-g73e16386cda0 #6 SMP Wed Aug 19 08:38:32 EDT 2020 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/#building-and-installing-the-opae-sdk-from-the-source","title":"Building and installing the OPAE SDK from the source","text":"<p>Download the OPAE SDK source package:</p> <ol> <li>Go to the section corresponding to the desired release on GitHub:</li> <li>Click the <code>Source code (tar.gz)</code> link under the section's <code>Assets</code>.</li> <li>On the command line, go through the following steps to install it:</li> </ol> <pre><code># Unpack\ntar xfvz opae-sdk-&lt;release&gt;.tar.gz\n# Configure\ncd opae-sdk-&lt;release&gt;\nmkdir build\ncd build\n# The default installation prefix is `/usr/local`;\n# You have the option to configure for a different location\ncmake [-DCMAKE_INSTALL_PREFIX=&lt;prefix&gt;] ..\n# Compile\nmake\n# Install: you need system administration privileges (`sudo`)\n# if you have elected to install in the default location\n[sudo] make install\n</code></pre> <p>The remainder of this guide assumes you installed into <code>/usr/local</code>.</p>"},{"location":"sw/fpga_api/quick_start/readme/#configuring-the-fpga-loading-an-fpga-afu","title":"Configuring the FPGA (loading an FPGA AFU)","text":"<p>The <code>fpgaconf</code> tool exercises the AFU reconfiguration functionality. It shows how to read a bitstream from a disk file, check its validity and compatibility, and then injects it into FPGA to be configured as a new AFU, which can then be discovered and used by user applications.</p> <p>For this step, you require a valid green bitstream (GBS) file. To reconfigure the FPGA slot, you can issue the following command as system administrator:</p> <pre><code>sudo fpgaconf -b 0x5e &lt;filename&gt;.gbs\n</code></pre> <p>The <code>-b</code> option to <code>fpgaconf</code> indicates the target bus number of the FPGA slot to be reconfigured. Alternatively, you can also specify the target socket number of the FPGA using the <code>-s</code> option.</p> <pre><code>$ sudo fpgaconf --help\nUsage:\n        fpgaconf [-hvn] [-b &lt;bus&gt;] [-d &lt;device&gt;] [-f &lt;function&gt;] [-s &lt;socket&gt;] &lt;gbs&gt;\n\n-h,--help           Print this help\n-v,--verbose        Increase verbosity\n                -n,--dry-run        Don't actually perform actions\n                -b,--bus            Set target bus number\n                -d,--device         Set target device number\n                -f,--function       Set target function number\n                -s,--socket         Set target socket number\n</code></pre> <pre><code>The sample application on the Building a Sample Application\nsection requires loading of an AFU called \"Native Loopback\nAdapter\" (NLB) on the FPGA. Please refer to the NLB documentation\nfor the location of the NLB's green bitstream. You also can verify\nif the NLB green bitstream has already been loaded into the FPGA\nslot by typing the following command and checking the output\nmatches the following:\n\n```bash\n$ cat /sys/class/fpga_region/region0/dfl-port.0/afu_id\nd8424dc4a4a3c413f89e433683f9040b\n```\n</code></pre> <pre><code>The fpgaconf tool is not available for the Intel PAC N3000. The NLB is\nalready included in the AFU.\n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/#building-a-sample-application","title":"Building a sample application","text":"<p>The library source includes code samples. Use these samples to learn how to call functions in the library. Build and run these samples as quick sanity checks to determine if your installation and environment are set up properly.</p> <p>In this guide, we will build <code>hello_fpga.c</code>. This is the \"Hello World!\" example of using the library.  This code searches for a predefined and known AFU called \"Native Loopback Adapter\" on the FPGA. If found, it acquires ownership and then interacts with the AFU by sending it a 2MB message and waiting for the message to be echoed back. This code exercises all major components of the API except for AFU reconfiguration: AFU search, enumeration, access, MMIO, and memory management.</p> <p>You can also find the source for <code>hello_fpga</code> in the <code>samples</code> directory of the OPAE SDK repository on GitHub.</p> <pre><code>    int main(int argc, char *argv[])\n{\nfpga_properties    filter = NULL;\nfpga_token         afu_token;\nfpga_handle        afu_handle;\nfpga_guid          guid;\nuint32_t           num_matches;\nvolatile uint64_t *dsm_ptr    = NULL;\nvolatile uint64_t *status_ptr = NULL;\nvolatile uint64_t *input_ptr  = NULL;\nvolatile uint64_t *output_ptr = NULL;\nuint64_t        dsm_wsid;\nuint64_t        input_wsid;\nuint64_t        output_wsid;\nfpga_result     res = FPGA_OK;\nif (uuid_parse(NLB0_AFUID, guid) &lt; 0) {\nfprintf(stderr, \"Error parsing guid '%s'\\n\", NLB0_AFUID);\ngoto out_exit;\n}\n/* Look for accelerator by its \"afu_id\" */\nres = fpgaGetProperties(NULL, &amp;filter);\nON_ERR_GOTO(res, out_exit, \"creating properties object\");\nres = fpgaPropertiesSetObjectType(filter, FPGA_ACCELERATOR);\nON_ERR_GOTO(res, out_destroy_prop, \"setting object type\");\nres = fpgaPropertiesSetGuid(filter, guid);\nON_ERR_GOTO(res, out_destroy_prop, \"setting GUID\");\n/* TODO: Add selection via BDF / device ID */\nres = fpgaEnumerate(&amp;filter, 1, &amp;afu_token, 1, &amp;num_matches);\nON_ERR_GOTO(res, out_destroy_prop, \"enumerating accelerators\");\nif (num_matches &lt; 1) {\nfprintf(stderr, \"accelerator not found.\\n\");\nres = fpgaDestroyProperties(&amp;filter);\nreturn FPGA_INVALID_PARAM;\n}\n/* Open accelerator and map MMIO */\nres = fpgaOpen(afu_token, &amp;afu_handle, 0);\nON_ERR_GOTO(res, out_destroy_tok, \"opening accelerator\");\nres = fpgaMapMMIO(afu_handle, 0, NULL);\nON_ERR_GOTO(res, out_close, \"mapping MMIO space\");\n/* Allocate buffers */\nres = fpgaPrepareBuffer(afu_handle, LPBK1_DSM_SIZE,\n(void **)&amp;dsm_ptr, &amp;dsm_wsid, 0);\nON_ERR_GOTO(res, out_close, \"allocating DSM buffer\");\nres = fpgaPrepareBuffer(afu_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n(void **)&amp;input_ptr, &amp;input_wsid, 0);\nON_ERR_GOTO(res, out_free_dsm, \"allocating input buffer\");\nres = fpgaPrepareBuffer(afu_handle, LPBK1_BUFFER_ALLOCATION_SIZE,\n(void **)&amp;output_ptr, &amp;output_wsid, 0);\nON_ERR_GOTO(res, out_free_input, \"allocating output buffer\");\nprintf(\"Running Test\\n\");\n/* Initialize buffers */\nmemset((void *)dsm_ptr,    0,    LPBK1_DSM_SIZE);\nmemset((void *)input_ptr,  0xAF, LPBK1_BUFFER_SIZE);\nmemset((void *)output_ptr, 0xBE, LPBK1_BUFFER_SIZE);\ncache_line *cl_ptr = (cache_line *)input_ptr;\nfor (uint32_t i = 0; i &lt; LPBK1_BUFFER_SIZE / CL(1); ++i) {\ncl_ptr[i].uint[15] = i+1; /* set the last uint in every cacheline */\n}\n/* Reset accelerator */\nres = fpgaReset(afu_handle);\nON_ERR_GOTO(res, out_free_output, \"resetting accelerator\");\n/* Program DMA addresses */\nuint64_t iova;\nres = fpgaGetIOAddress(afu_handle, dsm_wsid, &amp;iova);\nON_ERR_GOTO(res, out_free_output, \"getting DSM IOVA\");\nres = fpgaWriteMMIO64(afu_handle, 0, CSR_AFU_DSM_BASEL, iova);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_AFU_DSM_BASEL\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 0);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 1);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\nres = fpgaGetIOAddress(afu_handle, input_wsid, &amp;iova);\nON_ERR_GOTO(res, out_free_output, \"getting input IOVA\");\nres = fpgaWriteMMIO64(afu_handle, 0, CSR_SRC_ADDR, CACHELINE_ALIGNED_ADDR(iova));\nON_ERR_GOTO(res, out_free_output, \"writing CSR_SRC_ADDR\");\nres = fpgaGetIOAddress(afu_handle, output_wsid, &amp;iova);\nON_ERR_GOTO(res, out_free_output, \"getting output IOVA\");\nres = fpgaWriteMMIO64(afu_handle, 0, CSR_DST_ADDR, CACHELINE_ALIGNED_ADDR(iova));\nON_ERR_GOTO(res, out_free_output, \"writing CSR_DST_ADDR\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_NUM_LINES, LPBK1_BUFFER_SIZE / CL(1));\nON_ERR_GOTO(res, out_free_output, \"writing CSR_NUM_LINES\");\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CFG, 0x42000);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\nstatus_ptr = dsm_ptr + DSM_STATUS_TEST_COMPLETE/8;\n/* Start the test */\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 3);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n/* Wait for test completion */\nwhile (0 == ((*status_ptr) &amp; 0x1)) {\nusleep(100);\n}\n/* Stop the device */\nres = fpgaWriteMMIO32(afu_handle, 0, CSR_CTL, 7);\nON_ERR_GOTO(res, out_free_output, \"writing CSR_CFG\");\n/* Check output buffer contents */\nfor (uint32_t i = 0; i &lt; LPBK1_BUFFER_SIZE; i++) {\nif (((uint8_t*)output_ptr)[i] != ((uint8_t*)input_ptr)[i]) {\nfprintf(stderr, \"Output does NOT match input \"\n\"at offset %i!\\n\", i);\nbreak;\n}\n}\nprintf(\"Done Running Test\\n\");\n/* Release buffers */\nout_free_output:\nres = fpgaReleaseBuffer(afu_handle, output_wsid);\nON_ERR_GOTO(res, out_free_input, \"releasing output buffer\");\nout_free_input:\nres = fpgaReleaseBuffer(afu_handle, input_wsid);\nON_ERR_GOTO(res, out_free_dsm, \"releasing input buffer\");\nout_free_dsm:\nres = fpgaReleaseBuffer(afu_handle, dsm_wsid);\nON_ERR_GOTO(res, out_unmap, \"releasing DSM buffer\");\n/* Unmap MMIO space */\nout_unmap:\nres = fpgaUnmapMMIO(afu_handle, 0);\nON_ERR_GOTO(res, out_close, \"unmapping MMIO space\");\n/* Release accelerator */\nout_close:\nres = fpgaClose(afu_handle);\nON_ERR_GOTO(res, out_destroy_tok, \"closing accelerator\");\n/* Destroy token */\nout_destroy_tok:\nres = fpgaDestroyToken(&amp;afu_token);\nON_ERR_GOTO(res, out_destroy_prop, \"destroying token\");\n/* Destroy properties object */\nout_destroy_prop:\nres = fpgaDestroyProperties(&amp;filter);\nON_ERR_GOTO(res, out_exit, \"destroying properties object\");\nout_exit:\nreturn res;\n}\n</code></pre> <p>Linking with the OPAE library is straightforward.  Code using this library should include the header file <code>fpga.h</code>. Taking the GCC compiler on Linux as an example, the minimalist compile and link line should look like:</p> <pre><code>gcc -std=c99 hello_fpga.c -I/usr/local/include -L/usr/local/lib -lopae-c -luuid -ljson-c -lpthread -o hello_fpga\n</code></pre> <pre><code>The API uses some features from the C99 language standard. The\n`-std=c99` switch is required if the compiler does not support C99 by\ndefault.\n</code></pre> <pre><code>Third-party library dependency: The library internally uses\n`libuuid` and `libjson-c`. But they are not distributed as part of the\nlibrary. Make sure you have these libraries properly installed.\n</code></pre> <pre><code>The layout of AFU is different between the N3000 card and Rush Creek/Darby Creek.\nIn the N3000 card, the NLB and DMA are contained in the AFU, so we need to do\nenumeration again in AFU to discover the NLB.\nTo run the hello_fpga application on the N3000 card, it should use the `-c`\noption to support the N3000 card:\n\n```bash\n$ sudo ./hello_fpga -c\nRunning Test\nRunning on bus 0x08.\nAFU NLB0 found @ 28000\nDone Running Test\n```\n</code></pre> <p>To run the <code>hello_fpga</code> application; just issue:</p> <pre><code>$ sudo ./hello_fpga\nRunning Test\nDone\n</code></pre>"},{"location":"sw/fpga_api/quick_start/readme/#setup-iofs-release1-bitstream-on-fpga-pcie-card","title":"Setup IOFS Release1 Bitstream on FPGA PCIe card","text":"<p>Program IOFS Release1 bitstream on the FPGA D5005 or N6000 cards and reboot the system.</p> <p>Run this command:</p> <pre><code>$ lspci | grep acc\n3b:00.0 Processing accelerators: Intel Corporation Device af00 (rev 01)\n</code></pre> <p>Number of virtual functions supported by bitstream:</p> <pre><code>$ cat /sys/bus/pci/devices/0000:3b:00.0/sriov_totalvfs output: 3\n</code></pre> <p>Enable FPGA virtual functions:</p> <pre><code>sudo sh -c \"echo 3 &gt; /sys/bus/pci/devices/0000:3b:00.0/sriov_numvfs\"\n</code></pre> <p>List of FPGA PF and VF's:</p> <pre><code>Physical Functions (PFs):\n  3b:00.0 Processing accelerators: Intel Corporation Device af00 (rev 01)\n\nVirtual Functions (VFs).\n  3b:00.1 Processing accelerators: Intel Corporation Device af01 (rev 01)\n  3b:00.2 Processing accelerators: Intel Corporation Device af01 (rev 01)\n  3b:00.3 Processing accelerators: Intel Corporation Device af01 (rev 01)\n</code></pre> <p>Bind vfio-pcie driver to FPGA virtual functions:</p> <pre><code>sudo opaevfio  -i 0000:3b:00.1 -u userid -g groupid\nsudo opaevfio  -i 0000:3b:00.2 -u userid -g groupid\nsudo opaevfio  -i 0000:3b:00.3 -u userid -g groupid\n</code></pre> <p>List of fpga accelerators:</p> <pre><code>$ fpgainfo port\n\n//****** PORT ******//\n  Object Id                        : 0x600D000000000000\n  PCIe s:b:d.f                     : 0000:3b:00.3\n  Device Id                        : 0xAF00\n  Socket Id                        : 0xFF\n  Accelerator Id                   : 43425ee6-92b2-4742-b03a-bd8d4a533812\n  Accelerator GUID                 : 43425ee6-92b2-4742-b03a-bd8d4a533812\n  //****** PORT ******//\n  Object Id                        : 0x400D000000000000\n  PCIe s:b:d.f                     : 0000:3b:00.2\n  Device Id                        : 0xAF00\n  Socket Id                        : 0xFF\n  Accelerator Id                   : 8568AB4E-6bA5-4616-BB65-2A578330A8EB\n  Accelerator GUID                 : 8568AB4E-6bA5-4616-BB65-2A578330A8EB\n  //****** PORT ******//\n  Object Id                        : 0x200D000000000000\n  PCIe s:b:d.f                     : 0000:3b:00.1\n  Device Id                        : 0xAF00\n  Socket Id                        : 0xFF\n  Accelerator Id                   : 56e203e9-864f-49a7-b94b-12284c31e02b\n  Accelerator GUID                 : 56e203e9-864f-49a7-b94b-12284c31e02b\n\nFPGA VF1/3b:00.1/Host Exerciser Loopback Accelerator GUID: 56E203E9-864F-49A7-B94B-12284C31E02B\nFPGA VF2/3b:00.2/Host Exerciser Memory Accelerator GUID: 8568AB4E-6bA5-4616-BB65-2A578330A8EB\nFPGA VF3/3b:00.3/Host Exerciser HSSI Accelerator GUID: 43425ee6-92b2-4742-b03a-bd8d4a533812\n</code></pre> <p>Unbind pcie-vfio dirver to FPGA virtual functions:</p> <pre><code>sudo opaevfio  -r 0000:3b:00.1\n</code></pre> <p>Host Exerciser Loopback (HE-LBK) AFU can move data between host memory and FPGA:</p> <pre><code>$ host_exerciser lpbk\n\n[lpbk] [info] starting test run, count of 1\nInput Config:0\n  Allocate SRC Buffer\n  Allocate DST Buffer\n  Allocate DSM Buffer\n  Start Test\n  Test Completed\n  Host Exerciser swtest msg:0\n  Host Exerciser numReads:32\n  Host Exerciser numWrites:32\n  Host Exerciser numPendReads:0\n  Host Exerciser numPendWrites:0\n  [lpbk] [info] Test lpbk(1): PASS\n</code></pre> <pre><code>  In order to successfully run hello\\_fpga, the user needs to configure\n  system hugepage to reserve 2M-hugepages.\n  For example, the command below reserves 20 2M-hugepages:\n\n  ```bash\n  echo 20 | sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages\n  ```\n\n  For x86_64 architecture CPU, user can use the following command to find out available huge page sizes:\n\n  ```bash\n  $ grep pse /proc/cpuinfo | uniq\n  flags : ... pse ...\n  ```\n\n  If this command returns a non-empty string, 2MB pages are supported:\n\n  ```bash\n  $ grep pse /proc/cpuinfo | uniq\n  flags : ... pdpe1gb ...\n  ```\n\n  If this commands returns a non-empty string, 1GB pages are supported.\n  ````\n\n````{note}\nThe default configuration for many Linux distributions currently sets a\nrelatively low limit for pinned memory allocations per process \n(RLIMIT_MEMLOCK, often set to a default of 64kiB).\n\nTo run an OPAE application that attempts to share more memory than specified\nby this limit between software and an accelerator, you can either:\n\n* Run the application as root, or\n* Increase the limit for locked memory via `ulimit`:\n\n```bash\nulimit -l unlimited\n```\n\nSee the Installation Guide for how to permanently adjust the memlock limit.\n</code></pre>"},{"location":"sw/fpga_dfl_drv/fpga_dfl_drv/","title":"Enable OPAE on FPGA PCIe drivers","text":"<pre><code>.. toctree::\n.. highlight:: c\n.. highlight:: console\n</code></pre> <p>FPGA PCIe driver for PCIe-based Field-Programmable Gate Array (FPGA) solutions which implement the Device Feature List (DFL). This driver provides interfaces for user space applications to configure, enumerate, open and access FPGA accelerators on the FPGA DFL devices. additionally, it also enables system level management functions such as FPGA partial reconfiguration, power management, virtualization with DFL framework and DFL feature device drivers.</p> <p>OPAE 1.4.0 release supports both FPGA Intel Linux driver as well as Linux FPGA DFL driver patch set2. Linux PCIe FPGA DFL driver supports Intel FPGA devices.</p> <p>FPGA DFL Linux driver source code patchset2 available  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers?h=linux-5.4.y</p> <p>FPGA DFL Linux driver source code patchset1 available  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/fpga?h=v4.19.14</p> <p></p>"},{"location":"sw/fpga_tools/readme/","title":"fpga_tools","text":""},{"location":"sw/fpga_tools/readme/#fpgainfo","title":"fpgainfo","text":""},{"location":"sw/fpga_tools/readme/#name","title":"NAME","text":"<p>fpgainfo - FPGA information tool</p>"},{"location":"sw/fpga_tools/readme/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgainfo [-h | --help] [-s | --socket-id] &lt;command&gt; [&lt;args&gt;]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#description","title":"DESCRIPTION","text":"<p>fpgainfo is a tool to show FPGA information derived from sysfs files. The command argument is one of the following: errors, power, temp and is used to specify what type of information to report. Some commands may also have other arguments/options that can be used to control the behavior of that command.</p>"},{"location":"sw/fpga_tools/readme/#common-options","title":"COMMON OPTIONS","text":"<p><code>--help, -h</code></p> <pre><code>Print help information and exit.\n</code></pre> <p><code>--socket-id, -s</code></p> <pre><code>Socket ID encoded in BBS. Default=0\n</code></pre>"},{"location":"sw/fpga_tools/readme/#fpgainfo-commands","title":"FPGAINFO COMMANDS","text":"<p><code>errors</code></p> <pre><code>Show/clear errors of an FPGA resource as specified by the first argument.\nError information is parsed to display in human readable form.\n</code></pre> <p><code>power</code></p> <pre><code>Show total power consumed by the FPGA hardware in watts\n</code></pre> <p><code>temp</code></p> <pre><code>Show FPGA temperature values in degrees Farenheit\n</code></pre>"},{"location":"sw/fpga_tools/readme/#errors-options","title":"ERRORS OPTIONS","text":"<p><code>--clear, -c</code></p> <pre><code>Clear errors for the given FPGA resource\n</code></pre>"},{"location":"sw/fpga_tools/readme/#errors-arguments","title":"ERRORS ARGUMENTS","text":"<p>The first argument to the <code>errors</code> command is used to specify what kind of resource to act on. It must be one of the following: <code>fme</code>,<code>port</code>,<code>first_error</code>,<code>pcie0</code>,<code>pcie1</code>,<code>bbs</code>,<code>gbs</code>,<code>all</code> More details on the errors reported for the resource can be found below:</p>"},{"location":"sw/fpga_tools/readme/#errors-resources","title":"ERRORS RESOURCES","text":"<p><code>fme</code></p> <pre><code>Show/clear errors pertaining to the FME\n</code></pre> <p><code>port</code></p> <pre><code>Show/clear errors pertaining to the PORT\n</code></pre> <p><code>first_error</code></p> <pre><code>Show/clear first errors encountered by the FPGA\n</code></pre> <p><code>pcie0</code></p> <pre><code>Show/clear errors pertaining to the PCIE0 lane\n</code></pre> <p><code>pcie1</code></p> <pre><code>Show/clear errors pertaining to the PCIE1 lane\n</code></pre> <p><code>bbs</code></p> <pre><code>Show/clear errors pertaining to the BBS (blue bitstream)\n</code></pre> <p><code>gbs</code></p> <pre><code>Show/clear errors pertaining to the GBS (green bitstream)\n</code></pre> <p><code>all</code></p> <pre><code>Show/clear errors for all resources\n</code></pre>"},{"location":"sw/fpga_tools/readme/#examples","title":"EXAMPLES","text":"<p>This command shows the current power consumtion: <pre><code>./fpgainfo power\n</code></pre></p> <p>This command shows the current temperature reading: <pre><code>./fpgainfo temp\n</code></pre></p> <p>This command shows the errors for the FME resource: <pre><code>./fpgainfo errors fme\n</code></pre> This command clears all the errors on all resources: <pre><code>./fpgainfo errors all -c\n</code></pre></p>"},{"location":"sw/fpga_tools/readme/#fpgaconf","title":"fpgaconf","text":""},{"location":"sw/fpga_tools/readme/#name_1","title":"NAME","text":"<p>fpgadiag - Configure a green bitstream to an FPGA</p>"},{"location":"sw/fpga_tools/readme/#synopsis_1","title":"SYNOPSIS","text":"<p><code>fpgaconf [-hvn] [-b &lt;bus&gt;] [-d &lt;device&gt;] [-f &lt;function&gt;] [-s &lt;socket&gt;] &lt;gbs&gt;</code></p>"},{"location":"sw/fpga_tools/readme/#description_1","title":"DESCRIPTION","text":"<p>fpgaconf writes accelerator configuration bitstreams (also referred to as \"green bitstreams\" to an FPGA device recognized by OPAE. In the process, it also checks the green bitstream file for compatibility with the targeted FPGA and its current infrastructure bitstream (the \"blue bistream\"). fpgaconf takes the following arguments:</p> <p><code>-h, --help</code></p> <pre><code>Print usage information\n</code></pre> <p><code>-v, --verbose</code></p> <pre><code>Print more verbose messages while enumerating and configuring. Can be\ngiven more than once\n</code></pre> <p><code>-n, --dry-run</code></p> <pre><code>Perform enumeration, but skip any operations with side-effects (like the\nactual configuration of the bitstream\n</code></pre> <p><code>-b, --bus</code></p> <pre><code>PCI bus number of the FPGA to target\n</code></pre> <p><code>-d, --device</code></p> <pre><code>PCI device number of the FPGA to target\n</code></pre> <p><code>-f, --function</code></p> <pre><code>PCI function number of the FPGA to target\n</code></pre> <p><code>-s, --socket</code></p> <pre><code>Socket number of the FPGA to target\n</code></pre> <p>fpgaconf will enumerate available FPGA devices in the system and select compatible FPGAs for configuration. If there are more than one candidate FPGAs that are compatible with the given green bitstream, fpgaconf will exit and ask you to be more specific in selecting the target FPGAs (e.g. by specifying a socket number, or a PCIe bus/device/function).</p>"},{"location":"sw/fpga_tools/readme/#examples_1","title":"EXAMPLES","text":"<p><code>fpgaconf my_green_bitstream.gbs</code></p> <pre><code>Program \"my_green_bitstream.gbs\" to a compatible FPGA\n</code></pre> <p><code>fpgaconf -v -s 0 my_green_bitstream.gbs</code></p> <pre><code>Program \"my_green_bitstream.gbs\" to the FPGA in socket 0, if compatible,\nwhile printing out slightly more verbose information\n</code></pre>"},{"location":"sw/fpga_tools/readme/#fpgad","title":"fpgad","text":""},{"location":"sw/fpga_tools/readme/#name_2","title":"NAME","text":"<p>fpgad - log errors and generate events</p>"},{"location":"sw/fpga_tools/readme/#synopsis_2","title":"SYNOPSIS","text":"<p><code>fpgad --daemon [--directory=&lt;dir&gt;] [--logfile=&lt;file&gt;] [--pidfile=&lt;file&gt;] [--umask=&lt;mode&gt;] [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code> <code>fpgad [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_2","title":"DESCRIPTION","text":"<p>Periodically monitors/reports the error status reflected in the device driver's error status sysfs files. Establishes the channel by which events are communicated to the OPAE application. Programs a NULL bitstream in response to AP6 event.</p> <p>fpgad is required to be running before API calls <code>fpgaRegisterEvent</code> and <code>fpgaUnregisterEvent</code> will succeed.</p> <p>Use SIGINT to stop fpgad.</p> <p><code>-d, --daemon</code></p> <pre><code>When given, fpgad executes as a system demon process.\n</code></pre> <p><code>-D, --directory &lt;dir&gt;</code></p> <pre><code>When running in daemon mode, execute from the given directory.\nIf omitted when daemonizing, /tmp is used.\n</code></pre> <p><code>-l, --logfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, send output to file. When not in daemon mode, the output is sent to stdout.\nIf omitted when daemonizaing, /tmp/fpgad.log is used.\n</code></pre> <p><code>-p, --pidfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, write the daemon's process id to file.\nIf omitted when daemonizing, /tmp/fpgad.pid is used.\n</code></pre> <p><code>-m, --umask &lt;mode&gt;</code></p> <pre><code>When running in daemon mode, use the mode value as the file mode creation mask passed to umask.\nIf omitted when daemonizing, 0 is used.\n</code></pre> <p><code>-s, --socket &lt;sock&gt;</code></p> <pre><code>Listen for event API registration requests on sock. The default socket value used by the API is\n/tmp/fpga_event_socket.\n</code></pre> <p><code>-n, --null-bitstream &lt;file&gt;</code></p> <pre><code>Specify the NULL bitstream to program when an AP6 event occurs. This option may be given multiple\ntimes. The bitstream, if any, that matches the FPGA's PR interface id will be programmed when AP6\nis detected.\n</code></pre>"},{"location":"sw/fpga_tools/readme/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>If any issues are encountered, try the following for additional debug information:</p> <ol> <li>Examine the log file when in daemon mode.</li> <li>Run in non-daemon mode and view stdout.</li> </ol>"},{"location":"sw/fpga_tools/readme/#examples_2","title":"EXAMPLES","text":"<p><code>fpgad --daemon --null-bitstream=my_null_bits.gbs</code></p>"},{"location":"sw/fpga_tools/readme/#see-also","title":"SEE ALSO","text":"<p>umask</p>"},{"location":"sw/fpga_tools/readme/#fpgadiag","title":"fpgadiag","text":""},{"location":"sw/fpga_tools/readme/#name_3","title":"NAME","text":"<p>fpgadiag - FPGA diagnosis and testing tool.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_3","title":"SYNOPSIS","text":"<pre><code>fpgadiag [-m | --mode=] &lt;mode&gt; [-t | --target=] &lt;target&gt; [options]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#description_3","title":"DESCRIPTION","text":"<p>fpgadiag includes several tests to diagnose, test and report on the FPGA hardware.</p> <p><code>&lt;mode&gt;</code> chooses which test to run. <code>&lt;target&gt;</code> specifies on what platform to run the test. <code>&lt;target&gt;</code> can be either <code>fpga</code> or <code>ase</code>, where <code>ase</code> stands for \"AFU Simulation Environment\".</p> <p>The tests that can be selected by <code>&lt;mode&gt;</code> include:</p> <p>lpbk1</p> <pre><code>The test performs loopback test on the number of cachelines specified with \nthe `BEGIN` option. _fpgadiag_ sets up source and  destination buffers in \nmain memory. The FPGA then performs a memcpy from a source buffer to the \ndestination buffer, one cacheline at a time.\n\nA cacheline is 64 bytes. When `BEGIN = END`, you perform one iteration. When \n`BEGIN = END + x`, you perform `x` iterations. The first iteration consists \nof copying `BEGIN` cachelines; the second iteration consists of copying \n`BEGIN+1` cache lines; the third iteration consists of copying `BEGIN+3` \ncache lines, etc.\n\nThe latency is shown as the number of clock ticks.\n\nWhen you specify `MULTI-CL`, you copy `MULTI-CL` cache lines at a time.\nThere is always a WrFence. `WR-FENCE` chooses what virtual channel the \nWrFence occurs on.\n\nIf you specify continuous mode with `--cont`, the program runs an iteration\nuntil the timeout specified in `TIMEOUT` completes.\n</code></pre> <p>read</p> <pre><code>This test performs only a read, not a memcpy. It is used to measure read \nbandwidth.\n</code></pre> <p>write </p> <pre><code>This test is used to measure write bandwidth.\n</code></pre> <p>trput</p> <pre><code>This test measures both read and write bandwidth by performing 50% read and \n50% write tests.\n</code></pre> <p>sw</p> <pre><code>This is a send-and-respond (ping-pong) test where one side sends data and \nwaits for answer.\n</code></pre> <p>Each test requires presence of one of these bitstreams, as documented below. Before running a test, make sure its required bitstream is properly configured on the platform.</p> <ul> <li>nlb mode 0 for the <code>lpbk1</code> test.</li> <li>nlb mode 3 for the <code>trput</code>, <code>read</code>, and <code>write</code> tests.</li> <li>nlb mode 7 for the <code>sw</code> test.</li> </ul>"},{"location":"sw/fpga_tools/readme/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/readme/#common-options_1","title":"Common options","text":"<p><code>--help, -h</code></p> <pre><code>Print help information and exit.\n</code></pre> <p><code>--target=, -t</code></p> <pre><code>Values accepted for this switch are fpga or ase. Default=fpga\n</code></pre> <p><code>--mode=, -m</code></p> <pre><code>The test to run. Values accepted for this switch are `lpbk1`, `read`,\n`write`, `trput`, `sw`\n</code></pre> <p><code>--config=, -c</code></p> <pre><code>A configuration file in the JSON format that specifies options for a test.\nIf an option is specified both in the configuration file and on the command \nline, the value in the configuration file prevails\n</code></pre> <p><code>--socket-id=, -s</code></p> <pre><code>Socket ID encoded in BBS. Default=0\n</code></pre> <p><code>--bus-number=, -B</code></p> <pre><code>Bus number of the PCIe device. Default=0\n</code></pre> <p><code>--device=, -D</code></p> <pre><code>Device number of the PCIe device. Default=0\n</code></pre> <p><code>--function=, -F</code></p> <pre><code>Function number of the PCIe device. Default=0\n</code></pre> <p><code>--freq=, -T</code></p> <pre><code>Clock frequency in Hz. Default=400 MHz\n</code></pre> <p><code>--suppress-hdr, -S</code></p> <pre><code>Suppress column headers for text output. Default=off\n</code></pre> <p><code>--csv, -V</code></p> <pre><code>Comma separated value format. Default=off\n</code></pre>"},{"location":"sw/fpga_tools/readme/#lpbk1-test-options","title":"lpbk1 test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=D8424DC4-A4A3-C413-F89E-433683F9040B\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -U</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I Default=wrline-M\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. Default=auto\n</code></pre>"},{"location":"sw/fpga_tools/readme/#read-test-options","title":"read test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Attempt to prime the cache with hits. Default=off, Attempt to prime the \ncache with misses. Default=off\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Attempt to prime the cpu cache with misses. Default=off\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre>"},{"location":"sw/fpga_tools/readme/#write-test-options","title":"write test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I Default=wrline-M\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Attempt to prime the cache with hits. Default=off, Attempt to prime the \ncache with misses. Default=off\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Attempt to prime the cpu cache with misses. Default=off\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=`WRITE-VC`\n</code></pre> <p><code>--alt-wr-pattern, -l</code></p> <pre><code>Alternate Write Pattern. Default=off\n</code></pre>"},{"location":"sw/fpga_tools/readme/#trput-test-options","title":"trput test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. Default=off\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode (microseconds portion default=0; milliseconds \nportion default=0; seconds portion default=1; minutes portion default=0;\nhours portion default=0)\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I Default=wrline-M\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be  auto, vl0, vh0, vh1. Default=`WRITE-VC`\n</code></pre>"},{"location":"sw/fpga_tools/readme/#sw-test-options","title":"sw test options","text":"<p><code>--guid=, -g</code></p> <pre><code>Accelerator ID to enumerate. Default=7BAF4DEA-A57C-E91E-168A-455D9BDA88A3\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. Default=1, B = number of cache lines\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. Default=B, B and E designate number of cache lines\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. Default=1\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. Default=1\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I. Default=wrline-M\n</code></pre> <p><code>--cache-hint= -i</code></p> <pre><code>Can be rdline-I or rdline-S. Default=rdline-I\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random Default=auto\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random Default=auto\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. Default=`WRITE-VC`\n</code></pre> <p><code>--notice=, -N</code></p> <pre><code>Can be poll, csr-write, umsg-data, or umsg-hint. Default=poll\n</code></pre>"},{"location":"sw/fpga_tools/readme/#examples_3","title":"EXAMPLES","text":"<p>This command starts an <code>lpbk1</code> test on the FPGA on bus <code>0x5e</code>. The test  copies 57535, 57536, 57537, ..., up to 65535 cache lines, one line at a time. The test output is printed in the CSV format with header suppressed. <pre><code>./fpgadiag --mode=lpbk1 --target=fpga -SV --bus-number=0x5e --begin=57535\n--end=65535 --cache-hint=rdline-I --cache-policy=wrpush-I --multi-cl=1\n--write-vc=vl0 --read-vc=vh1 --wrfence-vc=auto\n</code></pre></p> <p>This command starts a <code>read</code> test on the FPGA located on bus <code>0xbe</code>. The test reads 2045 cache lines in the continuous mode with a 15-second timeout period.  Data is accessed with a strided pattern with a 10-byte stride length. <pre><code>./fpgadiag --mode=read --target=fpga -SV --bus-number=0xbe --begin=2045 --cont\n--timeout-sec=15   --cache-hint=rdline-I --multi-cl=1 -a=10 --write-vc=vh1\n--read-vc=auto --wrfence-vc=auto\n</code></pre></p> <p>This command starts an <code>sw</code> test on the FPGA located on bus <code>0xbe</code>. The test notifies completion using a CSR write. <pre><code>./fpgadiag --mode=sw --target=fpga -SV --bus-number=0xbe --begin=4 --end=8192\n--cache-hint=rdline-I --cache-policy=wrline-I --notice=csr-write --write-vc=vl0\n--wrfence-vc=auto --read-vc=random \n</code></pre></p>"},{"location":"sw/fpga_tools/readme/#troubleshooting_1","title":"TROUBLESHOOTING","text":"<p>When a test fails to run or gives errors, check the following:</p> <ul> <li>Is Intel FPGA driver properly installed?  See Installation Guide  for driver installation instructions.</li> <li>Are FPGA port permissions set properly? Check the permission bits of the port, for example, <code>/dev/intel-fpga-port-0</code>. Users need READ and WRITE permissions to run <code>fpgadiag</code> tests.</li> <li>Is hugepage properly configured on the system?  See Installation Guide for hugepage configuration steps.</li> <li>Is the required bitstream loaded? See DESCRIPTION for information about what bitstream is required by which test.</li> <li>Are <code>--begin</code> and <code>--end</code> values set properly? <code>--end</code> must be no smaller than the <code>--begin</code>. Also, <code>--begin</code> must be a multiple of the <code>--multi-cl</code> value.</li> <li>The <code>--warm-fpga-cache</code> and <code>--cool-fpga-cache</code> options in the <code>read</code> and <code>write</code> tests are mutually exclusive.</li> <li>The timeout options are only meaningful for the continuous mode  (with the <code>--cont</code> option).</li> </ul>"},{"location":"sw/fpga_tools/readme/#mmlink","title":"mmlink","text":""},{"location":"sw/fpga_tools/readme/#name_4","title":"NAME","text":"<p>MMLink - Debugging RTL.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_4","title":"SYNOPSIS","text":"<p><code>mmlink [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;TCP port&gt;] [-I &lt;IP Address&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_4","title":"DESCRIPTION","text":"<p>Remote signaltap is software  tool used for debug RTL (AFU), effectively a signal trace capability that Quartus places into a green bitstream. Remote Signal Tap provides  access the RST part of the Port MMIO space, and then runs the remote protocol on top.</p>"},{"location":"sw/fpga_tools/readme/#examples_4","title":"EXAMPLES","text":"<p><code>./mmlink  -B 0x5e -P 3333</code></p> <p>MMLink app starts and listens for connection.</p>"},{"location":"sw/fpga_tools/readme/#options_1","title":"OPTIONS","text":"<p><code>-B,--bus</code> FPGA Bus number.</p> <p><code>-D,--device</code> FPGA Device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-P,--port</code> TCP port number.</p> <p><code>-I,--ip</code> IP address of FPGA system. </p>"},{"location":"sw/fpga_tools/readme/#notes","title":"NOTES","text":"<p>Driver privilege:</p> <p>Change AFU driver privilege to user .</p> <p>command: chmod 777 /dev/intel-fpga-port.0</p> <p>set memlock:    </p> <p>command: ulimit -l 10000</p>"},{"location":"sw/fpga_tools/readme/#coreidle","title":"coreidle","text":""},{"location":"sw/fpga_tools/readme/#name_5","title":"NAME","text":"<p>coreidle - idles cores for shared TDP sockets to run online cores at maximum capacity.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_5","title":"SYNOPSIS","text":"<p><code>coreidle [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-G &lt;GBS path&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_5","title":"DESCRIPTION","text":"<p>This tools parses input GBS, extracts power from metadata ,calculates fpga power, number of online and idle cores. It moves threads from idle cores to online cores.</p>"},{"location":"sw/fpga_tools/readme/#examples_5","title":"EXAMPLES","text":"<p><code>./coreidle  -B 0x5e -G /home/lab/gbs/mode0.gbs</code></p> <p>Idle cores to run online cores at maximum capacity.</p>"},{"location":"sw/fpga_tools/readme/#options_2","title":"OPTIONS","text":"<p><code>-B,--bus</code> FPGA Bus number.</p> <p><code>-D,--device</code> FPGA Device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-G,--gbs</code> Green bitstream file path.</p>"},{"location":"sw/fpga_tools/readme/#fpgamux","title":"fpgamux","text":""},{"location":"sw/fpga_tools/readme/#name_6","title":"NAME","text":"<pre><code>fpgamux - Software MUX for running multiple AFU (accelerator functional unit) tests in one GBS (green bitsream)\n</code></pre>"},{"location":"sw/fpga_tools/readme/#synopsis_6","title":"SYNOPSIS","text":"<pre><code>fpgamux [-h] [-S|--socket-id SOCKET_ID] [-B|--bus-number BUS] [-D|--device DEVICE] [-F|--function FUNCTION]\n          [-G|--guid GUID] -m|--muxfile MUXFILE.json\n</code></pre>"},{"location":"sw/fpga_tools/readme/#description_6","title":"DESCRIPTION","text":"<p>fpgamux is a testing tool to interact with multiple AFUs that have been synthesized into one GBS along with the CCIP-MUX BBB (basic building block). The CCIP-MUX uses upper bits in the MMIO addresses to route MMIO reads/writes to the AFU running on the corresponding CCIP-MUX port. fpgamux uses a configuration file that lists the software components and configuration to use.</p> <p>.. note::</p> <pre><code>  Only one (the first) AFU is discoverable by the OPAE driver. Enumerating acceleration on an FPGA will find\n  the accelerator associated with the first AFU only. The first software component in the configuration will\n  be used to determine the GUID to use for enumeration. This can be overridden with the -G|--guid option.\n</code></pre>"},{"location":"sw/fpga_tools/readme/#options_3","title":"OPTIONS","text":"<pre><code>-S SOCKET_ID, --socket-id SOCKET_ID\n   socket id of FPGA resource\n\n-B BUS, --bus BUS\n   bus id of FPGA resource\n\n-D DEVICE, --device DEVICE\n   device id of FPGA resource\n\n\n-F FUNCTION, --function FUNCTION\n   function id of FPGA resource\n\n-G, --guid\n   specify what guid to use for the accelerator enumeration\n</code></pre>"},{"location":"sw/fpga_tools/readme/#configuration","title":"CONFIGURATION","text":"<p>fpgamux uses a configuration file (in JSON format) to determine what software components to instantiate and how to configure them for interacting with the AFUs in the GBS. This schema for this is listed below:</p> <pre><code>[\n    {\n        \"app\" : \"fpga_app\",\n        \"name\" : \"String\",\n        \"config\" : \"Object\"\n    }\n]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#examples_6","title":"EXAMPLES","text":"<p>An example configuration with two components is listed below:</p> <pre><code>[\n    {\n        \"app\" : \"nlb0\",\n        \"name\" : \"nlb0\",\n        \"config\" :\n        {\n            \"begin\" : 1,\n            \"end\" : 1,\n            \"multi-cl\" : 1,\n            \"cont\" : false,\n            \"cache-policy\" : \"wrline-M\",\n            \"cache-hint\" : \"rdline-I\",\n            \"read-vc\" : \"vh0\",\n            \"write-vc\" : \"vh1\",\n            \"wrfence-vc\" : \"write-vc\",\n            \"timeout-usec\" : 0,\n            \"timeout-msec\" : 0,\n            \"timeout-sec\" : 1,\n            \"timeout-min\" : 0,\n            \"timeout-hour\" : 0,\n            \"freq\" : 400000000\n        }\n    },\n    {\n        \"app\" : \"nlb3\",\n        \"name\" : \"nlb3\",\n        \"config\" :\n        {\n            \"mode\" : \"read\",\n            \"begin\" : 1,\n            \"end\" : 1,\n            \"multi-cl\" : 1,\n            \"strided-access\" : 1,\n            \"cont\" : false,\n            \"warm-fpga-cache\" : false,\n            \"cool-fpga-cache\" : false,\n            \"cool-cpu-cache\" : false,\n            \"cache-policy\" : \"wrline-M\",\n            \"cache-hint\" : \"rdline-I\",\n            \"read-vc\" : \"vh0\",\n            \"write-vc\" : \"vh1\",\n            \"wrfence-vc\" : \"write-vc\",\n            \"alt-wr-pattern\" : false,\n            \"timeout-usec\" : 0,\n            \"timeout-msec\" : 0,\n            \"timeout-sec\" : 1,\n            \"timeout-min\" : 0,\n            \"timeout-hour\" : 0,\n            \"freq\" : 400000000\n        }\n    }\n]\n</code></pre>"},{"location":"sw/fpga_tools/readme/#userclk","title":"userclk","text":""},{"location":"sw/fpga_tools/readme/#name_7","title":"NAME","text":"<p>userclk - to set afu high and low clock frequency.</p>"},{"location":"sw/fpga_tools/readme/#synopsis_7","title":"SYNOPSIS","text":"<p><code>userclk [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;Port id&gt;] [-H &lt;User clock high frequency&gt;] -L &lt;User clock low frequency&gt;]</code></p>"},{"location":"sw/fpga_tools/readme/#description_7","title":"DESCRIPTION","text":"<p>userclk tool used to set high and low clock frequency to acceleration function unit.</p>"},{"location":"sw/fpga_tools/readme/#examples_7","title":"EXAMPLES","text":"<p><code>./userclk  -B 0x5e -H 400 -L 200</code></p> <p>Sets AFU frequency.</p>"},{"location":"sw/fpga_tools/readme/#options_4","title":"OPTIONS","text":"<p><code>-B,--bus</code> FPGA Bus number.</p> <p><code>-D,--device</code> FPGA Device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-P,--port</code> Port id.</p> <p><code>-H,--freq-high</code> User clock high frequency. </p> <p><code>-L,--freq-low</code> User clock low frequency. </p>"},{"location":"sw/fpga_tools/coreidle/coreidle/","title":"coreidle","text":""},{"location":"sw/fpga_tools/coreidle/coreidle/#synopsis","title":"SYNOPSIS","text":"<p><code>coreidle [-v] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-G &lt;GBS path&gt;]</code></p>"},{"location":"sw/fpga_tools/coreidle/coreidle/#description","title":"DESCRIPTION","text":"<p><code>coreidle</code> parses the Accelerator Function Unit (AFU) metadata and extracts power information. <code>coreidle</code> calculates the FPGA power and calculates the number of online and idle cores. It moves threads from idle cores to online cores.  <code>coreidle</code> is only available the Integrated FPGA Platform. You cannot run <code>coreidle</code> on the PCIe Accelerator Card (PAC).</p>"},{"location":"sw/fpga_tools/coreidle/coreidle/#examples","title":"EXAMPLES","text":"<p><code>./coreidle  -B 0x5e -G /home/lab/gbs/mode0.gbs</code></p> <p>Idle cores to run online cores at maximum capacity.</p>"},{"location":"sw/fpga_tools/coreidle/coreidle/#options","title":"OPTIONS","text":"<p><code>-v,--version</code> Prints version information and exit.</p> <p><code>-B,--bus</code> FPGA bus number.</p> <p><code>-D,--device</code> FPGA device number.</p> <p><code>-F,--functio</code> FPGA function number.</p> <p><code>-S,--socket</code> FPGA socket number.</p> <p><code>-G,--gbs</code> Green bitstream file path.</p>"},{"location":"sw/fpga_tools/fecmode/fecmode/","title":"fecmode (N3000 specific tool)","text":""},{"location":"sw/fpga_tools/fecmode/fecmode/#synopsis","title":"SYNOPSIS","text":"<pre><code>fecmode [&lt;mode&gt;][&lt;args&gt;]\n</code></pre>"},{"location":"sw/fpga_tools/fecmode/fecmode/#description","title":"DESCRIPTION","text":"<p>Fecmode changes FEC mode of external ethernet PHY, this tool only support on N3000 Card.</p>"},{"location":"sw/fpga_tools/fecmode/fecmode/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>--segment, -S</code></p> <p>segment number of the PCIe device.</p> <p><code>--bus, -B</code> </p> <p>bus number of the PCIe device. </p> <p><code>--device, -D</code> </p> <p>device number of the PCIe device.</p> <p><code>--function, -F</code> function number of the PCIe device</p> <p><code>--rsu, -r</code> reboot card only if mode is not configured</p> <p><code>--debug, -d</code> output debug information </p>"},{"location":"sw/fpga_tools/fecmode/fecmode/#fec-mode","title":"FEC Mode","text":"<p><code>no</code> no FEC.</p> <p><code>kr</code> BaseR FEC (Fire-Code) correction \u2013 4 orders</p> <p><code>rs</code> Reed-Solomon FEC correction \u2013 7 orders</p>"},{"location":"sw/fpga_tools/fecmode/fecmode/#example","title":"EXAMPLE","text":"<p>This command change FEC mode to \u201ckr\u201d: <pre><code># fecmode -B 0x25 kr\n</code></pre></p> <p>This command reboot card (no need to specify bus number if there is only one card): <pre><code># fecmode -r\n</code></pre></p> <p>This command display the current FEC mode: <pre><code># fecmode\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/","title":"fpgabist","text":""},{"location":"sw/fpga_tools/fpgabist/fpgabist/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgabist [-h] [-i device_id] [-b bus] [-d device] [-f function] [path_to_gbs1 path_to_gbs2 ...]\n</code></pre>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#description","title":"DESCRIPTION","text":"<p>The <code>fpgabist</code> tool performs self-diagnostic tests on supported FPGA platforms.</p> <p>The tool accepts one or more Accelerator Function (AF) binaries from a predetermined set of AFs. Depending on the available binaries,  the tool runs appropriate tests and reports hardware issues.</p> <p><code>fpgabist</code> always uses <code>fpgainfo</code> to report system information before running any hardware tests.</p> <p>Currently, <code>fpgabist</code> accepts the following AFs:    1. nlb_mode_3: The native loopback (NLB) test implements a loopback from TX to RX. Use it to verify basic functionality    and to measure bandwidth.    2. dma_afu: The direct memory access (DMA) AFU test transfers data from host memory to FPGA-attached local memory. </p> <p>The installation includes the AF files, but you can also compile the AFs from the source. </p> <p>If there are multiple PCIe\u00ae devices, use -b, -d, -f to specify the BDF for the specific PCIe\u00ae device.</p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>[path_to_gbs1 path_to_gbs2 ...]</code></p> <p>Paths to Accelerator Function (AF) files.</p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p>You can use the single letter or the full parameter name for the command line arguments.</p> <p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>-i device_id, --device-id device_id</code></p> <p>Device ID for Intel FPGA. Default is: 0x09c4</p> <p><code>-B bus, --bus bus</code></p> <p>Bus number for specific FPGA</p> <p><code>-D device, --device device</code></p> <p>Device number for specific FPGA</p> <p><code>-F function, --function function</code></p> <p>Function number for specific FPGA</p>"},{"location":"sw/fpga_tools/fpgabist/fpgabist/#examples","title":"EXAMPLES","text":"<p><code>fpgabist &lt;path_to_gbs_files&gt;/dma_afu.gbs &lt;path_to_gbs_files&gt;/nlb_3.gbs</code></p> <p>Runs <code>fpgabist</code> on any platform in the system that matches the default device ID. This command runs both the DMA and   NLB_MODE_3 tests.</p> <p><code>fpgabist -i 09c4 -b 5 &lt;path to gbs&gt;/dma_afu.gbs</code></p> <p>Runs <code>fpgabist</code> the DMA test on the PCIe\u00ae  Endpoint with <code>device_id</code> 09c4 on bus 5. </p>"},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/","title":"fpgaconf","text":""},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgaconf [-hvVn] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] &lt;gbs&gt;</code></p>"},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/#description","title":"DESCRIPTION","text":"<p><code>fpgaconf</code> configures the FPGA with the accelerator function (AF). It also checks the AF for compatibility with  the targeted FPGA and the FPGA Interface Manager (FIM). <code>fpgaconf</code> takes the following arguments: </p> <p><code>-h, --help</code></p> <pre><code>Prints usage information.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-V, --verbose</code></p> <pre><code>Prints more verbose messages while enumerating and configuring. Can be\nrequested more than once.\n</code></pre> <p><code>-n, --dry-run</code></p> <pre><code>Performs enumeration. Skips any operations with side-effects such as the\nactual AF configuration.\n</code></pre> <p><code>-S, --segment</code></p> <pre><code>PCIe segment number of the target FPGA.\n</code></pre> <p><code>-B, --bus</code></p> <pre><code>PCIe bus number of the target FPGA.\n</code></pre> <p><code>-D, --device</code></p> <pre><code>PCIe device number of the target FPGA.\n</code></pre> <p><code>-F, --function</code></p> <pre><code>PCIe function number of the target FPGA.\n</code></pre> <p><code>--force</code></p> <pre><code>Reconfigure the AFU even if it is in use.\n</code></pre> <p><code>fpgaconf</code> enumerates available FPGA devices in the system and selects compatible FPGAs for configuration. If more than one FPGA is compatible with the AF, <code>fpgaconf</code> exits and asks you to be more specific in selecting the target FPGAs by specifying a a PCIe BDF.</p>"},{"location":"sw/fpga_tools/fpgaconf/fpgaconf/#examples","title":"EXAMPLES","text":"<p><code>fpgaconf my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to a compatible FPGA.\n</code></pre> <p><code>fpgaconf -V -B 0x3b my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA in bus 0x3b, if compatible,\nwhile printing out slightly more verbose information.\n</code></pre> <p><code>fpgaconf 0000:3b:00.0 my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA at address 0000:3b:00.0.\n</code></pre>"},{"location":"sw/fpga_tools/fpgad/fpgad/","title":"fpgad","text":""},{"location":"sw/fpga_tools/fpgad/fpgad/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgad --daemon [--version] [--directory=&lt;dir&gt;] [--logfile=&lt;file&gt;] [--pidfile=&lt;file&gt;] [--umask=&lt;mode&gt;] [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code> <code>fpgad [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code></p>"},{"location":"sw/fpga_tools/fpgad/fpgad/#description","title":"DESCRIPTION","text":"<p>fpgad monitors the device sensors, checking for sensor values that are out of the prescribed range. </p> <p>When any of the sensors is detected to be out of bounds, fpgad will focus on keeping the server from rebooting by masking PCIE AER, and send a message to system administrator. System administrator can take further actions like stop the application and stop the FPGA, but fpgad just focus on monitor the sensors and will not take any cooling actions. </p> <p>Note: fpgad must be running (as root) and actively monitoring devices when a sensor anomaly occurs in order to initiate Graceful Shutdown.  If fpgad is not loaded during such a sensor anomaly, the out-of-bounds scenario will not be detected, and the resulting effect on the hardware is undefined.</p>"},{"location":"sw/fpga_tools/fpgad/fpgad/#arguments","title":"ARGUMENTS","text":"<p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-d, --daemon</code></p> <pre><code>When specified, fpgad executes as a system daemon process.\n</code></pre> <p><code>-D, --directory &lt;dir&gt;</code></p> <pre><code>When running in daemon mode, run from the specified directory.\nIf omitted when daemonizing, `fpgad` uses /tmp.\n</code></pre> <p><code>-l, --logfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, send output to file. When not in daemon mode, the output goes to stdout.\nIf omitted when daemonizaing, fpgad uses /tmp/fpgad.log.\n</code></pre> <p><code>-p, --pidfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, write the daemon's process id to a file.\nIf omitted when daemonizing, fpgad uses /tmp/fpgad.pid.\n</code></pre> <p><code>-m, --umask &lt;mode&gt;</code></p> <pre><code>When running in daemon mode, use the mode value as the file mode creation mask passed to umask.\nIf omitted when daemonizing, fpgad uses 0.\n</code></pre> <p><code>-s, --socket &lt;sock&gt;</code></p> <pre><code>Listen for event API registration requests on the UNIX domain socket on the specified path. \nThe default=/tmp/fpga_event_socket.\n</code></pre> <p><code>-n, --null-bitstream &lt;file&gt;</code></p> <pre><code>Specify the NULL bitstream to program when an AP6 event occurs. This option may be specified multiple\ntimes. The AF, if any, that matches the FPGA's PR interface ID is programmed when an AP6\nevent occurs.\n</code></pre>"},{"location":"sw/fpga_tools/fpgad/fpgad/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>If you encounter any issues, you can get debug information in two ways:</p> <ol> <li>By examining the log file when in daemon mode.</li> <li>By running in non-daemon mode and viewing stdout.</li> </ol>"},{"location":"sw/fpga_tools/fpgad/fpgad/#examples","title":"EXAMPLES","text":"<p><code>fpgad --daemon --null-bitstream=my_null_bits.gbs</code></p> <p>This command starts fpgad as a system daemon process: <pre><code>sudo systemctl start fpgad\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgadiag/","title":"fpgadiag","text":""},{"location":"sw/fpga_tools/fpgadiag/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgadiag [-m | --mode=] &lt;mode&gt; [-t | --target=] &lt;target&gt; [options]\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#description","title":"DESCRIPTION","text":"<p>Includes several tests to diagnose, test, and report on the FPGA hardware.</p> <p><code>&lt;mode&gt;</code> chooses which test to run.  <code>&lt;target&gt;</code> specifies the platform that runs the test. <code>&lt;target&gt;</code> can be either <code>fpga</code> or <code>ase</code> where <code>ase</code>.  <code>&lt;ase&gt;</code> is the abbreviation for Accelerator Simulation Environment.</p> <p>The <code>&lt;mode&gt;</code> selects from the  following tests:</p> <p>lpbk1</p> <p>This test runs a loopback test on the number of cachelines specified with  the <code>BEGIN</code> option. <code>fpgadiag</code> sets up source and  destination buffers in  main memory. The FPGA then performs a <code>memcpy</code> from a source buffer to the  destination buffer, one cacheline at a time. </p> <p>A cacheline is 64 bytes. When <code>BEGIN = END</code>, the test performs one iteration. When  <code>BEGIN = END + x</code>, the test performs <code>x</code> iterations. The first iteration consists  of copying <code>BEGIN</code> cachelines; the second iteration consists of copying  <code>BEGIN+1</code> cache lines. The third iteration consists of copying <code>BEGIN+2</code>  cache lines, and so on. </p> <p>The latency is shown as the number of clock cycles. </p> <p>When you specify <code>MULTI-CL</code>, you copy <code>MULTI-CL</code> cache lines at a time. The WR-FENCE chooses on which virtual channel the WrFence occurs.</p> <p>If you specify continuous mode with <code>--cont</code>, the program iterates until the timeout specified in <code>TIMEOUT</code> completes.</p> <p>read</p> <p>This test performs reads. Use this test to measure read bandwidth. </p> <p>write </p> <p>This test performs writes. Use it to measure write bandwidth. </p> <p>trput</p> <p>This test measures both read and write bandwidth by performing 50% read and  50% write tests.</p> <p>sw</p> <p>This is a send-and-respond (ping-pong) test. One side sends data and  waits for response.</p> <p>Each test requires a particular AF. Before running a test, make sure the required AF is properly configured on the platform. </p> <ul> <li>The lpbk1 test requires the nlb mode 0 AF.</li> <li>The trput test requires the nlb mode 3 AF. </li> <li>The sw test requires the nlb mode 7 AF. This AF is only available for the integrated FPGA platform.      You cannot run it on the PCIe accelerator card (PAC).</li> </ul> <p>fpgalpbk</p> <p>This enable/disable FPGA loopback.</p> <p>fpgastats</p> <p>This get fpga mac statistics.</p> <p>mactest</p> <p>This compare mac addresses that read from MAC ROM with mac addresses read from Host side.</p>"},{"location":"sw/fpga_tools/fpgadiag/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/fpgadiag/#common-options","title":"Common options","text":"<p><code>--help, -h</code></p> <pre><code>Print help information and exit.\n</code></pre> <p><code>--target=, -t</code></p> <pre><code>This switch specifies fpga (hardware) or ase (simulation). The default=fpga.\n</code></pre> <p><code>--mode=, -m</code></p> <pre><code>The test to run. The valid values are `lpbk1`, `read`,\n`write`, `trput`, and `sw`.\n</code></pre> <p><code>--config=, -c</code></p> <pre><code>A configuration file in the JSON format that specifies options for a test.\nIf an option is specified both in the configuration file and on the command \nline, the value in the configuration file takes precedence.\n</code></pre> <p><code>--dsm-timeout-usec</code></p> <pre><code>Timeout in microseconds for test completion. The test fails if not completed by \nspecified timeout. The default=1000000.\n</code></pre> <p><code>--socket-id=, -s</code></p> <pre><code>Socket ID encoded in FPGA Interface Manager (FIM). The default=0.\n</code></pre> <p><code>--bus=, -B</code></p> <pre><code>Bus number of the PCIe device. The default=0.\n</code></pre> <p><code>--device=, -D</code></p> <pre><code>Device number of the PCIe device. The default=0.\n</code></pre> <p><code>--function=, -F</code></p> <pre><code>Function number of the PCIe device. The default=0.\n</code></pre> <p><code>--freq=, -T</code></p> <pre><code>Clock frequency (in Hz) used for bandwidth calculation. The default=400000000 Hz (400 MHz).\n</code></pre> <p><code>eval_rst .. note::     This frequency is used only when the software cannot infer the frequency from the accelerator.</code></p> <p><code>--suppress-hdr, -S</code></p> <pre><code>Suppress column headers for text output. The default=off.\n</code></pre> <p><code>--csv, -V</code></p> <pre><code>Comma separated value format. The default=off.\n</code></pre> <p><code>--suppress-stats</code></p> <pre><code>Suppress statistics output at the end of test. The default=off.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#lpbk1-test-options","title":"lpbk1 test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=D8424DC4-A4A3-C413-F89E-433683F9040B.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I The default=wrline-M.\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. The default=auto.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#read-test-options","title":"read test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. The default=1.\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Try to prime the cache with hits. The default=off. Try to prime the \ncache with misses. The default=off.\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Try to prime the cpu cache with misses. The default=off.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#write-test-options","title":"write test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. The default=1.\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I The default=wrline-M\n</code></pre> <p><code>--warm-fpga-cache -H; --cool-fpga-cache -M</code></p> <pre><code>Try to prime the cache with hits. The default=off. Try to prime the \ncache with misses. The default=off.\n</code></pre> <p><code>--cool-cpu-cache, -C</code></p> <pre><code>Try to prime the cpu cache with misses. The default=off.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=`WRITE-VC`.\n</code></pre> <p><code>--alt-wr-pattern, -l</code></p> <pre><code>Alternate Write Pattern. The default=off.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#trput-test-options","title":"trput test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=F7DF405C-BD7A-CF72-22F1-44B0B93ACD18.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--multi-cl=M, -u</code></p> <pre><code>M can equal 1, 2, or 4. The default=1.\n</code></pre> <p><code>--strided-access=S, -a</code></p> <pre><code>1&lt;= S &lt;= 64. The default=1\n</code></pre> <p><code>--cont, -L</code></p> <pre><code>Continuous mode. The default=off.\n</code></pre> <p><code>--timeout-usec=, --timeout-msec=, --timeout-sec=, --timeout-min=, --timeout-hour=</code></p> <pre><code>timeout for --cont mode. The default for all options is 0.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I The default=wrline-M.\n</code></pre> <p><code>--cache-hint=, -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random. The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be  auto, vl0, vh0, vh1. The default=`WRITE-VC`.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#sw-test-options","title":"sw test options","text":"<p><code>--guid=, -g</code></p> <pre><code>AFU ID to enumerate. The default=7BAF4DEA-A57C-E91E-168A-455D9BDA88A3.\n</code></pre> <p><code>--begin=B, -b</code></p> <pre><code>1 &lt;= B &lt;= 65535. The default=1, B = number of cache lines.\n</code></pre> <p><code>--end=E, -e</code></p> <pre><code>1 &lt;= E &lt;= 65535. The default=B, B and E designate number of cache lines.\n</code></pre> <p><code>--cache-policy=, -p</code></p> <pre><code>Can be wrline-I, wrline-M, or wrpush-I. The default=wrline-M.\n</code></pre> <p><code>--cache-hint= -i</code></p> <pre><code>Can be rdline-I or rdline-S. The default=rdline-I.\n</code></pre> <p><code>--read-vc=, -r</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random The default=auto.\n</code></pre> <p><code>--write-vc=, -w</code></p> <pre><code>Can be auto, vl0, vh0, vh1, random The default=auto.\n</code></pre> <p><code>--wrfence-vc=, -f</code></p> <pre><code>Can be auto, vl0, vh0, vh1. The default=`WRITE-VC`.\n</code></pre> <p><code>--notice=, -N</code></p> <pre><code>Can be poll or csr-write. The default=poll.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#enable-fpga-n3000-ethernet-group-vfio-mdev","title":"Enable FPGA N3000 Ethernet group VFIO mdev","text":"<p>FPGA DFL driver does not support any ioctls to read/write ethernet group info and registers. Users can read/write eth group registers by enabling VFIO mdev. Unbind the dfl_eth_group driver and bind vfio-mdev-dfl driver for ethernet group dfl-device; then userspace can take full control of ethernet group feature id 10.</p> <p>Ethernet group must be enabled before running fpgalpbk, mactest tools.</p>"},{"location":"sw/fpga_tools/fpgadiag/#steps-to-enablecreate-vfio-mdev","title":"Steps to enable/create vfio mdev","text":"<pre><code>unbind eth group feature id 10:\n    echo dfl-fme.0.8 &gt; /sys/bus/dfl/drivers/dfl-eth-group/unbind\n    echo dfl-fme.0.7 &gt; /sys/bus/dfl/drivers/dfl-eth-group/unbind\nbind to vfio-mdev-dfl:\n    echo vfio-mdev-dfl &gt; /sys/bus/dfl/devices/dfl-fme.0.7/driver_override\n    echo vfio-mdev-dfl &gt; /sys/bus/dfl/devices/dfl-fme.0.8/driver_override\nload vfio driver:\n    modprobe vfio_pci\n    modprobe vfio_iommu_type1\n    modprobe vfio_mdev\n    modprobe vfio_mdev_dfl\ntrigger mdev:\n    echo dfl-fme.0.7 &gt;/sys/bus/dfl/drivers_probe\n    echo dfl-fme.0.8 &gt;/sys/bus/dfl/drivers_probe\n    echo 83b8f4f2-509f-382f-3c1e-e6bfe0fa1001 &gt; /sys/bus/dfl/devices/dfl-fme.0.7/mdev_supported_types/vfio-mdev-dfl-1/create\n    echo 83b8f4f2-509f-382f-3c1e-e6bfe0fa1002 &gt; /sys/bus/dfl/devices/dfl-fme.0.8/mdev_supported_types/vfio-mdev-dfl-1/create\n\nlinux kerenl msg after enabling mdev:\n    i40e 0000:b3:00.0 eth1: NIC Link is Down\n    i40e 0000:b1:00.1 eth0: NIC Link is Down\n    vfio-mdev-dfl dfl-fme.2.7: MDEV: Registered\n    vfio-mdev-dfl dfl-fme.2.8: MDEV: Registered\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1005: Adding to iommu group 140\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1005: MDEV: group_id = 140\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1006: Adding to iommu group 141\n    vfio_mdev 83b8f4f2-509f-382f-3c1e-e6bfe0fa1006: MDEV: group_id = 141\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#remove-vfio-mdev","title":"Remove vfio mdev","text":"<pre><code>    echo 1 | sudo tee /sys/bus/mdev/devices/83b8f4f2-509f-382f-3c1e-e6bfe0fa1002/remove\n    echo 1 | sudo tee /sys/bus/mdev/devices/83b8f4f2-509f-382f-3c1e-e6bfe0fa1001/remove\n\n    rmmod vfio_mdev_dfl\n    modprobe dfl_eth_group\n\n    echo dfl-fme.0.7 &gt;/sys/bus/dfl/drivers_probe\n    echo dfl-fme.0.8 &gt;/sys/bus/dfl/drivers_probe\n\n    echo dfl-eth-group &gt; /sys/bus/dfl/devices/dfl-fme.0.7/driver_override\n    echo dfl-eth-group &gt; /sys/bus/dfl/devices/dfl-fme.0.8/driver_override\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#fpgalpbk-test-options","title":"fpgalpbk test options","text":"<p><code>--enable</code></p> <pre><code>Enable fpga phy loopback.\n</code></pre> <p><code>--disable</code></p> <pre><code>Disable fpga phy loopback.\n</code></pre> <p><code>--direction</code></p> <pre><code>Can be local, remote.\n</code></pre> <p><code>--type</code></p> <pre><code>Can be serial, precdr, postcdr.\n</code></pre> <p><code>--side</code></p> <pre><code>Can be line, host.\n</code></pre> <p><code>--port</code></p> <pre><code>0 &lt;= port &lt;= 7, the default is all.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#mactest-test-options","title":"mactest test options","text":"<p><code>--offset</code></p> <pre><code>Read mac addresses from an offset, The default=0.\n</code></pre>"},{"location":"sw/fpga_tools/fpgadiag/#examples","title":"EXAMPLES","text":"<p>This command starts a <code>lpbk1</code> test for the FPGA on bus <code>0x5e</code>. The test  copies 57535, 57536, 57537 ... up to 65535 cache lines, one line at a time. The test prints output in the comma separated values (CSV) format with the header suppressed. <pre><code>./fpgadiag --mode=lpbk1 --target=fpga -V --bus=0x5e --begin=57535\n--end=65535 --cache-hint=rdline-I --cache-policy=wrpush-I --multi-cl=1\n--write-vc=vl0 --read-vc=vh1 --wrfence-vc=auto\n</code></pre></p> <p>This command starts a <code>read</code> test on the FPGA located on bus <code>0xbe</code>. The test reads 2045 cache lines in the continuous mode with a 15-second timeout period.  The reads use a strided pattern with a 10-byte stride length. <pre><code>./fpgadiag --mode=read --target=fpga -V --bus=0xbe --begin=2045 --cont\n--timeout-sec=15 --cache-hint=rdline-I --multi-cl=1 -a=10 \n--read-vc=auto --wrfence-vc=auto\n</code></pre></p> <p>This command starts a <code>sw</code> test on the FPGA located on bus <code>0xbe</code>. The test signals completion using a CSR write. <pre><code>./fpgadiag --mode=sw --target=fpga -V --bus=0xbe --begin=4 --end=8192\n--cache-hint=rdline-I --cache-policy=wrline-I --notice=csr-write --write-vc=vl0\n--wrfence-vc=auto --read-vc=random \n</code></pre></p> <p>This command enable a <code>fpgalpbk</code> on the FPGA located on bus <code>0xbe</code>. <pre><code>./fpgadiag -m fpgalpbk --bus 0xbe --enable --direction local --type postcdr\n--side host\n</code></pre></p> <p>This command show <code>fpgastats</code> on the FPGA located on bus <code>0xbe</code>. <pre><code>./fpgadiag -m fpgastats --bus 0xbe\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgadiag/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>When a test fails to run or gives errors, check the following:</p> <ul> <li>Is the Intel FPGA driver properly installed?  See Installation Guide  for driver installation instructions.</li> <li>Are FPGA port permissions set properly? Check the permission bits of the port, for example, <code>/dev/intel-fpga-port-0</code>. You need READ and WRITE permissions to run <code>fpgadiag</code> tests.</li> <li>Is hugepage properly configured on the system?  See Installation Guide for hugepage configuration steps. In particular, <code>fpgadiag</code> requires a few 1 GB pages. </li> <li>Is the required AFU loaded? See DESCRIPTION for information about what AFU the test requires.</li> <li>Are <code>--begin</code> and <code>--end</code> values set properly? <code>--end</code> must be larger than the <code>--begin</code>. Also, <code>--begin</code> must be a multiple of the <code>--multi-cl</code> value.</li> <li>The <code>--warm-fpga-cache</code> and <code>--cool-fpga-cache</code> options in the <code>read</code> and <code>write</code> tests are mutually exclusive.</li> <li>The timeout options are only meaningful for the continuous mode  (with the <code>--cont</code> option).</li> </ul>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/","title":"fpgaflash","text":""},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgaflash [-h] {user,factory} file [bdf]\n</code></pre>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#description","title":"DESCRIPTION","text":"<p>fpgaflash updates the static FIM image loaded from flash at power-on.</p> <p>If there are multiple devices in the system, fpgaflash must specify a BDF to select the correct device. If no BDF is specified, fpgaflash prints out the BDFs of any compatible devices.</p>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{user, factory}</code></p> <p>Specifies the type of flash programming.</p> <p><code>user</code> </p> <p>Only reprograms the user image in flash.  </p> <p><code>factory</code> </p> <p>Reprograms the entire flash.  A catastrophic failure during a factory update such as a power outage  requires a USB cable and <code>quartus_pgm</code> to recover.</p> <p><code>file</code></p> <p>Specifies the Raw Programming Data File (rpd) to program into flash.</p> <p><code>bdf</code></p> <p>Specifies the bus, device and function (BDF) of device to program such as 04:00.0 or 0000:04:00.0. This flag is optional when there is a single device in the system.</p>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Print usage information.</p>"},{"location":"sw/fpga_tools/fpgaflash/fpgaflash/#example","title":"EXAMPLE","text":"<p><code>fpgaflash user new_image.rpd 0000:04:00.0</code></p> <p>Programs new_image.rpd to flash of device with BDF 0000:04:00.0.</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/","title":"super-rsu","text":""},{"location":"sw/fpga_tools/fpgaflash/superrsu/#synopsis","title":"SYNOPSIS","text":"<pre><code>super-rsu [-h] [-n] [--verify] | [ [--log-level {trace,debug,error,warn,info,notset}]\n          [--log-file &lt;filename&gt;] [--rsu-only] [--with-rsu] [--force-flash] ]\n      rsu_config\n</code></pre>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#description","title":"DESCRIPTION","text":"<p>super-rsu is a tool that can be used for flashing image files and commanding an Intel PAC device to perform RSU (remote system update - or a board reboot). Performing an RSU on an Intel PAC device will cause it to reload any firmware or programmable logic and restart its execution, a requirement for any updated firmware or programmable logic to take effect.</p> <p>At the core of super-rsu is its configuration file (referred to in this document as 'rsu_config') which is essentially a manifest file for identifying both the target device and the binary images (and their versions) to be flashed.</p> <p>At a high level, the flow of super-rsu should be: 1. Read and parse rsu_config file 2. Use product identifiers (like vendor, device and any additional vendor, device    pairs that may be present in the PCIe bus) to locate all compatible    devices on the PCIe bus. 3. For every device found on the system, update the device using the flash    images defined in the \"flash\" section in the rsu_config data (or nvmupdate    section).    Each item in the \"flash\" section is a \"flash spec\" that contains:    * The flash type (\"user\", \"bmc_fw\", \"bmc_img\", ...)    * The filename of the image to flash. super-rsu will look for this file      first in the same directory of the rsu_config file, and then look in the      current working directory.    * The version of the image.    * An optional \"force\" indicator    * An optional \"requires\" indicator    The \"nvmupdate\" section is used to describe an Ethernet firmware file and    its version. 4. Using the data in the \"nvmupdate\" and \"flash\" sections, the update routine    involves:   * If an \"nvmupdate\" section is present:     1. Locate the file on the file system to use to flash the Ethernet device.     2. Call nvmupdate to get an \"inventory\" of devices matching the vendor and        device id in this section.     3. Use this data to dynamically generate an nvmupdate compatible        configuration file.     4. Call nvmupdate with the generated configuration file to flash the        Ethernet interfaces in the Vista Creek card (if version reported by        system does not match the version in this section).   * For each spec in the \"flash\" section:     1. Locate the file on the file system to use to flash.     2. Compare the version listed in the \"flash spec\" to version reported by        the target component.     3. Create a task to call fpgaflash if either of the following conditions is        met (and the revision specified is compatible):        * The \"force\" indicator is present and set to true.        * The version in the spec does not match the version reported by the          system OR the flash type is factory type.   * For each task created from the \"flash\" section:     1. Call fpgaflash with the command line arguments that correspond to the        flash type and the file name in the spec used to create the task.        This opens and controls the execution of fpgaflash in another process.</p> <p>NOTE: If the system reports a revision for one of the components being flashed, this revision must be in the set of revisions listed in the manifest. Example: if the system reports 'a' for bmc_img and the manifest includes 'ab', then the image will be flashed.</p> <p>NOTE: Each update routine is run in a thread specific to a device located on the PCIe bus. Every task in an update routine involves opening a new process that is controlled and managed by its update routine thread. If a task includes a timeout and the timeout is reached, a termination request will be sent to its process and it will be counted as a failure. If a global timeout is reached in the main thread, a termination request will be sent to each thread performing the update. Consequently, the update routine will give the current task extra time before terminating the process. The RSU operation will only be performed if requested with either <code>--with-rsu</code> command line argument or with the <code>--rsu-only</code> command line argument. The former will perform the RSU command upon successful completion of flash operations. The latter will skip the process of version matching and flashing images and will only perform the RSU command. It is recommended that super-rsu be executed again if any flash operation is interrupted.</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>rsu config</code></p> <p>Specifies the name of the file containing the RSU configuration (in JSON format)</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Print usage information.</p> <p><code>--verify</code></p> <p>Compare versions of flashable components on the system against the manifest.   Return non-zero exit if compatible components are not up to date.</p> <p><code>-n, --dry-run</code></p> <p>Don't perform any updates, just a dry run.   This will print out commands that can be executed   in a Linux shell.</p> <p><code>--log-level {trace,debug,error,warn,info,notset}</code></p> <p>Log level to use. Default is 'info'.</p> <p>`--log-file  (default: /tmp/super-rsu.log) <p>Emit log messages (with DEBUG level) to filename   NOTE: The default log file (/tmp/super-rsu.log) is set to rollover every   time super-rsu is executed. This will create numbered backups before   truncating the log file. The maximum number of backups is 50.</p> <p><code>--rsu-only</code></p> <p>Only perform the RSU command.</p> <p><code>--with-rsu</code></p> <p>Perform RSU after updating flash components(experimental)</p> <p><code>--force-flash</code></p> <p>Flash all images regardless of versions matching or not.</p>"},{"location":"sw/fpga_tools/fpgaflash/superrsu/#configuration","title":"CONFIGURATION","text":"<p>The following is the JSON schema expected by super-rsu. Any deviance from this schema may result in errors executing super-rsu.</p> <pre><code>{\n\"definitions\": {},\n\"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\"$id\": \"http://example.com/root.json\",\n\"type\": \"object\",\n\"title\": \"The Root Schema\",\n\"required\": [\n\"product\",\n\"vendor\",\n\"device\",\n\"flash\"\n],\n\"optional\": [\n\"nvmupdate\",\n],\n\"properties\": {\n\"product\": {\n\"$id\": \"#/properties/product\",\n\"type\": \"string\",\n\"title\": \"The Product Schema\",\n\"default\": \"\",\n\"examples\": [\n\"n3000\"\n],\n\"pattern\": \"^(.*)$\"\n},\n\"vendor\": {\n\"$id\": \"#/properties/vendor\",\n\"type\": \"string\",\n\"title\": \"The Vendor Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x8086\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"device\": {\n\"$id\": \"#/properties/device\",\n\"type\": \"string\",\n\"title\": \"The Device Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x0b30\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"nvmupdate\": {\n\"$id\": \"#/properties/nvmupdate\",\n\"type\": \"object\",\n\"title\": \"The nvmupdate Schema\",\n\"required\": [\n\"vendor\",\n\"device\",\n\"filename\",\n\"version\"\n],\n\"optional\": [\n\"interfaces\"\n],\n\"properties\": {\n\"vendor\": {\n\"$id\": \"#/properties/nvmupdate/vendor\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Vendor Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x8086\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"device\": {\n\"$id\": \"#/properties/nvmupdate/device\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Device Schema\",\n\"default\": \"\",\n\"examples\": [\n\"0x0d58\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{4})$\"\n},\n\"interfaces\": {\n\"$id\": \"#/properties/nvmupdate/interfaces\",\n\"type\": \"number\",\n\"title\": \"The nvmupdate Interfaces Schema\",\n\"default\": \"1\",\n\"examples\": [\n2, 4\n]\n},\n\"filename\": {\n\"$id\": \"#/properties/nvmupdate/filename\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Filename Schema\",\n\"default\": \"\",\n\"examples\": [\n\"PSG_XL710_6p80_XLAUI_NCSI_CFGID2p61_Dual_DID_0D58_800049C6.bin\"\n],\n\"pattern\": \"^(.*)$\"\n},\n\"version\": {\n\"$id\": \"#/properties/nvmupdate/version\",\n\"type\": \"string\",\n\"title\": \"The nvmupdate Version Schema\",\n\"default\": \"\",\n\"examples\": [\n\"800049C6\"\n],\n\"pattern\": \"^((0x)?[A-Fa-f0-9]{8})$\"\n},\n\"timeout\": {\n\"$id\": \"#/properties/nvmupdate/timeout\",\n\"type\": \"string\",\n\"title\": \"The Timeout Schema\",\n\"default\": \"\",\n\"examples\": [\n\"10m\"\n],\n\"pattern\": \"^([0-9]+(\\\\.[0-9]+)?([dhms]))+$\"\n}\n}\n},\n\"flash\": {\n\"$id\": \"#/properties/flash\",\n\"type\": \"array\",\n\"title\": \"The Flash Schema\",\n\"items\": {\n\"$id\": \"#/properties/flash/items\",\n\"type\": \"object\",\n\"title\": \"The Items Schema\",\n\"required\": [\n\"filename\",\n\"type\",\n\"version\",\n\"revision\"\n],\n\"optional\": [\n\"enabled\",\n\"force\",\n\"timeout\",\n\"requires\"\n],\n\"properties\": {\n\"enabled\": {\n\"$id\": \"#/properties/flash/items/properties/enabled\",\n\"type\": \"boolean\",\n\"title\": \"The Enabled Schema\",\n\"default\": \"true\"\n},\n\"filename\": {\n\"$id\": \"#/properties/flash/items/properties/filename\",\n\"type\": \"string\",\n\"title\": \"The Filename Schema\",\n\"default\": \"\",\n\"examples\": [\n\"vista_creek_qspi_xip_v1.0.6.ihex\"\n],\n\"pattern\": \"^(.*)$\"\n},\n\"type\": {\n\"$id\": \"#/properties/flash/items/properties/type\",\n\"type\": \"string\",\n\"title\": \"The Type Schema\",\n\"default\": \"\",\n\"examples\": [\n\"bmc_fw\"\n],\n\"enum\": [\"user\", \"bmc_fw\", \"bmc_img\", \"dtb\", \"factory_only\",\n\"phy_eeprom\"]\n},\n\"version\": {\n\"$id\": \"#/properties/flash/items/properties/version\",\n\"type\": \"string\",\n\"title\": \"The Version Schema\",\n\"default\": \"\",\n\"examples\": [\n\"1.0.6\"\n],\n\"pattern\": \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\"\n},\n\"force\": {\n\"$id\": \"#/properties/flash/items/properties/force\",\n\"type\": \"boolean\",\n\"title\": \"The Force Schema\",\n\"default\": false,\n\"examples\": [\ntrue\n]\n},\n\"revision\": {\n\"$id\": \"#/properties/flash/items/properties/revision\",\n\"type\": \"string\",\n\"title\": \"The Revision Schema\",\n\"default\": \"\",\n\"examples\": [\n\"C\"\n],\n\"pattern\": \"^([A-Za-z])$\"\n},\n\"timeout\": {\n\"$id\": \"#/properties/nvmupdate/timeout\",\n\"type\": \"string\",\n\"title\": \"The Timeout Schema\",\n\"default\": \"\",\n\"examples\": [\n\"10m\"\n],\n\"pattern\": \"^([0-9]+(\\.[0-9]+)?([dhms]))+$\"\n},\n\"requires\": {\n\"$id\": \"#/properties/flash/items/properties/requires\",\n\"type\": \"string\",\n\"title\": \"The Requires Schema\",\n\"default\": \"\",\n\"examples\": [\n\"bmc_img &gt;= 1.0.12\"\n],\n\"pattern\": \"^(([a-z_]+) ((&lt;&gt;!=)?=) ([0-9a-z\\\\.]+)$\"\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/","title":"fpgainfo","text":""},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#synopsis","title":"SYNOPSIS","text":"<pre><code>   fpgainfo [-h] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\n            {errors,power,temp,fme,port,bmc,mac,phy,security}\n</code></pre>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#description","title":"DESCRIPTION","text":"<p>fpgainfo displays FPGA information derived from sysfs files. The command argument is one of the following: <code>errors</code>, <code>power</code>, <code>temp</code>, <code>port</code>, <code>fme</code>, <code>bmc</code>, <code>phy</code> or <code>mac</code>,<code>security</code>,<code>events</code>. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#fpgainfo-commands","title":"FPGAINFO COMMANDS","text":"<p><code>errors</code></p> <p>Show/clear errors of an FPGA resource that the first argument specifies. <code>fpgainfo</code> displays information in human readable form.</p> <p><code>power</code></p> <p>Show total the power in watts that the FPGA hardware consumes.</p> <p><code>temp</code></p> <p>Show FPGA temperature values in degrees Celcius.</p> <p><code>port</code></p> <p>Show information about the port such as the AFU ID of currently loaded AFU.</p> <p><code>fme</code></p> <p>Show information about the FPGA platform including the partial reconfiguration (PR) Interface ID, the OPAE version, and the FPGA Interface Manager (FIM) ID.</p> <p><code>bmc</code></p> <p>Show all Board Management Controller sensor values for the FPGA resource, if available.</p> <p><code>phy</code></p> <p>Show information about the PHY integrated in the FPGA, if available.</p> <p><code>mac</code></p> <p>Show information about the MAC address in ROM attached to the FPGA, if available.</p> <p><code>security</code></p> <p>Show information about the security keys, hashs and flash count, if available.</p> <p><code>events</code></p> <p>Show information about events and sensors, if available.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p> <p><code>--version, -v</code></p> <p>Prints version information and exit.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#common-arguments","title":"COMMON ARGUMENTS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-S, --segment</code></p> <p>PCIe segment number of resource.</p> <p><code>-B, --bus</code></p> <p>PCIe bus number of resource.</p> <p><code>-D, --device</code></p> <p>PCIe device number of resource.</p> <p><code>-F, --function</code></p> <p>PCIe function number of resource.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#errors-arguments","title":"ERRORS ARGUMENTS","text":"<p>The first argument to the <code>errors</code> command specifies the resource type. It must be one of the following:    <code>fme</code>,<code>port</code>,<code>all</code></p> <p><code>fme</code></p> <p>Show/clear FME errors. </p> <p><code>port</code></p> <p>Show/clear PORT errors.</p> <p><code>all</code></p> <p>Show/clear errors for all resources.</p> <p>The optional <code>&lt;command-args&gt;</code> arguments are:</p> <p><code>--clear, -c</code></p> <p>Clear errors for the given FPGA resource.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#phy-arguments","title":"PHY ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--group, -G</code></p> <p>Select which PHY group(s) information to show.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#events-arguments","title":"EVENTS ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--list,-l</code></p> <p>List boots (implies --all).</p> <p><code>--boot,-b</code></p> <p>Boot index to use, i.e: \u00a0\u00a0\u00a0\u00a00 for current boot (default). \u00a0\u00a0\u00a0\u00a01 for previous boot, etc.</p> <p><code>--count,-c</code></p> <p>Number of events to print.</p> <p><code>--all,-a</code></p> <p>Print all events.</p> <p><code>--sensors,-s</code></p> <p>Print sensor data too.</p> <p><code>--bits,-i</code></p> <p>Print bit values too.</p> <p><code>--help,-h</code></p> <p>Print this help.</p>"},{"location":"sw/fpga_tools/fpgainfo/fpgainfo/#examples","title":"EXAMPLES","text":"<p>This command shows the current power telemetry: <pre><code>./fpgainfo power\n</code></pre></p> <p>This command shows the current temperature readings: <pre><code>./fpgainfo temp\n</code></pre></p> <p>This command shows FME resource errors: <pre><code>./fpgainfo errors fme\n</code></pre> This command clears all errors on all resources: <pre><code>./fpgainfo errors all -c\n</code></pre> This command shows information of the FME on bus 0x5e <pre><code>./fpgainfo fme -B 0x5e\n</code></pre> This command shows information of the FPGA security on bus 0x5e <pre><code>./fpgainfo security -B 0x5e\n</code></pre> This command shows all events and sensors information including sensor bits: <pre><code>./fpgainfo events -asi\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/","title":"fpgamux","text":""},{"location":"sw/fpga_tools/fpgamux/fpgamux/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgamux [-h] [-S|--socket-id SOCKET_ID] [-B|--bus-number BUS] [-D|--device DEVICE] [-F|--function FUNCTION]\n        [-G|--guid GUID] -m|--muxfile &lt;filepath.json&gt;\n</code></pre>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#description","title":"DESCRIPTION","text":"<p><code>fpgamux</code> tests multiple AFUs that are synthesized into a single AFU along with the CCIP-MUX basic building block (BBB). The CCIP-MUX uses the upper bits in the MMIO addresses to route MMIO reads and writes to the AFU running on the corresponding CCIP-MUX port. <code>fpgamux</code> uses a configuration file that lists the software components and correct configuration. <code>fpgamux</code> only runs on the Integrated FPGA Platform.  You cannot run it on the PCIe accelerator card (PAC).</p> <p>.. note::</p> <pre><code>  The OPAE driver discovers only the first AFU. The first software component in the configuration \n  determines the GUID to use for enumeration. Use the -G|--guid option to override the GUID\n  for the first software component.\n</code></pre>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#options","title":"OPTIONS","text":"<p><code>-S SOCKET_ID, --socket-id SOCKET_ID</code></p> <p>socket id of FPGA resource.</p> <p><code>-B BUS, --bus BUS</code></p> <p>bus id of FPGA resource.</p> <p><code>-D DEVICE, --device DEVICE</code></p> <p>The device id of FPGA resource.</p> <p><code>-F FUNCTION, --function FUNCTION</code></p> <p>The function id of FPGA resource.</p> <p><code>-G, --guid</code></p> <p>Specifies the GUID to use for the resource enumeration.</p> <p><code>-m, --muxfile &lt;filepath.json&gt;</code></p> <p>The path to the <code>fpgamux</code> configuration file. This file must be in JSON format following the schema described below.</p>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#configuration","title":"CONFIGURATION","text":"<p><code>fpgamux</code> uses a configuration file (in JSON format) to determine what software components to instantiate and how to configure them to work with the AFUs. The schema includes the following elements:</p> <pre><code>    [\n        {\n            \"app\" : \"fpga_app\",\n            \"name\" : \"String\",\n            \"config\" : \"Object\"\n        }\n    ]\n</code></pre>"},{"location":"sw/fpga_tools/fpgamux/fpgamux/#examples","title":"EXAMPLES","text":"<p>The following example shows a configuration with two components: <pre><code>    [\n        {\n            \"app\" : \"nlb0\",\n            \"name\" : \"nlb0\",\n            \"config\" :\n            {\n                \"begin\" : 1,\n                \"end\" : 1,\n                \"multi-cl\" : 1,\n                \"cont\" : false,\n                \"cache-policy\" : \"wrline-M\",\n                \"cache-hint\" : \"rdline-I\",\n                \"read-vc\" : \"vh0\",\n                \"write-vc\" : \"vh1\",\n                \"wrfence-vc\" : \"write-vc\",\n                \"timeout-usec\" : 0,\n                \"timeout-msec\" : 0,\n                \"timeout-sec\" : 1,\n                \"timeout-min\" : 0,\n                \"timeout-hour\" : 0,\n                \"freq\" : 400000000\n            }\n        },\n        {\n            \"app\" : \"nlb3\",\n            \"name\" : \"nlb3\",\n            \"config\" :\n            {\n                \"mode\" : \"read\",\n                \"begin\" : 1,\n                \"end\" : 1,\n                \"multi-cl\" : 1,\n                \"strided-access\" : 1,\n                \"cont\" : false,\n                \"warm-fpga-cache\" : false,\n                \"cool-fpga-cache\" : false,\n                \"cool-cpu-cache\" : false,\n                \"cache-policy\" : \"wrline-M\",\n                \"cache-hint\" : \"rdline-I\",\n                \"read-vc\" : \"vh0\",\n                \"write-vc\" : \"vh1\",\n                \"wrfence-vc\" : \"write-vc\",\n                \"alt-wr-pattern\" : false,\n                \"timeout-usec\" : 0,\n                \"timeout-msec\" : 0,\n                \"timeout-sec\" : 1,\n                \"timeout-min\" : 0,\n                \"timeout-hour\" : 0,\n                \"freq\" : 400000000\n            }\n        }\n    ]\n</code></pre></p>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/","title":"fpgaport","text":""},{"location":"sw/fpga_tools/fpgaport/fpgaport/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgaport [-h] [-N NUMVFS] [-X] [--debug] {assign,release} device [port]\n</code></pre>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#description","title":"DESCRIPTION","text":"<p>The <code>fpgaport</code> enables and disables virtualization. It assigns and releases control of the port to the virtual function (VF). By default, the driver assigns the port to the physical function (PF) in the non-virtualization use case.</p>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{assign, release}</code></p> <pre><code>Action to perform.\n</code></pre> <p><code>device</code></p> <pre><code>The FPGA device being targeted with this action.\n</code></pre> <p><code>port</code></p> <pre><code>The number of the port.\n</code></pre>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-N NUMVFS, --numvfs NUMVFS</code></p> <pre><code>Create NUMVFS virtual functions. The typical value is 1.\n</code></pre> <p><code>-X, --destroy-vfs</code></p> <pre><code>Destroy all virtual functions prior to assigning.\n</code></pre> <p><code>--debug</code></p> <pre><code>Display additional log information.\n</code></pre> <p><code>-h, --help</code></p> <pre><code>Print usage information.\n</code></pre>"},{"location":"sw/fpga_tools/fpgaport/fpgaport/#example","title":"EXAMPLE","text":"<p><code>fpgaport release /dev/dfl-fme.0 0</code></p> <pre><code>Release port 0 from physical function control.\n</code></pre> <p><code>fpgaport assign /dev/dfl-fme.0 0</code></p> <pre><code>Assign port 0 to physical function control.\n</code></pre>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/","title":"fpgasupdate","text":""},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgasupdate [--log-level=&lt;level&gt;] file [bdf]</code></p>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#description","title":"DESCRIPTION","text":"<p>The <code>fpgasupdate</code> command implements a secure firmware update for the following programmable accelerator cards (PACs): * Intel\u00ae PAC with Intel Arria\u00ae 10 GX FPGA * Intel FPGA PAC D5005 * Intel PAC N3000</p> <p><code>--log-level &lt;level&gt;</code></p> <pre><code>Specifies the `log-level` which is the level of information output to your command tool.\nThe following seven levels  are available: `state`, `ioctl`, `debug`, `info`, `warning`,\n`error`, `critical`. Setting `--log-level=state` provides the most verbose output.\nSetting `--log-level=ioctl` provides the second most information, and so on. The default\nlevel is `info`.\n</code></pre> <p><code>file</code></p> <pre><code>Specifies the secure update firmware file to be programmed. This file may be to program a\nstatic region (SR), programmable region (PR), root entry hash, key cancellation, or other\ndevice-specific firmware.\n</code></pre> <p><code>bdf</code></p> <pre><code>The PCIe&amp;reg; address of the PAC to program. `bdf` is of the form `[ssss:]bb:dd:f`,\ncorresponding to PCIe segment, bus, device, function. The segment is optional. If\nyou do not specify a segment, the segment defaults to `0000`. If the system has only\none PAC you can omit the `bdf` and let `fpgasupdate`  determine the address\nautomatically.\n</code></pre>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>To gather more debug output, decrease the <code>--log-level</code> parameter. </p>"},{"location":"sw/fpga_tools/fpgasupdate/fpgasupdate/#examples","title":"EXAMPLES","text":"<p><code>fpgasupdate firmware.bin</code> <code>fpgasupdate firmware.bin 05:00.0</code> <code>fpgasupdate firmware.bin 0001:04:02.0 --log-level=ioctl</code></p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/","title":"host_exerciser","text":""},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: host_exerciser [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=warning\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mode UINT:value in {lpbk-&gt;0,read-&gt;1,trput-&gt;3,write-&gt;2} OR {0,1,3,2}=lpbk\n                              host exerciser mode {lpbk,read, write, trput}\n  --cls UINT:value in {cl_1-&gt;0,cl_2-&gt;1,cl_4-&gt;2,cl_8-&gt;3} OR {0,1,2,3}=cl_1\n                              number of CLs per request{cl_1, cl_2, cl_4, cl_8}\n  --continuousmode BOOLEAN=false\n                              test rollover or test termination\n  --atomic UINT:value in {cas_4-&gt;9,cas_8-&gt;11,fadd_4-&gt;1,fadd_8-&gt;3,off-&gt;0,swap_4-&gt;5,swap_8-&gt;7} OR {9,11,1,3,0,5,7}=off\n                              atomic requests (only permitted in combination with lpbk/cl_1)\n  --encoding UINT:value in {default-&gt;0,dm-&gt;1,pu-&gt;2,random-&gt;3} OR {0,1,2,3}=default\n                              data mover or power user encoding -- random interleaves both in the same stream\n  -d,--delay BOOLEAN=false    Enables random delay insertion between requests\n  --interleave UINT=0         Interleave requests pattern to use in throughput mode {0, 1, 2}\n                              indicating one of the following series of read/write requests:\n                              0: rd-wr-rd-wr\n                              1: rd-rd-wr-wr\n                              2: rd-rd-rd-rd-wr-wr-wr-wr\n  --interrupt UINT:INT in [0 - 3]\n                              The Interrupt Vector Number for the device\n  --contmodetime UINT=1       Continuous mode time in seconds\n  --testall BOOLEAN=false     Run all tests\n  --clock-mhz UINT=0          Clock frequency (MHz) -- when zero, read the frequency from the AFU\nSubcommands:\n  lpbk                        run simple loopback test\n  mem                         run simple mem test\n</code></pre>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#description","title":"DESCRIPTION","text":"<p>The host exerciser used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc.</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#host-exerciser-loopback-he-lbk","title":"Host Exerciser Loopback (HE-LBK)","text":"<p>HE-LB is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth.  Host Exerciser Loopback (HE-LBK) AFU can move data between host memory and FPGA.</p> <p>HE-LBK supports: 1. Latency (AFU to Host memory read) 2. MMIO latency (Write+Read) 3. MMIO BW (64B MMIO writes) 4. BW (Read/Write, Read only, Wr only)</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#host-exerciser-memory-he-mem","title":"Host Exerciser Memory (HE-MEM)","text":"<p>HE-MEM is used to exercise use of FPGA connected DDR; data read from the host is  written to DDR, and the same data is read from DDR before sending it back to the  host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller.</p> <p>Execution of these exercisors requires the user to bind specific VF endpoint to vfio-pci Bind the correct endpoint for a device with B/D/F 0000:b1:00.0</p> <p><code>[user@localhost]: sudo opae.io init -d 0000:b1:00.2 user:user</code></p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#host-exerciser-sub-commands","title":"HOST EXERCISER SUB COMMANDS","text":"<p><code>lpbk</code></p> <p>run host exerciser loopback test</p> <p><code>mem</code></p> <p>run host exerciser memory test</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set host exerciser tool log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>host exerciser tool time out, by default time out 60000</p> <p><code>-m,--mode</code></p> <p>host exerciser test modes are lpbk, read, write, trput</p> <p><code>--cls</code></p> <p>Number of cachelines per request 1, 2, 3, 4.</p> <p><code>--continuousmode</code></p> <p>Configures test rollover or test termination mode.</p> <p><code>--atomic</code></p> <p>atomic requests.</p> <p><code>--encoding</code></p> <p>select data mover mode or power user mode or random.</p> <p><code>-d,--delay</code></p> <p>Enables random delay insertion between requests.</p> <p><code>--interleave</code></p> <p>Enables interleave requests in throughput mode. Value:3'b000-Rd,Wr,Rd,Wr Value:3'b001-Rd,Rd,Wr,Wr Value:3'b010-Rd,Rd,Rd,Rd,Wr,Wr,Wr,Wr Value:3'b011-Not supported</p> <p><code>--interrupt</code></p> <p>Accelerator interrupt vector Number.</p> <p><code>--contmodetime</code></p> <p>Continuous mode time in seconds.</p> <p><code>--testall</code></p> <p>Run all host exerciser tests.</p> <p><code>--clock-mhz</code></p> <p>pcie clock frequency, default value 350Mhz.</p>"},{"location":"sw/fpga_tools/host_exerciser/host_exerciser/#examples","title":"EXAMPLES","text":"<p>This command exerciser Loopback afu: <pre><code>host_exerciser lpbk\n</code></pre></p> <p>This command exerciser memory afu: <pre><code>host_exerciser mem\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0: <pre><code>host_exerciser --pci-address 000:3b:00.0    lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run in write mode: <pre><code>host_exerciser --pci-address 000:3b:00.0   --mode write lpbl\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run 2 cache lines per request: <pre><code>host_exerciser --pci-address 000:3b:00.0   --cls cl_2  lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run continuous mode for 10 seconds: <pre><code>host_exerciser --pci-address 000:3b:00.0   -cls cl_1   -m 0 --continuousmode true --contmodetime 10 lpbk\n</code></pre></p>"},{"location":"sw/fpga_tools/hssi/hssi/","title":"hssi","text":""},{"location":"sw/fpga_tools/hssi/hssi/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi COMMON_OPTIONS MODE MODE_OPTIONS</code></p>"},{"location":"sw/fpga_tools/hssi/hssi/#description","title":"DESCRIPTION","text":"<p>The <code>hssi</code> application provides a means of interacting with the 10G and with the 100G HE-HSSI AFUs. In both 10G and 100G operating modes, the application initializes the AFU and completes the desired transfer as described by the mode- specific options.</p> <p>COMMON_OPTIONS - application options common to both 10G and 100G modes.</p> <p><code>-h, --help</code></p> <pre><code>Display common command-line help and exit.\n</code></pre> <p><code>-p, --pci-address ADDR</code></p> <pre><code>The PCIe address of the desired accelerator in ssss:bb:dd.f format.\n</code></pre> <p><code>-s, --shared on|off</code></p> <pre><code>Whether to open the accelerator in shared mode. The default is off.\n</code></pre> <p><code>-t, --timeout VALUE</code></p> <pre><code>The application timeout value in milliseconds. The default timeout is 60000 msec.\n</code></pre> <p>MODE - select AFU. Valid values are hssi_10g and hssi_100g.</p> <p>MODE_OPTIONS [hssi_10g] - application options specific to the 10G AFU.</p> <p><code>-h, --help</code></p> <pre><code>Display 10G AFU specific command-line help and exit.\n</code></pre> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--random-length fixed|random</code></p> <pre><code>Specify packet length randomization. Valid values are fixed and\nrandom. The default is fixed (no randomization).\n</code></pre> <p><code>--random-payload incremental|random</code></p> <pre><code>Specify payload randomization. Valid values are incremental and\nrandom. The default is incremental.\n</code></pre> <p><code>--packet-length LENGTH</code></p> <pre><code>Specify packet length. The default is 64 bytes.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--rnd-seed0 SEED0</code></p> <pre><code>Specify the prbs generator bits [31:0]. The default is 1592590336.\n</code></pre> <p><code>--rnd-seed1 SEED1</code></p> <pre><code>Specify the prbs generator bits [47:32]. The default is 1592590337.\n</code></pre> <p><code>--rnd-seed2 SEED2</code></p> <pre><code>Specify the prbs generator bits [91:64]. The default is 155373.\n</code></pre> <p>MODE_OPTIONS [hssi_100g] - application options specific to the 100G AFU.</p> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--gap random|none</code></p> <pre><code>Inter-packet gap. Valid values are random and none. The default is none.\n</code></pre> <p><code>--pattern random|fixed|increment</code></p> <pre><code>Pattern mode. Valid values are random, fixed, or increment. The default\nis random.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--start-size SIZE</code></p> <pre><code>Specify the packet size in bytes, or the first packet size for --pattern increment.\n</code></pre> <p><code>--end-size SIZE</code></p> <pre><code>Specify the end packet size in bytes.\n</code></pre> <p><code>--end-select pkt_num|gen_idle</code></p> <pre><code>Specify packet generation end mode.\n</code></pre> <p>MODE_OPTIONS [pkt_filt_10g] - application options specific to the Packet Filter 10G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.0\n</code></pre> <p>MODE_OPTIONS [pkt_filt_100g] - application options specific to the Packet Filter 100G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.1\n</code></pre>"},{"location":"sw/fpga_tools/hssi/hssi/#examples","title":"EXAMPLES","text":"<p><code>hssi -h</code> <code>hssi hssi_10g -h</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_10g --eth-loopback=on --num-packets=500</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_100g --pattern=increment</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/","title":"hssi_config","text":""},{"location":"sw/fpga_tools/hssi_config/readme/#synopsis","title":"Synopsis","text":"<p><code>hssi_config</code> reads or writes HSSI registers on either on an Intel\u00ae FPGA using the  FPGA Interface Manager (FIM) or on an HSSI retimer card attached to the board. <code>hssi_config</code> is only available for the Integrated FPGA Platform. You cannot run it  on the PCIe accelerator card (PAC).</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#usage","title":"Usage","text":"<p><code>hssi_config [--resource|-r &lt;sysfs resource&gt;] [--socket-id|s 0|1] command [command options]</code></p> <p>Where command is one of the following:</p> <pre><code>    dump [outfile.csv] [--input-file inputfile.csv]\niread instance (0,1) device-addr byte-address byte-count\n    iwrite instance (0,1) device-addr byte-address byte1 [byte2 [byte3...]]\nload [inputfile.csv] [--c-header]\nread lane(0-15) reg-address\n    rread device(0x30, 0x32, 0x34, 0x36) channel(0-3) address\n    rwrite device(0x30, 0x32, 0x34, 0x36) channel(0-3) address value\n    test (rd|rw) inputfile.csv [--acktimes] [--repeat N]\nwrite lane(0-15) reg-address value\n</code></pre> <p>The first argument is the command and any additional arguments are command arguments. The following options and commands are available:</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#options","title":"Options","text":"<p><code>[--resource|-r &lt;sysfs resource path&gt;</code></p> <p>The resource path in the sysfs pseudo-filesystem. Example:     <code>/sys/devices/pci0000\\:5e/0000\\:5e\\:00.0/resource0</code></p> <p><code>[--socket-id 0|1]</code></p> <p>The socket id of the target FPGA. Required on two-socket systems to differentiate between the two possible target FPGAs.</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#commands","title":"Commands","text":"<p><code>dump [outfile.csv] [--input-file inputfile.csv]</code></p> <p>Dump registers to stdout or to a file, if provided. <code>hssi_config</code> has a built-in set of registers to dump. The first argument is the path to a file to write. The command dumps to stdout if you do not  specify a file name. Use the --input-file option to specify a different set of registers. </p> <p><code>load [inputfile.csv] [--c-header]</code></p> <p>Load a set of register values from either stdin or an input file, if provided. The first argument  is the path to a file containing the registers to load. Loads from stdin if omitted.  </p> <p>Use --c-header to generate a C header file with an array of 64-bit numbers to write to the  <code>HSSI_CTRL</code> register. This header file can substitute for the input file.  NOTE: You must perform the acknowledge routine after each write.</p> <p><code>read lane(0-15) reg-address</code></p> <p>Read from a single XCVR (transceiver) register. The first command argument is the XCVR lane. Use -1 to specify a read from all lanes. The second argument is the XCVR address (offset).</p> <p><code>write lane(0-15) reg-address value</code></p> <p>Write to a single XCVR register. The first argument is the XCVR lane. The second argument is the XCVR address(offset). The third argument is the value to write to the register.</p> <p><code>rread device(0x30, 0x32, 0x34, 0x36) channel(0-3) address</code></p> <p>Read from a single retimer register. The first argument is the I2C device address. The second argument is the channel. The third argument is the register address (or I2C byte address).</p> <p><code>rwrite device(0x30, 0x32, 0x34, 0x36) channel(0-3) address value</code></p> <p>Write to a single retimer register. The first argument is the I2C device address. The second argument is the channel. The third argument is the register address (or I2C byte address). The fourth argument is the value to write.</p> <p><code>iread instance (0,1) device-addr byte-address byte-count</code></p> <p>Read from a device on the I2C bus. The first argument is the I2C controller instance (0 or 1). The second argument is the device address to read from. The third argument is the byte address of the register to read from the device. The fourth argument is the number of bytes to read.</p> <p><code>iwrite instance (0,1) device-addr byte-address byte1 [byte2 [byte3...]]</code></p> <p>Write to a device on the I2C bus. The first argument is the I2C controller instance (0 or 1). The second argument is the device address to read from. The third argument is the byte address of the register to read from the device. All subsequent arguments are the bytes to write to the device.</p> <p><code>test (rd|rw) inputfile.csv [--acktimes]</code></p> <p>Perform built-in test for reading or writing XCVR registers. The first argument is the path to a file containing the registers to test.</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#overview","title":"Overview","text":"<p>The <code>hssi_config</code> utility reads or writes hssi equalization parameters stored in either the transceiver (XCVR) registers or the registers of the retimer on the I2C bus. To access registers,  the hssi controller writes to the <code>HSSI_CTRL</code> register and reads from the <code>HSSI_STAT</code> register in the FPGA Management Engine (FME). These two registers implement the HSSI AUX bus mailbox protocol to access devices on other buses. Because <code>hssi_config</code> maps the FME MMIO space directly, the FPGA driver is not required.</p>"},{"location":"sw/fpga_tools/hssi_config/readme/#locating-the-fme-device","title":"Locating the FME Device","text":"<p>The FME reads and writes the <code>HSSI_CTRL</code> and <code>HSSI_STAT</code> registers on the NIOS device. The FME maps the MMIO address space of the FME identified by its resource in the sysfs psuedo-filesystem in Linux operating systems. To identify resource paths, use the <code>lspci</code> utility to query for Intel devices with device id of bcc0.</p> <p>Example:</p> <p><code>lspci -d 8086:bcc0</code></p> <p>This command should print out at least one line like the following example:</p> <p><code>5e:00.0 Processing accelerators: Intel Corporation Device bcc0</code></p> <p>Use the first three numbers (bus:device.function) to locate the device resource in the sysfs filesystem:</p> <p><code>/sys/devices/pci0000\\:&lt;bus&gt;/0000\\:&lt;bus&gt;\\:&lt;device&gt;.&lt;function&gt;/resource0</code></p> <p>For example, the example above with bus of 5e, device of 00 and function of 0 would use a resource path as follows:</p> <p><code>/sys/devices/pci0000\\:5e/0000\\:5e\\:00.0/resource0</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#csv-file-format","title":"CSV File Format","text":"<p>Any CSV file parsed by <code>hssi_config</code> must meet have at least four columns. The following table provides the column specifications:</p> Column Name Description 1 Register type. Can be either <code>FPGA_RX</code>, <code>FPGA_TX</code>, <code>RTMR_RX</code>, <code>RTMR_TX</code> (or their corresponding numeric values, 1-4). 2 Lane or Channel 0-15 for XCVR lanes on FPGA, 0-3 for retimer channels. -1 to designate all lanes or channels. 3 Device address (on I2C bus) Only applies to retimer registers. 0 - 3, -1 to designate all devices. 4 Register address (or offset) Examples: 0x213, 0x100. 5 Register value to write Examples: 0x1, 1, 0. Applies only when loading or writing registers."},{"location":"sw/fpga_tools/hssi_config/readme/#examples-of-commands","title":"Examples of Commands","text":""},{"location":"sw/fpga_tools/hssi_config/readme/#dumping-registers","title":"Dumping Registers","text":"<p>Dump default register set to stdout:</p> <p><code>&gt;hssi_config dump</code></p> <p>Dump default registers to a file, data.csv:</p> <p><code>&gt;hssi_config dump data.csv</code></p> <p>Dump to an output file, data.csv, Registers specified in an input file, regspec.csv:</p> <p><code>&gt;hssi_config dump data.csv --input-file regspec.csv</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#reading-single-registers","title":"Reading Single Registers","text":"<p>Read register from XCVR at 0x2e1 on lane 0:</p> <p><code>&gt;hssi_config read 0 0x2e1</code></p> <p>Read register 0x109 from retimer on channel 0, device 0x30, channel 1:</p> <p><code>&gt;hssi_config rread 0 0x30 0x109</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#loading-registers","title":"Loading Registers","text":"<p>Load registers specified in an input file called data.csv:</p> <p><code>&gt;hssi_config load data.csv</code></p> <p>Load registers specified from stdin:</p> <p><code>&gt;hssi_config load</code></p> <pre><code>FPGA_RX,1,-1,0x213,0\nFPGA_RX,2,-1,0x213,0\nFPGA_RX,3,-1,0x213,0\n&lt;CTRL-D&gt;\n</code></pre>"},{"location":"sw/fpga_tools/hssi_config/readme/#writing-single-registers","title":"Writing Single Registers","text":"<p>Write 1 to XCVR register at 0x2e1 on lane 0:</p> <p><code>&gt;hssi_config write 0 0x2e1 1</code></p> <p>Read register 0x109 from retimer on channel 0, device 0x30, channel 1:</p> <p><code>&gt;hssi_config rread 0 0x30 0x109</code></p>"},{"location":"sw/fpga_tools/hssi_config/readme/#testing-hssi-read-and-write","title":"Testing HSSI Read and Write","text":"<p><code>&gt;  test (rd|rw) register-file.csv [--acktimes]</code></p> <p><code>rd|wr</code></p> <p>Specifies either a <code>rd</code> or <code>wr</code> of transceiver registers. For writes, every register in the file is read from and written to in the following sequence:</p> <ol> <li>Read the register, save the value</li> <li>Write 1 to the register</li> <li>Read the register, verify that the register value is 1</li> <li>Write 0 to the register</li> <li>Read the register, verify that the register value is 0</li> <li>Write the original value to the register</li> <li>Read the register, assert it is the original value</li> </ol> <p><code>register=file.csv</code></p> <p>Specifies the path to a file containing the set of registers to test. </p> <p><code>--acktimes</code> </p> <p>Specifies the time spent in the <code>ack</code> routine. When measured, a summary of ack times prints  to stdout. This argument is optional.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/","title":"HSSI ethernet loopback","text":""},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssiloopback [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS] --loopback [{enable,disable}]\n</code></pre>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssiloopback</code>  tool enables and disable ethernet loopback.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p> <p><code>--loopback [{enable,disable}]</code></p> <p>Ethernet enable or disable loopback.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssiloopback/#examples","title":"EXAMPLES","text":"<p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback enable</code></p> <p>Enables ethernet loopback</p> <p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback disable</code></p> <p>Disable ethernet loopback</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/","title":"HSSI ethernet mac","text":""},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssimac [-h] --pcie-address PCIE_ADDRESS [--port PORT]\n</code></pre>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#description","title":"DESCRIPTION","text":"<p>The <code>hssimac</code>  tool provides Maximum TX and RX frame size.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0).</p> <p><code>--port PORT</code></p> <p>hssi port number.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssimac/#examples","title":"EXAMPLES","text":"<p><code>hssimac --pcie-address  0000:04:00.0 --port 1</code></p> <p>prints Maximum TX and RX frame size for port 1.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/","title":"HSSI ethernet statistics","text":""},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssistats [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS]\n</code></pre>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#description","title":"DESCRIPTION","text":"<p>The <code>hssistats</code>  tool provides the MAC statistics.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p>"},{"location":"sw/fpga_tools/hssi_ethernet/hssistats/#examples","title":"EXAMPLES","text":"<p><code>hssistats --pcie-address  0000:04:00.0</code></p> <p>prints the MAC statistics </p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/","title":"hssi_loopback","text":""},{"location":"sw/fpga_tools/hssi_loopback/readme/#name","title":"NAME","text":"<p>hssi_loopback - Software utility to run HSSI loopback tests on FPGA</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi_loopback [[--bus|-b &lt;bus number&gt;] [--device | -d &lt;device number&gt;] [--function | -f &lt;function number&gt;]]|[--socket-id &lt;socket-id&gt;]       [--mode|-m auto|e40|e10]        [send [&lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]] |status [clear] | stop | readmacs</code></p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#description","title":"DESCRIPTION","text":"<p>The <code>hssi_loopback</code> utility works in conjunction with a packet generator accelerator function unit (AFU) to test high-speed serial interface (HSSI) cards. The <code>hssi_loopback</code> utility tests both external and internal loopbacks. <code>hssi_loopback</code> runs an external loopback test when the command line arguments include both source and destination ports. <code>hssi_loopback</code> runs an internal loopback test when command line arguments include a single port. <code>hssi_loopback</code> only runs on the Intel Xeon with Arria 10 FPGA. You cannot run it on the Intel PAC (programmable accelerator card).</p> <p>NOTE: The following limitations apply to the current version of hssi_loopback:</p> <ul> <li>For the external loopback the two port arguments can be the same. For the e10 design, the ports should be the same.</li> <li>The <code>hssi_loopback</code> test supports only the e40 and e10 E2E AFUs.  The e10 E2E AFU tests HSSI with a retimer card.</li> <li>The <code>hssi_loopback</code> test uses the control and status registers (CSRs) defined in the AFU.</li> </ul>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#options","title":"OPTIONS","text":"<p><code>-S SOCKET_ID, --socket-id SOCKET_ID</code></p> <p>Socket ID FPGA resource.</p> <p><code>-B BUS, --bus BUS</code></p> <p>Bus ID of FPGA resource.</p> <p><code>-D DEVICE, --device DEVICE</code></p> <p>Device ID of FPGA resource.</p> <p><code>-F FUNCTION, --function FUNCTION</code></p> <p>Function ID of FPGA resource.</p> <p><code>-G, --guid</code></p> <p>Specifies guid for the resource enumeration.</p> <p><code>-m, --mode</code></p> <p>One of the following: [<code>auto</code>, <code>e40</code>, <code>e10</code>] <code>auto</code> is the default and indicates that the software runs the mode based on the first accelerator functional unit it identifies.</p> <p><code>-t, --timeout</code></p> <p>Timeout (in seconds) before the application terminates in continuous mode. Continuous mode is the default when you do not specify the number of packets.</p> <p><code>-y, --delay</code></p> <p>Delay (in seconds) between printing out a simple status line. Default is 0.100 seconds (100 milliseconds).</p> <p><code>-c, --packet-count</code></p> <p>The number of packets to send.</p> <p><code>-d, --packet-delay</code></p> <p>The delay in between packets. This delay is the number of 100 MHz clock cycles, roughly 10 nanoseconds.</p> <p><code>-s, --packet-size</code></p> <p>The packet size to send. The minimum is 46 bytes and the maximum is 1500 bytes. The default is 46 bytes.</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#commands","title":"COMMANDS","text":"<p><code>send &lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]</code></p> <p>Send packets from one port to the other. If the command line does not specify a destination port, the test runs an internal  loopback. Otherwise, the test runs an external loopback from the source port to the destination port.</p> <p><code>status [clear]</code></p> <p>Read and interpret the status registers and print to the screen. <code>clear</code> clears the status registers.</p> <p><code>stop</code></p> <p>Issue a stop command to all Ethernet controllers in the AFU.</p> <p><code>readmacs</code></p> <p>Read and display the port MAC addresses. An EEPROM stores the MAC addresses.</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#exit-codes","title":"EXIT CODES","text":"<p>0    Success - Number of packets received are equal to the number of packets sent and no errors           are reported.</p> <p>-1    Loopback failure - Either number of packets does not match or the test detected errors.</p> <p>-2    Errors parsing arguments.</p>"},{"location":"sw/fpga_tools/hssi_loopback/readme/#examples","title":"EXAMPLES","text":"<p>Read the MAC addresses of the AFU loaded on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback readmacs -B 0x5e\n</code></pre> <p>Run an external loopback, sending 100 packets from port 0 to port 1. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 1 -c 100\n</code></pre> <p>Run an internal loopback until a timeout of 5 seconds is reached. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 -t 5\n</code></pre>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/","title":"mem_tg","text":""},{"location":"sw/fpga_tools/mem_tg/mem_tg/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: mem_tg [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -g,--guid TEXT=4DADEA34-2C78-48CB-A3DC-5B831F5CECBB\n                              GUID\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=info\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mem-channel UINT=0     Target memory bank for test to run on (0 indexed)\n  --loops UINT=1              Number of read/write loops to be run\n  -w,--writes UINT=1          Number of unique write transactions per loop\n  -r,--reads UINT=1           Number of unique read transactions per loop\n  -b,--bls UINT=1             Burst length of each request\n  --stride UINT=1             Address stride for each sequential transaction\n  --data UINT:value in {fixed-&gt;0,prbs15-&gt;2,prbs31-&gt;3,prbs7-&gt;1,rot1-&gt;3} OR {0,2,3,1,3}=fixed\n                              Memory traffic data pattern: fixed, prbs7, prbs15, prbs31, rot1\n  -f,--mem-frequency UINT=0   Memory traffic clock frequency in MHz\nSubcommands:\n  tg_test                     configure &amp; run mem traffic generator test\n</code></pre>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#description","title":"DESCRIPTION","text":"<p>The memory traffic generator (TG) used to exercise and test available memory channels with a configurable traffic pattern.</p> <p>Execution of this application requires the user to bind the specific VF endpoint containing the mem_tg AFU id to vfio-pci</p> <p>In the TG, read responses are checked against a specified pattern. If the application is configured to perform a read only test on a region of memory that has not previously been initialized to contain that pattern it will flag a test failure.</p>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set application log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>mem_tg application time out, by default time out 60000</p> <p><code>-m,--mem-channel</code></p> <p>Target memory bank for test to run on (0 indexed)  default: 0</p> <p><code>--loops</code></p> <p>Number of read/write loops to be run  default: 1</p> <p><code>-w,--writes</code></p> <p>Number of unique write transactions per loop.  default: 1</p> <p><code>-r,--reads</code></p> <p>Number of unique read transactions per loop  default: 1</p> <p><code>-b,--bls</code></p> <p>AXI4 burst length of each request.  Supports 1-256 transfers beginning from 0. default: 0</p> <p><code>--stride</code></p> <p>Address stride for each sequential transaction (&gt;= burst length)  default: 1</p> <p><code>--data</code></p> <p>Memory traffic data pattern. 0 = fixed {0xFF, 0x00} 1 = prbs7 2 = prbs15 3 = prbs31 4 = rot1</p> <p>default: fixed</p> <p><code>-f, --mem-frequency</code></p> <p>Memory traffic clock frequency in MHz  default: 300 MHz</p>"},{"location":"sw/fpga_tools/mem_tg/mem_tg/#examples","title":"EXAMPLES","text":"<p>This command will run a basic read/write test on the channel 0 traffic generator: <pre><code>mem_tg tg_test\n</code></pre></p> <p>This command will run the application for an afu on pcie 000:b1:00.7: <pre><code>mem_tg --pci-address 000:b1:00.7 tg_test\n</code></pre></p> <p>This command will test channel 2 write bandwidth: <pre><code>mem_tg -loops 1000 -w 1000 -r 0 -m 2 tg_test\n</code></pre></p> <p>This command will perform a read bandwidth test with a burst of 16 on channel 1 and perform a data comparison with the prbs7 pattern: <pre><code>mem_tg -loops 1000 -w 0 -r 1000 -b 0xF --data prbs7 -m 1 tg_test\n</code></pre></p> <p>This command will perform a read/write test with 1 MB strided access to channel 0 memory: <pre><code>mem_tg -loops 10000 --stride 0x100000 tg_test\n</code></pre></p>"},{"location":"sw/fpga_tools/mmlink/mmlink/","title":"mmlink","text":""},{"location":"sw/fpga_tools/mmlink/mmlink/#synopsis","title":"Synopsis","text":"<p><code>mmlink [-v] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;TCP port&gt;] [-I &lt;IP Address&gt;]</code></p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#description","title":"Description","text":"<p>The Remote Signal Tap logic analyzer provides real-time hardware debugging for the Accelerator Function Unit (AFU).  It provides a signal trace capability that the Quartus Prime software adds to the AFU. The Remote Signal Tap logic analyzer provides access to the Remote Signal Tap part of the Port MMIO space and then runs the remote protocol.</p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#examples","title":"Examples","text":"<p><code>./mmlink  -B 0x5e -P 3333</code></p> <p>MMLink app starts and listens for connection.</p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#options","title":"Options","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-S,--socket</code> </p> <p>FPGA socket number.</p> <p><code>-P,--port</code> </p> <p>TCP port number.</p> <p><code>-I,--ip</code> </p> <p>IP address of FPGA system. </p>"},{"location":"sw/fpga_tools/mmlink/mmlink/#notes","title":"Notes","text":"<p>Driver privilege:</p> <p>Change AFU driver privilege to user:</p> <pre><code>$ chmod 777 /dev/intel-fpga-port.0\n</code></pre> <p>Change locked memory size:</p> <p>edit the file /etc/security/limits.conf</p> <pre><code>$ sudo vi /etc/security/limits.conf\n\nuser    hard   memlock           10000\n\nuser    soft   memlock           10000\n</code></pre> <p>Exit terminal and log into a new terminal.</p> <p>Verify that the locked memory is now set:  ``` $ ulimit -l 10000</p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/","title":"ofs.uio","text":""},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#synopsis","title":"SYNOPSIS","text":"<p><code>ofs.uio [-h] [--pcie-address PCIE_ADDRESS] [--uio uiox] [--feature-id FEATURE_ID] [--region-index REGION_INDEX]                   [--mailbox-cmdcsr offset] [--bit-size {8,16,32,64}] [--peek offset] [--poke offset value]                   [--mailbox-read offset] [--mailbox-dump address size] [--mailbox-write address value]</code></p> <p><code>ofs.uio [--uio uiox] [--peek offset]</code> <code>ofs.uio [--uio uiox] [--poke offset value]</code> <code>ofs.uio [--uio uiox] [--mailbox-read address]</code> <code>ofs.uio [--uio uiox] [--mailbox-write address value]</code> <code>ofs.uio [--uio uiox] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#description","title":"DESCRIPTION","text":"<p><code>ofs.uio</code> is a tool that provides user space access to DFL UIO devices, command line options like peek, poke, mailbox-read, mailbox-write, mailbox-dump to  access Configuration and Status Registers (CSRs).</p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#peek","title":"Peek","text":"<p>Peek/Read UIO CSR offset <code>ofs.uio [--uio uio] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#poke","title":"Poke","text":"<p>Poke/Write value to UIO CSR offset <code>ofs.uio [--uio uio] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-read","title":"Mailbox Read","text":"<p>Read CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-write","title":"Mailbox Write","text":"<p>Write value to CSR address using mailbox  <code>ofs.uio [--uio uio] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-dump","title":"Mailbox Dump","text":"<p>Reads/Dumps block size of CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#bit-size","title":"Bit size","text":"<p>Read/Write bit-field 8,16,32,64 sizes <code>ofs.uio [--uio uio] --bit-size 8 [--peek offset]</code> <code>ofs.uio [--uio uio] --bit-size 32 [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#pcie-address","title":"PCIe Address","text":"<p>PCIE_ADDR PCIe address of FPGA device <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#uio-region-index","title":"UIO region index","text":"<p>UIO region index, default region index is 0  <code>ofs.uio [--uio uio] --region-index 0 [--peek offset]</code> <code>ofs.uio [--uio uio] --region-index 1 [--peek offset]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#mailbox-command-status-csr-offset","title":"Mailbox command status csr offset","text":"<p>Mailbox command status csr offset,  default value set to dfl pcie subsystem system feature mailbox command status register offset 0x28  <code>ofs.uio [--uio uio] --mailbox-cmdcsr 0xa8 [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] --mailbox-cmdcsr 0xa8  [--mailbox-read address]</code></p>"},{"location":"sw/fpga_tools/ofs.uio/ofs.uio/#examples","title":"EXAMPLES","text":"<p>Peek/Read <pre><code>ofs.uio --uio uio0 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio6 --peek 0x0\npeek(0x0): 0x3000000100000020\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio0 --peek 0x0 --bit-size 32\npeek(0x0): 0x10002015\n</code></pre></p> <p>Poke/Write <pre><code>ofs.uio --uio uio6 --peek 0x8\npeek(0x8): 0x0\nofs.uio --uio uio6 --poke  0x8 0xabcdd12345\npoke(0x8):0xabcdd12345\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x8): 0x0\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --poke  0x8 0x1234\npoke(0x8):0x1234\n</code></pre></p> <p>Mailbox Read <pre><code>ofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --uio uio6 --mailbox-read 0x8\nMailboxRead(0x8): 0x110c000\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x8 \nMailboxRead(0x8): 0x110c000\n</code></pre></p> <p>Mailbox Write <pre><code>ofs.uio --uio uio6 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0):0x1234\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0 \nMailboxRead(0x0):0x1234\n</code></pre></p> <p>Mailbox Dump <pre><code>ofs.uio --uio uio6 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n</code></pre></p>"},{"location":"sw/fpga_tools/opae.io/opae.io/","title":"opae.io","text":""},{"location":"sw/fpga_tools/opae.io/opae.io/#synopsis","title":"SYNOPSIS","text":"<p><code>opae.io ls [-v,--viddid VID:DID]</code> <code>opae.io init [-d PCI_ADDR USER[:GROUP]]</code> <code>opae.io release [-d PCI_ADDR]</code> <code>opae.io [-d PCI_ADDR] [-r REGION] walk OFFSET [-u,--show-uuid]</code> <code>opae.io [-d PCI_ADDR] [-r REGION] peek OFFSET</code> <code>opae.io [-d PCI_ADDR] [-r REGION] poke OFFSET VALUE</code> <code>opae.io [-d PCI_ADDR] [-r REGION] SCRIPT ARG1 ARG2 ... ARGN</code> <code>opae.io [-d PCI_ADDR] [-r REGION]</code></p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#description","title":"DESCRIPTION","text":"<p><code>opae.io</code> is an interactive Python environment packaged on top of <code>libopaevfio.so</code>, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device.</p> <p><code>opae.io</code> has two operating modes: command line mode and interactive mode.</p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#command-line-mode","title":"COMMAND LINE MODE","text":"<p>To view the accelerator devices that are present on the system, <code>opae.io</code> provides the <code>ls</code> command option.</p> <p><code>opae.io ls [-v,--viddid VID:DID]</code></p> <p>Each accelerator device is listed along with the PCIe address, the PCIe vendor/device ID, a brief description of the device, and the driver to which the device is currently bound.</p> <p><code>opae.io</code> provide an option to initialize a PCIe device for use with the vfio-pci driver. In order for the device CSRs to be accessed from user space, the device must first be bound to the vfio-pci driver. This is the job of the <code>init</code> command option.</p> <p><code>opae.io init [-d PCI_ADDR USER:[GROUP]]</code></p> <p>The <code>init</code> command unbinds the specified device from its current driver and binds it to vfio-pci. This creates a new vfio group under /dev/vfio. This group path is then used by the <code>libopaevfio.so</code> library to interact with the device.</p> <p>To release the PCIe device from vfio-pci and return it to use with its previous driver, the <code>release</code> command option is used.</p> <p><code>opae.io release [-d PCI_ADDR]</code></p> <p>The <code>release</code> command option reverses the actions of the last <code>init</code> command, releasing the device from vfio-pci and binding it to the driver which was bound at the time the <code>init</code> command was issued.</p> <p>The <code>walk</code> command option traverses and displays the Device Feature List of the given region.</p> <p><code>opae.io walk [-d PCI_ADDR] [-r REGION] [OFFSET] [-u,--show-uuid]</code></p> <p>The various fields of each Device Feature Header are displayed. The <code>--show-uuid</code> option additionally displays the GUID for each feature. OFFSET can be used to specify the beginning of the DFL in the MMIO region.</p> <p>The <code>peek</code> command option reads and displays a CSR value.</p> <p><code>opae.io peek [-d PCI_ADDR] [-r REGION] OFFSET</code></p> <p>The <code>poke</code> command option writes a given value to a CSR.</p> <p><code>opae.io poke [-d PCI_ADDR] [-r REGION] OFFSET VALUE</code></p> <p><code>opae.io</code> can also execute Python scripts from the command line. These Python scripts may contain calls to the device built-in functions that are available during an interactive session. Refer to the description of interactive mode for details.</p> <p><code>opae.io [-d PCI_ADDR] [-r REGION] myscript.py a b c</code></p> <p>In order to enter the interactive mode of <code>opae.io</code>, simply invoke it and optionally pass the desired device address and MMIO region options.</p> <p><code>opae.io [-d PCI_ADDR] [-r REGION]</code></p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#interactive-mode","title":"INTERACTIVE MODE","text":"<p>Upon entering interactive mode, <code>opae.io</code> begins a Python interpreter session and displays the command prompt shown below:</p> <p>0000:3f:00.0[0]&gt;&gt;</p> <p>The first portion of the prompt shows the address of the active PCIe device, here 0000:3f:00.0. The part in square brackets shows the active MMIO region, here [0].</p> <p>The interpreter waits for a valid Python command, then attempts to execute the given command in the usual way. The only differences between the traditional Python command intepreter and <code>opae.io</code> are that opae.io provides 1) the notion of an active PCIe device and MMIO region and 2) several built-in functions and objects that allow manipulating the active device and MMIO region.</p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#built-in-functions","title":"BUILT-IN FUNCTIONS","text":"<p>The <code>opae.io</code> built-in functions assume an active device and MMIO region. Attempting to use the built-in functions without first opening a device and region will result in errors.</p> <p><code>peek(OFFSET)</code></p> <p>The <code>peek</code> built-in function reads and displays a CSR value from the active device and region, at the offset supplied by its argument.</p> <p>0000:3f:00.0[0]&gt;&gt; peek(0x28) 0xdeadbeef</p> <p><code>poke(OFFSET, VALUE)</code></p> <p>The <code>poke</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; poke(0x28, 0xdeadbeef)</p> <p><code>read_csr(OFFSET)</code></p> <p>The <code>read_csr</code> built-in function returns the value of the CSR at the active MMIO region and the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; print('0x{:0x}'.format(read_csr(0x28))) 0xdeadbeef</p> <p><code>write_csr(OFFSET, VALUE)</code></p> <p>The <code>write_csr</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; write_csr(0x28, 0xdeadbeef)</p> <p><code>device(PCI_ADDR)</code></p> <p>The <code>device</code> built-in function allows changing the active PCIe device.</p> <p>0000:3f:00.0[0]&gt;&gt; device('0000:2b:00.0') 0000:2b:00.0&gt;&gt;</p> <p><code>region(REGION)</code></p> <p>The <code>region</code> built-in function allows changing the active MMIO region.</p> <p>0000:2b:00.0&gt;&gt; region(0) 0000:2b:00.0[0]&gt;&gt;</p> <p><code>allocate_buffer(SIZE)</code></p> <p>The <code>allocate_buffer</code> built-in function creates and returns a DMA buffer object. The underlying buffer will be SIZE bytes in length.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = allocate_buffer(4096) 0000:2b:00.0[0]&gt;&gt; print(b1.size, '0x{:0x}'.format(b1.address), b1.io_address) 4096 0x7f9361c66000 0</p> <p><code>version()</code></p> <p>The <code>version</code> built-in function returns a tuple containing the four components used to identify the opae.io version:</p> <p>0000:2b:00.0[0]&gt;&gt; print(version()) ('opae.io', 0, 2, 0)</p>"},{"location":"sw/fpga_tools/opae.io/opae.io/#built-in-objects","title":"BUILT-IN OBJECTS","text":"<p><code>opae.io</code> interactive mode provides two global objects corresponding to the current device and that device's current MMIO region. These objects are referred to by global variables <code>the_device</code> and <code>the_region</code>, respectively.</p> <p>The <code>device</code> class:</p> <p>the_device.descriptor() : method that returns the integer file descriptor of the <code>VFIO container</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.descriptor()) 5</p> <p>the_device.repr() : method that is invoked when a <code>device</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device) 0000:2b:00.0</p> <p>the_device.allocate(SIZE) : method that allocates and returns a <code>system_buffer</code> object. The buffer will be mapped into the DMA space of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = the_device.allocate(4096)</p> <p>the_device.pci_address() : read-only property that returns the PCIe address of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.pci_address) 0000:2b:00.0</p> <p>the_device.num_regions : read-only property that returns the number of MMIO regions in <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.num_regions) 2</p> <p>the_device.regions : read-only property that returns a list of the active MMIO regions of <code>the_device</code>:</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.regions) [0, 2]</p> <p>The <code>region</code> class:</p> <p>the_region.write32(OFFSET, VALUE) : method that writes a 32-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read32(OFFSET) : method that returns a 32-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write32(0x28, 0xdeadbeef) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read32(0x28))) 0xdeadbeef</p> <p>the_region.write64(OFFSET, VALUE): method that writes a 64-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read64(OFFSET): method that returns a 64-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write64(0x28, 0xbaddecaf) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read64(0x28))) 0xbaddecaf</p> <p>the_region.index(): method that returns the MMIO index of <code>the_region</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region.index()) 0</p> <p>the_region.repr(): method that is invoked when a <code>region</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region) 0</p> <p>the_region.len(): method that is invoked to determine the MMIO region size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(len(the_region)) 524288</p> <p>The <code>allocate_buffer()</code> built-in function and the <code>device.allocate()</code> method return objects of type <code>system_buffer</code>.</p> <p>The <code>system_buffer</code> class is as follows:</p> <p><code>buf.size</code>: read-only property that gives the buffer size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(b1.size) 4096</p> <p><code>buf.address</code>: read-only property that gives the buffer's user mode virtual address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.address)) 0x7f2c15d8200</p> <p><code>buf.io_address</code>: read-only property that gives the buffer's IO address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.io_address)) 0x0</p> <p><code>buf.__getitem__</code> and <code>buf.__setitem__</code>: indexing get/set of 64-bit data item.</p> <p>0000:2b:00.0[0]&gt;&gt; b1[0] = 0xdecafbad 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1[0])) 0xdecafbad</p> <p><code>buf.read8(OFFSET)</code> <code>buf.read16(OFFSET)</code> <code>buf.read32(OFFSET)</code> <code>buf.read64(OFFSET)</code> : methods that read the given size data item from the given buffer OFFSET.</p> <p><code>buf.fill8(VALUE)</code> <code>buf.fill16(VALUE)</code> <code>buf.fill32(VALUE)</code> <code>buf.fill64(VALUE)</code> : methods that fill the buffer with the given VALUE, using the given size.</p> <p><code>b1.compare(b2)</code>: method that compares buffers. The method returns the index of the first byte that miscompares, or the length of b1.</p>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/","title":"opaeuio","text":""},{"location":"sw/fpga_tools/opaeuio/opaeuio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaeuio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-v] [device]</code></p>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/#description","title":"DESCRIPTION","text":"<p>The <code>opaeuio</code> command enables the binding/unbinding of a DFL device to/from the dfl-uio-pdev device driver. See https://kernel.org/doc/html/v4.14/driver-api/uio-howto.html for a description of uio.</p>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/#options","title":"OPTIONS","text":"<p><code>device</code>     The DFL device name, eg dfl_dev.10</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given device for uio.\nUsed in conjunction with -u, -g, and -d.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given device from uio.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when binding to uio.\nThe default value is dfl-uio-pdev.\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to uio. A new device node is created in\n/dev when the device is bound to uio. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to uio. Use this option to specify the\nnew device group for the device created in /dev.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"sw/fpga_tools/opaeuio/opaeuio/#examples","title":"EXAMPLES","text":"<p><code>opaeuio -h</code> <code>opaeuio -v</code> <code>sudo opaeuio -i -u lab -g labusers dfl_dev.10</code> <code>sudo opaeuio -r dfl_dev.10</code></p>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/","title":"opaevfio","text":""},{"location":"sw/fpga_tools/opaevfio/opaevfio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaevfio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-n] [-v] [addr]</code></p>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/#description","title":"DESCRIPTION","text":"<p>The <code>opaevfio</code> command enables the binding/unbinding of a PCIe device to/from the vfio-pci device driver. See https://kernel.org/doc/Documentation/vfio.txt for a description of vfio-pci.</p>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/#options","title":"OPTIONS","text":"<p><code>addr</code>     The PCIe address of the device in ssss:bb:dd.f format, eg 0000:7f:00.0</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given addr for vfio.\nUsed in conjunction with -u, -g, and -n.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given addr from vfio.\nUsed in conjunction with -d.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when releasing from vfio.\nWhen omitted, the device is not rebound to a driver (default).\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to vfio. A new device node is created in\n/dev/vfio when the device is bound to vfio-pci. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to vfio. Use this option to specify the\nnew device group for the device created in /dev/vfio.\n</code></pre> <p><code>-n, --no-sriov</code></p> <pre><code>Do not enable SR-IOV when binding to vfio. The default value for this option\nis FALSE, ie the script should specify SR-IOV functionality when binding to\nthe vfio-pci driver. When omitted, the modprobe command which loads the vfio-pci\ndriver will contain the `enable_sriov=1` option. When given, it will not.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"sw/fpga_tools/opaevfio/opaevfio/#examples","title":"EXAMPLES","text":"<p><code>opaevfio -h</code> <code>opaevfio -v</code> <code>sudo opaevfio -i -u lab -g labusers 0000:7f:00.0</code> <code>sudo opaevfio -r 0000:7f:00.0</code></p>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/","title":"Pac hssi config","text":"<pre><code># pac_hssi_config #\n\n## SYNOPSIS ##\n```console\npac_hssi_config.py [-h] subcommand [subarg] [bdf]\n</code></pre>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#description","title":"DESCRIPTION","text":"<p>The <code>pac_hssi_config.py</code> tool exercises the Ethernet 10 Gbps (10GbE) and 40GbE transceivers for designs using the Intel\u00ae Programmable Acceleration Card (PAC) with Intel Arria\u00ae 10 GX FPGA. This tool does not support the  Intel Xeon\u00ae Processor with Integrated FPGA. </p> <p></p> <p>The two required arguments to the <code>pac_hssi_config.py</code> tool specify the subcommand and bus, device, and function (BDF) for the PCIe device under test. You must provide the BDF parameter for systems with more than one PCIe card. </p> <pre><code>.. note::\n    If you do not provide the BDF when required, the command prints a list of valid BDFs for the system. You can also\n    determine the BDF using the ``lspci`` command.\n</code></pre> <p>For usage help, type the following at a command prompt:</p> <p><code>pac_hssi_config.py [-h|--help]</code></p> <p>To configure the network ports, send data, and read statistics, use the following form of the <code>pac_hssi_config.py</code> script:</p> <p><code>pac_hssi_config.py subcommand [subarg] [bdf]</code></p> <p>Only a subset of subcommand arguments support <code>subarg</code>. </p>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#table-1-general-subcommands","title":"Table 1. General Subcommands","text":"Subcommand Subarg Description <code>stat</code> N/A Prints high speed serial interface (HSSI) controller statistics. <code>eeprom</code> N/A Reads the 128-bit unique board ID, MAC address, and board-specific IDs from EEPROM."},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#table-2-1040-gbe-traffic-generation-subcommands","title":"Table 2. 10/40 GbE Traffic Generation Subcommands","text":"Subcommand Subarg Description <code>e10init</code> and <code>e40init</code> N/A Initializes HSSI PHY to 10GbE or 40GbE mode.  Clears statistics and enable internal HSSI transceiver loopback. <code>e10loop</code> and <code>e40loop</code> On/Off Turns on or off internal HSSI transceiver loopback. <code>e10reset</code> and <code>e40reset</code> On/Off Asserts or deasserts AFU reset.  Clears packet statistics and disables internal HSSI transceiver loopback. <code>e10send</code> and <code>e40send</code> N/A Sends 1,000,000 1500-byte packets. For 10GbE sends packets on all four ports. 40GbE has a single port. <code>e10stat</code> and <code>e40stat</code> N/A Prints packet statistics. <code>e10statclr</code> and <code>e40statclr</code> N/A Clears packet statistics.  Use this command after switching loopback modes to clear any transient statistics accumulated during the mode switch. <p>The transceiver equalization <code>eqwrite</code> and <code>eqread</code> subcommands write and read transceiver equalization settings.  These subcommands require you to specify the transceiver channel, the equalization setting, and the value (for writes).  Use the following form for the <code>eqwrite</code> command:</p> <p><code>pac_hssi_config.py eqwrite [transceiver channel number] [equalization setting] [equalization value] [bdf]</code></p> <p>Use the following form for the <code>eqread</code>command:</p> <p><code>pac_hssi_config.py eqread [transceiver channel number] [equalization setting] [bdf]</code> </p>"},{"location":"sw/fpga_tools/pac_hssi_config/pac_hssi_config/#table-3-transceiver-equalization-subcommands","title":"Table 3. Transceiver Equalization Subcommands","text":"Subcommand Channel Number Equalization Setting Value <code>eqwrite</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) Specifies the value for the specified equalization setting. <code>eqread</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) N/A <p>For more information about reconfiguring transceiver analog parameter settings In Arria\u00ae 10 devices, refer to \"Changing PMA Analog Parameters\" in the  Intel\u00ae Arria\u00ae 10 Transceiver PHY User Guide. </p>"},{"location":"sw/fpga_tools/packager/packager/","title":"packager","text":""},{"location":"sw/fpga_tools/packager/packager/#synopsis","title":"SYNOPSIS","text":"<p><code>packager &lt;cmd&gt; [arguments]</code></p>"},{"location":"sw/fpga_tools/packager/packager/#description","title":"Description","text":"<p>The packager provides tools that Accelerator Functional Unit (AFU) developers use to create Accelerator Function (AF)  files. The AF file is the programming file for an AFU on Intel\u00ae FPGA platforms. The packager tool concatenates the metadata from the JSON file to a raw binary file <code>(.rbf)</code> that the Intel Quartus\u00ae Prime software generates. </p> <p>The packager's only function is to create an AF file. Refer to Packager Command Syntax for more information about invoking the packager. The packager depends on a JSON file to describe AFU metadata. Refer to  Accelerator Description File for more information about the JSON file.</p> <p>The packager requires Python 2.7.1 and Python 2.7.3. The tool indicates if it is being called with a compatible  of Python.</p>"},{"location":"sw/fpga_tools/packager/packager/#packager-command-syntax","title":"Packager Command Syntax","text":"<p>The packager is a command line tool with the following syntax:</p> <p><code>$ packager &lt;cmd&gt; [arguments]</code></p> <p>The following table describes the <code>&lt;CMD&gt;</code> arguments:</p> Command Arguments Description <code>create-gbs</code> <code>--rbf=&lt;RBF_PATH&gt;</code> <code>--afu=&lt;AFU_JSON_PATH&gt;</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> Creates the AF file. The engineering name for this file is the green bit stream, abbreviated gbs. The <code>--rbf</code> and <code>--afu</code>   arguments are required.  <code>&lt;RBF_PATH&gt;</code> is the path to the RBF file for the AFU. The Quartus\u00ae Prime software generates this RBF by compiling the AFU design. <code>&lt;AFU_JSON_PATH&gt;</code> is the path to the Accelerator Description file. This is a JSON file that describes the metadata that <code>create-gbs</code> appends to the RBF. <code>&lt;GBS_PATH&gt;</code> is the path to the RBF file for the FPGA Interface Manager (FIM) that contains the FPGA interface unit and other interfaces. If you do not specify the <code>--gbs</code>, the command defaults to <code>&lt;rbf_name&gt;.gbs</code>. You can use the optional <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>modify-gbs</code> <code>--gbs=&lt;gbs_PATH&gt;</code> Modifies the AF file. The <code>--input-gbs</code>argument is required. If you do not provide the <code>--output-gbs</code> argument, <code>modify-gbs</code> overwrites the <code>--input-gbs</code> file. Use the <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>gbs-info</code> <code>--input-gbs=&lt;gbs_PATH&gt;</code> Prints information about the AF file. The <code>--input-gbs</code> argument is required. <code>get-rbf</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--rbf=&lt;RBF_PATH&gt;</code> Creates the RBF by extracting it from the AF file. The <code>--gbs</code>argument is required. If you do not specify the <code>--rbf</code> argument, the command defaults to <code>&lt;gbs_name.rbf</code> . None, or any <code>&lt;CMD&gt;</code> <code>--help</code> Summarizes the <code>&lt;CMD&gt;</code> options. Typing <code>packager --help</code> gives a list of <code>&lt;CMD&gt;</code> values. Typing <code>packager &lt;CMD&gt; --help</code> provides detailed help for <code>&lt;CMD&gt;</code>"},{"location":"sw/fpga_tools/packager/packager/#examples","title":"Examples","text":"<p>To generate an AF file, run:</p> <p><code>$ packager create-gbs --rbf=&lt;RBF_PATH&gt; --afu=&lt;AFU_JSON_PATH&gt; --gbs=&lt;GBS_PATH&gt;</code></p> <p>TIP: JSON files are very particular about syntax such as trailing commas. If you are getting errors, use <code>jsonlint.com</code> to validate that your JSON is formatted correctly. </p> <p>To modify metadata in an existing AF, run the following command:</p> <p><code>$ packager modify-gbs --input-gbs=&lt;PATH_TO_GBS_TO_BE_MODIFIED&gt; --outputgbs=&lt;NAME_FOR_NEW_GBS&gt; --set-value &lt;key&gt;:&lt;value&gt;</code></p> <p>You can pass in a number of : pairs with --set-value to update values in an AF.  <p>To print the metadata of an existing AF: </p> <p><code>$ packager get-info --gbs=&lt;GBS_PATH&gt;</code> </p> <p>To extract the RBF from the AF:</p> <p><code>$ packager get-rbf --gbs=&lt;GBS_PATH&gt; --rbf=&lt;NAME_FOR_RBF&gt;</code></p>"},{"location":"sw/fpga_tools/packager/packager/#accelerator-description-file","title":"Accelerator Description File","text":"<p>The Accelerator Description File is a JSON file that describes the metadata associated with an AFU. The Open Progammable Accelerator Engine (OPAE) uses this metadata during reconfiguration. Here is an example file:</p> <p><pre><code>{\n   \"version\": 1,\n   \"platform-name\": \"DCP\",\n   \"afu-image\": {\n      \"magic-no\": 488605312,\n      \"interface-uuid\": \"01234567-89AB-CDEF-0123-456789ABCDEF\",\n      \"power\": 0,\n      \"accelerator-clusters\": [{\n         \"name\": \"dma_test_afu\",\n         \"total-contexts\": 1,   \n         \"accelerator-type-uuid\": \"331DB30C-9885-41EA-9081-F88B8F655CAA\"\n      }\n      ]  \n   }\n}\n</code></pre> The packager stores these parameter values in the resultant AF. After reprogramming the AFU using partial reconfiguration (PR), the  software driver reconfigures the PLLs by writing the clock-frequency-high and clock-frequency-low values (if present) over the  PCIe\u00ae and CCI interfaces. </p> <p>.. note:: <pre><code>The JSON file format may change as the architecture evolves. Any changes to the current format trigger an update\nto the version number.  \n</code></pre></p> <p>CATEGORY | NAME | TYPE | DESCRIPTION | MANDATORY ---------|------|------|-------------|:----------:| Per-AFU  | version | Integer | Version of the metadata format. | Yes Per-AFU  | magic-no (to be deprecated)| Integer | Magic no. Associated with the FPGA Interface Manager. | No Per-AFU  | platform-name | String | Name of the platform for which the metadata is intended. The field value is \u201cDCP\u201d for Intel  Acceleration Stack for FPGAs. | No Per-AFU  | interface-uuid | UUID | Interface id associated with the FPGA Interface Manager. | Yes Per-AFU  | power | Integer | Accelerator Function power consumption, in watts. Set to 0 for Intel Acceleration Stack for FPGAs platforms. | Yes Per-AFU  | clock-frequency-low | Float | Clock frequency for 1st PLL (Clock network)1 in MHz. | No Per-AFU  | clock-frequency-high | Float | Clock frequency for 2nd PLL (0 if absent) in MHz. | No Per-AFC Cluster | total-contexts | Integer | Number of AFCs in this cluster. Always be 1 in current architectures. | Yes Per-AFC Cluster | afc-type-uuid |  UUID | AFC type = AFU ID in current architectures. | Yes Per-AFC Cluster | name | string | AFC name = AFU name in current architectures. | Yes</p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"sw/fpga_tools/pci_device/pci_device/","title":"pci_device","text":""},{"location":"sw/fpga_tools/pci_device/pci_device/#synopsis","title":"SYNOPSIS","text":"<p><code>pci_device [-h] [-E] device-filter [{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}]</code></p>"},{"location":"sw/fpga_tools/pci_device/pci_device/#description","title":"DESCRIPTION","text":"<p>pci_device is a tool to aid in common operations for managing PCIe devices and drivers.</p>"},{"location":"sw/fpga_tools/pci_device/pci_device/#options","title":"OPTIONS","text":""},{"location":"sw/fpga_tools/pci_device/pci_device/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<pre><code>`device filter`\n\nPCIe address of a device or vendor/device ID pair.\nThe PCIe address follows the format of [segment:]bus:device.function\nwhile the vendor/device ID pair follows the format [vendor ID]:[device ID]\nwhere at least one of these must be present.\n\n`{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}`\n\naction to perform on device\n\n`aer`\nPerform AER (Advanced Error Reporting) operations.\nThe aer action has its own sub-commands which are listed below:\n\n* `dump` sub-command will print out the AER error counters as reported\n   by the sysfs files for the device.\n* `mask` can either print out the current AER mask bits or set them\n  * If `show` or `print` (or nothing) is given after the `mask`\n    command, it will show the current mask bits for AER.\nBy default output will be written in stdout but can be written to an\noutput file if `-o|--output FILENAME` argument is given.\n  * If `all` is given after the `mask` command, it will mask all bits\n    (by setting the values to 0xffffffff and 0xffffffff).\n  * If `off` is given after the `mask` command, it will unmask all\n    bits (by setting the values to 0x0 and 0x0).\n  * If two numbers are present after the `mask` command, those two\n    numbers will be used to set the mask bits.\nValues for setting the mask can also be read in from an input file if\n`-i|--input FILENAME` argument is given.\n\n_NOTE_: mask related operations require root privileges\n\n`bind`\n\nAssociate a device with its driver.\n\n`plug`\n\nRestore a device that was previously given to `pci_device &lt;device&gt; unplug`\n\n`remove`\n\nRemove the pci device from the pci bus\n\n`rescan`\n\nRescan the bus as identified by the bus component of the PCIe device address\n\n'topology`\n\nPrint the PCIe topology from the root port to the PCIe device.\nThis shows the PCIe tree rooted at the PCIe root port.\nEach line shows the the PCIe address, vendor ID, and device ID along with\nthe driver bound to the device. The indentnation is used to show\nparent/child relationship of devices.\n\nThe line listing the target PCIe device as identified by the given PCIe\naddress will be highlighted in green while the endpoints will be\nhighlighted in cyan.\n\nThe example below shows the topology of an N3000 device with eight virtual\nfunctions created from one of the Ethernet controllers:\n\n```console\n[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)\n    [pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)\n        [pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3f:00.0), pci_id(0x8086, 0x0b30)] (dfl-pci)\n        [pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)\n    [pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3d:02.0), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.7), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.5), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.3), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.1), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.6), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.4), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.2), pci_id(0x8086, 0x154c)] (iavf)\n        [pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n\n```\n\n`unbind`\n\nUnbind the driver bound to the device.\n\n`unplug`\n\nRemove device from PCI bus in anticipation of a RSU event by configuring its root port and associated endpoints.\n\n`vf`\n\nCreate/destroy VFs (virtual functions) by setting the number here.\nThe number given here will be written to sriov_numvfs sysfs file triggering\nthe PCIe subsystem to create/destroy VFs so that the current number of VFs\nwill be equal to the given number. If the number given is outside of the total VFs supported, an error message will be displayed to indicate this.\n</code></pre>"},{"location":"sw/fpga_tools/pci_device/pci_device/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<pre><code>`-h, --help`\n\nshow this help message and exit\n\n`-E, --other-endpoints`\n\nperform action on peer PCIe devices\n</code></pre>"},{"location":"sw/fpga_tools/pci_device/pci_device/#examples","title":"EXAMPLES","text":"<pre><code>pci_device 0000:3d:00.0 remove\npci_device 0000:3d:00.0 rescan\npci_device 3d:00.0 topology\npci_device :0b30 topology\npci_device :0b30 aer\npci_device :0b30 aer mask\npci_device :0b30 aer mask all\npci_device :0b30 aer mask -o mask.dat\npci_device :0b30 aer mask -i mask.dat\n</code></pre>"},{"location":"sw/fpga_tools/rsu/rsu/","title":"rsu","text":""},{"location":"sw/fpga_tools/rsu/rsu/#synopsis","title":"SYNOPSIS","text":"<pre><code>rsu [-h] [-d] {bmc,bmcimg,retimer,fpga,sdm,fpgadefault} [PCIE_ADDR]\n</code></pre>"},{"location":"sw/fpga_tools/rsu/rsu/#description","title":"DESCRIPTION","text":""},{"location":"sw/fpga_tools/rsu/rsu/#mode-1-rsu","title":"Mode 1: RSU","text":"<pre><code>rsu bmc --page=(user|factory) [PCIE_ADDR]\nrsu retimer [PCIE_ADDR]\nrsu fpga --page=(user1|user2|factory) [PCIE_ADDR]\nrsu sdm --type=(sr|pr|sr_cancel|pr_cancel) [PCIE_ADDR]\n</code></pre> <p>Perform RSU (remote system update) operation on PAC device given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.</p>"},{"location":"sw/fpga_tools/rsu/rsu/#mode-2-default-fpga-image","title":"Mode 2: Default FPGA Image","text":"<pre><code>rsu fpgadefault --page=(user1|user2|factory) --fallback=&lt;csv&gt; [PCIE_ADDR]\n</code></pre> <p>Set the default FPGA boot sequence. The --page option determines the primary FPGA boot image. The --fallback option allows a comma-separated list of values to specify fallback images.</p>"},{"location":"sw/fpga_tools/rsu/rsu/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{bmc,bmcimg,retimer,fpga,sdm,fpgadefault}</code></p> <p>type of RSU operation or set Default FPGA Image operation.</p> <p><code>PCIE_ADDR</code>  PCIe address of device to do rsu (e.g. 04:00.0 or 0000:04:00.0) </p>"},{"location":"sw/fpga_tools/rsu/rsu/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code> show this help message and exit</p> <p><code>-d, --debug</code> log debug statements</p> <p><code>--force</code> force rsu operation</p>"},{"location":"sw/fpga_tools/rsu/rsu/#example","title":"EXAMPLE","text":"<pre><code># rsu bmc --page=user 25:00.0\n</code></pre> <p>Triggers a boot of the BMC image (user page) for the device with PCIe  address 25:00.0.</p> <pre><code># rsu bmc --page=factory 25:00.0\n</code></pre> <p>Triggers a factory boot of the BMC image for the device with  PCIe address 25:00.0.</p> <pre><code># rsu fpga --page=user2 25:00.0\n</code></pre> <p>Triggers a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0.</p> <pre><code># rsu --force fpga --page=user2 25:00.0\n</code></pre> <p>Forces a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0. Default behavior is to not perform  the rsu operation if DPC (downstream port containment) is not supported  and AER (advanced error reporting) is also not supported. Using --force  changes this behavior to perform rsu operation regardless but may result  in a surprise removal of pci devices which may cause the Linux kernel  to panic.</p> <pre><code># rsu fpga --page=factory 25:00.0\n</code></pre> <p>Triggers a factory reconfiguration of the FPGA for the device  with PCIe address 25:00.0.</p> <pre><code># rsu sdm --type=sr 25:00.0\n</code></pre> <p>Triggers Static Region key programming for the device with  PCIE address 25:00.0.</p> <pre><code># rsu fpgadefault --page=factory --fallback=user1,user2 25:00.0\n</code></pre> <p>Sets the FPGA boot sequence to factory with fallbacks user1, user2.</p>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/","title":"Super Remote System Update User Guide","text":"<pre><code>.. toctree::\n.. highlight:: c\n.. highlight:: console\n</code></pre>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#overview","title":"Overview","text":"<p>Intel Programmable Acceleration Card (PAC) devices are comprised of multiple processors and controllers that execute firmware. Maintaining and updating these firmware images manually is error-prone and does not scale well within the Data Center. The solution described here is derived with the following goals in mind:</p> <ul> <li>The ability to update one or more (possibly all) firwmare images with a single package.</li> <li>The ability to complete all firmware updates within a stipulated time window.</li> <li>The ability to update each PAC in the server, all servers in a Data Center, and multiple Data Centers remotely.</li> <li>The ability to remotely initiate download of the package and its installation with a single command per server instance.</li> <li>The ability to roll back firmware to a previous revision.</li> </ul>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#implementation","title":"Implementation","text":"<p>A single package containing firmware images for all programmable parts on a PAC is delivered as an RPM, eg opae-super-rsu-n3000.M.m.p-r.noarch.rpm. The RPM revision will sequentially increase with every update.</p> <p>Installing or upgrading the RPM invokes the complete update of all programmable parts on all PAC boards in the system.</p> <p>The standard RPM dependency framework ensures that correct versions of dependecy packages opae-intel-fpga-driver and fpga-tools-extra are installed on the system.</p> <p>Rolling back is achieved by uninstalling the current version and re-installing a previous version of the RPM.</p> <p>.. note:: <pre><code>Note: once Secure Update is deployed, roll back restrictions shall be implemented to prevent\nrollback attacks.\n</code></pre></p> <p>RPM management on remote systems is standard practice, requiring no new infrastructure/training.</p>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#details","title":"Details","text":"<p>The post-install hook of the opae-super-rsu-n3000 RPM is leveraged to call out to the super-rsu Python script to update all PAC boards. super-rsu uses the manifest file packaged within opae-super-rsu-n3000 to associate a firmware image with its version. Each of the firmware images contained in opae-super-rsu-n3000 is placed on the target system in /usr/share/opae/n3000.</p>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#algorithm","title":"Algorithm","text":"<ul> <li>Acquire the current firmware versions of all programmable parts.</li> <li>For each programmable image, if the installed version of firmware does not equal the version provided in the RPM manifest file, then update the firmware image, and set image_updated to True.</li> <li>After all updates, if image_updated, then initiate a safe reboot of all boards in the system.</li> <li>After safe reboot, verify that the reported firmware versions match those of the RPM manifest. If they do not match, then RPM installation exits with a failing status.</li> <li>Run board self test. If the self test fails, then the RPM installation exits with a failing status.</li> <li>If all of the above checks is successful, then RPM installation exits with a success status.</li> </ul>"},{"location":"sw/fpga_tools/super-rsu/super-rsu/#dependencies","title":"Dependencies","text":"<ul> <li>The standard Python package for the distro (version 2.7).</li> <li>The opae-intel-fpga-driver RPM. (version determined by opae-super-rsu-n3000)</li> <li>The opae-tools-extra RPM. (version determined by opae-super-rsu-n3000)</li> </ul>"},{"location":"sw/fpga_tools/userclk/userclk/","title":"userclk","text":""},{"location":"sw/fpga_tools/userclk/userclk/#synopsis","title":"SYNOPSIS","text":"<p><code>userclk [-hv] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] [-H &lt;User clock high frequency&gt;] -L &lt;User clock low frequency&gt;]</code></p>"},{"location":"sw/fpga_tools/userclk/userclk/#description","title":"DESCRIPTION","text":"<p>userclk sets the frequency range for an AFU. </p>"},{"location":"sw/fpga_tools/userclk/userclk/#examples","title":"EXAMPLES","text":"<p><code>./userclk -B 0x5e -H 400 -L 200</code></p> <p>Sets AFU frequency.</p>"},{"location":"sw/fpga_tools/userclk/userclk/#options","title":"OPTIONS","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-S,--segment</code> </p> <p>FPGA segment number.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-H,--freq-high</code> </p> <p>User clock high frequency. </p> <p><code>-L,--freq-low</code> </p> <p>User clock low frequency. </p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"sw/fpga_tools/vabtool/vabtool/","title":"vabtool","text":""},{"location":"sw/fpga_tools/vabtool/vabtool/#synopsis","title":"SYNOPSIS","text":"<p><code>vabtool [-r RETRIES] [-d] [-y] [-v] &lt;ACTION&gt;</code></p> <p>Where ACTION is defined as one of the following:</p> <p><code>vabtool sr_key_provision PCIE_ADDRESS SR_RKH_FILE FPGA_IMG_FILE</code> <code>vabtool sr_status PCIE_ADDRESS</code> <code>vabtool pr_key_provision PCIE_ADDRESS PR_AUTH_CERT_FILE PR_RKH_FILE</code> <code>vabtool pr_status PCIE_ADDRESS</code> <code>vabtool sr_key_cancel PCIE_ADDRESS SR_RKH_CANCEL_FILE</code> <code>vabtool sr_cancel_status PCIE_ADDRESS</code> <code>vabtool pr_key_cancel PCIE_ADDRESS PR_RKH_CANCEL_FILE</code> <code>vabtool pr_cancel_status PCIE_ADDRESS</code></p>"},{"location":"sw/fpga_tools/vabtool/vabtool/#description","title":"DESCRIPTION","text":"<p>The <code>vabtool</code> command helps perform Vendor Authenticated Boot provisioning of Static Region and Partial Reconfiguration Region key hashes and helps perform SR and PR hash cancellation and status reporting.</p>"},{"location":"sw/fpga_tools/vabtool/vabtool/#options","title":"OPTIONS","text":"<p><code>-r RETRIES, --retries RETRIES</code></p> <pre><code>Specifies the number of times a failed SR or PR key provision is to be\nretried. The default value for RETRIES is 3.\n</code></pre> <p><code>-d, --dry-run</code></p> <pre><code>Don't execute the actual fpgasupdate and rsu commands, but only print\nthe commands that would be executed during a normal run of the script.\n</code></pre> <p><code>-y, --yes</code></p> <pre><code>The tool will respond with an automatic Yes answer to all confirmation\nprompts posed by the sub-tools.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"sw/fpga_tools/vabtool/vabtool/#examples","title":"EXAMPLES","text":"<p><code>sudo vabtool -y sr_key_provision 0000:bc:00.0 my_sr_rkh.bin my_fpga.bin</code> <code>sudo vabtool sr_status 0000:bc:00.0</code> <code>sudo vabtool -y pr_key_provision 0000:bc:00.0 pr_auth_cert.bin my_pr_rkh.bin</code> <code>sudo vabtool pr_status 0000:bc:00.0</code> <code>sudo vabtool sr_key_cancel 0000:bc:00.0 my_sr_rhk_cancel.bin</code> <code>sudo vabtool sr_cancel_status 0000:bc:00.0</code> <code>sudo vabtool pr_key_cancel 0000:bc:00.0 my_pr_rhk_cancel.bin</code> <code>sudo vabtool pr_cancel_status 0000:bc:00.0</code></p>"},{"location":"sw/install_guide/installation_guide/","title":"OPAE Installation Guide","text":""},{"location":"sw/install_guide/installation_guide/#how-to-download-the-opae-sdk","title":"How to download the OPAE SDK","text":"<p>OPAE SDK releases are available on GitHub. Source code for the OPAE DFL device driver for Linux is also available on GitHub.</p>"},{"location":"sw/install_guide/installation_guide/#install-the-fedora","title":"Install the Fedora","text":"<p>Download the Fedora  (x86_64 version) installation file in fedora, and install the Fedora  in yourserver. You can choose Fedora Workstation or Fedora server.</p>"},{"location":"sw/install_guide/installation_guide/#build-the-kernel-and-dfl-drivers","title":"Build the kernel and DFL drivers","text":"<p>For building the OPAE kernel and kernel driver, the kernel development environment is required. So before you build the kernel, you must install the required packages. Run the following commands:</p> <pre><code>$ sudo dnf install gcc gcc-c++ make kernel-headers kernel-devel elfutils-libelf-devel ncurses-devel openssl-devel bison flex\n</code></pre> <p>Download the OPAE upstream kernel tree from github, for example download from fpga-ofs-dev-5.15-lts branch. <pre><code>$ git clone https://github.com/OPAE/linux-dfl.git -b fpga-ofs-dev-5.15-lts\n</code></pre></p> <p>Configure the kernel. <pre><code>$ cd linux-dfl\n$ cp /boot/config-`uname -r` .config\n$ cat configs/dfl-config &gt;&gt; .config\n$ echo 'CONFIG_LOCALVERSION=\"-dfl\"' &gt;&gt; .config\n$ echo 'CONFIG_LOCALVERSION_AUTO=y' &gt;&gt; .config\n$ sed -i -r 's/CONFIG_SYSTEM_TRUSTED_KEYS=.*/CONFIG_SYSTEM_TRUSTED_KEYS=\"\"/' .config\n$ sed -i '/^CONFIG_DEBUG_INFO_BTF/ s/./#&amp;/' .config\n$ echo 'CONFIG_DEBUG_ATOMIC_SLEEP=y' &gt;&gt; .config\n$ make olddefconfig\n</code></pre></p> <p>Compile and install the new kernel. <pre><code>$ make -j $(nproc)\n$ sudo make modules_install -j $(nproc)\n$ sudo make install\n</code></pre></p> <p>Build linux DFL Kernel instructions please also refer to: https://github.com/OPAE/linux-dfl/wiki/Build-the-linux-dfl-kernel</p> <p>When install finished, reboot your system. When the system login again, verify the kernel version is correct. For example: <pre><code>[figo@localhost linux-dfl]$ uname -a\nLinux localhost.localdomain 5.15.lts-dfl-g73e16386cda0 #6 SMP Mon Jun 13 21:21:31 -04 2022 x86_64 x86_64 x86_64\n</code></pre></p> <p>And also you can check the OPAE dfl drivers have auto-loaded. <pre><code>[figo@localhost linux-dfl]$ lsmod | grep fpga\nifpga_sec_mgr          20480  1 intel_m10_bmc_secure\nfpga_region            20480  3 dfl_fme_region,dfl_fme,dfl\nfpga_bridge            24576  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br\nfpga_mgr               16384  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme\n[figo@localhost linux-dfl]$ lsmod | grep dfl\ndfl_eth_group          36864  0\ndfl_fme_region         20480  0\ndfl_emif               16384  0\ndfl_n3000_nios         20480  0\ndfl_fme_br             16384  0\ndfl_fme_mgr            20480  1\ndfl_fme                49152  0\ndfl_afu                36864  0\ndfl_pci                20480  0\ndfl                    40960  7 dfl_pci,dfl_fme,dfl_fme_br,dfl_eth_group,dfl_n3000_nios,dfl_afu,dfl_emif\nfpga_region            20480  3 dfl_fme_region,dfl_fme,dfl\nfpga_bridge            24576  4 dfl_fme_region,fpga_region,dfl_fme,dfl_fme_br\nfpga_mgr               16384  4 dfl_fme_region,fpga_region,dfl_fme_mgr,dfl_fme\n</code></pre></p>"},{"location":"sw/install_guide/installation_guide/#build-the-opae-sdk","title":"Build the OPAE-SDK","text":"<p>Before you build the OPAE SDK, you must install the required packages. Run the following commands:</p>"},{"location":"sw/install_guide/installation_guide/#rocky-linux-85","title":"Rocky Linux 8.5","text":"<pre><code># dnf install -y 'dnf-command(config-manager)'\n# dnf config-manager --set-enabled powertools\n# dnf install -y epel-release\n# dnf check-update\n# dnf upgrade -y\n# dnf install -y python3 python3-pip python3-devel python3-jsonschema python3-pyyaml python3-pybind11 git gcc gcc-c++ make cmake libuuid-devel json-c-devel hwloc-devel tbb-devel cli11-devel spdlog-devel libedit-devel systemd-devel rpm-build rpmdevtools pybind11-devel yaml-cpp-devel libudev-devel linuxptp\n# python3 -m pip install jsonschema virtualenv pyyaml\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#fedora","title":"Fedora","text":"<pre><code># dnf check-update\n# dnf upgrade -y\n# dnf install -y python3 python3-pip python3-devel python3-jsonschema python3-pyyaml python3-pybind11 git gcc g++ make cmake libuuid-devel json-c-devel hwloc-devel tbb-devel libedit-devel rpm-build rpmdevtools pybind11-devel yaml-cpp-devel libudev-devel cli11-devel spdlog-devel linuxptp\n# pip3 install jsonschema virtualenv pyyaml\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#ubuntu-2004","title":"Ubuntu 20.04","text":"<pre><code># apt-get update\n# apt-get upgrade -y\n# apt-get install -y python3 python3-pip python3-dev git gcc g++ make cmake uuid-dev libjson-c-dev libhwloc-dev libtbb-dev libedit-dev libudev-dev linuxptp pandoc devscripts debhelper doxygen\n# pip3 install jsonschema virtualenv pyyaml pybind11\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#rhel-82","title":"RHEL 8.2","text":"<p>Register and enable Red Hat subscription to install any packages on the system.</p> <pre><code># subscription-manager register --proxy=PROXY --username=USER --password=PASSWORD --auto-attach\n</code></pre> <p>Set the RHEL version and install packages. Set proxy name and port number.</p> <pre><code># subscription-manager release --set=8.2 --proxy proxy-name.com:port number\n# subscription-manager repos --enable codeready-builder-for-rhel-8-x86_64-rpms\n# dnf upgrade -y\n# dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\n# dnf install -y python3 python3-pip python3-devel gdb vim git gcc gcc-c++ make cmake libuuid-devel rpm-build systemd-devel  nmap\n# dnf install -y python3-jsonschema json-c-devel tbb-devel rpmdevtools libcap-devel # dnf check-update || true\n# dnf install -y spdlog-devel cli11-devel python3-pyyaml python3-pybind11 hwloc-devel libedit-devel\n# python3 -m pip install --user jsonschema virtualenv pudb pyyaml\n</code></pre> <p>Install the latest version of cmake on top of the outdated cmake package from the package manager.</p> <pre><code># cd cmake-3.25.1/\n# ./bootstrap --prefix=/usr\n# make\n# make install\n# which cmake\n/usr/bin/cmake\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#create-opae-sdk-packages","title":"Create opae-sdk packages","text":"<p>Download the OPAE-SDK source code from github. For example, download from Master branch.</p> <pre><code>$ git clone https://github.com/OPAE/opae-sdk.git\n</code></pre> <p>Compile and build the OPAE-SDK RPMs (Fedora, Rocky, RHEL 8.2). <pre><code>$ cd opae-sdk/packaging/opae/rpm\n$ ./create fedora\n</code></pre></p> <p>Note that if you find that your distribution has changed package names such that there is a conflict when building RPMs, you can install all of the build dependencies so that the SDK compiles and then build the RPMs in unrestricted mode: <pre><code>$ cd opae-sdk/packaging/opae/rpm\n$ ./create unrestricted\n</code></pre></p> <p>After a successful compile, there are 3 rpm packages generated (Fedora, Rocky, RHEL8.2). For example: <pre><code>opae-2.1.0-1.fc34.x86_64.rpm\nopae-devel-2.1.0-1.fc34.x86_64.rpm\nopae-extra-tools-2.1.0-1.fc34.x86_64.rpm\n</code></pre></p> <p>Compile and build the OPAE-SDK deb packages (Ubuntu 22.04). <pre><code>$ cd opae-sdk/packaging/opae/deb\n$ ./create\n</code></pre></p> <p>After a successful compile, there are 3 deb packages generated (Ubuntu 22.04). For example: <pre><code>opae_2.1.1-1_amd64.deb  \nopae-devel_2.1.1-1_amd64.deb  \nopae-extra-tools_2.1.1-1_amd64.deb\n</code></pre></p>"},{"location":"sw/install_guide/installation_guide/#opae-sdk-installation-with-rpmdeb-packages","title":"OPAE SDK installation with rpm/deb packages","text":"<p>The rpm packages generated in the previous step can be installed using these commands:</p> <pre><code>$ sudo dnf install ./*.rpm\n</code></pre> <p>The deb packages generated in the previous step can be installed using these commands:</p> <pre><code>$ sudo dpkg -i  ./*.deb\n</code></pre> <p>When you installed the rpms, you can run fpgainfo command to check the FPGA FME infomation. For example: <pre><code>[figo@localhost install_guide]$ fpgainfo fme\nBoard Management Controller, MAX10 NIOS FW version: D.2.1.24\nBoard Management Controller, MAX10 Build version: D.2.0.7\n//****** FME ******//\nObject Id                        : 0xEF00000\nPCIe s:b:d.f                     : 0000:08:00.0\nDevice Id                        : 0x0B30\nSocket Id                        : 0x00\nPorts Num                        : 01\nBitstream Id                     : 0x2300011001030F\nBitstream Version                : 0.2.3\nPr Interface Id                  : f3c99413-5081-4aad-bced-07eb84a6d0bb\nBoot Page                        : user\n</code></pre></p> <p>To uninstall the OPAE rpms, you can use this commands <pre><code>$ dnf list installed | grep opae\n$ sudo dnf remove opae*.x86_64\n</code></pre></p> <p>To uninstall the OPAE deb, you can use this commands <pre><code>$ dpkg -l  | grep opae\n$ dpkg -r opae-extra-tools:amd64\n$ dpkg -r opae-devel:amd64\n$ dpkg -r opae\n</code></pre></p>"},{"location":"sw/install_guide/installation_guide/#fpga-device-access-permissions","title":"FPGA Device Access Permissions","text":"<p>Access to FPGA accelerators and devices is controlled using file access permissions on the Intel\u00ae FPGA device files, <code>/dev/dfl-fme.*</code> and <code>/dev/dfl-port.*</code>, as well as to the files reachable through <code>/sys/class/fpga_region/</code>.</p> <p>In order to allow regular (non-root) users to access accelerators, you need to grant them read and write permissions on <code>/dev/dfl-port.*</code> (with <code>*</code> denoting the respective socket, i.e. 0 or 1). E.g.:</p> <pre><code>$ sudo chmod a+rw /dev/dfl-port.0\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#memlock-limit","title":"Memlock limit","text":"<p>Depending on the requirements of your application, you may also want to increase the maximum amount of memory a user process is allowed to lock. The exact way to do this depends on your Linux distribution.</p> <p>You can check the current memlock limit using</p> <pre><code>$ ulimit -l\n</code></pre> <p>A way to permanently remove the limit for locked memory for a regular user is to add the following lines to your /etc/security/limits.conf:</p> <pre><code>user1    hard   memlock           unlimited\nuser1    soft   memlock           unlimited\n</code></pre> <p>This removes the limit on locked memory for user <code>user1</code>. To remove it for all users, you can replace <code>user1</code> with <code>*</code>:</p> <pre><code>*    hard   memlock           unlimited\n*    soft   memlock           unlimited\n</code></pre> <p>Note that settings in the /etc/security/limits.conf file don't apply to services.  To increase the locked memory limit for a service you need to modify the application's systemd service file and add the line:</p> <pre><code>[Service]\nLimitMEMLOCK=infinity\n</code></pre>"},{"location":"sw/install_guide/installation_guide/#hugepage-settings","title":"Hugepage Settings","text":"<p>Users need to configure system hugepages to reserve 2MB-hugepages or 1GB-hugepages. For example, the 'hello_fpga' sample requires several 2MB-hugepages. And the fpgadiag tool requires several 1GB-hugepages.</p> <p>The command below reserves 20 2M-hugepages:</p> <pre><code>$ sudo sh -c 'echo 20 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages'\n</code></pre> <p>The command below reserves 4 1GB-hugepages:</p> <pre><code>$ sudo sh -c 'echo 4 &gt; /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages'\n</code></pre> <p>For x86_64 architecture processors, user can use following command to find out avaiable hugepage sizes:</p> <pre><code>$ grep pse /proc/cpuinfo | uniq\nflags : ... pse ...\n</code></pre> <p>If this commands returns a non-empty string, 2MB pages are supported.</p> <pre><code>$ grep pse /proc/cpuinfo | uniq\nflags : ... pdpe1gb ...\n</code></pre> <p>If this commands returns a non-empty string, 1GB pages are supported.</p>"},{"location":"sw/tod/tod/","title":"Time of Day (ToD)","text":""},{"location":"sw/tod/tod/#synopsis","title":"SYNOPSIS","text":"<p>The Intel FPGA ToD driver in the kernel space exposes ToD IP as PHC (PTP Hardware Clock) device to the Linux PTP (Precision Time Protocol) stack to synchronize the system clock to its ToD information. The phc2sys utility of Linux PTP stack is used to access ToD information and synchronize the system clock.</p> <p>Install the Linux PTP utilities: <pre><code># sudo yum install linuxptp\n</code></pre></p> <p>phc_ctl and phc2sys utilities (linuxptp package) are used to control the PHC device and synchronize the system clock to its ToD information.</p> <p>phc_ctl: directly controls PHC device clock. <pre><code>Usage: phc_ctl [options] &lt;device&gt; -- [command]\n    device         ethernet or ptp clock device\nOptions:\n    -l [num]       set the logging level to 'num'\n    -q             do not print messages to the syslog\n    -Q             do not print messages to stdout\n    -v             prints the software version and exits\n    -h             prints this message and exits\nCommands:\n specify commands with arguments. Can specify multiple commands to be executed in order. \n Seconds are read as double precision floating point values.\n    set  [seconds]  set PHC time (defaults to time on CLOCK_REALTIME)\n    get             get PHC time\n    adj  &lt;seconds&gt;  adjust PHC time by offset\n    freq [ppb]      adjust PHC frequency (default returns current offset)\n    cmp             compare PHC offset to CLOCK_REALTIME\n    caps            display device capabilities (default if no command given)\n    wait &lt;seconds&gt;  pause between commands\n                    This command may be useful for sanity checking whether the PHC clock is\n                    running as expected.\n                    The arguments specified in seconds are read as double precision floating point\n                    values, and will scale to nanoseconds. This means providing a value of 5.5 means 5\n                    and one half seconds. This allows specifying fairly precise values for time.\n</code></pre></p> <p>phc2sys: synchronize two clocks. <pre><code>Usage: phc2sys [options]\nAutomatic configuration:\n    -a             turn on autoconfiguration\n    -r             synchronize system (realtime) clock\n                   repeat -r to consider it also as a time source\nManual configuration:\n    -c [dev|name]  slave clock (CLOCK_REALTIME)\n    -d [dev]       master PPS device\n    -s [dev|name]  master clock\n    -O [offset]    slave-master time offset (0)\n    -w             wait for ptp4l\nOptions:\n    -f [file]      configuration file\n    -E [pi|linreg] clock servo (pi)\n    -P [kp]        proportional constant (0.7)\n    -I [ki]        integration constant (0.3)\n    -S [step]      step threshold (disabled)\n    -F [step]      step threshold only on start (0.00002)\n    -R [rate]      slave clock update rate in HZ (1.0)\n    -N [num]       number of master clock readings per update (5)\n    -L [limit]     sanity frequency limit in ppb (200000000)\n    -M [num]       NTP SHM segment number (0)\n    -u [num]       number of clock updates in summary stats (0)\n    -n [num]       domain number (0)\n    -x             apply leap seconds by servo instead of kernel\n    -z [path]      server address for UDS (/var/run/ptp4l)\n    -l [num]       set the logging level to 'num' (6)\n    -t [tag]       add tag to log messages\n    -m             print messages to stdout\n    -q             do not print messages to the syslog\n    -v             prints the software version and exits\n    -h             prints this message and exits\n</code></pre></p>"},{"location":"sw/tod/tod/#description","title":"DESCRIPTION","text":"<p>The phc2sys utility is used to synchronize the system clock to the PTP Hardware Clock (PHC) or ToD clock. The phc_ctl utility is used to directly control PHC clock device.</p>"},{"location":"sw/tod/tod/#configuring-the-ptp-service","title":"Configuring the PTP service","text":"<ol> <li>Install the linuxptp package: <pre><code># sudo yum install linuxptp\n</code></pre></li> <li>Check PTP device is created successfully by the ToD driver. </li> </ol> <p>ToD driver registering as PHC device (clock_name: dfl_tod) to the Linux PTP stack and exposing to the Linux kernel to synchronize the system clock to its ToD information. <pre><code># cat /sys/class/ptp/ptp0/clock_name\ndfl_tod\n</code></pre></p> <ol> <li>Configure phc2sys service on a system:</li> </ol> <p>The phc2sys service is configured in the /etc/sysconfig/phc2sys configuration file. Define start-up option for phc2sys daemon in /etc/sysconfig/phc2sys. The master clock is /dev/ptp0 device and the slave clock is system clock/CLOCK_REALTIME: <pre><code> OPTIONS=\"-s /dev/ptp0 -c CLOCK_REALTIME -r -O 0 -R 16\"\n</code></pre></p> <ol> <li> <p>Start phc2sys service: <pre><code># service phc2sys start\n</code></pre></p> </li> <li> <p>Stop phc2sys service: <pre><code># service phc2sys stop\n</code></pre></p> </li> </ol>"},{"location":"sw/tod/tod/#examples","title":"Examples","text":""},{"location":"sw/tod/tod/#using-phc_ctl-utility","title":"using phc_ctl utility","text":"<p>Read the current clock time from the PHC clock device: <pre><code># sudo phc_ctl /dev/ptp0 get\n</code></pre></p> <p>Set the PHC clock time to CLOCK_REALTIME: <pre><code># sudo phc_ctl /dev/ptp0 set\n</code></pre></p> <p>Set PHC clock time to 0: <pre><code># sudo phc_ctl /dev/ptp0 set 0.0\n</code></pre></p> <p>Set PHC clock time to 0 and wait for 10 sec and read the clock time: <pre><code># sudo phc_ctl /dev/ptp0 set 0.0 wait 10.0 get\n</code></pre></p> <p>Set and compare PHC clock time to CLOCK_REALTIME: <pre><code># sudo phc_ctl /dev/ptp0 set cmp\n</code></pre></p> <p>Read the PHC device capabilities: <pre><code># sudo phc_ctl /dev/ptp0 caps\n</code></pre></p>"},{"location":"sw/tod/tod/#using-phc2sys-utility","title":"using phc2sys utility","text":"<p>To synchronize the system clock to the PHC clock: <pre><code># sudo phc2sys -s /dev/ptp0 -c CLOCK_REALTIME -r -O 0 -R 16 -m\nphc2sys[7896.789]: CLOCK_REALTIME phc offset  -1259509 s0 freq  -31462 delay   1338\nphc2sys[7896.852]: CLOCK_REALTIME phc offset  -1261498 s1 freq  -63144 delay   1328\nphc2sys[7896.914]: CLOCK_REALTIME phc offset       -15 s2 freq  -63159 delay   1328\nphc2sys[7896.977]: CLOCK_REALTIME phc offset       -19 s2 freq  -63167 delay   1327\nphc2sys[7897.039]: CLOCK_REALTIME phc offset       -35 s2 freq  -63189 delay   1328\nphc2sys[7897.102]: CLOCK_REALTIME phc offset       -37 s2 freq  -63201 delay   1331\nphc2sys[7897.165]: CLOCK_REALTIME phc offset       -30 s2 freq  -63205 delay   1328\nphc2sys[7897.227]: CLOCK_REALTIME phc offset       -50 s2 freq  -63234 delay   1331\nphc2sys[7897.290]: CLOCK_REALTIME phc offset       -50 s2 freq  -63249 delay   1329\nphc2sys[7897.353]: CLOCK_REALTIME phc offset       -62 s2 freq  -63276 delay   1334\nphc2sys[7897.415]: CLOCK_REALTIME phc offset       -53 s2 freq  -63286 delay   1335\nphc2sys[7897.478]: CLOCK_REALTIME phc offset       -46 s2 freq  -63295 delay   1325\nphc2sys[7897.541]: CLOCK_REALTIME phc offset       -57 s2 freq  -63320 delay   1334\nphc2sys[7897.603]: CLOCK_REALTIME phc offset       -39 s2 freq  -63319 delay   1327\nphc2sys[7897.666]: CLOCK_REALTIME phc offset       -31 s2 freq  -63323 delay   1328\nphc2sys[7897.728]: CLOCK_REALTIME phc offset       -48 s2 freq  -63349 delay   1327\nphc2sys[7897.791]: CLOCK_REALTIME phc offset       -42 s2 freq  -63357 delay   1323\nphc2sys[7897.854]: CLOCK_REALTIME phc offset       -41 s2 freq  -63369 delay   1324\nphc2sys[7897.916]: CLOCK_REALTIME phc offset       -44 s2 freq  -63384 delay   1328\nphc2sys[7897.979]: CLOCK_REALTIME phc offset       -13 s2 freq  -63366 delay   1327\nphc2sys[7898.042]: CLOCK_REALTIME phc offset       -16 s2 freq  -63373 delay   1327\nphc2sys[7898.104]: CLOCK_REALTIME phc offset       -19 s2 freq  -63381 delay   1328\nphc2sys[7898.167]: CLOCK_REALTIME phc offset       -16 s2 freq  -63384 delay   1327\nphc2sys[7898.229]: CLOCK_REALTIME phc offset         3 s2 freq  -63370 delay   1327\nphc2sys[7898.292]: CLOCK_REALTIME phc offset        16 s2 freq  -63356 delay   1325\nphc2sys[7898.355]: CLOCK_REALTIME phc offset        10 s2 freq  -63357 delay   1319\nphc2sys[7898.417]: CLOCK_REALTIME phc offset        23 s2 freq  -63341 delay   1327\nphc2sys[7898.480]: CLOCK_REALTIME phc offset        13 s2 freq  -63344 delay   1335\nphc2sys[7898.543]: CLOCK_REALTIME phc offset        23 s2 freq  -63330 delay   1323\nphc2sys[7898.605]: CLOCK_REALTIME phc offset        29 s2 freq  -63317 delay   1312\nphc2sys[7898.668]: CLOCK_REALTIME phc offset        22 s2 freq  -63315 delay   1324\nphc2sys[7898.730]: CLOCK_REALTIME phc offset        42 s2 freq  -63289 delay   1325\nphc2sys[7898.793]: CLOCK_REALTIME phc offset        29 s2 freq  -63289 delay   1333\nphc2sys[7898.856]: CLOCK_REALTIME phc offset        34 s2 freq  -63276 delay   1327\nphc2sys[7898.918]: CLOCK_REALTIME phc offset        21 s2 freq  -63278 delay   1331\nphc2sys[7898.981]: CLOCK_REALTIME phc offset        22 s2 freq  -63271 delay   1335\nphc2sys[7899.044]: CLOCK_REALTIME phc offset        30 s2 freq  -63256 delay   1327\nphc2sys[7899.106]: CLOCK_REALTIME phc offset        30 s2 freq  -63247 delay   1328\nphc2sys[7899.169]: CLOCK_REALTIME phc offset        37 s2 freq  -63231 delay   1333\nphc2sys[7899.232]: CLOCK_REALTIME phc offset        29 s2 freq  -63228 delay   1331\nphc2sys[7899.294]: CLOCK_REALTIME phc offset        24 s2 freq  -63225 delay   1330\n</code></pre></p>"}]}